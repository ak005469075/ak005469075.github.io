<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>力扣 |  小张之栈</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-力扣"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  力扣
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/02/%E5%8A%9B%E6%89%A3/" class="article-date">
  <time datetime="2023-07-02T14:25:25.000Z" itemprop="datePublished">2023-07-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%8A%9B%E6%89%A3/">力扣</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">68.1k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">332 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h1><p>vscode默认不支持c++11解决办法</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/269244754">vscode C++ 简易配置（支持c++11以上） - 知乎 (zhihu.com)</a></p>
<h2 id="单行输入，过滤逗号"><a href="#单行输入，过滤逗号" class="headerlink" title="单行输入，过滤逗号"></a>单行输入，过滤逗号</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; s;</span><br><span class="line"> int temp;</span><br><span class="line">   while(cin&gt;&gt;temp)</span><br><span class="line">   &#123;</span><br><span class="line">       s.emplace_back(temp); //可以过滤逗号</span><br><span class="line">       if(cin.get()==&#x27;\n&#x27;) break;</span><br><span class="line">   &#125;</span><br><span class="line"> for(int i:s)</span><br><span class="line">   cout&lt;&lt;i&lt;&lt;&quot; &quot;;</span><br></pre></td></tr></table></figure>

<h2 id="多行输入，外部以回车分割"><a href="#多行输入，外部以回车分割" class="headerlink" title="多行输入，外部以回车分割"></a>多行输入，外部以回车分割</h2><p>内部如果是空格分割</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  int n,m;</span><br><span class="line"></span><br><span class="line"> cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line"> getchar();//取走回车，为了下面的getline</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt;sw;</span><br><span class="line"></span><br><span class="line">for(int i=0;i&lt;m;i++)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> string s,tmp;</span><br><span class="line"></span><br><span class="line"> getline(cin,s);</span><br><span class="line"></span><br><span class="line"> istringstream ss(s);</span><br><span class="line"></span><br><span class="line"> while(ss&gt;&gt;tmp)&#123;</span><br><span class="line"></span><br><span class="line">   sw.push_back(tmp);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(string i:sw)</span><br><span class="line"></span><br><span class="line"> cout&lt;&lt;i&lt;&lt;&quot; &quot;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1<br>2<br>1 1 2 3<br>4 5 6 7<br>1 2 3 5 6 7 sw的元素个数为6</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while(getline(ss,tmp,&#x27;,&#x27;)) //逗号分割</span><br></pre></td></tr></table></figure>

<blockquote>
<p>3<br>2<br>1,2,3,4,5,6<br>7,8,9,10,11<br>1 2 3 4 5 6 7 8 9 10 11 sw的总数为11</p>
</blockquote>
<h2 id="外行输入，多个数组"><a href="#外行输入，多个数组" class="headerlink" title="外行输入，多个数组"></a>外行输入，多个数组</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; sw;</span><br><span class="line"></span><br><span class="line"> string s;</span><br><span class="line"></span><br><span class="line"> int n;</span><br><span class="line"></span><br><span class="line"> cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line"> getchar(); //否则，n=2时，下文的getline只读一行，因为之前的回车读到了</span><br><span class="line"></span><br><span class="line"> // cin.ignore();</span><br><span class="line"></span><br><span class="line"> for(int i=0;i&lt;n;i++)</span><br><span class="line"></span><br><span class="line"> &#123;</span><br><span class="line"></span><br><span class="line">  getline(cin,s);//默认分隔符为&#x27;\n&#x27; cin会默认去除\n</span><br><span class="line"></span><br><span class="line">  sw.push_back(s);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2<br>1,2<br>5,7<br>1,2 5,7 </p>
</blockquote>
<p>我再用string转化一波吧</p>
<p>还有另一个做法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; sw(2,&quot;&quot;);</span><br><span class="line">  string s;</span><br><span class="line">  for(int i=0;i&lt;2;i++)</span><br><span class="line">  &#123;</span><br><span class="line"> </span><br><span class="line">       getline(cin,s);</span><br><span class="line">       sw[i]=s;//如果是vector&lt;string&gt; sw;那就用push_back，因为这样定义是没有索引的。</span><br><span class="line">  &#125;</span><br><span class="line">    for(string i:sw)</span><br><span class="line">   cout&lt;&lt;i&lt;&lt;&quot; &quot;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1,2,3<br>4,5<br>1,2,3 4,5 </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">getline(cin,sw[i]);也可以</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="基于struct的存储"><a href="#基于struct的存储" class="headerlink" title="基于struct的存储"></a>基于struct的存储</h2><p>struct book{</p>
<p>int a;</p>
<p>int b;</p>
<p>};</p>
<p>vector&lt;book&gt; a(n); </p>
<h2 id="关于每行两元素的存储"><a href="#关于每行两元素的存储" class="headerlink" title="关于每行两元素的存储"></a>关于每行两元素的存储</h2><p>以下根据实际情况等价替代</p>
<p>map&lt;int,int&gt; mp;</p>
<p>vector&lt;pair&lt;int,int&gt; &gt; a;</p>
<blockquote>
<p>pair&lt;int,int&gt; p&#x3D;make_pair(3,4);</p>
</blockquote>
<p>vector&lt;vector&lt;int&gt; &gt; a;</p>
<p>vector&lt;book&gt; a;</p>
<h1 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h1><p><strong>数据结构的存储方式</strong>：数组和链表</p>
<p><strong>数据结构的基本操作</strong>：遍历+访问</p>
<p>线性就是for&#x2F;while迭代，否则就是递归(二叉树)</p>
<p>线性表略</p>
<p>链表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">listnode</span>&#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	listnode next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(listnode head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(listnode p=head;p!=null;p=p-&gt;next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//迭代访问p.val</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//或者递归访问head.val</span></span><br><span class="line">	<span class="built_in">traverse</span>(head-&gt;next)</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二叉树</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Treenode</span>&#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	Treenode left,right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(Treenode root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">traverse</span>(root.left);</span><br><span class="line"><span class="built_in">traverse</span>(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>N叉树</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Treenode&#123;</span><br><span class="line">	int val;</span><br><span class="line">	Treenode[] children;</span><br><span class="line">&#125;</span><br><span class="line">void traverse(Treenode root)</span><br><span class="line">&#123;</span><br><span class="line">	for(Treenode child:root.children)</span><br><span class="line">    	traverse(child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进而扩展为图，图就相当于N叉树的结合体</p>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>二叉树基本遍历比如</p>
<p>travers(root.left);&#x2F;&#x2F;一直往左遍历，直到root为null，会跳到下一行</p>
<p>travers(root.right);&#x2F;&#x2F;一直往右遍历，直到root为null，会跳到下一行，若是递归，则会再从该行开始（一般是先左子树，左子树遍历完，轮到右子树）</p>
<p><strong>单链表的倒序问题</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void travers(treenode * head)</span><br><span class="line">&#123;</span><br><span class="line">	if(head==nullptr) return;</span><br><span class="line">	travers(head-&gt;next);</span><br><span class="line">	cout&lt;&lt;head-&gt;val;</span><br><span class="line">	</span><br><span class="line">	//实现5-&gt;4-&gt;3-&gt;2-&gt;1</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>递归就相当于个栈，递归终止之后，就不停的pop栈顶元素</strong></p>
<blockquote>
<p>当递归函数调用结束后，系统会负责将函数的返回值从栈中取出，并将控制权返回给调用该函数的地方。系统会将返回值传递给上一层的递归调用，使得上一层递归函数可以继续执行后续的操作。</p>
</blockquote>
<p>二叉树问题，分为回溯法(一遍二叉树遍历)和动态规划(分解问题，有返回值)</p>
<h2 id="避坑点"><a href="#避坑点" class="headerlink" title="避坑点"></a>避坑点</h2><p><strong>思考整棵树与其左右字数关系</strong>，类似数学归纳法。</p>
<p>当程序”递“时，计算机栈保存该对象，程序不断”递“，计算机不断压栈；边界时，程序不断发生”归“的动作时，计算机不断出栈。</p>
<h2 id="104二叉树最大深度"><a href="#104二叉树最大深度" class="headerlink" title="104二叉树最大深度"></a>104二叉树最大深度</h2><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int depth=0;</span><br><span class="line">    int res=0;//记录最大值</span><br><span class="line">    </span><br><span class="line">    int maxDepth(TreeNode* root) &#123; //单纯访问</span><br><span class="line">        travers(root);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    void travers(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">      if(root==nullptr) return;</span><br><span class="line">       depth++;</span><br><span class="line">       res=max(depth,res);</span><br><span class="line">       travers(root-&gt;left);</span><br><span class="line">       travers(root-&gt;right);</span><br><span class="line">       depth--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//将depth理解为在二叉树上游走的指针即可</span><br></pre></td></tr></table></figure>

<p>递归，遇见终止的，就释放，回到原位置</p>
<h3 id="分解"><a href="#分解" class="headerlink" title="分解"></a>分解</h3><p><img src="/../../../Typora/img111/image-20230711221213896.png" alt="image-20230711221213896"></p>
<p>原问题：计算3为根节点的二叉树的深度。<br>子问题：计算9为根节点的二叉树的深度。<br>子问题：计算20为根节点的二叉树的深度。<br>所谓子问题就是和原问题一样，只是规模降低了。</p>
<p>当前节点深度&#x3D;max(左节点深度，右节点深度)+1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int getdepth(TreeNode *root)</span><br><span class="line">   &#123;</span><br><span class="line">       if(root==nullptr) return 0;   //叶子结点</span><br><span class="line">       int leftmax=getdepth(root-&gt;left);</span><br><span class="line">       int rightmax=getdepth(root-&gt;right);</span><br><span class="line"></span><br><span class="line">       return 1+max(leftmax,rightmax);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="144-二叉树前序遍历"><a href="#144-二叉树前序遍历" class="headerlink" title="144 二叉树前序遍历"></a>144 二叉树前序遍历</h2><p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p>
<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">travers</span>(root);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">travers</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        s.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">travers</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">travers</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="分解-1"><a href="#分解-1" class="headerlink" title="分解"></a>分解</h3><p>聚焦于子问题，类似于数学归纳法，子问题的逻辑正确，整体问题一定解决。</p>
<p>前序遍历就是根节点+左子树遍历<strong>结果</strong>+右子树遍历<strong>结果</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">       vector&lt;<span class="type">int</span>&gt; s;<span class="comment">//根节点，左子树，右子树</span></span><br><span class="line">       <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">       s.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">       vector&lt;<span class="type">int</span>&gt; left=<span class="built_in">preorderTraversal</span>(root-&gt;left);</span><br><span class="line">       s.<span class="built_in">insert</span>(s.<span class="built_in">end</span>(),left.<span class="built_in">begin</span>(),left.<span class="built_in">end</span>());</span><br><span class="line">       vector&lt;<span class="type">int</span>&gt; right=<span class="built_in">preorderTraversal</span>(root-&gt;right);</span><br><span class="line">       s.<span class="built_in">insert</span>(s.<span class="built_in">end</span>(),right.<span class="built_in">begin</span>(),right.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h2 id="后序位置的妙用"><a href="#后序位置的妙用" class="headerlink" title="后序位置的妙用"></a>后序位置的妙用</h2><p>1.把根节点当做第1层，打印出每个节点所在层数  （前序）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void traverse(TreeNode* root,int level)</span><br><span class="line">&#123;</span><br><span class="line">	if(root==nullptr) return;</span><br><span class="line">	printf(&quot;节点%s在第%d层&quot;,root,level);</span><br><span class="line">	traverse(root-&gt;left,level+1);</span><br><span class="line">	traverse(root-&gt;right,level+1);</span><br><span class="line">&#125;</span><br><span class="line">//调用</span><br><span class="line">traverse(root,1);</span><br></pre></td></tr></table></figure>

<p>2.打印每个结点的左右子树各有多少结点	（后序）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int count(TreeNode* root)&#123;</span><br><span class="line">if(root==nullptr) return 0;</span><br><span class="line">int leftco=count(root-&gt;left);</span><br><span class="line">int rightco=count(toor-&gt;right);</span><br><span class="line">//后序位置</span><br><span class="line">printf(...)</span><br><span class="line"></span><br><span class="line">return leftco+rightco+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个问题区别在于，第一个是递归时<strong>顺便</strong>带来的结果；第二个需要<strong>遍历完</strong>整棵树，才知道的结果</p>
<h2 id="543二叉树的直径"><a href="#543二叉树的直径" class="headerlink" title="543二叉树的直径"></a>543二叉树的直径</h2><p>给你一棵二叉树的根节点，返回该树的 直径 。</p>
<p>二叉树的 直径 是指树中任意两个节点之间最长路径的 长度 。这条路径可能经过也可能不经过根节点 root 。</p>
<p>两节点之间路径的 长度 由它们之间边数表示。</p>
<p><img src="/../../../Typora/img111/image-20230712101353602.png" alt="image-20230712101353602"></p>
<p>输入：root &#x3D; [1,2,3,4,5]<br>输出：3<br>解释：3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。<br>示例 2：</p>
<p>输入：root &#x3D; [1,2]<br>输出：1</p>
<h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>长度&#x3D;左子树深度+右子树深度</p>
<p><strong>所以求depth(1)，必求depth(2)和depth(3)</strong></p>
<p><strong>求depth(2)，必求depth(4)和depth(5)</strong></p>
<p>递归思想是先解决<strong>子问题</strong>，再回到整体问题。</p>
<p>以下代码所示（注意，不正确）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int depth(TreeNode * root)</span><br><span class="line">&#123;</span><br><span class="line">	if(root==nullptr) return 0;</span><br><span class="line">	int left=depth(root-&gt;left);</span><br><span class="line">	int right=depth(root-&gt;right);</span><br><span class="line">	</span><br><span class="line">    return left+right+1;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">//调用该函数depth(root)</span><br></pre></td></tr></table></figure>

<p>int left&#x3D;depth(root-&gt;left);当root为4时，执行该行</p>
<p>好，从头执行depth(左孩子)，4的左孩子是空指针，返回值得到0，赋值left&#x3D;0</p>
<p>进入下一行</p>
<p>int right&#x3D;depth(root-&gt;right);进入该行</p>
<p>从头执行depth(右孩子)，4的右孩子是空指针，返回值得到0，赋值right&#x3D;0</p>
<p>进入下一行</p>
<p>return left+right+1;进入该行。</p>
<p>得到depth(4)的返回值为1。</p>
<p>同理depth(5)的返回值为1。</p>
<p>则depth(2)的长度为2。</p>
<p><strong>当然，少考虑了一种情况，如果不经过根节点嘞，即只有左子树或只有右子树情况</strong></p>
<p><img src="/../../../Typora/img111/image-20230712103553998.png" alt="image-20230712103553998"></p>
<p>这个是时候可以一眼看出，直径为3，而不是2了吧。</p>
<p>这就需要<strong>取左子树和右子树深度的最大值了</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int res=0;</span><br><span class="line">...</span><br><span class="line">int depth(TreeNode * root)</span><br><span class="line">&#123;</span><br><span class="line">	if(root==nullptr) return 0;</span><br><span class="line">	int left=depth(root-&gt;left);</span><br><span class="line">	int right=depth(root-&gt;right);</span><br><span class="line">	//后序位置</span><br><span class="line">	res=max(left+right,res);</span><br><span class="line">    return max(left,right)+1;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">//调用</span><br></pre></td></tr></table></figure>

<p><strong>遇到子树问题，首先想到的是给函数设置返回值，然后在后序位置做文章。</strong></p>
<h2 id="动态规划-x2F-回溯-x2F-DFS"><a href="#动态规划-x2F-回溯-x2F-DFS" class="headerlink" title="动态规划&#x2F;回溯&#x2F;DFS"></a>动态规划&#x2F;回溯&#x2F;DFS</h2><h3 id="动态规划例子"><a href="#动态规划例子" class="headerlink" title="动态规划例子"></a>动态规划例子</h3><p>计算二叉树共有多少个节点</p>
<p><strong>着眼结构相同的子类问题</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int count(TreeNode * root)</span><br><span class="line">&#123;</span><br><span class="line">	if(root==nullptr) return 0;</span><br><span class="line">	int left=count(root-&gt;left);</span><br><span class="line">	int right=count(root-&gt;right);</span><br><span class="line">	</span><br><span class="line">	return left+right+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>斐波那契</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int fib(int N)</span><br><span class="line">&#123;</span><br><span class="line">	if(N==1||N==2) return 1;//递归出口</span><br><span class="line">	return fib(N-1)+fib(N-2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="回溯-1"><a href="#回溯-1" class="headerlink" title="回溯"></a>回溯</h3><p>遍历的思路，traverse()，打印出遍历二叉树的过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void travers(TreeNode * root)</span><br><span class="line">&#123;</span><br><span class="line">	if(root==nullptr) return;</span><br><span class="line">	printf(&quot;从结点%s到%s&quot;,root,root-&gt;left);</span><br><span class="line">	travers(root-&gt;left);</span><br><span class="line">	printf(&quot;从结点%s回到%s&quot;,root-&gt;left,root);</span><br><span class="line">	</span><br><span class="line">	printf(&quot;从结点%s到%s&quot;,root,root-&gt;right);</span><br><span class="line">	travers(root-&gt;right);</span><br><span class="line">	printf(&quot;从结点%s回到%s&quot;,root-&gt;right,root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多叉树遍历</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Node&#123;</span><br><span class="line">public:</span><br><span class="line">	int val;</span><br><span class="line">	vector&lt;Node*&gt; children;</span><br><span class="line">&#125;;</span><br><span class="line">void travers(Node *root)</span><br><span class="line">&#123;</span><br><span class="line">	if(root==nullptr) return;</span><br><span class="line">	for(Node * child=root;root-&gt;children!=nullptr;root=root-&gt;children)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;从结点%s到%s&quot;,root,child);</span><br><span class="line">		travers(child);</span><br><span class="line">		printf(&quot;从结点%s回到%s&quot;,child,root);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多叉树的遍历框架可以延伸到回溯法</p>
<p><strong>着眼节点之间的移动</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void backtrack()</span><br><span class="line">&#123;</span><br><span class="line">	for(int i=0;i&lt;...,i++)</span><br><span class="line">	&#123;</span><br><span class="line">	//做选择</span><br><span class="line">	...</span><br><span class="line">	//进入下一层决策树</span><br><span class="line">	backtrack(...);</span><br><span class="line">	</span><br><span class="line">	//撤销刚才做的选择</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>深度遍历</p>
<p>travers函数使得二叉树每个结点值+1</p>
<p><strong>着眼于单个结点上的操作</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void traverse(TreeNode* root)</span><br><span class="line">&#123;</span><br><span class="line">	if(root==nullptr) return;</span><br><span class="line">	root-&gt;val+=1;</span><br><span class="line">	traverse(root.left);</span><br><span class="line">	traverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DFS与回溯区别"><a href="#DFS与回溯区别" class="headerlink" title="DFS与回溯区别"></a>DFS与回溯区别</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;结点%s来了&quot;</span>,root);</span><br><span class="line">	<span class="comment">/*for (vector&lt;Node*&gt;::iterator it = root-&gt;children.begin(); it != root-&gt;children.end(); ++it)*/</span></span><br><span class="line">	<span class="keyword">for</span>(Node* child:root-&gt;children)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">dfs</span>(child);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;结点%s走了&quot;</span>,root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void traverse(TreeNode *root)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	if(root==nullptr) return;</span><br><span class="line">	for(...)</span><br><span class="line">	&#123;</span><br><span class="line">		print(...root,child);</span><br><span class="line">		traverse(child);</span><br><span class="line">		print(...child,root);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回溯算法，<strong>必须把“做选择”和”撤销操作”放在循环里</strong></p>
<h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><p>&#x2F;&#x2F;已知一棵树的根节点，层序遍历</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void levelbianli(TreeNode* root)</span><br><span class="line">&#123;</span><br><span class="line">	if(root==nullptr) return;</span><br><span class="line">	queue&lt;TreeNode*&gt; q;</span><br><span class="line">	q.push(root);</span><br><span class="line">	//从上到下</span><br><span class="line">	while(!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		int index=q.size();</span><br><span class="line">		//从左到右</span><br><span class="line">		for(int i=0;i&lt;index;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			TreeNode* cur=q.front();</span><br><span class="line">			q.pop();</span><br><span class="line">			//将下一层结点放入队列</span><br><span class="line">			if(cur-&gt;left!=nullptr)</span><br><span class="line">			q.push(cur-&gt;left);</span><br><span class="line">			if(cur-&gt;right!=nullptr)</span><br><span class="line">			q.push(cur-&gt;right);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二叉树输入"><a href="#二叉树输入" class="headerlink" title="二叉树输入"></a>二叉树输入</h2><p>(搞了半天我这是前序接收输入，我说为什么后续遍历不对)</p>
<p>我定义了一个vector，提前接收字符串序列，如a,b,c,d；如果要转换成数值(求和)也是可以的，stoi转换一下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; create()</span><br><span class="line">&#123;</span><br><span class="line">    string ss;</span><br><span class="line">    cin&gt;&gt;ss;</span><br><span class="line">    string token;</span><br><span class="line">    istringstream iss(ss);</span><br><span class="line">    vector&lt;string&gt; list;</span><br><span class="line">    while(getline(iss,token,&#x27;,&#x27;))</span><br><span class="line">    &#123;</span><br><span class="line">        list.push_back(token);</span><br><span class="line">    &#125;</span><br><span class="line">    iss.clear();</span><br><span class="line"></span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void receive(TreeNode* &amp;root,vector&lt;string&gt; ss)//前序接收输入</span><br><span class="line">&#123;</span><br><span class="line">    if(index&lt;ss.size())</span><br><span class="line">    &#123;</span><br><span class="line">        string tem=ss[index++];</span><br><span class="line">       // ss.pop_back();</span><br><span class="line">        if(tem==&quot;nullptr&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">            root=nullptr;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            root=new TreeNode;</span><br><span class="line">            root-&gt;val=tem;</span><br><span class="line">            receive(root-&gt;left,ss);</span><br><span class="line">            receive(root-&gt;right,ss);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>层序接收输入</strong></p>
<p>#include&lt;queue&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">void receive(TreeNode* &amp;root,vector&lt;string&gt;&amp; ss)</span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">    if(ss.empty()) </span><br><span class="line">    &#123;</span><br><span class="line">        root=nullptr;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    root=new TreeNode(ss[0]);//初始化，并添加第一个成员</span><br><span class="line">    ss.erase(ss.begin());//去除前端</span><br><span class="line">  </span><br><span class="line">     queue &lt;TreeNode*&gt;nodequeue;</span><br><span class="line">     nodequeue.push(root);//进入第一个元素</span><br><span class="line"></span><br><span class="line">     while(!ss.empty())</span><br><span class="line">     &#123;</span><br><span class="line">        TreeNode* cur=nodequeue.front();//访问前端元素</span><br><span class="line">        nodequeue.pop();//删除前端元素</span><br><span class="line">		</span><br><span class="line">		//左孩子</span><br><span class="line">        string leftval=ss[0];//由于每次有erase的缘故，相当于访问下一个</span><br><span class="line">        ss.erase(ss.begin());//ss又减1</span><br><span class="line">        if(leftval!=&quot;nullptr&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">            cur-&gt;left=new TreeNode(leftval);</span><br><span class="line">            nodequeue.push(cur-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        if(ss.empty()) break;</span><br><span class="line">		</span><br><span class="line">		//右孩子</span><br><span class="line">		</span><br><span class="line">        string rightval=ss[0];</span><br><span class="line">        ss.erase(ss.begin());</span><br><span class="line">         if(rightval!=&quot;nullptr&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">            cur-&gt;right=new TreeNode(rightval);</span><br><span class="line">            nodequeue.push(cur-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>vector&lt;int&gt;版本的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">struct tree&#123;</span><br><span class="line"></span><br><span class="line">    int val;</span><br><span class="line">    tree *left,*right;</span><br><span class="line">   // tree():val(),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">    tree(int x):val(x),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int start=0; //会导致输出有多余的0</span><br><span class="line">void jieshou(vector&lt;int&gt; a,tree* &amp;root)</span><br><span class="line">&#123;</span><br><span class="line">    if(start==a.size()) </span><br><span class="line">    &#123;</span><br><span class="line">        root=nullptr;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    queue&lt;tree*&gt; q;</span><br><span class="line">    root=new tree(a[start]);</span><br><span class="line"></span><br><span class="line">    q.push(root);</span><br><span class="line"></span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">      tree *cur=q.front();</span><br><span class="line">       q.pop();</span><br><span class="line"></span><br><span class="line">       start++;</span><br><span class="line">       //左孩子</span><br><span class="line">     //  if(a[start]!=-1) 不判断start的h话，会打印出0</span><br><span class="line">     if(start&lt;a.size()&amp;&amp;a[start]!=-1)</span><br><span class="line">       &#123;</span><br><span class="line">        cur-&gt;left=new tree(a[start]);</span><br><span class="line">        q.push(cur-&gt;left);</span><br><span class="line">       &#125;</span><br><span class="line">       if(start==a.size()) break;</span><br><span class="line"></span><br><span class="line">       //右孩子</span><br><span class="line">       start++;</span><br><span class="line">      //  if(a[start]!=-1)</span><br><span class="line">       if(start&lt;a.size()&amp;&amp;a[start]!=-1)</span><br><span class="line">       &#123;</span><br><span class="line">        cur-&gt;right=new tree(a[start]);</span><br><span class="line">        q.push(cur-&gt;right);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void bianli(tree* root)</span><br><span class="line">&#123;</span><br><span class="line">    if(root==nullptr) return;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;root-&gt;val;</span><br><span class="line">    bianli(root-&gt;left);</span><br><span class="line">    bianli(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    tree* node=nullptr;</span><br><span class="line">    vector&lt;int&gt; a&#123;1,2,3,4,5,6,-1&#125;;</span><br><span class="line">    jieshou(a,node);</span><br><span class="line">    bianli(node);</span><br><span class="line">//由于全局变量start=7超过索引，会打印0；1240536</span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="剑指55二叉树的深度"><a href="#剑指55二叉树的深度" class="headerlink" title="剑指55二叉树的深度"></a>剑指55二叉树的深度</h2><p>同104</p>
<h2 id="226-反转二叉树"><a href="#226-反转二叉树" class="headerlink" title="226 反转二叉树"></a>226 反转二叉树</h2><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p>
<p><img src="/../../../Typora/img111/image-20230712200429292.png" alt="image-20230712200429292"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br></pre></td></tr></table></figure>

<h3 id="个人做法"><a href="#个人做法" class="headerlink" title="个人做法"></a>个人做法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//即从第二层开始，倒序存储</span></span><br><span class="line">    <span class="comment">//子问题，左孩子与右孩子换位置的问题</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">back</span><span class="params">(TreeNode* &amp;root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">back</span>(root-&gt;left);</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">back</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        TreeNode *node=root-&gt;left;</span><br><span class="line">        root-&gt;left=root-&gt;right;</span><br><span class="line">        root-&gt;right=node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">back</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>哎，还是很晕，不想细节了。</p>
<p>我想到的就是说孩子互换。但是按正常逻辑来说</p>
<p><strong>遍历</strong></p>
<blockquote>
<p>单独抽出个结点，让它做什么,交换它的左右孩子</p>
<p>前中后位置都可以诶，中序要特别处理一下</p>
</blockquote>
<p><strong>分解</strong></p>
<blockquote>
<p>给函数一个定义，让它逻辑自洽</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* invertTree(TreeNode* root) &#123;</span><br><span class="line">       if(root==nullptr) return nullptr;</span><br><span class="line">       //函数定义，反转左子树，但实际是记录吧？</span><br><span class="line">       TreeNode *left=invertTree(root-&gt;left); </span><br><span class="line">       TreeNode *right=invertTree(root-&gt;right);//记录了右节点</span><br><span class="line">       </span><br><span class="line">       //交换左右节点</span><br><span class="line">       root-&gt;right=left;</span><br><span class="line">       root-&gt;left=right;</span><br><span class="line"></span><br><span class="line">       return root;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>嘶，应该是这样吧</p>
<h2 id="116-填充结点的右侧指针"><a href="#116-填充结点的右侧指针" class="headerlink" title="*116 填充结点的右侧指针"></a>*116 填充结点的右侧指针</h2><p>给定一个 <strong>完美二叉树</strong> ，其所有叶子节点都在同一层，每个父节点都有两个子节点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>
<p>初始状态下，所有 next 指针都被设置为 NULL。</p>
<p><img src="/../../../Typora/img111/image-20230712220310325.png" alt="image-20230712220310325"></p>
<h3 id="遍历-模拟三叉树"><a href="#遍历-模拟三叉树" class="headerlink" title="遍历(模拟三叉树)"></a>遍历(模拟三叉树)</h3><p>遍历，每个结点指向右侧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void bianli(Node* &amp;root1,Node* &amp;root2)//模拟三叉树</span><br><span class="line">&#123;</span><br><span class="line">    if(root1==nullptr||root2==nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    root1-&gt;next=root2;</span><br><span class="line">    //父节点相同的</span><br><span class="line">    bianli(root1-&gt;left,root1-&gt;right);</span><br><span class="line">    bianli(root2-&gt;left,root2-&gt;right);</span><br><span class="line">    //不同父节点的</span><br><span class="line">    bianli(root1-&gt;right,root2-&gt;left);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    Node* connect(Node* root) &#123;</span><br><span class="line">        if(root==nullptr) return nullptr;</span><br><span class="line">       bianli(root-&gt;left,root-&gt;right);</span><br><span class="line">       return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>它通过抽象一个三叉树</p>
<p>用左边的结点指向右边的结点</p>
<p>串联有三种情况：</p>
<p>左子树间的孩子串联</p>
<p>右子树间的孩子串联</p>
<p>左子树的最右孩子和右子树的最左孩子连接</p>
<p>输入为根结点的左孩子和右孩子</p>
<p>(哎，已经默认所有next指针设为null，就不需要特别考虑设置null了)</p>
<p><strong>传统的那个遍历方式，就是少考虑了中间5-&gt;6的指向</strong></p>
<h3 id="分解不可以"><a href="#分解不可以" class="headerlink" title="分解不可以"></a>分解不可以</h3><h3 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a>思想</h3><p>同父节点的连接</p>
<p>不同父节点的连接</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>二叉树问题</p>
<p>1.遍历</p>
<p>2.子问题</p>
<p>3.对于<strong>单独结点</strong>，需要做的事；<strong>在什么位置</strong>做这件事。（其他结点会按照该逻辑重复做下去）</p>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>合并有序链表</p>
<blockquote>
<p>目的：将两个链表按升序排列</p>
<p>1.虚拟节点的建立 :ListNode* dumpy&#x3D;new ListNode(-1);</p>
<ol start="2">
<li>访问该新链表：ListNode* p1&#x3D;dumpy;</li>
<li>访问原链表: ListNode *p&#x3D;head;</li>
<li>双指针思想</li>
</ol>
</blockquote>
<p>单链表分解</p>
<blockquote>
<p>目的：将一个链表分解成两个链表</p>
<p>1.分别新建两个虚拟节点</p>
<p>2.分别指向该新虚拟节点</p>
<p>3.访问原链表</p>
<p>4.按条件做</p>
</blockquote>
<p>合并k个有序链表</p>
<blockquote>
<p>题目：给你一个链表数组，每个链表都已经按<strong>升序</strong>排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<p>目的，合并k个链表（如何获取k个链表的最小节点）</p>
<p>引入：优先级队列（二叉堆）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;ListNode*,vector&lt;ListNode*&gt;,function&lt;bool(ListNode*,ListNode*)&gt; &gt;pq([](ListNode *a,ListNode* b)&#123;return a-&gt;val&gt;b-&gt;val&#125;);</span><br></pre></td></tr></table></figure>

<p>&lt;参数类型，容器类型，比较函数&gt;</p>
<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct cmp&#123;</span><br><span class="line">    bool operator()(ListNode *&amp;a,ListNode *&amp;b)</span><br><span class="line">    &#123;</span><br><span class="line">         return a-&gt;val&gt;b-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"> priority_queue&lt;ListNode*,vector&lt;ListNode*&gt;,cmp&gt;pq;</span><br><span class="line"> priority_queue要求接受函数对象而不是函数指针	</span><br><span class="line"> </span><br><span class="line"> 函数对象，如上述struct重构operator</span><br><span class="line"> 而函数指针指的是：如</span><br><span class="line"> bool cmp(const int a, const int b) &#123;</span><br><span class="line">    return a &lt; b;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">struct cmp&#123;</span><br><span class="line">    bool operator()(ListNode *&amp;a,ListNode *&amp;b)</span><br><span class="line">    &#123;</span><br><span class="line">         return a-&gt;val&gt;b-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;</span><br><span class="line">    </span><br><span class="line">        if(lists.empty()) return nullptr;</span><br><span class="line">        ListNode* dumpy=new ListNode(-1);//建立新链表</span><br><span class="line">        ListNode* p=dumpy;</span><br><span class="line"></span><br><span class="line">      priority_queue&lt;ListNode*,vector&lt;ListNode*&gt;,cmp&gt;pq;</span><br><span class="line">        for(ListNode* list:lists)</span><br><span class="line">        &#123;</span><br><span class="line">            if(list!=nullptr)</span><br><span class="line">                pq.push(list);//存各链表中最小的结点</span><br><span class="line">        &#125;</span><br><span class="line">/*如lists = [[1,4,5],[1,3,4],[2,6]]，pq存的是1-&gt;1&gt;2</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line">        while(!pq.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *node=pq.top();//访问</span><br><span class="line">            pq.pop();//弹出</span><br><span class="line">            p-&gt;next=node;//接到p后面</span><br><span class="line">            </span><br><span class="line">            if(node-&gt;next!=nullptr)//遍历某链表的下一个结点</span><br><span class="line">            &#123;</span><br><span class="line">                pq.push(node-&gt;next);</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            p=p-&gt;next;//下一个指针</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return dumpy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  if(node-&gt;next!&#x3D;nullptr)&#x2F;&#x2F;遍历某链表的下一个结点<br>            {<br>                pq.push(node-&gt;next);&#x2F;&#x2F;加入非空节点入优先队列（会经过排序）<br>            }<br>               pq中值为1-&gt;1-&gt;2</p>
<p>​     <strong>一开始是1</strong>，是第一个链表的[1,4,5]，<br>​            后面的是4，加入到pq，则是1-&gt;2-&gt;4<br>​            <strong>然后访问1</strong>，是第二个链表的[1,3,4]，<br>​            后面的是3，加入到pq,则是2-&gt;3-&gt;4<br>​            <strong>然后访问2</strong>，是第三个链表的[2,6]，<br>​            后面的是6，加入到pq，则是3-&gt;4-&gt;6<br>​            <strong>然后访问3</strong>,第二链表的[1,3,4]，<br>​            后面是4，加入到pq，则是4-&gt;4-&gt;6<br>​            <strong>然后访问4</strong>，第一链表的[1,4,5]，<br>​            后面的是5，加入到pq，则是4-&gt;5-&gt;6<br>​            <strong>然后访问4</strong>，第二链表的[1,3,4]<br>​            后面的是nullptr，终于不加入了，pq为5-&gt;6<br>​            <strong>然后访问5</strong>，第一链表的[1,4,5]<br>​            后面的是nullptr，pq为6<br>​            <strong>然后访问6</strong>，没啦。<br>​            </p>
</blockquote>
<h1 id="回溯-2"><a href="#回溯-2" class="headerlink" title="回溯"></a>回溯</h1><p>回溯，核心就是递归，在递归调用前<strong>选择</strong>，递归调用后<strong>撤销</strong></p>
<p>通过列表中每固定一个数（做出的选择），形成了路径</p>
<p>纯暴力解法</p>
<blockquote>
<p>1.列表中选择某点</p>
<p>#做选择</p>
<p>2.列表中移除该点</p>
<p>3.路径添加该点</p>
<p>4.递归</p>
<p>#撤销</p>
<p>5.路径移除该点</p>
<p>6.该选择恢复到列表中</p>
</blockquote>
<h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt; &gt;res;</span><br><span class="line">void backtrack(vector&lt;int&gt; a,vector&lt;int&gt; path,vector&lt;bool&gt;used);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; a;</span><br><span class="line">    int num;</span><br><span class="line">    while(cin&gt;&gt;num)</span><br><span class="line">    &#123;</span><br><span class="line">        a.push_back(num);</span><br><span class="line">        if(cin.get()==&#x27;\n&#x27;) break;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; path;//路径</span><br><span class="line">    vector&lt;bool&gt; used(a.size());</span><br><span class="line">    backtrack(a,path,used);</span><br><span class="line"></span><br><span class="line">    // for(auto li:res)</span><br><span class="line">    // &#123;</span><br><span class="line">    //     for(auto lii:li)</span><br><span class="line">    //     cout&lt;&lt;lii;</span><br><span class="line"></span><br><span class="line">    //     cout&lt;&lt;endl;</span><br><span class="line">    // &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void backtrack(vector&lt;int&gt; a,vector&lt;int&gt; path,vector&lt;bool&gt;used)</span><br><span class="line">&#123;</span><br><span class="line">    //触发结束条件</span><br><span class="line">    if(path.size()==a.size())</span><br><span class="line">    &#123;</span><br><span class="line">        res.push_back(path);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;a.size();i++)&#123;</span><br><span class="line">        //排除不合法选项</span><br><span class="line">        if(used[i]) //已经访问过 </span><br><span class="line">        continue;</span><br><span class="line">        //选择</span><br><span class="line">       // cout&lt;&lt;&quot;xuanze:&quot;&lt;&lt;a[i]&lt;&lt;endl;</span><br><span class="line">        path.push_back(a[i]);</span><br><span class="line">        used[i]=true;</span><br><span class="line">        //做下一个选择</span><br><span class="line">        backtrack(a,path,used);</span><br><span class="line">        //撤销选择</span><br><span class="line">        path.pop_back();</span><br><span class="line">        used[i]=false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h2><p>n*n的棋盘，放n个皇后，每行放一个，不得互相攻击，求可能的放法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;string&gt; &gt;res;</span><br><span class="line">bool isvalid(vector&lt;string&gt; &amp;board,int row,int col);</span><br><span class="line">void backtrack(vector&lt;string&gt; a,int row);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;string&gt; board(n,string(n,&#x27;.&#x27;));//棋盘</span><br><span class="line">  </span><br><span class="line">    backtrack(board,0);//从第0行开始放</span><br><span class="line"></span><br><span class="line">    for(auto li:res)</span><br><span class="line">    &#123;</span><br><span class="line">        for(auto lii:li)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;lii&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">           </span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void backtrack(vector&lt;string&gt; a,int row)</span><br><span class="line">&#123;</span><br><span class="line">    //触发结束条件</span><br><span class="line">    if(row==a.size())</span><br><span class="line">    &#123;</span><br><span class="line">        res.push_back(a);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">     int n=a[row].size();</span><br><span class="line">    for(int col=0;col&lt;n;col++)&#123;</span><br><span class="line">        //排除不合法选项</span><br><span class="line">       </span><br><span class="line">        if(!isvalid(a,row,col))</span><br><span class="line">        &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        //选择</span><br><span class="line">        a[row][col]=&#x27;Q&#x27;;</span><br><span class="line">        //做下一个选择</span><br><span class="line">        backtrack(a,row+1);</span><br><span class="line"> </span><br><span class="line">        //撤销选择</span><br><span class="line">        a[row][col]=&#x27;.&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">bool isvalid(vector&lt;string&gt; &amp;board,int row,int col)</span><br><span class="line">&#123;</span><br><span class="line">    int n=board.size();//行</span><br><span class="line">    //两行之间垂直，遇到左上，遇到右上</span><br><span class="line">    for(int i=0;i&lt;=row;i++)//列</span><br><span class="line">    &#123;</span><br><span class="line">        if(board[i][col]==&#x27;Q&#x27;) return false;</span><br><span class="line">    &#125;</span><br><span class="line">    //右上</span><br><span class="line">    for(int i=row-1,j=col+1;i&gt;=0&amp;&amp;j&lt;n;i--,j++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(board[i][j]==&#x27;Q&#x27;) return false;</span><br><span class="line">    &#125;</span><br><span class="line">    //左上</span><br><span class="line">    for(int i=row-1,j=col-1;i&gt;=0&amp;&amp;j&gt;=0;i--,j--)</span><br><span class="line">    &#123;</span><br><span class="line">        if(board[i][j]==&#x27;Q&#x27;) return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for xuanze in liebiao:</span><br><span class="line">	//筛选不符项</span><br><span class="line">	if(!valid()) continue;</span><br><span class="line">	//做选择</span><br><span class="line">	//下一个递归</span><br><span class="line">	//撤销选择</span><br></pre></td></tr></table></figure>

<p>是否有效，路径，结束条件</p>
<h2 id="463岛屿的周长"><a href="#463岛屿的周长" class="headerlink" title="463岛屿的周长"></a>463岛屿的周长</h2><p>先判断是否是岛屿，是就加4，再判断该格子的上下左右是否是岛屿，是，则有重叠部分，结果-1</p>
<h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int jisuan(vector&lt;vector&lt;int&gt;&gt;&amp; grid) </span><br><span class="line">   &#123;</span><br><span class="line">       int res=0;</span><br><span class="line">       int r=grid.size();</span><br><span class="line">       int c=grid[0].size();</span><br><span class="line">       for(int i=0;i&lt;r;i++)</span><br><span class="line">       &#123;</span><br><span class="line">           for(int j=0;j&lt;c;j++)</span><br><span class="line">           &#123;</span><br><span class="line">               if(grid[i][j]==1)</span><br><span class="line">               &#123;</span><br><span class="line">                   res+=4;</span><br><span class="line">                   if(i+1&lt;r&amp;&amp;grid[i+1][j]==1) res-=1;</span><br><span class="line">                   if(j+1&lt;c&amp;&amp;grid[i][j+1]==1) res-=1;</span><br><span class="line">                   if(i-1&gt;=0&amp;&amp;grid[i-1][j]==1) res-=1;</span><br><span class="line">                   if(j-1&gt;=0&amp;&amp;grid[i][j-1]==1) res-=1;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return res;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>或者4*陆地数-2*重叠的边数(即，往下走和往右走，遇到陆地了，edge+1)</p>
<h3 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">int dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid,int r,int c) </span><br><span class="line"> &#123;</span><br><span class="line"></span><br><span class="line">     //从一个岛屿走向边界，周长+1</span><br><span class="line">     if(r&lt;0||r&gt;=grid.size()||c&lt;0||c&gt;=grid[0].size()) return 1;</span><br><span class="line">     </span><br><span class="line">     if(grid[r][c]==0) return 1;//从陆地走向水域，周长+1</span><br><span class="line"></span><br><span class="line">     if(grid[r][c]!=1) return 0;//说明遍历过了</span><br><span class="line"></span><br><span class="line">     grid[r][c]=2;//表示访问过</span><br><span class="line"></span><br><span class="line">     return dfs(grid,r-1,c)+ dfs(grid, r + 1, c)+ dfs(grid, r, c - 1)+ dfs(grid, r, c + 1);</span><br><span class="line"> &#125;</span><br><span class="line"> int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line"></span><br><span class="line">     int res=0;</span><br><span class="line">     for(int i=0; i&lt;grid.size(); i++)&#123;</span><br><span class="line">         for(int j=0; j&lt;grid[0].size(); j++)&#123;</span><br><span class="line">             if(grid[i][j]==1)&#123;</span><br><span class="line">                 res+= dfs(grid, i, j);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return res;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int left=0,right=...;</span><br><span class="line">while(...)//注意点</span><br><span class="line">&#123;</span><br><span class="line">int mid=left+(right-left)/2;//防止溢出</span><br><span class="line">if(nums[mid]==target)</span><br><span class="line">...</span><br><span class="line">else if(&lt;)</span><br><span class="line">left=mid+1;</span><br><span class="line">else if(&gt;)</span><br><span class="line">right=mid-1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="寻找一个数"><a href="#寻找一个数" class="headerlink" title="寻找一个数"></a>寻找一个数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int l=0,r=nums.size()-1;</span><br><span class="line">while(l&lt;=r)</span><br><span class="line">&#123;</span><br><span class="line">	int mid=left+(right-left)/2;//防止溢出</span><br><span class="line">if(nums[mid]==target)</span><br><span class="line">return mid;</span><br><span class="line">else if(&lt;)</span><br><span class="line">left=mid+1;</span><br><span class="line">else if(&gt;)</span><br><span class="line">right=mid-1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是有序数组 2 3 3 3 4 5 6，target为3，求得的索引会是2，得不到左边的3和右边的3</p>
<h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><p>找最短路径</p>
<p>本质是图，从起点走到终点，求最短路径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">int BFS(Node start, Node target)</span><br><span class="line">&#123;</span><br><span class="line">    queue&lt;Node&gt; q;</span><br><span class="line">    set&lt;Node&gt; visited;//避免回头</span><br><span class="line"></span><br><span class="line">    q.push(start);</span><br><span class="line">    visited.insert(start);</span><br><span class="line"></span><br><span class="line">    while (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        int size = q.size();</span><br><span class="line">        for (int i = 0; i &lt; size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Node cur = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            if (cur == target)</span><br><span class="line">                return step;</span><br><span class="line"></span><br><span class="line">            for (auto x : cur的相邻结点)</span><br><span class="line">            &#123;</span><br><span class="line">                if (visited.count(x) == 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(x);</span><br><span class="line">                    visited.insert(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //否则没有找到目标结点</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>核心问题：穷举</p>
<p>解决对象：一般求最值</p>
<p>dp前提：</p>
<blockquote>
<p>1.具有最优子结构</p>
<p>2.通过子问题最值得到原问题最值</p>
<p>3.正确的状态转移方程</p>
</blockquote>
<p>优化：备忘录、DP table</p>
<h2 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h2><p>明确<strong>base case</strong> -&gt;明确 <strong>状态</strong> -&gt; 明确 <strong>选择</strong>-&gt;定义 <strong>dp数组</strong>的含义</p>
<p>基本框架</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 自顶向下递归的动态规划</span><br><span class="line">def dp(状态1, 状态2, ...):</span><br><span class="line">    for 选择 in 所有可能的选择:</span><br><span class="line">        # 此时的状态已经因为做了选择而改变</span><br><span class="line">        result = 求最值(result, dp(状态1, 状态2, ...))</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line"># 自底向上迭代的动态规划</span><br><span class="line"># 初始化 base case</span><br><span class="line">dp[0][0][...] = base case</span><br><span class="line"># 进行状态转移</span><br><span class="line">for 状态1 in 状态1的所有取值：</span><br><span class="line">    for 状态2 in 状态2的所有取值：</span><br><span class="line">        for ...</span><br><span class="line">            dp[状态1][状态2][...] = 求最值(选择1，选择2...)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="以斐波那契为例-重叠子问题的消除方法"><a href="#以斐波那契为例-重叠子问题的消除方法" class="headerlink" title="以斐波那契为例(重叠子问题的消除方法)"></a>以斐波那契为例(重叠子问题的消除方法)</h2><p>它不是求最值，严格来讲不是动态规划问题</p>
<p><strong>暴力递归</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int fib(int N) &#123;</span><br><span class="line">    if (N == 1 || N == 2) return 1;</span><br><span class="line">    return fib(N - 1) + fib(N - 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果n&#x3D;20，那么自顶向下的<strong>递归树</strong>就是</p>
<p><img src="/../../../Typora/img111/image-20230806174428184.png" alt="image-20230806174428184"></p>
<p>会遇到<strong>重叠子问题</strong>，比如f(17)，上述递归树就是说，想知道f(20)，去求f(19)和f(18)。。。直至求f(1)和f(2)</p>
<p>递归时间的复杂度就是*<em>子问题个数(结点总数)<em>解决一个子问题所需时间(比如循环算法)</em></em></p>
<p>上述时间为O(2ⁿ)*O(1)</p>
<p>为了优化，引入了<strong>备忘录解法</strong>和<strong>递推解法</strong></p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h3><p><strong>自顶向下</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int fib(int n)</span><br><span class="line">&#123;</span><br><span class="line">	//初始化为0</span><br><span class="line">	vector&lt;int&gt; memo(n+1,0);</span><br><span class="line">	return dp(memo,n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int dp(vector&lt;int&gt;memo,int n)</span><br><span class="line">&#123;</span><br><span class="line">	//base case</span><br><span class="line">	if(n==0||n==1) return 0;</span><br><span class="line">	//如果计算过</span><br><span class="line">	if(memo[n]!=0) return memo[n];</span><br><span class="line">	memo[n]=dp(memo,n-1)+dp(memo,n-2);</span><br><span class="line">	return memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相当于将递归树大量冗余的部分进行了 <strong>剪枝</strong></p>
<p><strong>减少了子问题中结点的个数</strong></p>
<p>子问题就是 <code>f(1)</code>, <code>f(2)</code>, <code>f(3)</code> … <code>f(20)</code>，n个值</p>
<p>时间复杂度O(n)</p>
<h3 id="递推"><a href="#递推" class="headerlink" title="递推"></a>递推</h3><p><strong>自底向上</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int fib(int n)</span><br><span class="line">&#123;</span><br><span class="line">	if(n==0) return 0;</span><br><span class="line">	int *dp=new int[n+1];</span><br><span class="line">	//base case</span><br><span class="line">	dp[0]=0;dp[1]=1;</span><br><span class="line">	//状态转移</span><br><span class="line">	for(int i=2;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">	dp[i]=dp[i-1]+dp[i-2];</span><br><span class="line">	&#125;</span><br><span class="line">	return dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h3><p>上述的斐波那契算法，会发现，当前n状态只和n-1状态、n-2状态有关</p>
<p>所以可以</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int fit(int n)</span><br><span class="line">&#123;</span><br><span class="line">	if(n==0||n==1) return n;</span><br><span class="line">	int tem1=0,tem2=0;</span><br><span class="line">	for(int 2=0;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int result=tem1+tem2;</span><br><span class="line">		tem2=tem1;</span><br><span class="line">		tem1=result;</span><br><span class="line">	&#125;</span><br><span class="line">	return tem1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="凑零钱问题-最优子结构"><a href="#凑零钱问题-最优子结构" class="headerlink" title="凑零钱问题(最优子结构)"></a>凑零钱问题(最优子结构)</h2><p><strong>最优子结构满足条件：子问题间独立</strong></p>
<p>给你 <code>k</code> 种面值的硬币，面值分别为 <code>c1, c2 ... ck</code>，每种硬币的数量无限，再给一个总金额 <code>amount</code>，问你<strong>最少</strong>需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 </p>
<p>暴力递归法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int dp(vector&lt;int&gt; coin,int amount)</span><br><span class="line">&#123;</span><br><span class="line">	if(amount==0) return 0;//base </span><br><span class="line">	else if(amount&lt;0) return -1;</span><br><span class="line">	int res=INT_MAX;</span><br><span class="line">	for(auto a:coin)</span><br><span class="line">	&#123;</span><br><span class="line">		//计算子问题</span><br><span class="line">		int subcoin=dp(coin,amount-coin);</span><br><span class="line">		if(subcoin==-1) continue;</span><br><span class="line">		//子问题中选择最优解</span><br><span class="line">		res=min(res,subcoin+1);//+1表示使用了当前硬币</span><br><span class="line">	&#125;</span><br><span class="line">	return res==INT_MAX ? -1:res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了优化，这里用递推</p>
<p>定义dp[i]，目标金额为i，至少需要dp[i]枚硬币</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int findcoin(vector&lt;int&gt; a,int amount)</span><br><span class="line">&#123;</span><br><span class="line">	if(amount==0) return 0;</span><br><span class="line">	vector&lt;int&gt; dp(amount+1,amount+1);</span><br><span class="line">	dp[0]=0;</span><br><span class="line">	//遍历dp数组</span><br><span class="line">	for(int i=0;i&lt;dp.size();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		//遍历硬币</span><br><span class="line">		for(int tem:a)</span><br><span class="line">		&#123;</span><br><span class="line">		//别忘了，i现在指代的是目标金额，tem是coin的元素</span><br><span class="line">			if(i-tem&lt;0) continue;</span><br><span class="line">			dp[i]=min(dp[i],dp[i-tem]+1);</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	return (dp[amount]==amount+1)?-1:dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300.最长递增子序列"></a>300.最长递增子序列</h2><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p>
<p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [10,9,2,5,3,7,101,18]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,0,3,2,3]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [7,7,7,7,7,7,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p>1.去定义一个dp数组，其意义为从nums取前i个元素时，最长递增长度为dp[i]</p>
<p>2.那么i相当于每次新数组的最后一位，那么再来个for循环，从0遍历到i</p>
<p>3.如果nums[j]&lt;nums[i]，那么dp[i]&#x3D;max(dp[i],dp[j]+1);这个+1表示使用了当前数</p>
<p>4.更新res</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int findlength(vector&lt;int&gt; nums)</span><br><span class="line">  &#123;</span><br><span class="line">      int res=0;</span><br><span class="line">      int n=nums.size();</span><br><span class="line">      if(nums.size()==0) return 0;</span><br><span class="line">      vector&lt;int&gt;dp(n+1,0);//记dp[i]表示一个递增数组，元素个数为i时的最长递增长度为dp[i]</span><br><span class="line">      for(int i=0;i&lt;nums.size();i++)//定义i为数组的最后一位</span><br><span class="line">      &#123;</span><br><span class="line">          dp[i]=1;</span><br><span class="line">          for(int j=0;j&lt;i;j++)//从0遍历到i</span><br><span class="line">          &#123;</span><br><span class="line">              if(nums[i]&gt;nums[j])//</span><br><span class="line">                  dp[i]=max(dp[i],dp[j]+1);</span><br><span class="line">          &#125;</span><br><span class="line">          res=max(res,dp[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      return res;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n²)</p>
<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def findSubArray(nums):</span><br><span class="line">    N = len(nums) # 数组/字符串长度</span><br><span class="line">    left, right = 0, 0 # 双指针，表示当前遍历的区间[left, right]，闭区间</span><br><span class="line">    sums = 0 # 用于统计 子数组/子区间 是否有效，根据题目可能会改成求和/计数</span><br><span class="line">    res = 0 # 保存最大的满足题目要求的 子数组/子串 长度</span><br><span class="line">    while right &lt; N: # 当右边的指针没有搜索到 数组/字符串 的结尾</span><br><span class="line">        sums += nums[right] # 增加当前右边指针的数字/字符的求和/计数</span><br><span class="line">        while 区间[left, right]不符合题意: # 此时需要一直移动左指针，直至找到一个符合题意的区间</span><br><span class="line">            sums -= nums[left] # 移动左指针前需要从counter中减少left位置字符的求和/计数</span><br><span class="line">            left += 1 # 真正的移动左指针，注意不能跟上面一行代码写反</span><br><span class="line">        # 到 while 结束时，我们找到了一个符合题意要求的 子数组/子串</span><br><span class="line">        res = max(res, right - left + 1) # 需要更新结果</span><br><span class="line">        right += 1 # 移动右指针，去探索新的区间</span><br><span class="line">    return res</span><br><span class="line"></span><br><span class="line">作者：负雪明烛</span><br><span class="line">链接：https://leetcode.cn/problems/max-consecutive-ones-iii/solutions/609055/fen-xiang-hua-dong-chuang-kou-mo-ban-mia-f76z/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h2 id="1004-最大连续1的个数"><a href="#1004-最大连续1的个数" class="headerlink" title="1004 最大连续1的个数"></a>1004 最大连续1的个数</h2><p>最大可翻转k个0，求数组中连续1最大的个数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,1,0,0,0,1,1,1,1,0], K = 2</span><br><span class="line">输出：6</span><br><span class="line">解释：[1,1,1,0,0,1,1,1,1,1,1]</span><br><span class="line">粗体数字从 0 翻转到 1，最长的子数组长度为 6。</span><br></pre></td></tr></table></figure>

<p>转换为滑动窗口问题，如果最大的窗口中的0的个数为k，就可以组成最大连续1的个数</p>
<p>双指针法，左指针控制左索引i，右指针控制右索引j   最大个数为j-i+1，记录0的个数zero</p>
<p>先遍历数组，如果nums[i]&#x3D;0,zero++</p>
<p>一旦zero&gt;k，就需要减少zero，那就是将左指针向右滑动，直到zero&lt;&#x3D;k，更新左索引</p>
<p>更新最大值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int longestOnes(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">     int res=0,zero=0,left=0;</span><br><span class="line">     for(int r=0;r&lt;nums.size();++r)</span><br><span class="line">     &#123;</span><br><span class="line">         if(nums[r]==0) ++zero;</span><br><span class="line">         while(zero&gt;k)</span><br><span class="line">         &#123;</span><br><span class="line">             if(nums[left]==0)</span><br><span class="line">             &#123;</span><br><span class="line">                 --zero;</span><br><span class="line">             &#125; </span><br><span class="line">             left++;</span><br><span class="line">         &#125;</span><br><span class="line">         res=max(res,r-left+1);</span><br><span class="line">     &#125;</span><br><span class="line">     return res;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h1 id="牛客"><a href="#牛客" class="headerlink" title="牛客"></a>牛客</h1><h2 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h2><h3 id="wp"><a href="#wp" class="headerlink" title="wp"></a>wp</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int pos = 0;</span><br><span class="line">bool priority(char m, char n) &#123;//判断优先度</span><br><span class="line">    if (m == &#x27;(&#x27;) return false;</span><br><span class="line">    else if ((m == &#x27;+&#x27; || m == &#x27;-&#x27;) &amp;&amp; (n == &#x27;*&#x27; || n == &#x27;/&#x27;)) return false;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">void cal(stack&lt;char&gt;&amp; op, stack&lt;int&gt;&amp; num) &#123;</span><br><span class="line"></span><br><span class="line">    int b = num.top();//先弹出来的属于第二个数</span><br><span class="line">    num.pop();</span><br><span class="line">    int a = num.top();</span><br><span class="line">    num.pop();</span><br><span class="line">    char zifu = op.top(); //栈顶运算符</span><br><span class="line">    op.pop();</span><br><span class="line">    if (zifu == &#x27;+&#x27;) a = a + b;</span><br><span class="line">    else if (zifu == &#x27;-&#x27;) a = a - b;</span><br><span class="line">    else if (zifu == &#x27;*&#x27;) a = a * b;</span><br><span class="line">    else a = a / b;</span><br><span class="line">    num.push(a);//计算后放回去</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    stack&lt;char&gt; op;</span><br><span class="line">    stack&lt;int&gt; num;</span><br><span class="line"></span><br><span class="line">    op.push(&#x27;(&#x27;);//先加个左括号</span><br><span class="line">    s += &#x27;)&#x27;;</span><br><span class="line">    bool flag = false;//是否出现了数字</span><br><span class="line">    for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">        if (s[i] == &#x27;(&#x27;) op.push(&#x27;(&#x27;);//遇到括号，放进op栈</span><br><span class="line">        else if (s[i] == &#x27;)&#x27;) &#123;//遇到右括号,计算，直到遇到左括号</span><br><span class="line">            while (op.top() != &#x27;(&#x27;) &#123;</span><br><span class="line">                cal(op, num);</span><br><span class="line">            &#125;</span><br><span class="line">            op.pop();//将左括号弹出</span><br><span class="line">        &#125; else if (flag) &#123; //出现了数字</span><br><span class="line"></span><br><span class="line">        //判断op栈顶优先于当前字符，计算</span><br><span class="line">            while (priority(op.top(), s[i])) &#123;</span><br><span class="line">                cal(op, num);</span><br><span class="line">            &#125;</span><br><span class="line">            op.push(s[i]);//否则加入新字符</span><br><span class="line">            flag = false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            int j = i;</span><br><span class="line">            if (s[j] == &#x27;-&#x27; || s[j] == &#x27;+&#x27;) i++;</span><br><span class="line">            while (isdigit(s[i])) i++;</span><br><span class="line">            string temp = s.substr(j, i - j);</span><br><span class="line">            num.push(stoi(temp));</span><br><span class="line">            i--;</span><br><span class="line">            flag = true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; num.top() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="错误代码"><a href="#错误代码" class="headerlink" title="错误代码"></a>错误代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">void cal(vector&lt;char&gt; &amp;op,stack&lt;int&gt; &amp;num)</span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">       char zifu=op[0];</span><br><span class="line">       op.erase(op.begin());</span><br><span class="line">       if(zifu==&#x27;+&#x27;)</span><br><span class="line">       &#123;</span><br><span class="line">            int a=num.top();</span><br><span class="line">            num.pop();</span><br><span class="line">            int b=num.top();</span><br><span class="line">            num.pop();</span><br><span class="line">            num.push(a+b);</span><br><span class="line">       &#125;</span><br><span class="line">        if(zifu==&#x27;-&#x27;)</span><br><span class="line">       &#123;</span><br><span class="line">            int a=num.top();</span><br><span class="line">            num.pop();</span><br><span class="line">            int b=num.top();</span><br><span class="line">            num.pop();</span><br><span class="line"></span><br><span class="line">            num.push(b-a);</span><br><span class="line">       &#125;</span><br><span class="line">         if(zifu==&#x27;*&#x27;)</span><br><span class="line">       &#123;</span><br><span class="line">            int a=num.top();</span><br><span class="line">            num.pop();</span><br><span class="line">            int b=num.top();</span><br><span class="line">            num.pop();</span><br><span class="line"></span><br><span class="line">            num.push(b*a);</span><br><span class="line">       &#125;</span><br><span class="line">       if(zifu==&#x27;/&#x27;)</span><br><span class="line">       &#123;</span><br><span class="line">            int a=num.top();</span><br><span class="line">            num.pop();</span><br><span class="line">            int b=num.top();</span><br><span class="line">            num.pop();</span><br><span class="line">            //不考虑b=0</span><br><span class="line">            num.push(b/a);</span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line"></span><br><span class="line">    stack&lt;char&gt; op;</span><br><span class="line">    vector&lt;char&gt; opnew;//后缀操作符记录</span><br><span class="line">    stack&lt;int&gt; num;</span><br><span class="line">    string n=&quot;&quot;;</span><br><span class="line">    for(int i=0;i&lt;s.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">      //  </span><br><span class="line">        if(s[i]==&#x27;+&#x27;||s[i]==&#x27;-&#x27;||s[i]==&#x27;*&#x27;||s[i]==&#x27;/&#x27;||s[i]==&#x27;(&#x27;)</span><br><span class="line">            &#123;</span><br><span class="line">                op.push(s[i]);</span><br><span class="line">                num.push(stoi(n));</span><br><span class="line">                n=&quot;&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        else if(s[i]==&#x27;)&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            while(op.top()!=&#x27;(&#x27;)</span><br><span class="line">            &#123;</span><br><span class="line">                opnew.push_back(op.top());</span><br><span class="line">                op.pop();</span><br><span class="line"></span><br><span class="line">                if(op.top()==&#x27;(&#x27;)</span><br><span class="line">              &#123;</span><br><span class="line">                op.pop();</span><br><span class="line">                break;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            n+=s[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    num.push(stoi(n));//获取最后一个值</span><br><span class="line"></span><br><span class="line">    //将op剩余的操作符给opnew</span><br><span class="line">    while(!op.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        opnew.push_back(op.top());</span><br><span class="line">        op.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    // for(auto a:opnew)</span><br><span class="line">    // &#123;</span><br><span class="line">    //     cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    // &#125;</span><br><span class="line">    // while(!num.empty())</span><br><span class="line">    // &#123;</span><br><span class="line">    //     cout&lt;&lt;num.top()&lt;&lt;endl;</span><br><span class="line">    //     num.pop();</span><br><span class="line">    // &#125;</span><br><span class="line">    while(!opnew.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        cal(opnew,num);</span><br><span class="line">    &#125;</span><br><span class="line">   //int result=0;</span><br><span class="line">   </span><br><span class="line">    cout&lt;&lt;num.top();</span><br><span class="line">    // cout&lt;&lt;num.top()&lt;&lt;&quot; &quot;&lt;&lt;num.size()&lt;&lt;endl;</span><br><span class="line">    // num.pop();</span><br><span class="line">    // cout&lt;&lt;num.top();</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>&#x2F;<br>*<br>10<br>5<br>400</p>
</blockquote>
<h2 id="尼科彻斯定理"><a href="#尼科彻斯定理" class="headerlink" title="尼科彻斯定理"></a>尼科彻斯定理</h2><p>a^3（a为任意）&#x3D;连续a个奇数的和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">   int n;</span><br><span class="line">   cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">   int num=n*n*n;</span><br><span class="line">    int flag=-1,start=1;</span><br><span class="line">   for(int j=1;j&lt;num;j+=2)</span><br><span class="line">   &#123;</span><br><span class="line">        int co=0,result=0;</span><br><span class="line">        while(co&lt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            result+=j+co*2;</span><br><span class="line">            co++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(result==num)</span><br><span class="line">        &#123;</span><br><span class="line">            start=j;</span><br><span class="line">            flag=1;</span><br><span class="line">            break;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">   &#125;</span><br><span class="line">    if(flag==1)</span><br><span class="line">    &#123;</span><br><span class="line">       int co=0;</span><br><span class="line">       string s=&quot;&quot;;</span><br><span class="line">       while(co&lt;n)</span><br><span class="line">       &#123;</span><br><span class="line">        s+=to_string(start+co*2)+&quot;+&quot;;</span><br><span class="line">        co++;</span><br><span class="line">       &#125;</span><br><span class="line">    cout&lt;&lt;s.substr(0,s.size()-1);</span><br><span class="line">    &#125;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进阶那就是等差数列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">   int n;</span><br><span class="line">   cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">   int num=n*n*n;</span><br><span class="line">   //sn=na+n(n-1)*d/2 找首项的问题</span><br><span class="line">   int a=(num-n*(n-1))/n;</span><br><span class="line">   for(int i=0;i&lt;n;i++)</span><br><span class="line">   &#123;</span><br><span class="line">        cout&lt;&lt;to_string(a+i*2);</span><br><span class="line">        if(i!=n-1) cout&lt;&lt;&quot;+&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="公共子串计算"><a href="#公共子串计算" class="headerlink" title="公共子串计算"></a>公共子串计算</h2><p><strong>查找、动态规划</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    string s1,s2;</span><br><span class="line">    cin&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line">    int n=s1.size(),m=s2.size();</span><br><span class="line">    //int len1=s1.size(),len2=s2.size();</span><br><span class="line">    int maxlen=0;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt;a(n+1,vector&lt;int&gt;(m+1,0));</span><br><span class="line">    //a[i][j] 即s1的前i个字符与s2的前j个字符的最大公共子串长度</span><br><span class="line">    //基础值填充</span><br><span class="line">    // for(int i=0;i&lt;n;i++)</span><br><span class="line">    // &#123;</span><br><span class="line">    //     if(s1[0]==s2[i])</span><br><span class="line">    //     &#123;</span><br><span class="line">    //         a[0][i]=1;</span><br><span class="line">    //         maxlen=1;</span><br><span class="line">    //     &#125;</span><br><span class="line">    //     //else a[0][i]=0;</span><br><span class="line">    // &#125;</span><br><span class="line">    // for(int i=0;i&lt;m;i++)</span><br><span class="line">    // &#123;</span><br><span class="line">    //     if(s1[i]==s2[0])</span><br><span class="line">    //     &#123;</span><br><span class="line">    //         a[i][0]=1;</span><br><span class="line">    //         maxlen=1;</span><br><span class="line">    //     &#125;</span><br><span class="line">    //     //else a[i][0]=0;</span><br><span class="line">    // &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)//注意是</span><br><span class="line">    for(int j=1;j&lt;=m;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(s1[i-1]==s2[j-1])//i为尾结点与j尾结点为止的字符相等</span><br><span class="line">        &#123;</span><br><span class="line">            a[i][j]=a[i-1][j-1]+1;//</span><br><span class="line">            maxlen=max(maxlen,a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;maxlen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串字符匹配"><a href="#字符串字符匹配" class="headerlink" title="字符串字符匹配"></a>字符串字符匹配</h2><p>一个短字符串，一个长字符串，短串的字符在长串有所出现即可，不用管次数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">   string t1,t2;</span><br><span class="line">   while(cin&gt;&gt;t1&gt;&gt;t2)//多组样例输入</span><br><span class="line">&#123;</span><br><span class="line">     int n=t1.size(),m=t2.size();</span><br><span class="line">     map&lt;char,int&gt;mp;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        mp[t1[i]]+=1;</span><br><span class="line">    &#125;</span><br><span class="line">    // for(auto a:mp)</span><br><span class="line">    // cout&lt;&lt;a.first&lt;&lt;&quot;,&quot;&lt;&lt;a.second&lt;&lt;endl;</span><br><span class="line">    for(auto&amp; list:mp)//这里要有&amp;，否则不会改变</span><br><span class="line">    for(int j=0;j&lt;m;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(list.second!=0)</span><br><span class="line">        &#123;</span><br><span class="line">        if(list.first==t2[j])</span><br><span class="line">         list.second=0;//list.second--不可取，只要子串的字符出现过</span><br><span class="line">         //即可，不用管次数</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int flag=-1;</span><br><span class="line">    //cout&lt;&lt;endl;</span><br><span class="line">    for(auto a:mp)</span><br><span class="line">    &#123;</span><br><span class="line">    //    cout&lt;&lt;a.first&lt;&lt;&quot;,&quot;&lt;&lt;a.second&lt;&lt;endl;</span><br><span class="line">      if(a.second&gt;0)</span><br><span class="line">      &#123;</span><br><span class="line">        cout&lt;&lt;&quot;false&quot;&lt;&lt;endl;</span><br><span class="line">        flag=1;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(flag&lt;0) cout&lt;&lt;&quot;true&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">   string t1,t2;</span><br><span class="line">   while(cin&gt;&gt;t1&gt;&gt;t2)//多组样例输入</span><br><span class="line">&#123;</span><br><span class="line">     int n=t1.size(),m=t2.size();</span><br><span class="line">     set&lt;char&gt; set1;</span><br><span class="line">    for(int i=0;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        set1.insert(t2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    // for(auto a:mp)</span><br><span class="line">    // cout&lt;&lt;a.first&lt;&lt;&quot;,&quot;&lt;&lt;a.second&lt;&lt;endl;</span><br><span class="line">    int flag=-1;</span><br><span class="line">    for(auto list:t1)</span><br><span class="line">   &#123;</span><br><span class="line">    if(!set1.count(list))</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;false&quot;;</span><br><span class="line">        flag=1;</span><br><span class="line">        break;</span><br><span class="line">    &#125; </span><br><span class="line">   &#125;</span><br><span class="line">   if(flag&lt;0) cout&lt;&lt;&quot;true&quot;;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="华为机试"><a href="#华为机试" class="headerlink" title="华为机试"></a>华为机试</h1><h1 id="1-字符串分割"><a href="#1-字符串分割" class="headerlink" title="1.字符串分割"></a>1.字符串分割</h1><p>给定一个非空字符串S，其被N个‘-’分隔成N+1的子串，给定正整数K，要求除第一个子串外，其余的子串每K个字符组成新的子串，并用‘-’分隔。对于新组成的每一个子串，如果它含有的小写字母比大写字母多，则将这个子串的所有大写字母转换为小写字母；反之，如果它含有的大写字母比小写字母多，则将这个子串的所有小写字母转换为大写字母；大小写字母的数量相等时，不做转换。<br>输入描述:<br>输入为两行，第一行为参数K，第二行为字符串S。<br>输出描述:<br>输出转换后的字符串。<br>示例1<br>输入<br>3<br>12abc-abCABc-4aB@<br>输出<br>12abc-abc-ABC-4aB-@<br>说明<br>子串为12abc、abCABc、4aB@，第一个子串保留，后面的子串每3个字符一组为abC、ABc、4aB、@，abC中小写字母较多，转换为abc，ABc中大写字母较多，转换为ABC，4aB中大小写字母都为1个，不做转换，@中没有字母，连起来即12abc-abc-ABC-4aB-@<br>示例2<br>输入<br>12<br>12abc-abCABc-4aB@<br>输出<br>12abc-abCABc4aB@<br>说明<br>子串为12abc、abCABc、4aB@，第一个子串保留，后面的子串每12个字符一组为abCABc4aB@，这个子串中大小写字母都为4个，不做转换，连起来即12abc-abCABc4aB@</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">string zichuan(string s) //将子串转换大小写</span><br><span class="line">&#123;</span><br><span class="line">    int xiaoxie=1,daxie=1; //统计小写与大写数量</span><br><span class="line">    for(int i=0;i&lt;s.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(s[i]&gt;=&#x27;a&#x27;&amp;&amp;s[i]&lt;=&#x27;z&#x27;)</span><br><span class="line">                xiaoxie++;</span><br><span class="line">        if(s[i]&gt;=&#x27;A&#x27;&amp;&amp;s[i]&lt;=&#x27;Z&#x27;)</span><br><span class="line">                daxie++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(xiaoxie&gt;daxie)           //若小写的多，将大写字母转化为小写。</span><br><span class="line">    for(int j=0;j&lt;s.size();j++)</span><br><span class="line">        if(s[j]&gt;=&#x27;A&#x27;&amp;&amp;s[j]&lt;=&#x27;Z&#x27;)</span><br><span class="line">        s[j]=(s[j]-&#x27;A&#x27;)%26+&#x27;a&#x27;;</span><br><span class="line"></span><br><span class="line">    if(xiaoxie&lt;daxie)</span><br><span class="line">    for(int j=0;j&lt;s.size();j++)</span><br><span class="line">        if(s[j]&gt;=&#x27;a&#x27;&amp;&amp;s[j]&lt;=&#x27;z&#x27;)</span><br><span class="line">        s[j]=(s[j]-&#x27;a&#x27;)%26+&#x27;A&#x27;;</span><br><span class="line"></span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    string ch1=&quot;&quot;,ch=&quot;&quot;;    //ch1记为第一子串；ch为其它子串总和</span><br><span class="line">    int co=0,co1=0,flag=0;  //co为ch的长度,co1用来统计从0开始的子串个数,flag用来区分是否是第一字串</span><br><span class="line">    for(int i=0;i&lt;s.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">       char c=s[i];</span><br><span class="line">       if(c==&#x27;-&#x27;)</span><br><span class="line">        flag=1;</span><br><span class="line">     if(flag==0&amp;&amp;c!=&#x27;-&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            ch1+=c; //第一个字符串</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    if(flag==1&amp;&amp;c!=&#x27;-&#x27;)</span><br><span class="line">    &#123;</span><br><span class="line">        ch+=c;</span><br><span class="line">        co++; //</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //已知ch1,co,ch了</span><br><span class="line">    int t=co-co%n;//从该位置往后，字符数是不足k个的</span><br><span class="line">   // cout&lt;&lt;t&lt;&lt;endl&lt;&lt;ch;</span><br><span class="line">    string ch2=&quot;&quot;; //子字符串</span><br><span class="line">    for(int j=0;j&lt;co;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        ch2+=ch[j];</span><br><span class="line">        co1++;</span><br><span class="line">        if(co1&lt;=t) //&lt;t不行</span><br><span class="line">        &#123;</span><br><span class="line">            if(co1%n==0) </span><br><span class="line">             &#123;</span><br><span class="line">            ch1=ch1+&#x27;-&#x27;+zichuan(ch2);</span><br><span class="line">            //cout&lt;&lt;ch2&lt;&lt;co1&lt;&lt;endl;</span><br><span class="line">            ch2=&quot;&quot;;//清零</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(co1==co)</span><br><span class="line">        &#123;</span><br><span class="line">            ch1=ch1+&#x27;-&#x27;+zichuan(ch2);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">     cout&lt;&lt;ch1&lt;&lt;endl&lt;&lt;co&lt;&lt;endl&lt;&lt;t;</span><br><span class="line">     //cout&lt;&lt;zichuan(ch)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-组成最大数"><a href="#2-组成最大数" class="headerlink" title="2.组成最大数"></a>2.组成最大数</h1><p>小组中每位都有一张卡片<br>卡片是<code>6</code>位以内的正整数<br>将卡片连起来可以组成多种数字<br>计算组成的最大数字</p>
<h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h2><p><code>,</code>分割的多个正整数字符串<br>不需要考虑非数字异常情况<br>小组种最多<code>25</code>个人</p>
<h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h2><p>最大数字字符串</p>
<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">22,221</span><br></pre></td></tr></table></figure>

<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">22221</span><br></pre></td></tr></table></figure>

<h3 id="思想-2"><a href="#思想-2" class="headerlink" title="思想"></a>思想</h3><p>长度相同，数值大的在前；</p>
<p>长度不同，拼接值大的在前</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string a,string b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string c1=a+b;</span><br><span class="line">        string c2=b+a;</span><br><span class="line">        <span class="keyword">return</span> c1&gt;c2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;sds;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;string&gt; s;</span><br><span class="line">    string t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="function">istringstream <span class="title">iss</span><span class="params">(t)</span></span>;</span><br><span class="line">    string token;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(iss,token,<span class="string">&#x27;,&#x27;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        s.<span class="built_in">push_back</span>(token);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    iss.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// while(cin&gt;&gt;num)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     s.push_back(num); //先获取值</span></span><br><span class="line">    <span class="comment">//     if(cin.get()==&#x27;\n&#x27;) break;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>(),<span class="built_in">cmp</span>());<span class="comment">//或者asd</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// for(vector&lt;string&gt;::iterator it=s.begin();it!=s.end();it++)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     cout&lt;&lt;*it&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">  </span><br><span class="line">    string result=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)  <span class="comment">//存在[0,0]的情况。这样处理会是00</span></span><br><span class="line">    result+=s[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(result[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;result;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="拼接最大值"><a href="#拼接最大值" class="headerlink" title="*拼接最大值"></a>*拼接最大值</h2><p>给定长度分别为 m 和 n 的两个数组，其元素由 0-9 构成，表示两个自然数各位上的数字。现在从这两个数组中选出 k (k &lt;&#x3D; m + n) 个数字拼接成一个新的数，要求从同一个数组中取出的数字保持其在原数组中的相对顺序。</p>
<p>求满足该条件的最大数。结果返回一个表示该最大数的长度为 k 的数组。</p>
<p>说明: 请尽可能地优化你算法的时间和空间复杂度。</p>
<p>示例 1:</p>
<p>输入:<br>nums1 &#x3D; [3, 4, 6, 5]<br>nums2 &#x3D; [9, 1, 2, 5, 8, 3]<br>k &#x3D; 5<br>输出:<br>[9, 8, 6, 5, 3]<br>示例 2:</p>
<p>输入:<br>nums1 &#x3D; [6, 7]<br>nums2 &#x3D; [6, 0, 4]<br>k &#x3D; 5<br>输出:<br>[6, 7, 6, 0, 4]<br>示例 3:</p>
<p>输入:<br>nums1 &#x3D; [3, 9]<br>nums2 &#x3D; [8, 9]<br>k &#x3D; 3<br>输出:<br>[9, 8, 9]</p>
<h3 id="思想-3"><a href="#思想-3" class="headerlink" title="思想"></a>思想</h3><p>求子问题，nums1中取i个组成最大的子序列，nums2中取k-i个，组成最大的子序列，合并，求所有的i的可能</p>
<p>要使得子序列最大，那从左到右是递减的</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       vector&lt;<span class="type">int</span>&gt; max_n1,max_n2;</span><br><span class="line">       <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxseq</span><span class="params">(k,<span class="number">0</span>)</span></span>;</span><br><span class="line">       <span class="type">int</span> n1=nums1.<span class="built_in">size</span>(),n2=nums2.<span class="built_in">size</span>();</span><br><span class="line">       <span class="type">int</span> start=<span class="built_in">max</span>(<span class="number">0</span>,k-n2);<span class="comment">//表示从nums1中取得的下限</span></span><br><span class="line">       <span class="type">int</span> end=<span class="built_in">min</span>(k,n1);<span class="comment">//表示从nums1中取得的上限</span></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       如果k-n2为负数，意味着不需要在</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;=end;i++) <span class="comment">//</span></span><br><span class="line">       &#123;</span><br><span class="line">           vector&lt;<span class="type">int</span>&gt; max_n1=<span class="built_in">pick_max</span>(nums1,i);</span><br><span class="line">           vector&lt;<span class="type">int</span>&gt; max_n2=<span class="built_in">pick_max</span>(nums2,k-i);</span><br><span class="line">           vector&lt;<span class="type">int</span>&gt; curmerge=<span class="built_in">merge</span>(max_n1,max_n2);</span><br><span class="line">           <span class="keyword">if</span>(<span class="built_in">compare</span>(curmerge,<span class="number">0</span>,maxseq,<span class="number">0</span>)&gt;<span class="number">0</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               maxseq=curmerge;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> maxseq;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pick_max</span><span class="params">(vector&lt;<span class="type">int</span>&gt; num,<span class="type">int</span> k)</span><span class="comment">//个数为k的最大序列</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    <span class="type">int</span> drop=num.<span class="built_in">size</span>()-k;<span class="comment">//允许丢弃数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(drop&gt;<span class="number">0</span>&amp;&amp;!st.<span class="built_in">empty</span>()&amp;&amp;st.<span class="built_in">back</span>()&lt;num[i])<span class="comment">//1.drop和drop&gt;0做条件不一样</span></span><br><span class="line">        &#123;</span><br><span class="line">            st.<span class="built_in">pop_back</span>();</span><br><span class="line">            drop--;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//st.push_back(num[i]);</span></span><br><span class="line">        <span class="keyword">if</span>(st.<span class="built_in">size</span>()&lt;k) <span class="comment">//没有取够k个</span></span><br><span class="line">            st.<span class="built_in">push_back</span>(num[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//取够了就继续丢弃</span></span><br><span class="line">        &#123;</span><br><span class="line">            drop--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//st.resize(k);</span></span><br><span class="line">  <span class="keyword">return</span> st;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a,vector&lt;<span class="type">int</span>&gt; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="comment">// if(a.size()==0) return b;</span></span><br><span class="line">    <span class="comment">// if(b.size()==0) return a;</span></span><br><span class="line">      <span class="type">int</span> index1=<span class="number">0</span>,index2=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(index1&lt;a.<span class="built_in">size</span>()&amp;&amp;index2&lt;b.<span class="built_in">size</span>())</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">//vector默认字典序排序</span></span><br><span class="line">        <span class="comment">//如123与179,7&gt;2</span></span><br><span class="line">       <span class="comment">// if(vector&lt;int&gt;(a.begin()+index1,a.end()) &gt; vector&lt;int&gt;(b.begin()+index2,b.end()) )</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="built_in">compare</span>(a,index1,b,index2)&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(a[index1++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(b[index2++]);</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//将剩余值放进result(a,b长度不同导致while提前结束，有剩余值未处理)</span></span><br><span class="line">      <span class="built_in">copy</span>(a.<span class="built_in">begin</span>()+index1,a.<span class="built_in">end</span>(),<span class="built_in">back_inserter</span>(result));</span><br><span class="line">      <span class="built_in">copy</span>(b.<span class="built_in">begin</span>()+index2,b.<span class="built_in">end</span>(),<span class="built_in">back_inserter</span>(result));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  可以替换如下</span></span><br><span class="line">    <span class="comment">// while (index1 &lt; a.size()) &#123;</span></span><br><span class="line">    <span class="comment">//     result.push_back(a[index1++]);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// while (index2 &lt; b.size()) &#123;</span></span><br><span class="line">    <span class="comment">//     result.push_back(b[index2++]);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  <span class="comment">//  num.push_back(a);</span></span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">//比较字典序</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a,<span class="type">int</span> i,vector&lt;<span class="type">int</span>&gt; b,<span class="type">int</span> j)</span><span class="comment">//2.错在这里，bool和int是不一样的，淦！</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="keyword">while</span>(i&lt;a.<span class="built_in">size</span>()&amp;&amp;j&lt;b.<span class="built_in">size</span>())</span><br><span class="line">      &#123;   </span><br><span class="line">        <span class="comment">//如123与179,7&gt;2</span></span><br><span class="line">       <span class="type">int</span> diff=a[i]-b[j];</span><br><span class="line">       <span class="keyword">if</span>(diff!=<span class="number">0</span>) <span class="keyword">return</span> diff;</span><br><span class="line">       i++;</span><br><span class="line">       j++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//剩下的值</span></span><br><span class="line">      <span class="keyword">return</span> (a.<span class="built_in">size</span>()-i)-(b.<span class="built_in">size</span>()-j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<p>1.范围选择问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; maxNumber(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int k) &#123;</span><br><span class="line">...</span><br><span class="line">for(int i=0;i&lt;=k;i++) //一旦输入如下，是不对的</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>输入：</p>
<p>[6,7] [6,0,4] 5</p>
<p>输出：</p>
<p>[7,6,0,4]</p>
<p>预期结果：</p>
<p>[6,7,6,0,4]</p>
</blockquote>
<p>过程如下：</p>
<blockquote>
<p>i&#x3D;0,k-i&#x3D;5<br>xulie1</p>
<p>xulie2<br>6 0 4<br>curmerge<br>6 0 4<br>maxseq&#x3D;<br>6 0 4<br><strong>i&#x3D;1,k-i&#x3D;4</strong><br><strong>xulie1</strong><br><strong>7</strong><br><strong>xulie2</strong><br><strong>6 0 4</strong><br><strong>curmerge</strong><br><strong>7 6 0 4</strong><br><strong>maxseq&#x3D;</strong><br><strong>7 6 0 4</strong><br>i&#x3D;2,k-i&#x3D;3<br>xulie1<br>6 7<br>xulie2<br>6 0 4<br>curmerge<br>6 7 6 0 4<br>maxseq&#x3D;<br>7 6 0 4<br>i&#x3D;3,k-i&#x3D;2<br>xulie1<br>6 7<br>xulie2<br>6 4<br>curmerge<br>6 7 6 4<br>maxseq&#x3D;<br>7 6 0 4<br>i&#x3D;4,k-i&#x3D;1<br>xulie1<br>6 7<br>xulie2<br>6<br>curmerge<br>6 7 6<br>maxseq&#x3D;<br>7 6 0 4<br>i&#x3D;5,k-i&#x3D;0<br>xulie1<br>6 7<br>xulie2</p>
<p>curmerge<br>6 7<br>maxseq&#x3D;<br>7 6 0 4<br>7 6 0 4</p>
</blockquote>
<p>分析可得，目的是要求5位，但是从一开始的结果就有3位，4位，甚至是2位，究其原因是没有判断两数组各自的长度是否够k位。</p>
<p>一开始就限定nums1要取的元素</p>
<p>如果k-nums2.size()&gt;0， 就说明nums2的数组元素不够k个，那就至少从nums1中取k-nums2.size()个；不然完全可以从0开始。</p>
<p>如果k与nums1长度相比，nums1本身不够k个，那nums1最多取nums1.size()个。</p>
<p>解决方法</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; max_n1,max_n2;</span><br><span class="line">    vector&lt;int&gt; maxseq(k,0);</span><br><span class="line">      int m = nums1.size(), n = nums2.size();</span><br><span class="line">         int start = max(0, k - n), end = min(k, m);</span><br><span class="line">    for(int i= start;i&lt;=end;i++) //</span><br><span class="line">    &#123;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>start&#x3D;2 ,end&#x3D;2<br>6 7<br>xulie2<br>6 0 4<br>curmerge<br>6 7 6 0 4<br>6 7 6 0 4</p>
</blockquote>
<p>2.pick_max中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  for(int i=0;i&lt;num.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        while(drop&gt;0&amp;&amp;!st.empty()&amp;&amp;st.back()&lt;num[i])//1.drop和drop&gt;0做条件不一样</span><br><span class="line">        &#123;</span><br><span class="line">            st.pop_back();</span><br><span class="line">            drop--;</span><br><span class="line">        &#125;</span><br><span class="line">       //st.push_back(num[i]);</span><br><span class="line">        if(st.size()&lt;k) //没有取够k个</span><br><span class="line">            st.push_back(num[i]);</span><br><span class="line">        else //取够了就继续丢弃</span><br><span class="line">        &#123;</span><br><span class="line">            drop--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //st.resize(k);</span><br><span class="line">  return st;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">可以进行如下替换</span><br><span class="line"> for(int i=0;i&lt;num.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        while(drop&gt;0&amp;&amp;!st.empty()&amp;&amp;st.back()&lt;num[i])//1.drop和drop&gt;0做条件不一样</span><br><span class="line">        &#123;</span><br><span class="line">            st.pop_back();</span><br><span class="line">            drop--;</span><br><span class="line">        &#125;</span><br><span class="line">       st.push_back(num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    st.resize(k);</span><br><span class="line">  return st;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.vector也是默认字典序排列的</p>
<p>在compare中可以</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if(vector&lt;int&gt;(a.begin()+index1,a.end()) &gt; vector&lt;int&gt;(b.begin()+index2,b.end()) )</span><br><span class="line">       if(compare(a,index1,b,index2)&gt;0)</span><br><span class="line">        &#123;</span><br><span class="line">            result.push_back(a[index1++]);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            result.push_back(b[index2++]);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<h1 id="3-统计射击成绩"><a href="#3-统计射击成绩" class="headerlink" title="3.统计射击成绩"></a>3.统计射击成绩</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个射击比赛成绩单<br>包含多个选手若干次射击的成绩分数<br>请对每个选手按其最高三个分数之和进行降序排名<br>输出降序排名后的选手ID序列<br>条件如下:</p>
<ol>
<li>一个选手可以有多个射击成绩的分数 且次序不固定</li>
<li>如果一个选手成绩小于三个 则认为选手的所有成绩无效 排名忽略该选手</li>
<li>如果选手的成绩之和相等,则成绩相等的选手按照其ID降序排列</li>
</ol>
<h2 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述"></a>输入描述</h2><p>输入第一行:一个整数 <code>N</code><br>表示该场比赛总共进行了<code>N</code>次射击<br>产生<code>N</code>个成绩分数 <code>2 &lt;= N &lt;= 100</code><br>输入第二行 一个长度为<code>N</code>的整数序列<br>表示参与本次射击的选手Id<br><code>0 &lt;= ID &lt;= 99</code><br>输入第三行是长度为<code>N</code>的整数序列<br>表示参与每次射击的选手对应的成绩<br><code>0 &lt;= 成绩 &lt;= 100</code></p>
<h2 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述"></a>输出描述</h2><p>符合题设条件的降序排名后的选手ID序列</p>
<h2 id="示例一-1"><a href="#示例一-1" class="headerlink" title="示例一"></a>示例一</h2><h3 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">13</span><br><span class="line">3,3,7,4,4,4,4,7,7,3,5,5,5</span><br><span class="line">53,80,68,24,39,76,66,16,100,55,53,80,55</span><br></pre></td></tr></table></figure>

<p>Copy</p>
<h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5,3,7,4</span><br></pre></td></tr></table></figure>

<p>Copy</p>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>该场射击比赛进行了<code>13</code>次,参赛选手为<code>3 4 5 7</code><br><code>3</code>号选手的成绩为<code>53 80 55</code>最高三个成绩的和为 <code>188</code><br><code>4</code>号选手的成绩为<code>24 39 76 66</code>最高三个和为<code>181</code><br><code>5</code>号选手的成绩为<code>53 80 55</code> 最高三个和为<code>188</code><br><code>7</code>号选手成绩为<code>68 16 100</code> 最高三个和<code>184</code><br>比较各个选手最高三个成绩的和<br><code>3 = 5 &gt; 7 &gt; 4</code><br>由于<code>3</code>和<code>5</code>成绩相等 且<code>5 &gt; 3</code> 所以输出为<code>5,3,7,4</code></p>
<h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>第二行，选手id，顺序不固定</p>
<p>第三行，对应选手id所取得的成绩score。</p>
<p>1.想到map键值对。</p>
<p>由于一个选手对应多个成绩</p>
<p>且成绩若多于3个，需要取最高的三个</p>
<p>2.若少于3个，该成绩无效（输出时，需要判断）</p>
<p>综上的思路是</p>
<p><code>map&lt;int,vector&lt;int&gt; &gt; scores;</code></p>
<blockquote>
<p>理由：键为id，值为多个成绩</p>
</blockquote>
<p>输入时先获取整数序列值，需要将逗号分割，再将字符串转数字</p>
<p>主函数下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">string input1,input2;</span><br><span class="line">cin&gt;&gt;input1&gt;&gt;input2;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; id;     <span class="comment">//用于接收第二行</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; score;	<span class="comment">//接收第三行</span></span><br><span class="line"></span><br><span class="line">string ch=<span class="string">&quot;&quot;</span>;<span class="comment">//子串</span></span><br><span class="line"><span class="comment">//接收输入</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;intput1.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(input1[i]!=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    	ch+=input1[i];</span><br><span class="line">    <span class="keyword">if</span>(input1[i]==<span class="string">&#x27;,&#x27;</span>||i==input1.<span class="built_in">size</span>()<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        id.<span class="built_in">push_back</span>(<span class="built_in">atoi</span>(ch.<span class="built_in">c_str</span>()));  <span class="comment">//将字符串转化为数字并存入id中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ch=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;intput2.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(input1[<span class="number">2</span>]!=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    	ch+=input2[i];</span><br><span class="line">    <span class="keyword">if</span>(input2[i]==<span class="string">&#x27;,&#x27;</span>||i==input2.<span class="built_in">size</span>()<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        score.<span class="built_in">push_back</span>(<span class="built_in">atoi</span>(ch.<span class="built_in">c_str</span>()));  <span class="comment">//将字符串转化为数字并存入id中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取完值，想办法键值对应</span></span><br><span class="line">map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt; &gt; scores;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> key=id[i];</span><br><span class="line">    <span class="type">int</span> value=score[i];</span><br><span class="line">   map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt; &gt;::iterator it=scores.<span class="built_in">find</span>(key);</span><br><span class="line">    <span class="keyword">if</span>(it !=it.<span class="built_in">end</span>()) <span class="comment">//找到该键</span></span><br><span class="line">    &#123;</span><br><span class="line">        scores[key].<span class="built_in">push_back</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//如果没有这个键，添加(比如第一次时，key=4，但找不到，先添加值)</span></span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; list;</span><br><span class="line">        list.<span class="built_in">push_back</span>(value);</span><br><span class="line">        </span><br><span class="line">        scores[key]=list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此时是一个id对应多个成绩。</span></span><br><span class="line"><span class="comment">//对成绩筛选并加和。</span></span><br><span class="line"><span class="keyword">for</span>(map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt; &gt;::iterator it=scores.<span class="built_in">begin</span>();it!=scores.<span class="built_in">end</span>();it++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">if</span>(it-&gt;second.<span class="built_in">size</span>()&gt;=<span class="number">3</span>)<span class="comment">//如果成绩数不少于3个</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">sort</span>(scores.<span class="built_in">rbegin</span>(),scores.<span class="built_in">rend</span>());<span class="comment">//降序排列</span></span><br><span class="line">         num=it-&gt;second[<span class="number">0</span>]+it-&gt;second[<span class="number">1</span>]+it-&gt;second[<span class="number">2</span>];<span class="comment">//最高的三个成绩</span></span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        num=<span class="number">0</span>; <span class="comment">//成绩作废为0;</span></span><br><span class="line">    &#125;</span><br><span class="line">    it-&gt;second.<span class="built_in">clear</span>();<span class="comment">//清空值</span></span><br><span class="line">    it-&gt;second.<span class="built_in">push_back</span>(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//键值对排序，因为要按照值排序，且值相同时，id大的在前。</span></span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt; &gt; &gt; <span class="built_in">sortedsc</span>(scores.<span class="built_in">begin</span>(),scores.<span class="built_in">end</span>());<span class="comment">//赋值给sortedsc，用来处理单个键值对情况。</span></span><br><span class="line"><span class="built_in">sort</span>(sortedsc.<span class="built_in">begin</span>(),sortedsc.<span class="built_in">end</span>(),Compare);<span class="comment">//Compare为自定义算法</span></span><br><span class="line"></span><br><span class="line">     vector&lt; pair&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt; &gt; &gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span>(it=sortedscores.<span class="built_in">begin</span>(); it!=sortedscores.<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(it-&gt;second[<span class="number">0</span>]&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">         cout&lt;&lt;it-&gt;first;</span><br><span class="line">        <span class="keyword">if</span>(it+<span class="number">1</span>!=sortedscores.<span class="built_in">end</span>())   <span class="comment">//如果不是最后一位，输出逗号</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;,&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct Compare</span><br><span class="line">&#123;</span><br><span class="line">	bool operator()(pair&lt;int,vector&lt;int&gt; &gt;&amp;a,pair&lt;int,vector&lt;int&gt; &gt;&amp;b)/*当你定义一个函数对象并希望它能够像函数一样被调用时，你需要重载函数调用运算符 ()。在函数调用运算符的定义中，括号是必需的，用于指示该函数对象应该如何被调用。*/</span><br><span class="line">	&#123;</span><br><span class="line">		if(a.second==b.second) //值相同，找键值大的</span><br><span class="line">			return a.first&gt;b.first;</span><br><span class="line">		return a.second&gt;b.second;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct CustomComparator &#123;   </span><br><span class="line">bool operator()(int a, int b) const &#123;        </span><br><span class="line">// Custom comparison logic        </span><br><span class="line">return a &lt; b;</span><br><span class="line">// Sort integers in ascending order    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">sort(v.begin(),v.end(),CustomComparator());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Compare</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(pair&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt; &gt;&amp;a,pair&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt; &gt;&amp;b)</span><span class="comment">/*当你定义一个函数对象并希望它能够像函数一样被调用时，你需要重载函数调用运算符 ()。在函数调用运算符的定义中，括号是必需的，用于指示该函数对象应该如何被调用。*/</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(a.second==b.second) <span class="comment">//值相同，找键值大的</span></span><br><span class="line">			<span class="keyword">return</span> a.first&gt;b.first;</span><br><span class="line">		<span class="keyword">return</span> a.second&gt;b.second;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">string input1,input2;</span><br><span class="line">cin&gt;&gt;input1&gt;&gt;input2;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; id;     <span class="comment">//用于接收第二行</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; score;	<span class="comment">//接收第三行</span></span><br><span class="line"></span><br><span class="line">string ch=<span class="string">&quot;&quot;</span>;<span class="comment">//子串</span></span><br><span class="line"><span class="comment">//接收输入</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;input1.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(input1[i]!=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    	ch+=input1[i];</span><br><span class="line">    <span class="keyword">if</span>(input1[i]==<span class="string">&#x27;,&#x27;</span>||i==input1.<span class="built_in">size</span>()<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        id.<span class="built_in">push_back</span>(<span class="built_in">atoi</span>(ch.<span class="built_in">c_str</span>()));  <span class="comment">//将字符串转化为数字并存入id中</span></span><br><span class="line">      <span class="comment">//   cout&lt;&lt;ch&lt;&lt;endl;</span></span><br><span class="line">        ch=<span class="string">&quot;&quot;</span>;<span class="comment">//清零</span></span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ch=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;input2.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(input2[i]!=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    	ch+=input2[i];</span><br><span class="line">    <span class="keyword">if</span>(input2[i]==<span class="string">&#x27;,&#x27;</span>||i==input2.<span class="built_in">size</span>()<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        score.<span class="built_in">push_back</span>(<span class="built_in">atoi</span>(ch.<span class="built_in">c_str</span>()));  <span class="comment">//将字符串转化为数字并存入id中</span></span><br><span class="line">      <span class="comment">//  cout&lt;&lt;ch&lt;&lt;endl;</span></span><br><span class="line">        ch=<span class="string">&quot;&quot;</span>;<span class="comment">//清零</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取完值，想办法键值对应</span></span><br><span class="line">map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt; &gt; scores;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> key=id[i];</span><br><span class="line">    <span class="type">int</span> value=score[i];</span><br><span class="line">   map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt; &gt;::iterator it=scores.<span class="built_in">find</span>(key);</span><br><span class="line">    <span class="keyword">if</span>(it !=scores.<span class="built_in">end</span>()) <span class="comment">//找到该键</span></span><br><span class="line">    &#123;</span><br><span class="line">        scores[key].<span class="built_in">push_back</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//如果没有这个键，添加(比如第一次时，key=4，但找不到，先添加值)</span></span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; list;</span><br><span class="line">        list.<span class="built_in">push_back</span>(value);</span><br><span class="line">        </span><br><span class="line">        scores[key]=list;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// cout&lt;&lt;key&lt;&lt;&quot; &quot;&lt;&lt;value&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此时是一个id对应多个成绩。</span></span><br><span class="line"><span class="comment">//对成绩筛选并加和。</span></span><br><span class="line"><span class="keyword">for</span>(map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt; &gt;::iterator it=scores.<span class="built_in">begin</span>();it!=scores.<span class="built_in">end</span>();it++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">if</span>(it-&gt;second.<span class="built_in">size</span>()&gt;=<span class="number">3</span>)<span class="comment">//如果成绩数不少于3个</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">sort</span>(it-&gt;second.<span class="built_in">rbegin</span>(),it-&gt;second.<span class="built_in">rend</span>());<span class="comment">//降序排列</span></span><br><span class="line">         num=it-&gt;second[<span class="number">0</span>]+it-&gt;second[<span class="number">1</span>]+it-&gt;second[<span class="number">2</span>];<span class="comment">//最高的三个成绩</span></span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        num=<span class="number">0</span>; <span class="comment">//成绩作废为0;</span></span><br><span class="line">    &#125;</span><br><span class="line">    it-&gt;second.<span class="built_in">clear</span>();<span class="comment">//清空值</span></span><br><span class="line">    it-&gt;second.<span class="built_in">push_back</span>(num);</span><br><span class="line">  <span class="comment">//  cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;num&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//键值对排序，因为要按照值排序，且值相同时，id大的在前。</span></span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt; &gt; &gt; <span class="built_in">sortedsc</span>(scores.<span class="built_in">begin</span>(),scores.<span class="built_in">end</span>());<span class="comment">//赋值给sortedsc，用来处理单个键值对情况。</span></span><br><span class="line"><span class="built_in">sort</span>(sortedsc.<span class="built_in">begin</span>(),sortedsc.<span class="built_in">end</span>(),<span class="built_in">Compare</span>());<span class="comment">//Compare为自定义算法</span></span><br><span class="line"></span><br><span class="line">     vector&lt; pair&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt; &gt; &gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span>(it=sortedsc.<span class="built_in">begin</span>(); it!=sortedsc.<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(it-&gt;second[<span class="number">0</span>]&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">         cout&lt;&lt;it-&gt;first;</span><br><span class="line">        <span class="keyword">if</span>(it+<span class="number">1</span>!=sortedsc.<span class="built_in">end</span>())   <span class="comment">//如果不是最后一位，输出逗号</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;,&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-子串匹配"><a href="#4-子串匹配" class="headerlink" title="4.子串匹配"></a>4.子串匹配</h1><p>链接：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/5382ff24fbf34a858b15f93e2bd85307?f=discussion">https://www.nowcoder.com/questionTerminal/5382ff24fbf34a858b15f93e2bd85307?f=discussion</a><br>来源：牛客网</p>
<p>给定两个字符串 s和 t ，判断 s是否为 t 的子序列。</p>
<p>  你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度n ~&#x3D; 500,000），而 s 是个短字符串（长度 &lt;&#x3D;100）。  </p>
<p>  字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。  </p>
<p>  进阶：时间复杂度O(n) O(n)\ O(n) ，空间复杂度O(n) O(n)\ O(n) </p>
<h3 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述:"></a><strong>输入描述:</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">共两行，第一行为字符串s,  第二行为字符串t</span><br><span class="line">字符串t的长度 1&lt;=n&lt;=500000</span><br><span class="line">字符串s的长度 1&lt;=m&lt;=100</span><br></pre></td></tr></table></figure>

<h3 id="输出描述-2"><a href="#输出描述-2" class="headerlink" title="输出描述:"></a><strong>输出描述:</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出true或者是false，true表示是s是t的子序列，false表示s不是t的子序列</span><br></pre></td></tr></table></figure>

<p>示例1</p>
<h3 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">abc</span><br><span class="line">ahbgdc</span><br></pre></td></tr></table></figure>

<h3 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure>

<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string s, t;</span><br><span class="line">    cin&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    int index=0;</span><br><span class="line">    for(int i=0;i&lt;s.size();)</span><br><span class="line">    &#123;</span><br><span class="line">        if(index&gt;=t.size())</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;&quot;false&quot;;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(s[i]==t[index])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">        cout&lt;&lt;&quot;true&quot;;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="5-数据分类"><a href="#5-数据分类" class="headerlink" title="5.数据分类"></a>5.数据分类</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>对一个数据<code>a</code>进行分类，<br>分类方法是，此数据<code>a</code>(4个字节大小)的4个字节相加对一个给定值<code>b</code>取模，<br>如果得到的结果小于一个给定的值<code>c</code>则数据<code>a</code>为有效类型，其类型为取模的值。<br>如果得到的结果大于或者等于<code>c</code>则数据<code>a</code>为无效类型。</p>
<p>比如一个数据<code>a = 0x01010101</code>，<code>b = 3</code><br>按照分类方法计算：<code>(0x01 + 0x01 + 0x01 + 0x01) % 3 = 1</code><br>所以如果<code>c</code>等于<code>2</code>，则此<code>a</code>就是有效类型，其类型为<code>1</code><br>如果<code>c</code>等于<code>1</code>，则此<code>a</code>是无效类型</p>
<p>又比如一个数据<code>a = 0x01010103</code>，<code>b = 3</code><br>按分类方法计算：<code>(0x01 + 0x01 + 0x01 + 0x03) % 3 = 0</code><br>所以如果<code>c = 2</code>则此<code>a</code>就是有效类型，其类型为<code>0</code><br>如果<code>c = 0</code>则此<code>a</code>是无效类型</p>
<p>输入<code>12</code>个数据，<br>第一个数据为<code>c</code>，第二个数据为<code>b</code>，<br>剩余<code>10</code>个数据为需要分类的数据</p>
<p>请找到有效类型中包含数据最多的类型，<br>并输出该类型含有多少个数据</p>
<h2 id="输入描述-3"><a href="#输入描述-3" class="headerlink" title="输入描述"></a>输入描述</h2><p>输入<code>12</code>个数据用空格分割，<br>第一个数据为<code>c</code>，第二个数据为<code>b</code>，<br>剩余<code>10</code>个数据为需要分类的数据。</p>
<h2 id="输出描述-3"><a href="#输出描述-3" class="headerlink" title="输出描述"></a>输出描述</h2><p>请找到有效类型中包含数据最多的类型，<br>并输出该类型含有多少个数据。</p>
<h2 id="示例一-2"><a href="#示例一-2" class="headerlink" title="示例一"></a>示例一</h2><h3 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 4 256 257 258 259 260 261 262 263 264 265</span><br></pre></td></tr></table></figure>

<h3 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<h3 id="个人代码"><a href="#个人代码" class="headerlink" title="个人代码"></a>个人代码</h3><blockquote>
<p>将十进制转化为十六进制，说是四字节，那就是8个值，我用的vector(8,0)记录</p>
<p>十六进制加和，那就是8个值中两两组合，a*16+b</p>
<p>再将模后的值存入新的vector，用来统计出现次数，从大到小排序，输出最大值</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">zijie</span><span class="params">(<span class="type">int</span> num)</span><span class="comment">//十进制处理成十六进制</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">//四个字节，8个值</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(<span class="number">8</span>,<span class="number">0</span>)</span></span>; <span class="comment">//默认0填充</span></span><br><span class="line">    <span class="comment">//十六进制 //四字节</span></span><br><span class="line">    <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(num/<span class="number">16</span>!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> shang=num/<span class="number">16</span>;</span><br><span class="line">        <span class="type">int</span> yushu=num%shang;</span><br><span class="line">        num=shang;</span><br><span class="line">        <span class="comment">//s.push_back(yushu);</span></span><br><span class="line">        s[index]=yushu;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一定有一个1；</span></span><br><span class="line">    s[index]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>()); <span class="comment">//反转</span></span><br><span class="line">    <span class="comment">//   for(int i=0;i&lt;ss.size();i++)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     cout&lt;&lt;ss[i]&lt;&lt;&quot;,&quot;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">jiahe</span><span class="params">(vector&lt;<span class="type">int</span>&gt; s,<span class="type">int</span> b)</span><span class="comment">//十六进制各部分加和，再模b</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i=i+<span class="number">2</span>)<span class="comment">//</span></span><br><span class="line">    &#123;</span><br><span class="line">        sum+=s[i]*<span class="number">16</span>+s[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum%b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ss;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;num)</span><br><span class="line">    &#123;</span><br><span class="line">        ss.<span class="built_in">push_back</span>(num);</span><br><span class="line">        <span class="keyword">if</span>(cin.<span class="built_in">get</span>()==<span class="string">&#x27;\n&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(int i=0;i&lt;ss.size();i++)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     cout&lt;&lt;ss[i]&lt;&lt;&quot;,&quot;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="type">int</span> c=ss[<span class="number">0</span>],b=ss[<span class="number">1</span>];</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; leixing;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;ss.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        leixing.<span class="built_in">push_back</span>(<span class="built_in">jiahe</span>(<span class="built_in">zijie</span>(ss[i]),b));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ss.clear();//只会重置size</span></span><br><span class="line">    <span class="comment">// for(int i = 0; i &lt; ss.size(); ++i)//删除ss的元素，以便之后使用</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//      delete ss[i];</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// ss.clear();</span></span><br><span class="line">    <span class="comment">//想要清空元素，重复利用ss，不行，嘶</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">zhi</span><span class="params">(<span class="number">100</span>,<span class="number">0</span>)</span></span>;<span class="comment">//暂时记为模的最大值为99吧</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;leixing.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">// cout&lt;&lt;leixing[i]&lt;&lt;&quot;,&quot;;</span></span><br><span class="line">        <span class="keyword">if</span>(leixing[i]&lt;c)</span><br><span class="line">        &#123;</span><br><span class="line">           zhi[leixing[i]]++; <span class="comment">//比如模后的值是4，s[4]++</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(zhi.<span class="built_in">begin</span>(),zhi.<span class="built_in">end</span>());<span class="comment">//默认从小到大排序</span></span><br><span class="line">    <span class="built_in">reverse</span>(zhi.<span class="built_in">begin</span>(),zhi.<span class="built_in">end</span>());<span class="comment">//</span></span><br><span class="line">    cout&lt;&lt;zhi[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//cout&lt;&lt;jiahe(zhi,3);</span></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考wp（map映射）"><a href="#参考wp（map映射）" class="headerlink" title="参考wp（map映射）"></a>参考wp（map映射）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int jiahe(int num);</span><br><span class="line">void solution(vector&lt;int&gt; s)//</span><br><span class="line">&#123;</span><br><span class="line">     int c=s[0];</span><br><span class="line">     int b=s[1];</span><br><span class="line">     map&lt;int,int&gt; mp;//映射</span><br><span class="line">     for(int i=2;i&lt;s.size();i++)</span><br><span class="line">     &#123;</span><br><span class="line">        int r=jiahe(s[i])%b;</span><br><span class="line">        if(r&lt;c) mp[r]=mp.count(r)?mp[r]+1:1;//键值相同+1，没有则置1</span><br><span class="line">     &#125;</span><br><span class="line">     int max=0;</span><br><span class="line">    // map&lt;int,int&gt;::iterator it;</span><br><span class="line">     for(const auto&amp; pair:mp)</span><br><span class="line">     &#123;</span><br><span class="line">        if(pair.second&gt;max) max=pair.second;</span><br><span class="line">     &#125;</span><br><span class="line">     cout&lt;&lt;max;</span><br><span class="line">&#125;</span><br><span class="line">int jiahe(int num)//十六进制各部分加和</span><br><span class="line">&#123;</span><br><span class="line">    int sum=0;</span><br><span class="line">    for(int i=0;i&lt;4;i++)//</span><br><span class="line">    &#123;</span><br><span class="line">        sum+=static_cast&lt;char&gt;(num&gt;&gt;i*8);</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; ss;</span><br><span class="line">    int num;</span><br><span class="line">    while(cin&gt;&gt;num)</span><br><span class="line">    &#123;</span><br><span class="line">        ss.push_back(num);</span><br><span class="line">        if(cin.get()==&#x27;\n&#x27;) break;</span><br><span class="line">    &#125;</span><br><span class="line">    solution(ss);</span><br><span class="line">    </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>map.find()是迭代器指向元素 if maps.find(1)&#x3D;&#x3D;maps.end()，无该元素</p>
<p>map.count()，结果只为0或1</p>
<p>static_cast 强制类型转化操作</p>
<p>&gt;&gt;i*8 取字节 (i&#x3D;0-3)：</p>
<p>四字节32位是以大端方式排列的，</p>
<p>即最高位（最左）-&gt;最低位（最右）</p>
<p>259为例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int num=259;</span><br><span class="line">   cout&lt;&lt;hex&lt;&lt;259&lt;&lt;endl;</span><br><span class="line">   cout&lt;&lt;(num&gt;&gt;0)&lt;&lt;&quot; char:&quot;&lt;&lt;int(static_cast&lt;char&gt;(num&gt;&gt;0))&lt;&lt;endl;</span><br><span class="line">   cout&lt;&lt;(num&gt;&gt;8)&lt;&lt;&quot; char:&quot;&lt;&lt;int(static_cast&lt;char&gt;(num&gt;&gt;8))&lt;&lt;endl;</span><br><span class="line">   cout&lt;&lt;(num&gt;&gt;2*8)&lt;&lt;&quot; char:&quot;&lt;&lt;int(static_cast&lt;char&gt;(num&gt;&gt;16))&lt;&lt;endl;</span><br><span class="line">   cout&lt;&lt;(num&gt;&gt;3*8)&lt;&lt;&quot; char:&quot;&lt;&lt;int(static_cast&lt;char&gt;(num&gt;&gt;24))&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>结果为：（不纠结了，就这么记着吧）</p>
<blockquote>
<p>103<br>103 char:3<br>1 char:1<br>0 char:0<br>0 char:0 </p>
</blockquote>
</blockquote>
<h1 id="6-5键键盘"><a href="#6-5键键盘" class="headerlink" title="6.5键键盘"></a>6.5键键盘</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>有一个特殊的五键键盘<br>上面有<code>A</code>、<code>Ctrl-C</code>、<code>Ctrl-X</code>、<code>Ctrl-V</code>、<code>Ctrl-A</code><br><code>A</code>键在屏幕上输出一个字母<code>A</code><br><code>Ctrl-C</code>将当前所选的字母复制到剪贴板<br><code>Ctrl-X</code>将当前选择的字母复制到剪贴板并清空所选择的字母<br><code>Ctrl-V</code>将当前剪贴板的字母输出到屏幕<br><code>Ctrl-A</code>选择当前屏幕中所有字母<br>注意：</p>
<ol>
<li>剪贴板初始为空</li>
<li>新的内容复制到剪贴板会覆盖原有内容</li>
<li>当屏幕中没有字母时,<code>Ctrl-A</code>无效</li>
<li>当没有选择字母时<code>Ctrl-C</code>、<code>Ctrl-X</code>无效</li>
<li>当有字母被选择时<code>A</code>和<code>Ctrl-V</code>这两个输出功能的键,<br>会先清空所选的字母再进行输出</li>
</ol>
<p>给定一系列键盘输入,<br>输出最终屏幕上字母的数量</p>
<h2 id="输入描述-4"><a href="#输入描述-4" class="headerlink" title="输入描述"></a>输入描述</h2><p>输入为一行<br>为简化解析用数字<code>12345</code>分别代替<code>A</code>、<code>Ctrl-C</code>、<code>Ctrl-X</code>、<code>Ctrl-V</code>、<code>Ctrl-A</code>的输入<br>数字用空格分割</p>
<h2 id="输出描述-4"><a href="#输出描述-4" class="headerlink" title="输出描述"></a>输出描述</h2><p>输出一个数字为屏幕上字母的总数量</p>
<h2 id="示例一-3"><a href="#示例一-3" class="headerlink" title="示例一"></a>示例一</h2><h3 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 1 1</span><br></pre></td></tr></table></figure>

<p>Copy</p>
<h3 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><h3 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 1 5 1 5 2 4 4</span><br></pre></td></tr></table></figure>

<h3 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<h2 id="个人代码-仅试过用例"><a href="#个人代码-仅试过用例" class="headerlink" title="个人代码(仅试过用例)"></a>个人代码(仅试过用例)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">void solution(vector&lt;int&gt; ss)</span><br><span class="line">&#123;</span><br><span class="line">    int token=0,co=0;//缓冲区的字母数 与 目前字母数</span><br><span class="line">    int onxuanze=-1,onzimu=-1,c=-1;//被选择、有输入字母、复制操作</span><br><span class="line">    for(int i=0;i&lt;ss.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        //token+=ss[i];</span><br><span class="line">        if(ss[i]==1) //输入值</span><br><span class="line">        &#123;</span><br><span class="line">            //说明有输入，如果有选择命令，则覆盖</span><br><span class="line">            //没有则追加输入</span><br><span class="line">          //  onzimu=1;   //有值</span><br><span class="line">           // if(onxuanze&gt;0) //选中值</span><br><span class="line">           if(ss[i-1]==5) //选中一定是紧挨的操作，否则不成立</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                co=1;  //直接覆盖</span><br><span class="line">            &#125;</span><br><span class="line">            else co++;</span><br><span class="line">        &#125; </span><br><span class="line"> </span><br><span class="line">          if(ss[i]==2)//复制  </span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            if(ss[i-1]==5)//要复制一定有选中，是紧挨的选中</span><br><span class="line">            &#123;</span><br><span class="line">                token=co;</span><br><span class="line">                c=1;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(ss[i]==3)//剪切</span><br><span class="line">        &#123;</span><br><span class="line">            if(ss[i-1]==5)</span><br><span class="line">            &#123;</span><br><span class="line">              token=co;</span><br><span class="line">              co=0;</span><br><span class="line">              onzimu=-9;//清空字母</span><br><span class="line">              c=1;//复制</span><br><span class="line">            &#125;   </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int v=0;</span><br><span class="line">        if(ss[i]==4) //输出</span><br><span class="line">        &#123;      </span><br><span class="line">            </span><br><span class="line">            if(c&gt;0) //原地v</span><br><span class="line">            &#123;</span><br><span class="line">                co=token;//这种是选中后，复制，再v，所以覆盖</span><br><span class="line">                v++;</span><br><span class="line">            &#125; </span><br><span class="line">           </span><br><span class="line">            //那追加v怎么办呢？</span><br><span class="line">            if(v&gt;0) co+=token;</span><br><span class="line">            //如果选中了，直接v，那就是覆盖了</span><br><span class="line">            /*</span><br><span class="line">            它可以是选择，复制，再v，也是一样的覆盖</span><br><span class="line">             1 1 5 1 5 2 4 4应该是输出2，而不是3</span><br><span class="line">            它这种情况就是，选中后不一定马上v，会有复制的情况</span><br><span class="line">             */</span><br><span class="line">           // if(ss[i-1]==5) co=token;           </span><br><span class="line">        &#125;</span><br><span class="line">        // if(ss[i]==5) //选中</span><br><span class="line">        // &#123;</span><br><span class="line">        //     if(onzimu&gt;0) //有字母</span><br><span class="line">        //     &#123;</span><br><span class="line">        //         onxuanze=1;</span><br><span class="line">        //         //token=co; //当前选中数</span><br><span class="line">        //     &#125;</span><br><span class="line">             </span><br><span class="line">        // &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;co;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; ss;</span><br><span class="line">    string t;</span><br><span class="line">    while(cin&gt;&gt;t)</span><br><span class="line">    &#123;</span><br><span class="line">        ss.push_back(stoi(t));</span><br><span class="line">         if(cin.get()==&#x27;\n&#x27;) break;</span><br><span class="line">    &#125;</span><br><span class="line">    solution(ss);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="wp-1"><a href="#wp-1" class="headerlink" title="wp"></a>wp</h2><p>用字符串cur记录当前的输出字母”A”</p>
<p>cur的长度即为最终输出</p>
<p>copy为缓冲区里的字母</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">void solution(vector&lt;int&gt; ss)</span><br><span class="line">&#123;</span><br><span class="line">    string copy=&quot;&quot;;    //剪切板</span><br><span class="line">   // string select=&quot;&quot;; </span><br><span class="line">    string cur=&quot;&quot;; //当前面板</span><br><span class="line">    int flag=0; //是否选中</span><br><span class="line">    for(int op:ss)&#123;</span><br><span class="line">        switch(op)</span><br><span class="line">        &#123;</span><br><span class="line">        case 1:</span><br><span class="line">            if(flag!=1)</span><br><span class="line">           &#123;</span><br><span class="line">                cur+=&quot;A&quot;;</span><br><span class="line">                flag=0;</span><br><span class="line">           &#125;</span><br><span class="line">           else</span><br><span class="line">           &#123;</span><br><span class="line">             cur=&quot;&quot;; //</span><br><span class="line">             cur+=&quot;A&quot;;</span><br><span class="line">             flag=0;</span><br><span class="line">           &#125;</span><br><span class="line">            break;</span><br><span class="line">        case 2:</span><br><span class="line">            if((cur.size()!=0)&amp;&amp;(flag!=0)) //没有选中</span><br><span class="line">            &#123;</span><br><span class="line">                copy=cur;    //复制</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case 3:</span><br><span class="line">            if((cur.size()!=0)&amp;&amp;(flag!=0))&#123; </span><br><span class="line">                copy=cur;</span><br><span class="line">                cur=&quot;&quot;;    //清零</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case 4:   //输出</span><br><span class="line">            if((copy.size()!=0)&amp;&amp;(flag!=0))&#123; </span><br><span class="line">                cur=copy;</span><br><span class="line">                flag=0;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(copy.size()!=0)//选中了</span><br><span class="line">            &#123;</span><br><span class="line">                cur+=copy;</span><br><span class="line">                flag=0;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case 5:</span><br><span class="line">           flag=1;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;cur.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-检查是否存在满足条件的数字组合"><a href="#7-检查是否存在满足条件的数字组合" class="headerlink" title="7.检查是否存在满足条件的数字组合"></a>7.检查是否存在满足条件的数字组合</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个正整数数组，检查数组中是否存在满足规则的数字组合</p>
<p>规则：A &#x3D; B + 2C</p>
<h2 id="输入描述-5"><a href="#输入描述-5" class="headerlink" title="输入描述"></a>输入描述</h2><p>第一行输出数组的元素个数。</p>
<p>接下来一行输出所有数组元素，用空格隔开。</p>
<h2 id="输出描述-5"><a href="#输出描述-5" class="headerlink" title="输出描述"></a>输出描述</h2><p>如果存在满足要求的数，在同一行里依次输出规则里A&#x2F;B&#x2F;C的取值，用空格隔开。</p>
<p>如果不存在，输出0。</p>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>数组长度在3-100之间。<br>数组成员为0-65535，数组成员可以重复，但每个成员只能在结果算式中使用一次。如：数组成员为[0, 0, 1, 5]，0出现2次是允许的，但结果0 &#x3D; 0 + 2 * 0是不允许的，因为算式中使用了3个0。<br>用例保证每组数字里最多只有一组符合要求的解。</p>
<h2 id="输入-6"><a href="#输入-6" class="headerlink" title="输入"></a>输入</h2><p>4<br>2 7 3 0</p>
<h2 id="输出-6"><a href="#输出-6" class="headerlink" title="输出"></a>输出</h2><p>7 3 2</p>
<h2 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h2><p>7 &#x3D; 3 + 2 * 2</p>
<h2 id="个人代码-3for"><a href="#个人代码-3for" class="headerlink" title="个人代码(3for)"></a>个人代码(3for)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//a=b+2c，同一个数字最多出现1次</span><br><span class="line">//a-b=2c  =&gt;(a-b)/2=c</span><br><span class="line">//用例保证了只有一组符号要求的解</span><br><span class="line">void solution(vector&lt;int&gt; s)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0;i&lt;s.size();i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;s.size();j++)&#123;</span><br><span class="line">              for(int k=0;k&lt;s.size();k++)&#123;</span><br><span class="line">                if(i==j||i==k||k==j) continue;</span><br><span class="line">                if((s[i]-s[j])==2*s[k])</span><br><span class="line">                &#123;</span><br><span class="line">                        cout&lt;&lt;s[i]&lt;&lt;&quot; &quot;&lt;&lt;s[j]&lt;&lt;&quot; &quot;&lt;&lt;s[k];</span><br><span class="line">                        exit(0);</span><br><span class="line">                &#125;   </span><br><span class="line">                  if((s[i]-s[k])==2*s[j])</span><br><span class="line">                &#123;</span><br><span class="line">                        cout&lt;&lt;s[i]&lt;&lt;&quot; &quot;&lt;&lt;s[k]&lt;&lt;&quot; &quot;&lt;&lt;s[j];</span><br><span class="line">                        exit(0);</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        cout&lt;&lt;0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int length,num;</span><br><span class="line">    cin&gt;&gt;length;</span><br><span class="line">    vector&lt;int&gt; s;</span><br><span class="line"></span><br><span class="line">    while(cin&gt;&gt;num)</span><br><span class="line">    &#123;</span><br><span class="line">        s.push_back(num);</span><br><span class="line">        if(cin.get()==&#x27;\n&#x27;) break;</span><br><span class="line">    &#125;</span><br><span class="line">    solution(s);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="8-数组拼接"><a href="#8-数组拼接" class="headerlink" title="*8.数组拼接"></a>*8.数组拼接</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h2><p>现在有多组整数数组，需要将他们合并成一个新的数组。合并规则，从每个数组里按顺序取出固定长度的内容合并到新的数组中，取完的内容会删除掉，如果该行不足固定长度或者已经为空，则直接取出剩余部分的内容放到新的数组中，继续下一行。如样例1，获得长度3，先遍历第一行，获得2,5,6；再遍历第二行，获得1,7,4；再循环回到第一行，获得7,9,5；再遍历第二行，获得3,4；再回到第一行，获得7，按顺序拼接成最终结果。</p>
<h2 id="输入描述-6"><a href="#输入描述-6" class="headerlink" title="输入描述"></a>输入描述</h2><p>第一行是每次读取的固定长度,<code>0&lt;长度&lt;10</code>；<br>第二行是整数数组的数目<code>0&lt;数目&lt;1000</code>,<br>第<code>3~n</code>行是需要合并的数组,不同的数组用回车换行分隔,<br>数组内部用逗号分隔。最大不超过<code>100</code>个元素</p>
<h2 id="输出描述-6"><a href="#输出描述-6" class="headerlink" title="输出描述"></a>输出描述</h2><p>输出一个新的数组,用逗号分隔</p>
<h2 id="示例一-4"><a href="#示例一-4" class="headerlink" title="示例一"></a>示例一</h2><h3 id="输入-7"><a href="#输入-7" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">2,5,6,7,9,5,7</span><br><span class="line">1,7,4,3,4</span><br></pre></td></tr></table></figure>

<p>Copy</p>
<h3 id="输出-7"><a href="#输出-7" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2,5,6,1,7,4,7,9,5,3,4,7</span><br></pre></td></tr></table></figure>

<p>Copy</p>
<h2 id="示例二-1"><a href="#示例二-1" class="headerlink" title="示例二"></a>示例二</h2><h3 id="输入-8"><a href="#输入-8" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">3</span><br><span class="line">1,2,3,4,5,6</span><br><span class="line">1,2,3</span><br><span class="line">1,2,3,4</span><br></pre></td></tr></table></figure>

<p>Copy</p>
<h3 id="输出-8"><a href="#输出-8" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1,2,3,4,1,2,3,1,2,3,4,5,6</span><br></pre></td></tr></table></figure>

<h2 id="个人代码（有错误处）"><a href="#个人代码（有错误处）" class="headerlink" title="个人代码（有错误处）"></a>个人代码（有错误处）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">void solution(vector&lt;string&gt; &amp;s,int m,int n)</span><br><span class="line">&#123;</span><br><span class="line">   string result=&quot;&quot;,token=&quot;&quot;,shuzhi=&quot;&quot;;</span><br><span class="line"></span><br><span class="line">   int begin=0,len=m+m,flag=m,tiaoguo=0;//len是m+逗号数+1(哎，逗号这个问题)</span><br><span class="line">   //flag遍历完的数组数，tiaoguo为当前是否循环</span><br><span class="line">  </span><br><span class="line">  // substr()</span><br><span class="line">   while(flag)</span><br><span class="line">   &#123;</span><br><span class="line">    for(int i=0;i&lt;n;i++)//每个数组</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        //begin是每次取子串的起始位置，怎么处理begin&gt;size()的问题</span><br><span class="line">        if((begin+len)&lt;s[i].size())   //索引保持在正常范围内,即下一次循环还能截取   </span><br><span class="line">            &#123;</span><br><span class="line">                token+=s[i].substr(begin,len); </span><br><span class="line">                //cout&lt;&lt;&quot;can substr&quot;&lt;&lt;token&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        else if(begin+len&gt;s[i].size()&amp;&amp;begin&lt;s[i].size()) //</span><br><span class="line">        &#123;//下一次不能截取，那就直接读完</span><br><span class="line">                    token=s[i].substr(begin); //直接取完</span><br><span class="line">                    token+=&quot;,&quot;;    //加个逗号</span><br><span class="line">                    flag--;</span><br><span class="line">                  //  cout&lt;&lt;&quot;ou substr&quot;&lt;&lt;token;</span><br><span class="line">        &#125;</span><br><span class="line">        else continue; //下次循环</span><br><span class="line">               result+=token;</span><br><span class="line">               token=&quot;&quot;;//清零</span><br><span class="line"></span><br><span class="line">               //shuzhi=s[i];//后面用到</span><br><span class="line">    &#125;</span><br><span class="line">//如果长度不一样，怎么确保哪些弄完，哪些没弄完</span><br><span class="line"></span><br><span class="line">      //  if((begin+len)&lt;shuzhi.size()) //防止下次substr溢出</span><br><span class="line">            begin+=len;//下一次截取起始位置</span><br><span class="line">       // else continue;</span><br><span class="line">       // if(tiaoguo&gt;0) continue; //跳出这次循环</span><br><span class="line">    //     if(begin+len&lt;s[i].size())//substr的起始位置不超过字符本身，就是说还可以截取</span><br><span class="line">    //     &#123;</span><br><span class="line">    //         token=s[i].substr(begin,len); //截取</span><br><span class="line">    //     //    tiaoguo=-1; //下一次循环不跳过</span><br><span class="line">    //     &#125;</span><br><span class="line">    //     else //否则直接赋值</span><br><span class="line">    //     &#123;</span><br><span class="line">    //         token=s[i];</span><br><span class="line">    //    //     tiaoguo=1;//跳出这次循环</span><br><span class="line">    //         flag++;//跳出次数，即每次读m，读完的次数</span><br><span class="line">    //     &#125;</span><br><span class="line">    //     result+=token;</span><br><span class="line"></span><br><span class="line">     &#125;    </span><br><span class="line">    cout&lt;&lt;result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  //  int n,m;</span><br><span class="line">  // cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">   //getchar();//取走回车，为了下面的getline</span><br><span class="line"></span><br><span class="line"> string s;</span><br><span class="line">  int m,n;</span><br><span class="line">  cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    vector&lt;string&gt; sw;</span><br><span class="line">  getchar(); //否则，n=2时，下文的getline只读一行，因为之前的回车读到了</span><br><span class="line"> // cin.ignore();</span><br><span class="line">  for(int i=0;i&lt;n;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    getline(cin,s);//默认分隔符为&#x27;\n&#x27; cin会默认去除\n</span><br><span class="line">    sw.emplace_back(s);</span><br><span class="line">  &#125;</span><br><span class="line">  solution(sw,m,n);</span><br><span class="line"></span><br><span class="line">   // cout&lt;&lt;sw.size();</span><br><span class="line">  // vector</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>面临的问题有：</p>
<p>1.因为是带着逗号来的，而且是字符串存储，双位数+逗号和单位数+逗号，难以把控，（举例1,123,4和1,2,3,4, 这个位置问题啊，阿西吧）</p>
<p>解决办法：想办法以整数添加吧；或者for循环里以“，”分割，添加m位添加数字。</p>
<p>2.substr的溢出问题，我用begin代表初始位置，捕捉m长度的数值，用子串字符串作为缓冲添加</p>
<p>解决办法：因为每次循环完，begin会增加m长度，更新substr的初始位置，会大过原有索引。</p>
<p>。。。必须去掉逗号的影响</p>
</blockquote>
<h1 id="9-数列描述"><a href="#9-数列描述" class="headerlink" title="9.数列描述"></a>9.数列描述</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>有一个数列a[N] (N&#x3D;60)，从a[0]开始，每一项都是一个数字。数列中a[n+1]都是a[n]的描述。其中a[0]&#x3D;1。</p>
<p>规则如下：</p>
<p>a[0]:1</p>
<p>a[1]:11(含义：其前一项a[0]&#x3D;1是1个1，即“11”。表示a[0]从左到右，连续出现了1次“1”）</p>
<p>a[2]:21(含义：其前一项a[1]&#x3D;11，从左到右：是由两个1组成，即“21”。表示a[1]从左到右，连续出现了两次“1”)</p>
<p>a[3]:1211(含义：其前一项a[2]&#x3D;21，从左到右：是由一个2和一个1组成，即“1211”。表示a[2]从左到右，连续出现了1次“2”，然后又连续出现了1次“1”)</p>
<p>a[4]:111221(含义：其前一项a[3]&#x3D;1211，从左到右：是由一个1、一个2、两个1组成，即“111221”。表示a[3]从左到右，连续出现了1次“1”，连续出现了1次“2”，连续出现了两次“1”)</p>
<p>请输出这个数列的第n项结果（a[n]，0≤n≤59）。</p>
<h2 id="输入描述-7"><a href="#输入描述-7" class="headerlink" title="输入描述"></a>输入描述</h2><p>数列的第n项(0≤n≤59)</p>
<p>4</p>
<h2 id="输出描述-7"><a href="#输出描述-7" class="headerlink" title="输出描述"></a>输出描述</h2><p>数列的内容</p>
<p>111221</p>
<h2 id="个人代码（有误）"><a href="#个人代码（有误）" class="headerlink" title="个人代码（有误）"></a>个人代码（有误）</h2><p><strong>怎么达成递归条件啊</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; s(61);</span><br><span class="line">string back(int num)</span><br><span class="line">&#123;</span><br><span class="line">    //a[n]就是对a[n-1]的描述</span><br><span class="line">    //即a[n-1]中,a[n-1][i]的情况,从左往右，出现次数与该值。。。</span><br><span class="line">    //例如 a[3]=&quot;1211&quot;，那么a[4]=&quot;111221&quot;一次1，一次2，二次1</span><br><span class="line">    //那就是0-9，记为j，来个index记录一下，如果相等，对应位置a[j]++</span><br><span class="line">    //但面临的问题是，不知道是连续的呢，还是独立的呢</span><br><span class="line">    //</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; index(10,0);</span><br><span class="line">   </span><br><span class="line">    if(num==3) </span><br><span class="line">    &#123;</span><br><span class="line">       // s[num]=&quot;1&quot;;</span><br><span class="line">        return &quot;21&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    // if(s[num])    </span><br><span class="line">    int pre=s[num-1][0]-&#x27;0&#x27;;</span><br><span class="line">    index[pre]++; </span><br><span class="line">        for(int i=1;i&lt;back(num-1).size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int tem=s[num-1][i]-&#x27;0&#x27;;//其中的值</span><br><span class="line">        if(tem==pre) //从左到右相同，连续统计</span><br><span class="line">        &#123;</span><br><span class="line">            index[tem]++;</span><br><span class="line">        &#125;    </span><br><span class="line">       // string s=to_string(123);</span><br><span class="line">      // to_string(23);</span><br><span class="line">        else//相邻不同</span><br><span class="line">        &#123;</span><br><span class="line">            s[num]+=to_string(index[pre])+to_string(pre);//给s[num];</span><br><span class="line">            index[tem]=1;//防止以前统计过，置为1</span><br><span class="line">            pre=tem;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s[num] += to_string(index[pre]) + to_string(pre);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   return s[num];</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   back(4);</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="个人代码（纠正后）"><a href="#个人代码（纠正后）" class="headerlink" title="个人代码（纠正后）"></a>个人代码（纠正后）</h2><p>放弃递归想法，直接从已知一步步算到所求。比如已知s[0],s[1]，求s[5]；先算s[2]，再算s[3]…直到s[5];</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//vector&lt;string&gt; s(61,&quot;&quot;);</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">s</span><span class="params">(<span class="number">61</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bianli</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//a[n]就是对a[n-1]的描述</span></span><br><span class="line">    <span class="comment">//即a[n-1]中,a[n-1][i]的情况,从左往右，出现次数与该值。。。</span></span><br><span class="line">    <span class="comment">//例如 a[3]=&quot;1211&quot;，那么a[4]=&quot;111221&quot;一次1，一次2，二次1</span></span><br><span class="line">    <span class="comment">//那就是0-9，记为j，来个index记录一下，如果相等，对应位置a[j]++</span></span><br><span class="line">    <span class="comment">//但面临的问题是，不知道是连续的呢，还是独立的呢</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// if(s[num])    </span></span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=num;i++) <span class="comment">//从第2项算到第num项</span></span><br><span class="line">    &#123;</span><br><span class="line">          <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">index</span><span class="params">(<span class="number">10</span>,<span class="number">0</span>)</span></span>; <span class="comment">//每次初始化为0</span></span><br><span class="line">          <span class="type">int</span> pre=s[i<span class="number">-1</span>][<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>; <span class="comment">//记录s[1]的第一个元素</span></span><br><span class="line">            index[pre]++;   <span class="comment">//对应下标相加</span></span><br><span class="line">       <span class="comment">// cout&lt;&lt;&quot;sdsd&quot;&lt;&lt;&quot;: &quot;&lt;&lt;pre&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;s[i<span class="number">-1</span>].<span class="built_in">size</span>();k++) </span><br><span class="line">        &#123;</span><br><span class="line">             <span class="type">int</span> tem=s[i<span class="number">-1</span>][k]-<span class="string">&#x27;0&#x27;</span>;<span class="comment">//取第k个值</span></span><br><span class="line">             <span class="comment">//cout&lt;&lt;&quot;s[i-1]&quot;&lt;&lt;&quot; &quot;&lt;&lt;s[i-1].size()&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span>(tem==pre) <span class="comment">//如果从左到右相同，连续统计</span></span><br><span class="line">        &#123;</span><br><span class="line">            index[tem]++;</span><br><span class="line">        &#125;    </span><br><span class="line">       <span class="comment">// string s=to_string(123);</span></span><br><span class="line">      <span class="comment">// to_string(23);</span></span><br><span class="line">        <span class="keyword">else</span><span class="comment">//相邻不同</span></span><br><span class="line">        &#123;</span><br><span class="line">            s[i]+=<span class="built_in">to_string</span>(index[pre])+<span class="built_in">to_string</span>(pre);<span class="comment">//给s[i]赋值 统计数+对应数;</span></span><br><span class="line">           <span class="comment">//s[i]=&quot;123&quot;;</span></span><br><span class="line">          <span class="comment">// cout&lt;&lt;&quot;出现次数: &quot;&lt;&lt;index[pre]&lt;&lt;&quot;，对应值 &quot;&lt;&lt;pre&lt;&lt;endl;</span></span><br><span class="line">            index[tem]=<span class="number">1</span>;<span class="comment">//防止以前统计过，置为1</span></span><br><span class="line">            pre=tem;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">// cout&lt;&lt;&quot;wewe&quot;&lt;&lt;&quot;: &quot;&lt;&lt;tem&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//会少比一次嘞，内循环比完后，还剩最后一次的值没有描述</span></span><br><span class="line">        <span class="comment">//s[i]+=&quot;123&quot;;</span></span><br><span class="line">         s[i]+=<span class="built_in">to_string</span>(index[pre])+<span class="built_in">to_string</span>(pre);</span><br><span class="line">       <span class="comment">//   cout&lt;&lt;&quot;出现次数: &quot;&lt;&lt;index[pre]&lt;&lt;&quot;，对应值 &quot;&lt;&lt;pre&lt;&lt;endl;</span></span><br><span class="line">       <span class="comment">//下标置0，为了下一次循环</span></span><br><span class="line">      <span class="comment">//  index.clear();//删不掉</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//s.push_back(&quot;11&quot;);没效果？</span></span><br><span class="line">    s[<span class="number">0</span>]=<span class="string">&quot;1&quot;</span>;</span><br><span class="line">    s[<span class="number">1</span>]=<span class="string">&quot;11&quot;</span>;</span><br><span class="line">    <span class="comment">//s[2]=&quot;21&quot;</span></span><br><span class="line">    <span class="comment">//s[3]=&quot;1211&quot;</span></span><br><span class="line">    <span class="comment">//s[4]=&quot;111221&quot;</span></span><br><span class="line">    <span class="comment">//s[5]=&quot;312211&quot;</span></span><br><span class="line">    <span class="comment">//s[6]=</span></span><br><span class="line">   <span class="comment">//  bianli(1);</span></span><br><span class="line">   <span class="comment">//cout&lt;&lt;s[0]&lt;&lt;&quot; &quot;&lt;&lt;s[1];</span></span><br><span class="line">    <span class="built_in">bianli</span>(<span class="number">6</span>);</span><br><span class="line">  <span class="comment">//  cout&lt;&lt;s[3];</span></span><br><span class="line">  cout&lt;&lt;s[<span class="number">6</span>];</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="10-考勤信息"><a href="#10-考勤信息" class="headerlink" title="10.考勤信息"></a>10.考勤信息</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>公司用一个字符串来表示员工的出勤信息</p>
<p>absent：缺勤</p>
<p>late：迟到</p>
<p>leaveearly：早退</p>
<p>present：正常上班</p>
<p>现需根据员工出勤信息，判断本次是否能获得出勤奖，能获得出勤奖的条件如下：</p>
<p>缺勤不超过一次；</p>
<p>没有连续的迟到&#x2F;早退；</p>
<p>任意连续7次考勤，缺勤&#x2F;迟到&#x2F;早退不超过3次。</p>
<h2 id="输入描述-8"><a href="#输入描述-8" class="headerlink" title="输入描述"></a>输入描述</h2><p>用户的考勤数据字符串，记录条数 &gt;&#x3D; 1；</p>
<p>输入字符串长度 &lt; 10000；</p>
<p>不存在非法输入</p>
<p>如：</p>
<p>2</p>
<p>present</p>
<p>present absent present present leaveearly present absent</p>
<h2 id="输出描述-8"><a href="#输出描述-8" class="headerlink" title="输出描述"></a>输出描述</h2><p>根据考勤数据字符串，如果能得到考勤奖，输出”true”；否则输出”false”，</p>
<p>对于输入示例的结果应为：</p>
<p>true false</p>
<h2 id="输入-9"><a href="#输入-9" class="headerlink" title="输入"></a>输入</h2><p>2</p>
<p>present</p>
<p>present present</p>
<h2 id="输出-9"><a href="#输出-9" class="headerlink" title="输出"></a>输出</h2><p>true</p>
<p>true</p>
<h2 id="输入-10"><a href="#输入-10" class="headerlink" title="输入"></a>输入</h2><p>2</p>
<p>present</p>
<p>present absent present present leaveearly present absent</p>
<h2 id="输出-10"><a href="#输出-10" class="headerlink" title="输出"></a>输出</h2><p>true</p>
<p>false</p>
<h2 id="个人代码-1"><a href="#个人代码-1" class="headerlink" title="个人代码"></a>个人代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void neibuchuli(vector&lt;string&gt; &amp;s)//把空格去掉</span><br><span class="line">&#123;</span><br><span class="line">    string st=s[0];//实际是s[i][0]</span><br><span class="line">    string token;</span><br><span class="line">    stringstream ss(st);</span><br><span class="line">    while(getline(ss,token,&#x27; &#x27;))</span><br><span class="line">    &#123;</span><br><span class="line">        s.push_back(token);//以后不用s[0]了，从1开始。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//absent late leaveearly 前三个不超过三次 present</span><br><span class="line"></span><br><span class="line">/*缺勤不超过一次；</span><br><span class="line"></span><br><span class="line">没有连续的迟到/早退；</span><br><span class="line"></span><br><span class="line">任意连续7次考勤，缺勤/迟到/早退不超过3次。</span><br><span class="line">*/</span><br><span class="line">void solution(vector&lt;string&gt; s)</span><br><span class="line">&#123;</span><br><span class="line"> int queqin=0,chidao=0,zaotui=0;</span><br><span class="line"> for(int i=1;i&lt;s.size();i++)</span><br><span class="line"> &#123;</span><br><span class="line">    //一开始退出语句在这里，不对</span><br><span class="line">   // switch()</span><br><span class="line">    if(s[i]==&quot;absent&quot;)</span><br><span class="line">   &#123;</span><br><span class="line">     queqin++;</span><br><span class="line">   //  cout&lt;&lt;i&lt;&lt;&quot; &quot;;</span><br><span class="line">   &#125; </span><br><span class="line">    if(s[i]==&quot;late&quot;) chidao++;</span><br><span class="line">    if(s[i]==&quot;leaveearly&quot;) zaotui++;</span><br><span class="line"></span><br><span class="line">   //   cout&lt;&lt;&quot;i: &quot;&lt;&lt;i&lt;&lt;&quot; queqin:&quot;&lt;&lt;queqin&lt;&lt;&quot; late: &quot;&lt;&lt;chidao&lt;&lt;&quot; leaveearly: &quot;&lt;&lt;zaotui&lt;&lt;endl;</span><br><span class="line">  //条件不能放在前面</span><br><span class="line">  //缺勤不能超过1次</span><br><span class="line">   if(queqin&gt;1) </span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;false&quot;&lt;&lt;endl;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //连续的迟到或早退</span><br><span class="line">    if(i&gt;1&amp;&amp;(s[i]==&quot;late&quot;||s[i]==&quot;leaveearly&quot;))</span><br><span class="line">    &#123;</span><br><span class="line">        if(s[i]==s[i-1])</span><br><span class="line">        &#123;</span><br><span class="line">        cout&lt;&lt;&quot;false&quot;&lt;&lt;endl;</span><br><span class="line">        return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //缺勤/迟到/早退不超过三次</span><br><span class="line">    if(queqin+chidao+zaotui&gt;3)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;false&quot;&lt;&lt;endl;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"> &#125;</span><br><span class="line"> cout&lt;&lt;&quot;true&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int num;</span><br><span class="line">    cin&gt;&gt;num;</span><br><span class="line">    vector&lt;string&gt; s[num];</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">    string sw;</span><br><span class="line">    for(int i=0;i&lt;num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        getline(cin,sw); //回车为分割点</span><br><span class="line">        s[i].push_back(sw);</span><br><span class="line">    &#125;</span><br><span class="line">    //  for(string list:s[0])</span><br><span class="line">    //      cout&lt;&lt;list&lt;&lt;&quot; &quot;&lt;&lt;endl;</span><br><span class="line">    //     for(string list:s[1])</span><br><span class="line">    //     cout&lt;&lt;list&lt;&lt;&quot; &quot;&lt;&lt;endl;</span><br><span class="line"> //   cout&lt;s[0].size()&lt;&lt;&quot; &quot;&lt;&lt;s[0][0].size();</span><br><span class="line">    for(int j=0;j&lt;num;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        neibuchuli(s[j]);</span><br><span class="line">    &#125;</span><br><span class="line">        //  for(string list:s[1])</span><br><span class="line">        //  cout&lt;&lt;list&lt;&lt;&quot; &quot;&lt;&lt;endl;</span><br><span class="line">    // for(string s11:s[0])</span><br><span class="line">    //  cout&lt;&lt;s11&lt;&lt;&quot;!@#@!#&quot;&lt;&lt;endl;</span><br><span class="line">    //  cout&lt;&lt;s[0].size();</span><br><span class="line">     for(int k=0;k&lt;num;k++)</span><br><span class="line">     &#123;</span><br><span class="line">         solution(s[k]);</span><br><span class="line">     &#125;</span><br><span class="line">        //   for(string list:s[1])</span><br><span class="line">        //   &#123;</span><br><span class="line">        //     if(list==&quot;absent&quot;)</span><br><span class="line">        //         cout&lt;&lt;list&lt;&lt;endl;</span><br><span class="line">        //   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><blockquote>
<p>1.以回车为分割，获取字符串</p>
<p>用到getline()，vector&lt;string&gt;</p>
<p>2.内部的空格分割，再追加字符串</p>
<p>用到stringstream，getline，push_back()</p>
<p>3.循环判断，标志++</p>
</blockquote>
<h1 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h1><p>vector&lt;int&gt; s;</p>
<p>不知道大小，加值就push_back</p>
<p>知道大小，则vector&lt;int&gt; s(10);</p>
<p>可以s[0]&#x3D;1;直接赋值</p>
<h1 id="11-区间反转文章"><a href="#11-区间反转文章" class="headerlink" title="11.区间反转文章"></a>11.区间反转文章</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>给定一段英文文章片段，由若干单词组成，单词间以空格间隔，单词下标从零开始，请翻转片段中指定区间的单词顺序并返回翻转后的内容。</p>
<p>例如给定的英文文章片段为“I am a developer.”，</p>
<p>翻转区间为[0,3]，</p>
<p>则输出”developer. a am l”。</p>
</blockquote>
<h2 id="输入描述-9"><a href="#输入描述-9" class="headerlink" title="输入描述"></a>输入描述</h2><blockquote>
<p>使用换行隔开三个参数，第一个参数为英文文章内容即英文字符串，第二个参数为待翻转内容起始单词下标，第三个参数为待翻转内容最后一个单词下标。</p>
</blockquote>
<h2 id="输出描述-9"><a href="#输出描述-9" class="headerlink" title="输出描述"></a>输出描述</h2><blockquote>
<p>翻转后的英文文章片段，所有单词之间以一个半角空格分隔符进行输出</p>
</blockquote>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><blockquote>
<p>输入<br>I am a developer<br>1<br>2<br>输出<br>I a am developer</p>
</blockquote>
<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><blockquote>
<p>输入<br>hello world<br>-1<br>1<br>输出<br>world hello</p>
</blockquote>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void solution1(vector&lt;string&gt; &amp;s,int begin,int end)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    string sum=&quot;&quot;;</span><br><span class="line">    vector&lt;string&gt; sw;</span><br><span class="line"></span><br><span class="line">    for(int i=begin;i&lt;=end;i++)</span><br><span class="line">     &#123;</span><br><span class="line"></span><br><span class="line">        sw.push_back(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">   // cout&lt;&lt;sw.size();</span><br><span class="line">    reverse(sw.begin(),sw.end());</span><br><span class="line">    // for(string list:sw)</span><br><span class="line">    // &#123;</span><br><span class="line">    //     cout&lt;&lt;list&lt;&lt;&quot; &quot;;</span><br><span class="line">    // &#125;</span><br><span class="line">    for(int j=begin;j&lt;=end;j++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      //哦，对于sw来说是从0开始的</span><br><span class="line">        // cout&lt;&lt;s[j]&lt;&lt;&quot; &quot;&lt;&lt;sw[j-begin]&lt;&lt;endl;</span><br><span class="line">        s[j]=sw[j-begin];</span><br><span class="line">    &#125;</span><br><span class="line"> //   cout&lt;&lt;s.size();</span><br><span class="line">    for(int k=0;k&lt;s.size();k++)</span><br><span class="line">    &#123;</span><br><span class="line">        //cout&lt;&lt;s[k];</span><br><span class="line">        if(k!=s.size()-1)</span><br><span class="line">        sum+=s[k]+&quot; &quot;;</span><br><span class="line">        else sum+=s[k];</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    cout&lt;&lt;sum;</span><br><span class="line">&#125;</span><br><span class="line">void solution2(vector&lt;string&gt; &amp;s,int l,int r)</span><br><span class="line">&#123;</span><br><span class="line">    while(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        string tem=s[l];</span><br><span class="line">        s[l]=s[r];</span><br><span class="line">        s[r]=tem;</span><br><span class="line">        l++;</span><br><span class="line">        r--;</span><br><span class="line">    &#125;</span><br><span class="line">     for(int k=0;k&lt;s.size();k++)</span><br><span class="line">    &#123;</span><br><span class="line">        //cout&lt;&lt;s[k];</span><br><span class="line">        if(k!=s.size()-1)</span><br><span class="line">        cout&lt;&lt;s[k]&lt;&lt;&quot; &quot;;</span><br><span class="line">        else cout&lt;&lt;s[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;string&gt; s;</span><br><span class="line">    string t,token;</span><br><span class="line">    //cin&gt;&gt;t;</span><br><span class="line">  //  getchar();</span><br><span class="line">    getline(cin,t);</span><br><span class="line">  //  getchar();</span><br><span class="line">    stringstream ss(t);</span><br><span class="line">    while(getline(ss,token,&#x27; &#x27;))</span><br><span class="line">    &#123;</span><br><span class="line">        s.push_back(token);</span><br><span class="line">    &#125;</span><br><span class="line">    // for(string sqq:s)</span><br><span class="line">    // cout&lt;&lt;sqq&lt;&lt;&quot;,&quot;;</span><br><span class="line">    int begin,end;//单词下标位置</span><br><span class="line">    cin&gt;&gt;begin&gt;&gt;end;</span><br><span class="line">   // solution1(s,begin,end);</span><br><span class="line">   solution2(s,begin,end);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>solution1是自己的方法，solution2是大佬<a target="_blank" rel="noopener" href="http://t.csdn.cn/6nGdh">HANWEN KE</a>的wp</p>
<h1 id="12-最大括号深度"><a href="#12-最大括号深度" class="headerlink" title="12.最大括号深度"></a>12.最大括号深度</h1><p>现有一字符串 仅由<code>&#39;(&#39;,&#39;)&#39;,&#39;&#123;&#39;,&#39;&#125;&#39;,&#39;[&#39;,&#39;]&#39;</code>六种括号组成<br>若字符串满足以下条件之一，则为无效字符串</p>
<ol>
<li>任意类型的左右括号数量不相等</li>
<li>存在未按正确顺序(先左后右)闭合的括号，<br>输出括号的最大嵌套深度<br>若字符串无效则输出<code>0</code><br><code>0 &lt;= 字符串长度 &lt;= 100000</code></li>
</ol>
<h2 id="输入描述-10"><a href="#输入描述-10" class="headerlink" title="输入描述"></a>输入描述</h2><p>一个只包括<code>&#39;(&#39;,&#39;)&#39;,&#39;&#123;&#39;,&#39;&#125;&#39;,&#39;[&#39;,&#39;]&#39;</code>的字符串</p>
<h2 id="输出描述-10"><a href="#输出描述-10" class="headerlink" title="输出描述"></a>输出描述</h2><p>一个整数 ，最大的括号深度</p>
<h2 id="示例一-5"><a href="#示例一-5" class="headerlink" title="示例一"></a>示例一</h2><h3 id="输入-11"><a href="#输入-11" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[]</span><br></pre></td></tr></table></figure>

<p>Copy</p>
<h3 id="输出-11"><a href="#输出-11" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<p>Copy</p>
<h3 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h3><p>有效字符串最大嵌套深度为1</p>
<h2 id="示例二-2"><a href="#示例二-2" class="headerlink" title="示例二"></a>示例二</h2><h3 id="输入-12"><a href="#输入-12" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">([]&#123;()&#125;)</span><br></pre></td></tr></table></figure>

<p>Copy</p>
<h3 id="输出-12"><a href="#输出-12" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<h2 id="个人代码-2"><a href="#个人代码-2" class="headerlink" title="个人代码"></a>个人代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">一字符串仅由三种（6个）括号组成，</span><br><span class="line">求嵌套深度，若不合法，输出0</span><br><span class="line">*/</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void solution(string s)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;char&gt; t;</span><br><span class="line">    int depth=0;</span><br><span class="line">   //3.为了防止&#125;[]()这种情况，所以必须先入首字符</span><br><span class="line">    if(s[0]!=&#x27;(&#x27;&amp;&amp;s[0]!=&#x27;[&#x27;&amp;&amp;(s[0]!=&#x27;&#123;&#x27;))</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;0;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for(int i=0;i&lt;s.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if((s[i]==&#x27;(&#x27;)||(s[i]==&#x27;[&#x27;)||(s[i]==&#x27;&#123;&#x27;))</span><br><span class="line">        &#123;</span><br><span class="line">            t.push_back(s[i]);</span><br><span class="line">            //depth=max(depth,t.size()); //报错？</span><br><span class="line">            if(depth&lt;t.size())</span><br><span class="line">            depth=t.size();</span><br><span class="line">        &#125;</span><br><span class="line">        if(i&gt;0)</span><br><span class="line">        &#123;</span><br><span class="line">            if(s[i]==&#x27;)&#x27;&amp;&amp;t[t.size()-1]==&#x27;(&#x27;)</span><br><span class="line">            &#123;</span><br><span class="line">              t.pop_back();//1.哦，pop了之后，t的size改变了，进而索引变了,所以不能t[i-1]</span><br><span class="line">             // depth=t.size();</span><br><span class="line">            &#125;   </span><br><span class="line">            if(s[i]==&#x27;]&#x27;&amp;&amp;t[t.size()-1]==&#x27;[&#x27;)</span><br><span class="line">            &#123;</span><br><span class="line">                t.pop_back();</span><br><span class="line">            //  depth++;</span><br><span class="line">            &#125;</span><br><span class="line">            if(s[i]==&#x27;&#125;&#x27;&amp;&amp;t[t.size()-1]==&#x27;&#123;&#x27;)</span><br><span class="line">            &#123;</span><br><span class="line">                t.pop_back();</span><br><span class="line">             // depth++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    //2.求最大嵌套深度，不是有效括号个数，那就是t存储个数</span><br><span class="line">    if(t.size()!=0) cout&lt;&lt;0;</span><br><span class="line">    else cout&lt;&lt;depth;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    solution(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="思想-4"><a href="#思想-4" class="headerlink" title="思想"></a>思想</h2><p>栈的利用，括号匹配</p>
<h1 id="13-字符串加密"><a href="#13-字符串加密" class="headerlink" title="13.字符串加密"></a>13.字符串加密</h1><p>给你一串未加密的字符串<code>str</code>，<br>通过对字符串的每一个字母进行改变来实现加密，<br>加密方式是在每一个字母<code>str[i]</code>偏移特定数组元素<code>a[i]</code>的量，<br>数组<code>a</code>前三位已经赋值：<code>a[0]=1</code>,<code>a[1]=2</code>,<code>a[2]=4</code>。<br>当<code>i&gt;=3</code>时，数组元素<code>a[i]=a[i-1]+a[i-2]+a[i-3]</code>，<br>例如：原文 <code>abcde</code> 加密后 <code>bdgkr</code>，其中偏移量分别是<code>1</code>,<code>2</code>,<code>4</code>,<code>7</code>,<code>13</code>。</p>
<h2 id="输入描述-11"><a href="#输入描述-11" class="headerlink" title="输入描述"></a>输入描述</h2><p>第一行为一个整数<code>n</code>（<code>1 &lt;= n &lt;= 1000</code>），<br>表示有<code>n</code>组测试数据，每组数据包含一行，<br>原文<code>str</code>（只含有小写字母， <code>0 &lt; 长度 &lt;= 50</code>）。</p>
<h2 id="输出描述-11"><a href="#输出描述-11" class="headerlink" title="输出描述"></a>输出描述</h2><p>每组测试数据输出一行，表示字符串的密文</p>
<h2 id="示例一-6"><a href="#示例一-6" class="headerlink" title="示例一"></a>示例一</h2><h3 id="输入-13"><a href="#输入-13" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">xy</span><br></pre></td></tr></table></figure>

<h3 id="输出-13"><a href="#输出-13" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ya</span><br></pre></td></tr></table></figure>

<h2 id="个人代码-3"><a href="#个人代码-3" class="headerlink" title="个人代码"></a>个人代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void pianyi(vector&lt;int&gt; &amp;a,int n)</span><br><span class="line">&#123;</span><br><span class="line">    a[0]=1;</span><br><span class="line">    a[1]=2;</span><br><span class="line">    a[2]=4;</span><br><span class="line">    for(int i=3;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i]=a[i-1]+a[i-2]+a[i-3];</span><br><span class="line">       // cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void solution(string &amp;s,vector&lt;int&gt; a)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0;i&lt;s.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s[i]=(s[i]-&#x27;a&#x27;+a[i])%26+&#x27;a&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // string s;</span><br><span class="line">    // cin&gt;&gt;s;</span><br><span class="line">    // vector&lt;int&gt; a(s.size());</span><br><span class="line">    // pianyi(a,s.size());//算出从0到s.size-1的偏移量</span><br><span class="line">    // solution(s,a);</span><br><span class="line">    int n=0;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    getchar();</span><br><span class="line">    vector&lt;string&gt; s;</span><br><span class="line">    string t;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        getline(cin,t);</span><br><span class="line">         s.push_back(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // for(string list:s)</span><br><span class="line">    // cout&lt;&lt;list&lt;&lt;&quot; &quot;;</span><br><span class="line">    int len=0;</span><br><span class="line">    for(string list:s)</span><br><span class="line">    &#123;</span><br><span class="line">        //len=max(len,list.size());</span><br><span class="line">        if(len&lt;list.size())</span><br><span class="line">            len=list.size();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; a(len);</span><br><span class="line">      pianyi(a,len);//算出从0到s.size-1的偏移量</span><br><span class="line">      for(int i=0;i&lt;s.size();i++)</span><br><span class="line">      &#123;</span><br><span class="line">        solution(s[i],a);</span><br><span class="line">      &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可用递归函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function fn(num)&#123;</span><br><span class="line">    if(num==0)&#123;</span><br><span class="line">        return 1</span><br><span class="line">    &#125;</span><br><span class="line">    else  if(num==1)&#123;</span><br><span class="line">        return 2</span><br><span class="line">    &#125; </span><br><span class="line">    else if(num==2)&#123;</span><br><span class="line">        return 4</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        return fn(num-1)+fn(num-2)+fn(num-3)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="14-整数对最小和"><a href="#14-整数对最小和" class="headerlink" title="14.整数对最小和"></a>14.整数对最小和</h1><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>给定两个整数数组 <code>array1</code> <code>array2</code>数组元素按升序排列<br>假设从<code>array1</code> <code>array2</code>中分别取出一个元素可构成一对元素<br>现在需要取出<code>K</code>对元素<br>并对取出的所有元素求和<br>计算和的最小值<br>注意：<br>两对元素如果对应于<code>array1</code> <code>array2</code>中的两个下标均相同，则视为同一个元素</p>
</blockquote>
<h2 id="输入描述-12"><a href="#输入描述-12" class="headerlink" title="输入描述"></a>输入描述</h2><p>输入两行数组<code>array1</code> <code>array2</code><br>每行首个数字为数组大小 <code>size</code>( <code>0 &lt; size &lt;= 100</code>)<br><code>0 &lt; array1(i) &lt;= 10000 &lt; array2(i) &lt;= 1000</code><br>接下来一行为正整数<code>k</code> (<code>0 &lt; k &lt;= array1.size() * array2.size()</code>)</p>
<h2 id="输出描述-12"><a href="#输出描述-12" class="headerlink" title="输出描述"></a>输出描述</h2><p>满足要求的最小和</p>
<h2 id="示例一-7"><a href="#示例一-7" class="headerlink" title="示例一"></a>示例一</h2><h3 id="输入-14"><a href="#输入-14" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3 1 1 2</span><br><span class="line">3 1 2 3</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h3 id="输出-14"><a href="#输出-14" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>



<h3 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h3><p>用例中，需要取两个元素 取第一个数组第<code>0</code>个元素 与第二个数组第<code>0</code>个元素，组成一对元素<code>[1,1]</code><br>取第一个数组第<code>1</code>个元素 与第二个数组第<code>0</code>个元素，组成一对元素<code>[1,1]</code><br>求和为<code>1+1+1+1=4</code> 为满足要求的最小和</p>
<h2 id="个人代码-4"><a href="#个人代码-4" class="headerlink" title="个人代码"></a>个人代码</h2><blockquote>
<p>1.各自排序，我用的快速排序</p>
<p>2.比较最小值相加即可</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">/*</span><br><span class="line">3 1 1 2</span><br><span class="line">3 1 2 3</span><br><span class="line">2</span><br><span class="line">*/</span><br><span class="line">int part(vector&lt;int&gt; &amp;a,int low,int high);</span><br><span class="line">void quicksort(vector&lt;int&gt; &amp;a,int low,int high);</span><br><span class="line"></span><br><span class="line">int part(vector&lt;int&gt; &amp;a,int low,int high)</span><br><span class="line">&#123;</span><br><span class="line">    int i=low,j=high,privot=a[low];//基准</span><br><span class="line">    while(i&lt;j)</span><br><span class="line">    &#123;</span><br><span class="line">        while(i&lt;j&amp;&amp;a[j]&gt;privot)//右边找一个小于privot的值</span><br><span class="line">        &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(a[i++],a[j]);//交换完，i右移</span><br><span class="line">        &#125;</span><br><span class="line">        while(i&lt;j&amp;&amp;a[i]&lt;=privot)//左边找一个大于privot的值</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(a[i],a[j--]);//交换完,j左移</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    return i;</span><br><span class="line">&#125;</span><br><span class="line">void quicksort(vector&lt;int&gt; &amp;a,int low,int high)</span><br><span class="line">&#123;</span><br><span class="line">    int mid;</span><br><span class="line">    if(low&lt;high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid=part(a,low,high);//基准值</span><br><span class="line">        quicksort(a,low,mid-1);</span><br><span class="line">        quicksort(a,mid+1,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //a[0]取i个，则a[1]取k-i个；</span><br><span class="line">    //从a[0]求i个最小值和，从a[1]求k-i个最小值和</span><br><span class="line"> </span><br><span class="line">    //排序，各自求最小值。双指针</span><br><span class="line">    vector&lt;int&gt; a[2];</span><br><span class="line">    int num;</span><br><span class="line">    for(int i=0;i&lt;2;i++)</span><br><span class="line">    &#123;</span><br><span class="line">       while(cin&gt;&gt;num)</span><br><span class="line">       &#123;</span><br><span class="line">        a[i].push_back(num);</span><br><span class="line">        if(cin.get()==&#x27;\n&#x27;) break;</span><br><span class="line">       &#125;</span><br><span class="line">      // cin.ignore();</span><br><span class="line">    &#125;</span><br><span class="line">    int k;</span><br><span class="line">    cin&gt;&gt;k;//这个是对数，即a[0][i]与a[1][j]所组成的对数</span><br><span class="line"></span><br><span class="line">    // quicksort(a[1],1,a[1][0]);</span><br><span class="line">    // for(int i:a[1])</span><br><span class="line">    // cout&lt;&lt;i&lt;&lt;&quot; &quot;;</span><br><span class="line"></span><br><span class="line">    //从小到大排序过后</span><br><span class="line">    //quicksort(a[0],1,a[0][0]); 为啥不行嘞</span><br><span class="line">    quicksort(a[0],1,a[0].size()-1);</span><br><span class="line">    quicksort(a[1],1,a[1].size()-1);</span><br><span class="line">    int i=1,j=1,co=0,sum=0;</span><br><span class="line">    //取的是整数&quot;对&quot;，最小和，意味着有一方有最小的值，固定下来即可。</span><br><span class="line">    //逮住一个最小的薅，组成整数&quot;对&quot;</span><br><span class="line">    while(i&lt;a[0][0]&amp;&amp;co&lt;k)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a[0][i]&lt;a[0][j])</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=a[0][i++]+a[0][j];</span><br><span class="line">            co++;</span><br><span class="line">        &#125;</span><br><span class="line">        else </span><br><span class="line">        &#123;</span><br><span class="line">            sum+=a[0][i]+a[0][j++];</span><br><span class="line">            co++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="wp-2"><a href="#wp-2" class="headerlink" title="wp"></a>wp</h2><p>来自<a target="_blank" rel="noopener" href="https://wiki.amoscloud.com/zh/ProgramingPractice/NowCoder/Adecco/Topic0002">题目0002-整数对最小和 | AmosCloud Wiki</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct Node &#123;</span><br><span class="line">    int i, j, val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bool cmp(Node a, Node b) &#123;</span><br><span class="line">    return a.val &lt; b.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int m, n, k;</span><br><span class="line">    cin &gt;&gt; m;//a1数组的大小</span><br><span class="line">    vector&lt;int&gt; arr1(m);</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; arr1[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; n;//a2数组的大小</span><br><span class="line">    vector&lt;int&gt; arr2(n);</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; arr2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; k;//整数对个数</span><br><span class="line"></span><br><span class="line">    vector&lt;Node&gt; nodes(m * n);</span><br><span class="line">    int nodesLen = 0;</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">            nodes[nodesLen].i = i;</span><br><span class="line">            nodes[nodesLen].j = j;</span><br><span class="line">            nodes[nodesLen].val = arr1[i] + arr2[j];</span><br><span class="line">            nodesLen++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(nodes.begin(), nodes.end(), cmp);//从小到大排序</span><br><span class="line"></span><br><span class="line">    int ans = 0;</span><br><span class="line">    vector&lt;bool&gt; used(m, false);</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    for (int i = 0; i &lt; nodesLen; i++) &#123;</span><br><span class="line">        if (used[nodes[i].i]) continue;</span><br><span class="line">        ans += nodes[i].val;</span><br><span class="line">        used[nodes[i].i] = true;</span><br><span class="line">        cnt++;</span><br><span class="line">        if (cnt == k) break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="15-求字符串中所有整数的最小和"><a href="#15-求字符串中所有整数的最小和" class="headerlink" title="15.求字符串中所有整数的最小和"></a>15.求字符串中所有整数的最小和</h1><h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>字符串s，只包含 a-z A-Z + - ；<br>合法的整数包括<br>1） 正整数 一个或者多个0-9组成，如 0 2 3 002 102<br>2）负整数 负号 - 开头，数字部分由一个或者多个0-9组成，如 -0 -012 -23 -00023</p>
</blockquote>
<h2 id="输入描述-13"><a href="#输入描述-13" class="headerlink" title="输入描述"></a>输入描述</h2><p>包含数字的字符串</p>
<h2 id="输出描述-13"><a href="#输出描述-13" class="headerlink" title="输出描述"></a>输出描述</h2><p>所有整数的最小和</p>
<h2 id="示例一-8"><a href="#示例一-8" class="headerlink" title="示例一"></a>示例一</h2><p>输入</p>
<blockquote>
<p>bb1234aa</p>
</blockquote>
<p>输出</p>
<blockquote>
<p>10</p>
</blockquote>
<h2 id="个人代码-5"><a href="#个人代码-5" class="headerlink" title="个人代码"></a>个人代码</h2><p>1.正数按个位加，负数按最大值减</p>
<p>2.用了stoi，字符串转化为数字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void solution(string s)</span><br><span class="line">&#123;</span><br><span class="line">    int sum=0,flag=-1;</span><br><span class="line">    string t=&quot;&quot;;</span><br><span class="line">    for(char i:s)</span><br><span class="line">    &#123;</span><br><span class="line">        if(i==&#x27;-&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            flag=1;</span><br><span class="line">            continue;//跳过本次循环</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag&gt;0) //负数处理</span><br><span class="line">        &#123;</span><br><span class="line">            if(i&gt;=&#x27;0&#x27;&amp;&amp;i&lt;=&#x27;9&#x27;)</span><br><span class="line">            &#123;</span><br><span class="line">                  t+=i;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                 sum-=stoi(t);</span><br><span class="line">                  t=&quot;&quot;;</span><br><span class="line">                  flag=-9;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else//正数处理</span><br><span class="line">        &#123;</span><br><span class="line">            if(i&gt;=&#x27;0&#x27;&amp;&amp;i&lt;=&#x27;9&#x27;)</span><br><span class="line">         &#123;</span><br><span class="line">             sum+=i-&#x27;0&#x27;;</span><br><span class="line">         &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;sum;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    // cout&lt;&lt;&#x27;a&#x27;-&#x27;0&#x27;&lt;&lt;endl;</span><br><span class="line">    // cout&lt;&lt;&#x27;A&#x27;-&#x27;0&#x27;&lt;&lt;endl;</span><br><span class="line">    // cout&lt;&lt;&#x27;+&#x27;-&#x27;0&#x27;&lt;&lt;endl;</span><br><span class="line">    //所有整数的最小和，1234既可以看做是一个数1234，也可以看做4个数(1,2,3,4)。确保加和最小</span><br><span class="line">    //有减号，则-最大值。</span><br><span class="line">    //全是正整数，则按个位加和</span><br><span class="line">    //有正有减，个位正数加与最小负数相加</span><br><span class="line">    //  string s1=&quot;00123&quot;,s2=&quot;120&quot;;</span><br><span class="line">    //  cout&lt;&lt;stoi(s1);</span><br><span class="line">    solution(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="16-乱序整数序列两数之和绝对值最小"><a href="#16-乱序整数序列两数之和绝对值最小" class="headerlink" title="16.乱序整数序列两数之和绝对值最小"></a>16.乱序整数序列两数之和绝对值最小</h1><h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个随机的整数数组(可能存在正整数和负整数)<code>nums</code>,<br>请你在该数组中找出两个数，其和的绝对值<code>(|nums[x]+nums[y]|)</code>为最小值<br>并返回这两个数(按从小到大返回)以及绝对值。<br>每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<h2 id="输入描述-14"><a href="#输入描述-14" class="headerlink" title="输入描述"></a>输入描述</h2><p>一个通过空格空格分割的有序整数序列字符串，最多<code>1000</code>个整数，<br>且整数数值范围是<code>[-65535,65535]</code></p>
<h2 id="输出描述-14"><a href="#输出描述-14" class="headerlink" title="输出描述"></a>输出描述</h2><p>两个数和两数之和绝对值</p>
<h2 id="示例一-9"><a href="#示例一-9" class="headerlink" title="示例一"></a>示例一</h2><h3 id="输入-15"><a href="#输入-15" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1 -3 7 5 11 15</span><br></pre></td></tr></table></figure>

<p>Copy</p>
<h3 id="输出-15"><a href="#输出-15" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-3 5 2</span><br></pre></td></tr></table></figure>

<h2 id="个人代码-6"><a href="#个人代码-6" class="headerlink" title="个人代码"></a>个人代码</h2><p>双for</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">/*</span><br><span class="line">一个通过空格空格分割的有序整数序列字符串，最多`1000`个整数，</span><br><span class="line">且整数数值范围是`[-65535,65535]`</span><br><span class="line"></span><br><span class="line">其和的绝对值`(|nums[x]+nums[y]|)`为最小值</span><br><span class="line">并返回这两个数(按从小到大返回)以及绝对值。</span><br><span class="line">*/</span><br><span class="line">/*</span><br><span class="line">-1 -3 7 5 11 15</span><br><span class="line">-3 5 2</span><br><span class="line">*/</span><br><span class="line">//怎么说，非必要不同号</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; s;</span><br><span class="line">    //输入是有序整数</span><br><span class="line">    int num;</span><br><span class="line">    while(cin&gt;&gt;num)</span><br><span class="line">    &#123;</span><br><span class="line">        s.push_back(num);</span><br><span class="line">        if(cin.get()==&#x27;\n&#x27;) break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // for(int i:s)</span><br><span class="line">    // cout&lt;&lt;i&lt;&lt;&quot;,&quot;;</span><br><span class="line">    int min_num=1000,n1=s[0],n2=s[0];</span><br><span class="line">    for(int i=0;i&lt;s.size();i++)</span><br><span class="line">    for(int j=i+1;j&lt;s.size();j++)</span><br><span class="line">    &#123;</span><br><span class="line">       if(min_num&gt; abs(s[i]+s[j]))</span><br><span class="line">       &#123;</span><br><span class="line">            min_num=abs(s[i]+s[j]);</span><br><span class="line">            n1=s[i];</span><br><span class="line">            n2=s[j];</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;n1&lt;&lt;&quot; &quot;&lt;&lt;n2&lt;&lt;&quot; &quot;&lt;&lt;min_num;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="17-非严格递增连续数字序列"><a href="#17-非严格递增连续数字序列" class="headerlink" title="17.非严格递增连续数字序列"></a>17.非严格递增连续数字序列</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote>
<p>输入一个字符串仅包含大小写字母和数字<br>求字符串中包含的最长的非严格递增连续数字序列长度比如:<br>12234属于非严格递增数字序列</p>
</blockquote>
<h2 id="输入-16"><a href="#输入-16" class="headerlink" title="输入"></a>输入</h2><p>输入一个字符串仅包含大小写字母和数字</p>
<h2 id="输出-16"><a href="#输出-16" class="headerlink" title="输出"></a>输出</h2><p>输出字符串中包含的最长的非严格递增连续数字序列长度</p>
<h2 id="示例一-10"><a href="#示例一-10" class="headerlink" title="示例一"></a>示例一</h2><p>输入</p>
<blockquote>
<p>abc2234019A334bc</p>
</blockquote>
<p>输出</p>
<blockquote>
<p>4</p>
</blockquote>
<h2 id="个人代码-7"><a href="#个人代码-7" class="headerlink" title="个人代码"></a>个人代码</h2><p>当前值与前者比较</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//非严格递增长度 12234bs36912 长度5</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //一个个遍历咯，</span><br><span class="line">    /*</span><br><span class="line">    是数字，且每次比前值相等或大一点，就co+1</span><br><span class="line">    否则，将最长值len更新,co清零，重新计算</span><br><span class="line">    */</span><br><span class="line">    string t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    char pre=&#x27;0&#x27;;</span><br><span class="line">    int begin=0,co=0,len=0;</span><br><span class="line">     for(int i=0;i&lt;t.size();i++) //令pre存储第一个字符为数值</span><br><span class="line">    &#123;</span><br><span class="line">        if(t[i]&gt;=&#x27;0&#x27;&amp;&amp;t[i]&lt;=&#x27;9&#x27;)</span><br><span class="line">            &#123;</span><br><span class="line">                pre=t[i];</span><br><span class="line">                begin=i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(begin&lt;t.size()) co++; //如果存在这样一个pre</span><br><span class="line"></span><br><span class="line">    for(int i=begin+1;i&lt;t.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(t[i]&gt;=&#x27;0&#x27;&amp;&amp;t[i]&lt;=&#x27;9&#x27;)//如果是数字</span><br><span class="line">        &#123;</span><br><span class="line">            if(t[i]&gt;=pre)//如果是非严格递增</span><br><span class="line">            &#123;</span><br><span class="line">                pre=t[i];</span><br><span class="line">                co++;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                len=max(len,co);</span><br><span class="line">                co=1;//置为1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else//如果不是数字</span><br><span class="line">        &#123;</span><br><span class="line">            len=max(len,co);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="18-分积木"><a href="#18-分积木" class="headerlink" title="*18.分积木"></a>*18.分积木</h1><h2 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>Solo和koko是两兄弟，妈妈给了他们一大堆积木，每块积木上都有自己的重量。现在他们想要将这些积木分成两堆。哥哥Solo负责分配，弟弟koko要求两个人获得<br>的积木总重量“相等”（根据Koko的逻辑），</p>
<p>个数可以不同，不然就会哭，</p>
<p>但koko只会先将两个数转成二进制再进行加法，而且总会忘记进位（每个进位都忘记）。</p>
<p>如当25（11001）加11（1011）时，koko得到的计算结果是18（10010）：<br>11001<br>+01011</p>
</blockquote>
<h2 id="输入描述-15"><a href="#输入描述-15" class="headerlink" title="输入描述"></a>输入描述</h2><blockquote>
<p>3<br>3 5 6<br>第一行是一个整数N(2≤N≤100)，表示有多少块积木；</p>
<p>第二行为空格分开的N个整数Ci(1≤Ci≤10^6)，表示第i块积木的重量。</p>
</blockquote>
<h2 id="输出描述-15"><a href="#输出描述-15" class="headerlink" title="输出描述"></a>输出描述</h2><blockquote>
<p>11<br>让koko不哭，输出Solo所能获得积木的最大总重量；否则输出“NO”。</p>
</blockquote>
<h2 id="个人代码-8"><a href="#个人代码-8" class="headerlink" title="个人代码"></a>个人代码</h2><p>参考了<a target="_blank" rel="noopener" href="https://wiki.amoscloud.com/zh/ProgramingPractice/NowCoder/Adecco/Topic0107">题目0107-分积木 | AmosCloud Wiki</a></p>
<blockquote>
<p>其思想</p>
<p>1.如果该数组的值满足“可分配”条件，全部一起异或，最终值一定为0</p>
<p>2.关于最终结果为总和减去最小值</p>
<p>举个例子</p>
<p>3 5 6</p>
<p>最小值是3，同时减去3</p>
<p>0 2 3</p>
<p>全部异或，一定为0，暂时这样理解吧。不懂</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">/*</span><br><span class="line">两人获得积木总重量相等</span><br><span class="line"></span><br><span class="line">计算方式，任意i个积木重量之和等于另外k-i个二进制相加(直接异或)的十进制之和</span><br><span class="line">第一行为积木数</span><br><span class="line">第二行为各积木重量</span><br><span class="line">目的，分配重量相等</span><br><span class="line">*/</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // int a=25,b=11;</span><br><span class="line">    // cout&lt;&lt;(a^b);</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;int&gt; a(n);</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line">    // for(int s:a)</span><br><span class="line">    //     cout&lt;&lt;s&lt;&lt;&quot;,&quot;;</span><br><span class="line">    int solo=0,coco=0;</span><br><span class="line">    //这怎么搞呢，solo=coco，这些数怎么拼凑呢</span><br><span class="line">    //假如有5个数,保证两边个数可以不同，但和相同</span><br><span class="line">    //solo  i个数 cooc n-i个数</span><br><span class="line">    //暴力解法怎么做？</span><br><span class="line">    //？？？？？？？？？？？？？</span><br><span class="line">    </span><br><span class="line">    //看了wp，其思路为相同的值异或为0</span><br><span class="line">    /*</span><br><span class="line">    该思想是异或到底，得到值为0，则成功</span><br><span class="line">    减去最小数字即可</span><br><span class="line">    */</span><br><span class="line">    int num=a[0],sum=num,tmp=num;</span><br><span class="line">    for(int k=1;k&lt;n;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum+=a[k];</span><br><span class="line">        num=min(num,a[k]);</span><br><span class="line">        tmp^=a[k];</span><br><span class="line">    &#125;</span><br><span class="line">    if(tmp!=0) cout&lt;&lt;&quot;NO&quot;;</span><br><span class="line">    else cout&lt;&lt;sum-num;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="19-连续字母长度"><a href="#19-连续字母长度" class="headerlink" title="*19 连续字母长度"></a>*19 连续字母长度</h1><h2 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>给定一个字符串，只包含大写字母，求在包含同一字母的子串中，长度第 k 长的子串的长度，相同字母只取最长的那个子串。</p>
</blockquote>
<h2 id="输入描述-16"><a href="#输入描述-16" class="headerlink" title="输入描述"></a>输入描述</h2><blockquote>
<p>第一行有一个子串(1&lt;长度&lt;&#x3D;100)，只包含大写字母。<br>第二行为 k的值</p>
</blockquote>
<h2 id="输出描述-16"><a href="#输出描述-16" class="headerlink" title="输出描述"></a>输出描述</h2><blockquote>
<p>输出连续出现次数第k多的字母的次数。</p>
</blockquote>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>输入1</p>
<blockquote>
<p>AAAAHHHBBCDHHHH<br>3</p>
</blockquote>
<p>输出1</p>
<blockquote>
<p>2</p>
</blockquote>
<p>输入2</p>
<blockquote>
<p>AABAAA<br>2</p>
</blockquote>
<p>输出2</p>
<blockquote>
<p>1</p>
</blockquote>
<h2 id="个人代码-不完整"><a href="#个人代码-不完整" class="headerlink" title="个人代码(不完整)"></a>个人代码(不完整)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">/*</span><br><span class="line">给定一个字符串，只包含大写字母，</span><br><span class="line">求在包含同一字母的子串中，长度第 k 长的子串的长度，</span><br><span class="line">相同字母只取最长的那个子串。</span><br><span class="line"></span><br><span class="line">AAAAHHHBBCDHHHH</span><br><span class="line">3</span><br><span class="line">输出2</span><br><span class="line">说明：同一字母最长的子串中，A为4，H为4(H为3去掉)，B为2，C为1,D为1</span><br><span class="line"></span><br><span class="line">AABAAA</span><br><span class="line">2</span><br><span class="line">输出1</span><br><span class="line">说明：A取最长的为3,B为1</span><br><span class="line">*/</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct cmp</span><br><span class="line">&#123;</span><br><span class="line">    bool operator()(pair&lt;char,int&gt; &amp;a,pair&lt;char,int&gt; &amp;b)</span><br><span class="line">    &#123;</span><br><span class="line">        return a.second&gt;b.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    /*</span><br><span class="line">    初始思路：需要统计相同字母的子串最大长度，还要排序。</span><br><span class="line">    1.那就map键值对,记录还要排个序，难点在于排序</span><br><span class="line">    2.直接vector，最后排序一下，难点在于相同字母不同长度的取舍:</span><br><span class="line">    那还要再额外建立一个vector标记A,B,C咯？</span><br><span class="line"></span><br><span class="line">    试试第一个吧</span><br><span class="line">    */</span><br><span class="line">   string s;</span><br><span class="line">   cin&gt;&gt;s;</span><br><span class="line">   int n;</span><br><span class="line">   cin&gt;&gt;n;</span><br><span class="line">   map&lt;char,int&gt; mp;</span><br><span class="line">   mp[s[0]]=1;</span><br><span class="line">   char pre=s[0];</span><br><span class="line">   int co=1;//该值长度为1</span><br><span class="line">   for(int i=1;i&lt;s.size();i++)</span><br><span class="line">   &#123;</span><br><span class="line">       if(pre==s[i])</span><br><span class="line">       &#123;</span><br><span class="line">        co++;</span><br><span class="line">       &#125;</span><br><span class="line">       else//如果当前值与pre不等</span><br><span class="line">       &#123;</span><br><span class="line">            if(mp.count(pre)) //如果有这个字符，更新一下最大值</span><br><span class="line">            &#123;</span><br><span class="line">                if(mp[pre]&lt;co)</span><br><span class="line">                    mp[pre]=co;</span><br><span class="line">            &#125;</span><br><span class="line">            else//没有就添加这个字符</span><br><span class="line">            &#123;</span><br><span class="line">                //mp[pre]=1;</span><br><span class="line">                mp[s[i]]=1;</span><br><span class="line">            &#125;</span><br><span class="line">            pre=s[i]; //更新一下pre</span><br><span class="line">            co=1;//置为1</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   for(pair&lt;char,int&gt; list:mp)</span><br><span class="line">   &#123;</span><br><span class="line">    cout&lt;&lt;list.first&lt;&lt;&quot;,&quot;&lt;&lt;list.second&lt;&lt;endl;</span><br><span class="line">   &#125;</span><br><span class="line">    vector&lt; pair&lt;char,int&gt; &gt;mp2(mp.begin(),mp.end());</span><br><span class="line">   //没有考虑不同字母，相同长度的情况</span><br><span class="line">    sort(mp2.begin(),mp2.end(),cmp());</span><br><span class="line">    </span><br><span class="line">//    for(pair&lt;char,int&gt; list:mp2)</span><br><span class="line">//    cout&lt;&lt;list.first&lt;&lt;&quot;,&quot;&lt;&lt;list.second&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>aaaaabbbccd<br>3<br>a,5<br>c,2</p>
</blockquote>
<blockquote>
<p>abcccdd<br>2<br>a,1<br>c,3</p>
</blockquote>
<p>嘶，为什么会漏键值对呢。</p>
<p>近距离聚焦一波</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">for(int i=1;i&lt;s.size();i++)</span><br><span class="line"> &#123;</span><br><span class="line">     if(pre==s[i])</span><br><span class="line">     &#123;</span><br><span class="line">           co++;</span><br><span class="line">     &#125;</span><br><span class="line">     else//如果当前值与pre不等</span><br><span class="line">     &#123;</span><br><span class="line">          if(mp.count(pre)) //如果有这个字符，更新一下最大值</span><br><span class="line">          &#123;</span><br><span class="line">              if(mp[pre]&lt;co)</span><br><span class="line">                  mp[pre]=co;</span><br><span class="line">          &#125;</span><br><span class="line">          else//没有就添加这个字符</span><br><span class="line">          &#123;</span><br><span class="line">              //mp[pre]=1;</span><br><span class="line">              mp[s[i]]=1;</span><br><span class="line">          &#125;</span><br><span class="line">          pre=s[i]; //更新一下pre</span><br><span class="line">          co=1;//置为1</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>更新后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">for(int i=1;i&lt;s.size();i++)</span><br><span class="line">  &#123;</span><br><span class="line">      if(pre==s[i])</span><br><span class="line">      &#123;</span><br><span class="line">            co++;</span><br><span class="line">      &#125;</span><br><span class="line">      else//如果当前值与pre不等</span><br><span class="line">      &#123;</span><br><span class="line">           if(mp.count(pre)) //如果有这个字符，更新一下最大值</span><br><span class="line">           &#123;</span><br><span class="line">               if(mp[pre]&lt;co)</span><br><span class="line">                   mp[pre]=co;</span><br><span class="line">           &#125;</span><br><span class="line">          // else//没有就添加这个字符</span><br><span class="line">          // &#123;</span><br><span class="line">               //mp[pre]=1;</span><br><span class="line">               </span><br><span class="line">           mp[s[i]]=1; //并将未知值添加进来</span><br><span class="line">          // &#125;</span><br><span class="line">           pre=s[i]; //更新一下pre</span><br><span class="line">           co=1;//置为1</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>abcccdd<br>2<br>a,1<br>b,1<br>c,3<br>d,1</p>
</blockquote>
<p>怎么最后一个值没添上去嘞</p>
<p>当最后一个字符，是连续字符时，没有及时更新。</p>
<h2 id="个人代码-9"><a href="#个人代码-9" class="headerlink" title="个人代码"></a>个人代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">/*</span><br><span class="line">给定一个字符串，只包含大写字母，</span><br><span class="line">求在包含同一字母的子串中，长度第 k 长的子串的长度，</span><br><span class="line">相同字母只取最长的那个子串。</span><br><span class="line"></span><br><span class="line">AAAAHHHBBCDHHHH</span><br><span class="line">3</span><br><span class="line">输出2</span><br><span class="line">说明：同一字母最长的子串中，A为4，H为4(H为3去掉)，B为2，C为1,D为1</span><br><span class="line"></span><br><span class="line">AABAAA</span><br><span class="line">2</span><br><span class="line">输出1</span><br><span class="line">说明：A取最长的为3,B为1</span><br><span class="line">*/</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct cmp</span><br><span class="line">&#123;</span><br><span class="line">    bool operator()(pair&lt;char,int&gt; &amp;a,pair&lt;char,int&gt; &amp;b)</span><br><span class="line">    &#123;</span><br><span class="line">        return a.second&gt;b.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    /*</span><br><span class="line">    初始思路：需要统计相同字母的子串最大长度，还要排序。</span><br><span class="line">    1.那就map键值对,记录还要排个序，难点在于排序</span><br><span class="line">    2.直接vector，最后排序一下，难点在于相同字母不同长度的取舍:</span><br><span class="line">    那还要再额外建立一个vector标记A,B,C咯？</span><br><span class="line"></span><br><span class="line">    试试第一个吧</span><br><span class="line">    */</span><br><span class="line">   string s;</span><br><span class="line">   cin&gt;&gt;s;</span><br><span class="line">   int n;</span><br><span class="line">   cin&gt;&gt;n;</span><br><span class="line">   map&lt;char,int&gt; mp;</span><br><span class="line">   mp[s[0]]=1;</span><br><span class="line">   char pre=s[0];</span><br><span class="line">   int co=1;//该值长度为1</span><br><span class="line">   for(int i=1;i&lt;s.size();i++)</span><br><span class="line">   &#123;</span><br><span class="line">       if(pre==s[i])</span><br><span class="line">       &#123;</span><br><span class="line">             co++;</span><br><span class="line">       &#125;</span><br><span class="line">       else//如果当前值与pre不等</span><br><span class="line">       &#123;</span><br><span class="line"></span><br><span class="line">        //把前者更新</span><br><span class="line">            if(mp.count(pre)) //如果有这个字符，更新一下最大值</span><br><span class="line">            &#123;</span><br><span class="line">                if(mp[pre]&lt;co)</span><br><span class="line">                    mp[pre]=co;</span><br><span class="line">            &#125;</span><br><span class="line">           // else//没有就添加这个字符</span><br><span class="line">           // &#123;</span><br><span class="line">                //mp[pre]=1;</span><br><span class="line"></span><br><span class="line">        //并将当前字符添加进来</span><br><span class="line">            mp[s[i]]=1; //</span><br><span class="line">           // &#125;</span><br><span class="line">            pre=s[i]; //更新一下pre</span><br><span class="line">            co=1;//置为1</span><br><span class="line">       &#125;</span><br><span class="line">       //最后如果是连续值，更新</span><br><span class="line">       if(mp.count(pre)) //如果有这个字符，更新一下最大值</span><br><span class="line">            &#123;</span><br><span class="line">                if(mp[pre]&lt;co)</span><br><span class="line">                    mp[pre]=co;</span><br><span class="line">            &#125;</span><br><span class="line">   &#125;</span><br><span class="line">//    for(pair&lt;char,int&gt; list:mp)</span><br><span class="line">//    &#123;</span><br><span class="line">//     cout&lt;&lt;list.first&lt;&lt;&quot;,&quot;&lt;&lt;list.second&lt;&lt;endl;</span><br><span class="line">//    &#125;</span><br><span class="line">    vector&lt; pair&lt;char,int&gt; &gt;mp2(mp.begin(),mp.end());</span><br><span class="line">    </span><br><span class="line">   //不同字母，相同长度的情况是并列排序的</span><br><span class="line">    sort(mp2.begin(),mp2.end(),cmp()); //map默认按键排序，自定义按值排序</span><br><span class="line">    </span><br><span class="line">//    for(pair&lt;char,int&gt; list:mp2)</span><br><span class="line">//    cout&lt;&lt;list.first&lt;&lt;&quot;,&quot;&lt;&lt;list.second&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;mp2[n-1].second;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="标星知识点"><a href="#标星知识点" class="headerlink" title="标星知识点"></a>标星知识点</h2><p>map的键的唯一，(去重)</p>
<p>vector&lt; pair&lt;&gt; &gt;与map的关系</p>
<p>前值与当前值</p>
<h1 id="20-滑动窗口最大值"><a href="#20-滑动窗口最大值" class="headerlink" title="*20.滑动窗口最大值"></a>*20.滑动窗口最大值</h1><h2 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回 滑动窗口中的最大值 。</p>
</blockquote>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><blockquote>
<p>输入：nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3<br>输出：[3,3,5,5,6,7]<br>解释：<br>滑动窗口的位置                最大值</p>
<hr>
<p>[1  3  -1] -3  5  3  6  7       3<br>1 [3  -1  -3] 5  3  6  7       3<br>1  3 [-1  -3  5] 3  6  7       5<br>1  3  -1 [-3  5  3] 6  7       5<br>1  3  -1  -3 [5  3  6] 7       6<br>1  3  -1  -3  5 [3  6  7]      7</p>
</blockquote>
<h2 id="个人代码-10"><a href="#个人代码-10" class="headerlink" title="个人代码"></a>个人代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">给你一个整数数组 nums，</span><br><span class="line">有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。</span><br><span class="line">你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</span><br><span class="line">返回 滑动窗口中的最大值 。</span><br><span class="line">*/</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void bijiao(vector&lt;int&gt; a,int begin)</span><br><span class="line">&#123;</span><br><span class="line">    int maxn=a[begin];</span><br><span class="line">    for(int i=begin;i&lt;a.size();i++)</span><br><span class="line">        maxn=max(maxn,a[i]);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;maxn;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; nums;</span><br><span class="line">    //int num;</span><br><span class="line">    string s;</span><br><span class="line">    getline(cin,s);</span><br><span class="line">    stringstream ss(s);</span><br><span class="line">    string t;</span><br><span class="line">    while(getline(ss,t,&#x27;,&#x27;))</span><br><span class="line">    &#123;</span><br><span class="line">        nums.push_back(stoi(t));</span><br><span class="line">    &#125;</span><br><span class="line">    int k;</span><br><span class="line">    cin&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">   vector&lt;int&gt; a;</span><br><span class="line">    //窗口大小为k，每次处理完，右移</span><br><span class="line">    //那就是第一次添加k个数</span><br><span class="line">    //之后每添加一个数就进行比较，输出</span><br><span class="line">    int co=0;</span><br><span class="line">    for(int i=0;i&lt;nums.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a.push_back(nums[i]);</span><br><span class="line">        co++;</span><br><span class="line">        if(co==k) break;</span><br><span class="line">    &#125;</span><br><span class="line">//1,3,-1,-3,5,3,6,7</span><br><span class="line">    co=k;</span><br><span class="line">    bijiao(a,0);</span><br><span class="line">    int i=1;</span><br><span class="line">    while(co&lt;nums.size())</span><br><span class="line">    &#123;</span><br><span class="line">        a.push_back(nums[co]);</span><br><span class="line">        cout&lt;&lt;&quot; &quot;;</span><br><span class="line">        bijiao(a,i);</span><br><span class="line">        i++;</span><br><span class="line">        co++;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="力扣代码-有误"><a href="#力扣代码-有误" class="headerlink" title="力扣代码(有误)"></a>力扣代码(有误)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; b;</span><br><span class="line">    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">          vector&lt;int&gt; a;</span><br><span class="line"></span><br><span class="line">          //初始k个值</span><br><span class="line">          for(int i=0;i&lt;k;i++)</span><br><span class="line">            a.push_back(nums[i]);</span><br><span class="line"></span><br><span class="line">        //对值进行比较</span><br><span class="line">        bijiao(a,0);</span><br><span class="line">        int i=1,co=k;</span><br><span class="line">        while(co&lt;nums.size())</span><br><span class="line">        &#123;</span><br><span class="line">            a.push_back(nums[co]);</span><br><span class="line">            bijiao(a,i);</span><br><span class="line">            i++;</span><br><span class="line">            co++;</span><br><span class="line">        &#125;</span><br><span class="line">        return b;</span><br><span class="line">    &#125;</span><br><span class="line"> void bijiao(vector&lt;int&gt; a,int begin)</span><br><span class="line">    &#123;</span><br><span class="line">        int maxn=a[0]; //错误之处 =a[begin]即可</span><br><span class="line">        for(int i=begin;i&lt;a.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            maxn=max(maxn,a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        b.push_back(maxn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>嘶，按理说没毛病诶</p>
<p>针对[1,-1] 1</p>
<p>代码1是</p>
<blockquote>
<p>1 -1</p>
</blockquote>
<p>力扣是</p>
<blockquote>
<p>1,1</p>
</blockquote>
<p>针对[1,-2,0,4] 2</p>
<p>代码1是</p>
<blockquote>
<p>1 0 4</p>
</blockquote>
<p>力扣是</p>
<blockquote>
<p>1 1 4</p>
</blockquote>
<p>考虑是。。</p>
<p>哦，没事了，我在bijiao函数中的初始化不对，我<strong>标注</strong>了，不改了</p>
<p><strong>嗯，力扣，不出所料地超时了</strong></p>
<p>那就是双for的问题咯</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int i=1,co=k;</span><br><span class="line">while(co&lt;nums.size())</span><br><span class="line">        &#123;</span><br><span class="line">            a.push_back(nums[co]);</span><br><span class="line">            bijiao(a,i);</span><br><span class="line">            i++;</span><br><span class="line">            co++;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; nums;</span><br><span class="line">    int num;</span><br><span class="line">    while(cin&gt;&gt;num)</span><br><span class="line">    &#123;</span><br><span class="line">        nums.push_back(num);</span><br><span class="line">        if(cin.get()==&#x27;\n&#x27;) break;</span><br><span class="line">    &#125;</span><br><span class="line">    int k;</span><br><span class="line">    cin&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    deque&lt;int&gt; q;//双端队列</span><br><span class="line">   vector&lt;int&gt; a;</span><br><span class="line">//    for(int i=0;i&lt;k;i++) //确保引进k个值，且末尾是最大的</span><br><span class="line">//    &#123;</span><br><span class="line">//     while(!q.empty()&amp;&amp;q.back()&lt;nums[i])</span><br><span class="line">//     &#123;</span><br><span class="line">//         q.pop_back();</span><br><span class="line">//     &#125;</span><br><span class="line">//     q.push_back(nums[i]);</span><br><span class="line">//   //  a.push_back(q.front());</span><br><span class="line">//    &#125;</span><br><span class="line">  //双端队列，用来保存单点递减队列，保持队首为最大值，为了确保窗口值，存储索引</span><br><span class="line">   for(int i=0;i&lt;nums.size();i++)</span><br><span class="line">   &#123;</span><br><span class="line">      while(!q.empty()&amp;&amp;nums[q.back()]&lt;=nums[i])//如果不空且末尾值&lt;=当前值</span><br><span class="line">        q.pop_back();//清除该值</span><br><span class="line"></span><br><span class="line">        q.push_back(i);//添加新下标</span><br><span class="line"></span><br><span class="line">        if(q.front()&lt; i-k+1) //q里已经有k+1个元素，删除左边值</span><br><span class="line">            q.pop_front();</span><br><span class="line">        if(i+1&gt;=k) //窗口形成</span><br><span class="line">        a.push_back(nums[q.front()]);</span><br><span class="line">   &#125;</span><br><span class="line">    for(int list:a)</span><br><span class="line">    cout&lt;&lt;list&lt;&lt;&quot;,&quot;;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="标星知识点-1"><a href="#标星知识点-1" class="headerlink" title="标星知识点"></a>标星知识点</h2><p>超时</p>
<p>wp说是<strong>单调队列结构</strong>：为了可以同时弹出队首和队尾的元素，我们需要使用双端队列。满足这种单调性的双端队列一般称作「单调队列」。</p>
<p>删除比待加入的小的值，直到遇见更大的值</p>
<blockquote>
<p>1.为什么用双端队列</p>
</blockquote>
<p>数组5,3,4,1</p>
<p>第一次入队 5</p>
<p>第二次入队 5 3</p>
<p>第三次入队 5 4 <strong>出现在这里</strong>，一般队列是back入，front出（即队尾入，队头出）；这里需要从back出。</p>
<p>第四次入队 5 4 1</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/77981148">C++中queue和deque的区别 - 知乎 (zhihu.com)</a></p>
<blockquote>
<p>2.窗口值的维护</p>
</blockquote>
<p>用队列存储索引的好处就是，可以判断窗口值大小，进而移动窗口</p>
<p>如:5 3 4 1 k&#x3D;2</p>
<p>当入队了 5 3 判定当前值4</p>
<p>之后入队了是 5  4</p>
<p>因为4的索引为2，5的索引为0；i-k+1&#x3D;2-2+1，即3的下标为1</p>
<p>弹出5</p>
<p>哎，这样吧，<strong>虽然队列里的值可能不会满足k个值，但是通过加进来的值的下标，我们可以将队首下标与临界值i-k+1比较，小于就弹出</strong></p>
<blockquote>
<p>3.窗口值已定</p>
</blockquote>
<p>那就是当前下标值+1&gt;&#x3D;k</p>
<p>对于数组大小n，窗口m来说</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; n - m + 1; i++) &#123;//决定窗口起始位置</span><br><span class="line">          int sum = 0;</span><br><span class="line">          for (int j = i; j &lt; i + m; j++) &#123;//决定了获取m个值</span><br><span class="line">              sum += integers.get(j);</span><br><span class="line">          &#125;</span><br><span class="line">          if (sum &gt; res) res = sum;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>



<h2 id="59-队列最大值"><a href="#59-队列最大值" class="headerlink" title="59.队列最大值"></a>59.队列最大值</h2><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p>
<p>若队列为空，pop_front 和 max_value 需要返回 -1</p>
<h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><p>输入:<br>[“MaxQueue”,”push_back”,”push_back”,”max_value”,”pop_front”,”max_value”]<br>[[],[1],[2],[],[],[]]<br>输出: [null,null,null,2,1,2]<br>示例 2：</p>
<p>输入:<br>[“MaxQueue”,”pop_front”,”max_value”]<br>[[],[],[]]<br>输出: [null,-1,-1]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class MaxQueue &#123;</span><br><span class="line">    queue&lt;int&gt; que;</span><br><span class="line">    deque&lt;int&gt; deq;</span><br><span class="line">public:</span><br><span class="line">    MaxQueue() &#123; &#125;</span><br><span class="line">    int max_value() &#123;</span><br><span class="line">        return deq.empty() ? -1 : deq.front();</span><br><span class="line">    &#125;</span><br><span class="line">    void push_back(int value) &#123;</span><br><span class="line">        que.push(value);</span><br><span class="line">        while(!deq.empty() &amp;&amp; deq.back() &lt; value)</span><br><span class="line">            deq.pop_back();</span><br><span class="line">        deq.push_back(value);</span><br><span class="line">    &#125;</span><br><span class="line">    int pop_front() &#123;</span><br><span class="line">        if(que.empty()) return -1;</span><br><span class="line">        int val = que.front();</span><br><span class="line">        if(val == deq.front())</span><br><span class="line">            deq.pop_front();</span><br><span class="line">        que.pop();</span><br><span class="line">        return val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：jyd</span><br><span class="line">链接：https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/solution/jian-zhi-offer-59-ii-dui-lie-de-zui-da-z-0pap/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<p>什么意思，为什么要一个queue+一个deque呢？</p>
<blockquote>
<p>一个deque不就可以保持最大值吗。</p>
</blockquote>
<p>举例，</p>
<p>[“MaxQueue”,”push_back”,”push_back”,”max_value”,”pop_front”,”max_value”]<br>[[],[1],[2],[],[],[]]</p>
<p>如果只有deque，为了维持最大值</p>
<p>输入 1：队列情况 1</p>
<p>输入2：队列情况   2 (1被清除了)</p>
<p>此时最大值为2</p>
<p>那么又执行了pop_front，2被清楚了</p>
<p>队列没值了</p>
<p>那就会输出-1</p>
<p>所以需要一个普通队列按顺序进队，以防pop操作时，deque队列仅删掉一个最大值就出现空队列的情况</p>
<p>你看 queue : 1 2 pop操作后，还有2</p>
<p>​		deque : 输入1 2 那就只有2（因为该队列的作用是维持最大值在队首） pop后，队列空了</p>
<blockquote>
<p>而为什么一个queue不行，显而易见了</p>
</blockquote>
<p>一个普通队列无法保留单调的最值问题。</p>
<h1 id="21-素数之积"><a href="#21-素数之积" class="headerlink" title="21.素数之积"></a>21.素数之积</h1><p>RSA加密算法在网络安全世界中无处不在，它利用了极大整数因数分解的困难度，数据越大，安全系数越高。</p>
<p>给定一个32位正整数，请对其进行因数分解，找出是哪两个素数的乘积。</p>
<h2 id="输入描述-17"><a href="#输入描述-17" class="headerlink" title="输入描述"></a><strong>输入描述</strong></h2><p>一个正整数num</p>
<p>0 &lt; num &lt;&#x3D; 2147483647</p>
<h2 id="输出描述-17"><a href="#输出描述-17" class="headerlink" title="输出描述"></a><strong>输出描述</strong></h2><p>如果成功找到，以单个空格分割，从小到大输出两个素数，分解失败，请输出-1 -1。</p>
<h2 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1"></a><strong>示例1</strong></h2><p>输入输出示例仅供调试，后台判题数据一般不包含示例</p>
<p><strong>输入</strong></p>
<p><strong><code>15</code></strong></p>
<p><strong>输出</strong></p>
<p><strong><code>3 5</code></strong></p>
<h2 id="个人代码-11"><a href="#个人代码-11" class="headerlink" title="个人代码"></a>个人代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">给定一个32位正整数，</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">请对其进行因数分解，找出是哪两个素数的乘积。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果成功找到，以单个空格分割，</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">从小到大输出两个素数，分解失败，请输出-1 -1。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">issushu</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(num);i++)</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(num%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> num,tem=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> cin&gt;&gt;num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(num&lt;=<span class="number">1</span>) </span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;-1 -1&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(num);i++)</span><br><span class="line"></span><br><span class="line"> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">issushu</span>(i)&amp;&amp;num%i==<span class="number">0</span>) </span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">   tem=num/i;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">issushu</span>(tem))</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;tem;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;-1 -1&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="22-仿LISP运算"><a href="#22-仿LISP运算" class="headerlink" title="*22.仿LISP运算"></a>*22.仿LISP运算</h1><h2 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h2><p> LISP语言唯一的语法就是括号要配对。<br> 形如 (OP P1 P2 …)，括号内元素由单个空格分割。<br> 其中第一个元素OP为操作符，后续元素均为其参数，参数个数取决于操作符类型<br> 注意：参数 P1, P2 也有可能是另外一个嵌套的 (OP P1 P2 …)<br> 当前OP类型为add&#x2F;sub&#x2F;mul&#x2F;div(全小写)，分别代表整数的加减乘除法。简单起见，OP参数个数为2</p>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a><strong>举例</strong></h2><p>  输入：(mul 3 -7)输出：-21<br>  输入：(add 1 2) 输出：3<br>  输入：(sub (mul 2 4) (div 9 3)) 输出 ：5<br>  输入：(div 1 0) 输出：error<br><strong>输入描述</strong>：<br>  合法C字符串，字符串长度不超过512，用例保证了无语法错误<br><strong>输出描述</strong>：<br>  合法C字符串，字符包括’0’-‘9’及负号’-‘或者’error’</p>
<h2 id="个人代码（有误，暂略）"><a href="#个人代码（有误，暂略）" class="headerlink" title="个人代码（有误，暂略）"></a>个人代码（有误，暂略）</h2><p>双栈思想：操作码栈，参数栈。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;string&gt; op;</span><br><span class="line">stack&lt;int&gt; num;</span><br><span class="line">void jisuan(stack&lt;string&gt; &amp;op,stack&lt;int&gt; &amp;nums,int n1,int n2)</span><br><span class="line">&#123;</span><br><span class="line">    string s=op.top();</span><br><span class="line">   // cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    op.pop();//弹出</span><br><span class="line">    switch(s[0])&#123; //说是只支持int或char</span><br><span class="line">         case &#x27;a&#x27;:</span><br><span class="line">               // return n1+n2;</span><br><span class="line">               nums.push(n1+n2);</span><br><span class="line">                break;</span><br><span class="line">        case &#x27;m&#x27;:</span><br><span class="line">               // return n1*n2;</span><br><span class="line">                 nums.push(n1*n2);</span><br><span class="line">                break;</span><br><span class="line">        case &#x27;s&#x27;:</span><br><span class="line">               // return n1-n2;</span><br><span class="line">               nums.push(n1-n2);</span><br><span class="line">                break;</span><br><span class="line">        case &#x27;d&#x27;:</span><br><span class="line">               // return n1/n2;</span><br><span class="line">               if(n2==0) cout&lt;&lt;&quot;error&quot;;</span><br><span class="line">               else nums.push(n1/n2);</span><br><span class="line">                break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void solution(string s)</span><br><span class="line">&#123;</span><br><span class="line">    int index=0;//操作数下标</span><br><span class="line">    for(int i=0;i&lt;s.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        //(sub (mul 256 45) (div 91 30))</span><br><span class="line">        if(s[i]==&#x27;(&#x27;) //截取操作符</span><br><span class="line">        &#123;</span><br><span class="line">            op.push(s.substr(i+1,3));//</span><br><span class="line">           // cout&lt;&lt;s.substr(i+1,3)&lt;&lt;endl;</span><br><span class="line">             i=i+4;//符号位后第一个参数前的空格</span><br><span class="line">             index=i+1;//符号位后第一个参数的起始位置。可能是负数，可能是两位以上</span><br><span class="line">        &#125;</span><br><span class="line">        else if(s[i]==&#x27; &#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">           // index=i+1;//</span><br><span class="line">           if(index&lt;i)</span><br><span class="line">           &#123;</span><br><span class="line">                num.push(stoi(s.substr(index,i-index)));//起始位置与个数</span><br><span class="line">                //cout&lt;&lt;num.top();</span><br><span class="line">                 i++;</span><br><span class="line">                index=i+1;//第二个参数的起始位置</span><br><span class="line">           &#125;</span><br><span class="line">          </span><br><span class="line">         //  num.push_back(stoi(s[index]));//哦，如果是两位数，就不能这样写</span><br><span class="line">        &#125;</span><br><span class="line">        else if(s[i]==&#x27;)&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            if(index&lt;i) </span><br><span class="line">            &#123;</span><br><span class="line">                num.push(stoi(s.substr(index, i - index)));</span><br><span class="line">                i++;</span><br><span class="line">                index = i + 1; // 参数起始位置</span><br><span class="line">            &#125;</span><br><span class="line">            //括号闭合一次，就算一次</span><br><span class="line">            int n2=num.top();</span><br><span class="line">            num.pop();</span><br><span class="line">            int n1=num.top();</span><br><span class="line">            num.pop();</span><br><span class="line">            jisuan(op,num,n1,n2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    while(!op.empty())//操作符栈非空</span><br><span class="line">    &#123;</span><br><span class="line">            int n2=num.top();</span><br><span class="line">            num.pop();</span><br><span class="line">            int n1=num.top();</span><br><span class="line">            num.pop();</span><br><span class="line">            jisuan(op,num,n1,n2);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;num.top();</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    //vector&lt;char&gt; kuohao;</span><br><span class="line">    solution(s);</span><br><span class="line">   // cout&lt;&lt;num.top();</span><br><span class="line">   while(!op.empty())</span><br><span class="line">   &#123;</span><br><span class="line">    cout&lt;&lt;op.top()&lt;&lt;endl;</span><br><span class="line">    op.pop();</span><br><span class="line">   &#125;</span><br><span class="line">    while(!num.empty())</span><br><span class="line">   &#123;</span><br><span class="line">    cout&lt;&lt;num.top()&lt;&lt;endl;</span><br><span class="line">    num.pop();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>栈里的数值没有写进去？</p>
<h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; num_stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作符栈</span></span><br><span class="line">stack&lt;string&gt; opera_stack;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> param_1, <span class="type">int</span> param_2)</span> </span>&#123;</span><br><span class="line">    string op = opera_stack.<span class="built_in">top</span>();</span><br><span class="line">    opera_stack.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="string">&quot;add&quot;</span>) &#123;</span><br><span class="line">        num_stack.<span class="built_in">push</span>(param_1 + param_2);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;sub&quot;</span>) &#123;</span><br><span class="line">        num_stack.<span class="built_in">push</span>(param_1 - param_2);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;mul&quot;</span>) &#123;</span><br><span class="line">        num_stack.<span class="built_in">push</span>(param_1 * param_2);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (param_2 == <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;error&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> res = param_1 / param_2;</span><br><span class="line">            <span class="keyword">if</span> (param_1 % param_2 != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    res -= <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            num_stack.<span class="built_in">push</span>(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solution_01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理输入</span></span><br><span class="line">    string exp;</span><br><span class="line">    <span class="built_in">getline</span>(cin, exp);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mark = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> param_1 = <span class="number">0</span>; <span class="comment">// 参数1</span></span><br><span class="line">    <span class="type">int</span> param_2 = <span class="number">0</span>; <span class="comment">// 参数2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; exp.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">        string ch = exp.<span class="built_in">substr</span>(i, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&quot;(&quot;</span>) &#123;</span><br><span class="line">            opera_stack.<span class="built_in">push</span>(exp.<span class="built_in">substr</span>(i + <span class="number">1</span>, <span class="number">3</span>));</span><br><span class="line">            i += <span class="number">4</span>;</span><br><span class="line">            mark = i + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&quot;)&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mark &lt; i) &#123;</span><br><span class="line">                num_stack.<span class="built_in">push</span>(<span class="built_in">stoi</span>(exp.<span class="built_in">substr</span>(mark, i - mark)));</span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">                mark = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            param_2 = num_stack.<span class="built_in">top</span>();</span><br><span class="line">            num_stack.<span class="built_in">pop</span>();</span><br><span class="line">            param_1 = num_stack.<span class="built_in">top</span>();</span><br><span class="line">            num_stack.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">calc</span>(param_1, param_2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&quot; &quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mark &lt; i) &#123;</span><br><span class="line">                    num_stack.<span class="built_in">push</span>(<span class="built_in">stoi</span>(exp.<span class="built_in">substr</span>(mark, i - mark)));</span><br><span class="line">                    mark = i + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!opera_stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        param_2 = num_stack.<span class="built_in">top</span>();</span><br><span class="line">        num_stack.<span class="built_in">pop</span>();</span><br><span class="line">        param_1 = num_stack.<span class="built_in">top</span>();</span><br><span class="line">        num_stack.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">calc</span>(param_1, param_2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num_stack.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">solution_01</span>();</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="23-贪吃蛇"><a href="#23-贪吃蛇" class="headerlink" title="*23.贪吃蛇"></a>*23.贪吃蛇</h1><h2 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h2><p>贪吃蛇是一个经典游戏，蛇的身体由若干方格连接而成，身体随蛇头移动。蛇头触碰到食物时，蛇的长度会增加一格。蛇头和身体的任一方格或者游戏版图边界碰撞时，游戏结束。</p>
<p>下面让我们来完成贪吃蛇游戏的模拟：<br>给定一个N<em>M的数组ar，代表N</em>M个方格组成的版图，贪吃蛇每次移动一个方格。若ar[i][j]=&#x3D;’H’，表示该方可为贪吃蛇的起始位置;若ar[i][j]=&#x3D;’F’，表示该方格为食物，若ar[i][j]&#x3D;&#x3D;’E’，表示该方格为空格。<br>贪吃蛇初始长度为1，初始移动方向为向左。输入为给定一系列贪吃蛇的移动操作，返回操作后蛇的长度，如果在操作执行完之前已经游戏结束，返回游戏结束时贪吃蛇的长度。<br>贪吃蛇移动、吃食物和碰撞处理的细节见下面图示:</p>
<p><img src="/../../../Typora/img111/image-20230717184145792.png"></p>
<p>图 1:截取了贪吃蛇移动的一个中间状态，H表示蛇头，F表示食物，数字为蛇身体各节的 编号，蛇为向左移动，此时蛇头和食物已经相邻。</p>
<p>图 2:蛇头向左移动一格，蛇头和食物重叠，注意此时食物的格子成为了新的蛇头，第 1节 身体移动到蛇头位置，第 2节身体移动到第 1节身体位置，以此类推，最后添加第 4节升 起到原来第 3节身体的位置。</p>
<p>图 3:蛇头继续向左移动一格，身体的各节按上述规则移动，此时蛇头已经和边界相邻，但 还未碰撞。</p>
<p>图 4:蛇头继续向左移动一格，此时蛇头<strong>已经超过边界</strong>，发生碰撞，游戏结束。</p>
<p>图 5和图 6给出一个<strong>蛇头和身体碰撞</strong>的例子，蛇为向上移动。图 5时蛇头和第 7节身体相 邻，但还未碰撞;图 6蛇头向上移动一格，此时蛇头和第 8节身体都移动到了原来第 7节 身体的位置，发生碰撞，游戏结束。</p>
<h2 id="输入描述-18"><a href="#输入描述-18" class="headerlink" title="输入描述:"></a>输入描述:</h2><p>输入第 1行为空格分隔的字母，代表贪吃蛇的移动操作。字母取值为 U、D、L、R、G，其中U、D、L、R分别表示贪吃蛇往上、下、左、右转向，<strong>转向时贪吃蛇不移动</strong>，G表示<strong>贪吃蛇按当前的方向移动一格</strong>。用例保证输入的操作正确。</p>
<p>第 2行为空格分隔的两个数，指定为 N和 M，<strong>为数组的行和列数</strong>。余下 N行每行是空格分 隔的 M个字母。字母取值为 H、F和 E，<strong>H表示贪吃蛇的起始位置</strong>，<strong>F表示食物</strong>，<strong>E表示该 方格为空</strong>。用例保证有且<strong>只有一个 H，而 F和 E会有多个</strong>。</p>
<h2 id="输出描述-18"><a href="#输出描述-18" class="headerlink" title="输出描述:"></a>输出描述:</h2><p>输出一个数字为蛇的长度。<br>示 例:<br>输入<br>D G G<br>3 3<br>F F F<br>F F H<br>E F E<br>输出<br>1</p>
<p>说明：向下移动两格，第一步吃空，第二步越界，故长度为1。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><p>主要思路为：</p>
<blockquote>
<p>更新路线：</p>
<p>​		1.当遇到E时，即空格，删除尾巴，添加新头部 (维持长度不变)</p>
<p>​		2.当遇到F时，添加头部	(添加长度)</p>
<p>​		3.始终用头部进行“移动”判断E和F</p>
<p>返回所记录的有效坐标的个数，即为长度</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">int tanchishe(vector&lt;char&gt; s, vector&lt;vector&lt;char&gt;&gt; a, int n, int m)</span><br><span class="line">&#123;</span><br><span class="line">    // 找到起始位置</span><br><span class="line">    int x = 0, y = 0;</span><br><span class="line">    for (int i = 0; i &lt; n; i++)</span><br><span class="line">        for (int j = 0; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (a[i][j] == &#x27;H&#x27;)</span><br><span class="line">            &#123;</span><br><span class="line">                a[i][j] = &#x27;E&#x27;; // 头移动变空格</span><br><span class="line">                x = i;</span><br><span class="line">                y = j;</span><br><span class="line"></span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    pair&lt;int, int&gt; head = make_pair(x, y); // 头部</span><br><span class="line">    cout &lt;&lt; &quot;头部坐标:&quot; &lt;&lt; head.first &lt;&lt; &quot;,&quot; &lt;&lt; head.second &lt;&lt; endl;</span><br><span class="line">    //  vector&lt;pair&lt;int,int&gt; &gt; body&#123;head&#125;;//初始化</span><br><span class="line"></span><br><span class="line">    deque&lt;pair&lt;int, int&gt;&gt; body = &#123;head&#125;; // 为了头部插入</span><br><span class="line">    char direction = &#x27;L&#x27;;</span><br><span class="line">    for (auto dir : s)</span><br><span class="line">    &#123;</span><br><span class="line">        // pair&lt;int,int&gt; next; //1.不该在这个位置，第一次选择方向而不是G时，默认为0,0</span><br><span class="line">        if (dir == &#x27;U&#x27;)</span><br><span class="line">            direction = &#x27;U&#x27;;</span><br><span class="line">        if (dir == &#x27;D&#x27;)</span><br><span class="line">            direction = &#x27;D&#x27;;</span><br><span class="line">        if (dir == &#x27;L&#x27;)</span><br><span class="line">            direction = &#x27;L&#x27;;</span><br><span class="line">        if (dir == &#x27;R&#x27;)</span><br><span class="line">            direction = &#x27;R&#x27;;</span><br><span class="line">        if (dir == &#x27;G&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            pair&lt;int, int&gt; next;</span><br><span class="line">            switch (direction)</span><br><span class="line">            &#123;</span><br><span class="line">            case &#x27;U&#x27;: // 上移</span><br><span class="line">                // x--;</span><br><span class="line">                next = make_pair(body[0].first - 1, body[0].second);</span><br><span class="line">                break;</span><br><span class="line">            case &#x27;D&#x27;:</span><br><span class="line">                // x++;</span><br><span class="line">                next = make_pair(body[0].first + 1, body[0].second);</span><br><span class="line">                cout &lt;&lt; endl</span><br><span class="line">                     &lt;&lt; next.first &lt;&lt; &quot;,&quot; &lt;&lt; next.second &lt;&lt; endl;</span><br><span class="line">                cout &lt;&lt; endl</span><br><span class="line">                     &lt;&lt; body.front().first &lt;&lt; &quot;,&quot; &lt;&lt; body.front().second &lt;&lt; endl;</span><br><span class="line">                break;</span><br><span class="line">            case &#x27;L&#x27;:</span><br><span class="line">                // y--;</span><br><span class="line">                next = make_pair(body[0].first, body[0].second - 1);</span><br><span class="line">                break;</span><br><span class="line">            case &#x27;R&#x27;:</span><br><span class="line">                // y++;</span><br><span class="line">                next = make_pair(body[0].first, body[0].second + 1);</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">                if (x &lt; 0 || y &lt; 0 || x &gt; n - 1 || y &gt; m - 1)</span><br><span class="line">                    return body.size();</span><br><span class="line"></span><br><span class="line">                cout &lt;&lt; endl;</span><br><span class="line">                // 尾巴碰撞检查</span><br><span class="line">                for (auto c : body)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (c == next)</span><br><span class="line">                        return body.size();</span><br><span class="line">                &#125;</span><br><span class="line">                //  if(found) return body.size();</span><br><span class="line">                //   if(x==a[0]&amp;&amp;y==a[1]) return body.size();</span><br><span class="line">                // if()</span><br><span class="line">                if (a[next.first][next.second] == &#x27;E&#x27;) // 空格</span><br><span class="line">                &#123;</span><br><span class="line">                    // 更新身体，添加头部，去掉尾部</span><br><span class="line">                    // body.push_back(&#123;x,y&#125;);</span><br><span class="line">                    cout &lt;&lt; &quot;删除尾巴，添加头部:&quot; &lt;&lt; next.first &lt;&lt; &quot;,&quot; &lt;&lt; next.second &lt;&lt; endl;</span><br><span class="line">                    body.pop_back();</span><br><span class="line">                    body.push_front(next);</span><br><span class="line">                    // body.insert(next,body.begin(),body.end());错误用法</span><br><span class="line">                &#125;</span><br><span class="line">                else if (a[next.first][next.second] == &#x27;F&#x27;) // 吃了东西</span><br><span class="line">                &#123;</span><br><span class="line">                    // 1.有个问题</span><br><span class="line">                    // 一开始的时候，没有执行G，deque里没有值，默认为0,0，相当于判定了0,0</span><br><span class="line">                    // 如果真的是F</span><br><span class="line">                    cout &lt;&lt; &quot;吃了东西&quot; &lt;&lt; next.first &lt;&lt; &quot;,&quot; &lt;&lt; next.second &lt;&lt; endl;</span><br><span class="line">                    body.push_front(next);</span><br><span class="line">                    a[next.first][next.second] = &#x27;E&#x27;;</span><br><span class="line">                &#125;</span><br><span class="line">                cout &lt;&lt; &quot;body:&quot; &lt;&lt; endl;</span><br><span class="line">                for (auto c : body)</span><br><span class="line">                    cout &lt;&lt; &quot;(&quot; &lt;&lt; c.first &lt;&lt; &quot;,&quot; &lt;&lt; c.second &lt;&lt; &quot;) &quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return body.size();</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;char&gt; s;</span><br><span class="line">    char sw;</span><br><span class="line">    while (cin &gt;&gt; sw)</span><br><span class="line">    &#123;</span><br><span class="line">        s.push_back(sw);</span><br><span class="line">        if (cin.get() == &#x27;\n&#x27;)</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;char&gt;&gt; a(n, vector&lt;char&gt;(m)); // a[n][m];</span><br><span class="line">    for (int i = 0; i &lt; n; i++)</span><br><span class="line">        for (int j = 0; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; tanchishe(s, a, n, m);</span><br><span class="line">    //    pair&lt;int,int&gt; de=make_pair(1,3);</span><br><span class="line">    //    deque&lt;pair&lt;int,int&gt; &gt;s=&#123;de&#125;;</span><br><span class="line">    //    cout&lt;&lt;s[0].first+1&lt;&lt;&quot; &quot;&lt;&lt;s[0].second;</span><br><span class="line">    // for(int i=0;i&lt;n;i++)</span><br><span class="line">    // &#123;</span><br><span class="line">    //     for(int j=0;j&lt;m;j++)</span><br><span class="line">    // &#123;</span><br><span class="line">    //     cout&lt;&lt;a[i][j]&lt;&lt;&quot; &quot;;</span><br><span class="line">    // &#125;</span><br><span class="line">    // cout&lt;&lt;endl;</span><br><span class="line">    // &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="24-解密犯罪时间"><a href="#24-解密犯罪时间" class="headerlink" title="*24.解密犯罪时间"></a>*24.解密犯罪时间</h1><p>警察在侦破一个案件时，得到了线人给出的可能犯罪时间，形如 “HH:MM” 表示的时刻。<br>根据警察和线人的约定，为了隐蔽，该时间是修改过的，解密规则为：利用当前出现过的数字，构造下一个<strong>距离当前时间最近的时刻</strong>，则该时间为可能的犯罪时间<strong>。每个出现数字都可以被无限次使用</strong>。</p>
<h2 id="输入描述-19"><a href="#输入描述-19" class="headerlink" title="输入描述:"></a>输入描述:</h2><p>形如HH:SS的字符串，表示原始输入</p>
<h2 id="输出描述-19"><a href="#输出描述-19" class="headerlink" title="输出描述:"></a>输出描述:</h2><p>形如HH:SS的字符串，表示推理出来的犯罪时间</p>
<h2 id="示例1-2"><a href="#示例1-2" class="headerlink" title="示例1"></a>示例1</h2><p>输入</p>
<blockquote>
<p>18:52</p>
</blockquote>
<p>输出</p>
<blockquote>
<p>18:55</p>
</blockquote>
<p>说明</p>
<blockquote>
<p>利用数字1, 8, 5, 2构造出来的最近时刻是18:55，是3分钟之后。结果不是18:51因为这个时刻是18小时52分钟之后。</p>
</blockquote>
<h2 id="示例2-1"><a href="#示例2-1" class="headerlink" title="示例2"></a>示例2</h2><p>输入</p>
<blockquote>
<p>23:59</p>
</blockquote>
<p>输出</p>
<blockquote>
<p>22:22</p>
</blockquote>
<p>说明</p>
<blockquote>
<p>利用数字2, 3, 5, 9构造出来的最近时刻是22:22。 答案一定是第二天的某一时刻，所以选择可构造的最小时刻为犯罪时间。</p>
</blockquote>
<p>备注:</p>
<p>可以保证线人给定的字符串一定是合法的。例如，“01:35” 和 “11:08” 是合法的，“1:35” 和 “11:8” 是不合法的。<br>最近的时刻有可能在第二天</p>
<p><strong>目的</strong></p>
<blockquote>
<p>也就是说是，拆分组合后的，最大又最接近的时间。</p>
<p>线人肯定是给的提前的时间，所以要预估接下来的时间</p>
</blockquote>
<p>23:59，拆成[2,3,5,9]，任意组合，第二天最大又最接近的时间为22:22，23:55呢？</p>
<h2 id="个人代码-有误"><a href="#个人代码-有误" class="headerlink" title="个人代码(有误)"></a>个人代码(有误)</h2><pre><code>/*思路（错误思路，不符合用例）
正常情况下：组合遍历，结果为大于原时间中，最小的那个时间
特殊情况下：第二天的时间，小于又最接近原时间的时间
*/
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    map&lt;char,int&gt; mp;</span><br><span class="line">    for(int i=0;i&lt;s.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(s[i]!=&#x27;:&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!mp.count(s[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                mp[s[i]]=s[i]-&#x27;0&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //1124</span><br><span class="line">    map&lt;string,string&gt; hh,mm;</span><br><span class="line">    // map&lt;char,int&gt; mp;</span><br><span class="line">    // mp[&#x27;1&#x27;]=&#x27;1&#x27;-&#x27;0&#x27;;</span><br><span class="line">    // mp[&#x27;2&#x27;]=&#x27;2&#x27;-&#x27;0&#x27;;</span><br><span class="line">    // mp[&#x27;3&#x27;]=&#x27;3&#x27;-&#x27;0&#x27;;</span><br><span class="line">   </span><br><span class="line">   // 构造可能的HH</span><br><span class="line">    for(pair&lt;char,int&gt;list1:mp)</span><br><span class="line">    for(pair&lt;char,int&gt;list2:mp)</span><br><span class="line">    &#123;</span><br><span class="line">        string token=to_string(list1.second)+to_string(list2.second);</span><br><span class="line">        if(list1.second&lt;2)</span><br><span class="line">        &#123;</span><br><span class="line">         </span><br><span class="line">            if(!hh.count(hh[token]))</span><br><span class="line">            hh[token]=token;</span><br><span class="line">        &#125;</span><br><span class="line">        if(list1.second==2&amp;&amp;list2.second&lt;4)</span><br><span class="line">        &#123;</span><br><span class="line">           if(!hh.count(hh[token]))</span><br><span class="line">            hh[token]=token;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //构造可能的MM</span><br><span class="line">     for(pair&lt;char,int&gt;list1:mp)</span><br><span class="line">    for(pair&lt;char,int&gt;list2:mp)</span><br><span class="line">    &#123;</span><br><span class="line">        string token=to_string(list1.second)+to_string(list2.second);</span><br><span class="line">        if(list1.second&lt;7)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!mm.count(mm[token]))</span><br><span class="line">            mm[token]=token;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // for(pair&lt;string,string&gt; list:hh)</span><br><span class="line">    //     cout&lt;&lt;list.first&lt;&lt;&quot;,&quot;&lt;&lt;list.second&lt;&lt;&quot; &quot;&lt;&lt;endl;</span><br><span class="line">    //     cout&lt;&lt;&quot;分钟里&quot;;</span><br><span class="line">    // for(pair&lt;string,string&gt; list:mm)</span><br><span class="line">    //     cout&lt;&lt;list.first&lt;&lt;&quot;,&quot;&lt;&lt;list.second&lt;&lt;&quot; &quot;&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    //看分钟里是否大于</span><br><span class="line">  //  string s=&quot;11:23&quot;;</span><br><span class="line">    int fenzhong=stoi(s.substr(3,2));</span><br><span class="line">    int xiaoshi=stoi(s.substr(0,2));</span><br><span class="line">   // cout&lt;&lt;s.substr(3,2);</span><br><span class="line">    string h=&quot;&quot;,m=&quot;&quot;;</span><br><span class="line">    int flag=-1;</span><br><span class="line">    for(pair&lt;string,string&gt; list:mm)</span><br><span class="line">    &#123;</span><br><span class="line">        if(stoi(list.second)&gt;fenzhong)</span><br><span class="line">        &#123;</span><br><span class="line">            m=list.second;</span><br><span class="line">            flag=1;</span><br><span class="line">            cout&lt;&lt;s.substr(0,2)+&quot;:&quot;+m;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //看小时里是否大于</span><br><span class="line">        </span><br><span class="line">       for(pair&lt;string,string&gt; list:hh)</span><br><span class="line">            cout&lt;&lt;list.second&lt;&lt;endl;</span><br><span class="line">            </span><br><span class="line">    if(flag&lt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">           for(pair&lt;string,string&gt; list:hh)</span><br><span class="line">    &#123;</span><br><span class="line">        if(stoi(list.second)&gt;xiaoshi)</span><br><span class="line">        &#123;</span><br><span class="line">            h=list.second;</span><br><span class="line">            flag=1;</span><br><span class="line">            cout&lt;&lt;h+&quot;:&quot;+s.substr(3,2);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   //那就是第二天的时间，这个时间是比输入值小但又是最接近的时间</span><br><span class="line">   //倒序找吧</span><br><span class="line">   if(flag&lt;0)</span><br><span class="line">   &#123;</span><br><span class="line">        for(auto it=mm.rbegin();it!=mm.rend();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(stoi(it-&gt;second)&lt;fenzhong)</span><br><span class="line">        &#123;</span><br><span class="line">            m=it-&gt;second;</span><br><span class="line">            flag=1;</span><br><span class="line">            cout&lt;&lt;s.substr(0,2)+&quot;:&quot;+m;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(flag&lt;0)</span><br><span class="line">    &#123;</span><br><span class="line">       for(auto it=hh.rbegin();it!=hh.rend();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(stoi(it-&gt;second)&lt;xiaoshi)</span><br><span class="line">        &#123;</span><br><span class="line">            h=it-&gt;second;</span><br><span class="line">            flag=1;</span><br><span class="line">            cout&lt;&lt;h+&quot;:&quot;+s.substr(3,2);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">    // char s1=static_cast&lt;char&gt;(97);</span><br><span class="line">    // char s=1+&#x27;0&#x27;;</span><br><span class="line">    // cout&lt;&lt;s;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现的目标：</p>
<blockquote>
<p>先找分钟有没有满足的，即大于真实分钟</p>
<p>不通过</p>
<p>再找小时有没有满足的，即大于真实小时</p>
<p>也不通过</p>
<p>说明是第二天的了</p>
<p>找第二天最小的</p>
</blockquote>
<p>输入23:59 真实时间是22:22 ，而不是23:53</p>
<p>第二天就是要找最小的，而不是最接近的了。</p>
<p>而且是小时和分钟都找最小的嘞</p>
<p>看了其他用例才知道</p>
<p><strong>12:58得到15:11</strong> 这个时间确实比15:58接近。</p>
<p>而且，对于正常情况，小时和分钟要同时保证<strong>现在时间</strong>要 <strong>最接近</strong> <strong>真实时间</strong></p>
<p>不是单纯</p>
<p>那得计算了诶，想简单了。</p>
<p>h*60+m 保持差值最小吧</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><blockquote>
<p>&#x2F;<em>思路（<br>正常情况下：结果为大于当前时间中，最小的那个真实时间，是*<em>大于当前时间的</em></em><br>特殊情况下：第二天的时间，即最小的真实时间，是<strong>小于当前时间</strong>的</p>
<p>能不能理解为，正常情况下：小时大于当前，分钟小于当前</p>
<p>​						特殊情况下：都小哈？</p>
<p>*&#x2F;</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    int fenzhong=stoi(s.substr(3,2));</span><br><span class="line">    int xiaoshi=stoi(s.substr(0,2));</span><br><span class="line">   // cout&lt;&lt;s.substr(3,2);</span><br><span class="line">    string h=&quot;&quot;,m=&quot;&quot;;</span><br><span class="line">    int flag=-1;</span><br><span class="line">  </span><br><span class="line">    //看小时里是否大于</span><br><span class="line">        for(pair&lt;string,string&gt;list:hh)</span><br><span class="line">        &#123;</span><br><span class="line">            if(stoi(list.second)&gt;xiaoshi)</span><br><span class="line">            &#123;</span><br><span class="line">                flag=2;</span><br><span class="line">                h=list.second;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag==2)//如果有满足的小时，找满足的分钟</span><br><span class="line">        &#123;</span><br><span class="line">             for(pair&lt;string,string&gt;list:mm)</span><br><span class="line">        &#123;</span><br><span class="line">            if(stoi(list.second)&lt;fenzhong)</span><br><span class="line">            &#123;</span><br><span class="line">                flag=3;</span><br><span class="line">                m=list.second;</span><br><span class="line">                cout&lt;&lt;h+&quot;:&quot;+m;</span><br><span class="line">                return 0;//结束了</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        if(flag&lt;0)//不然就是第二天的了</span><br><span class="line">        &#123;</span><br><span class="line">             for(pair&lt;string,string&gt;list:hh)</span><br><span class="line">        &#123;</span><br><span class="line">            if(stoi(list.second)&lt;xiaoshi)</span><br><span class="line">            &#123;</span><br><span class="line">                //flag=2;</span><br><span class="line">                h=list.second;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">              for(pair&lt;string,string&gt;list:mm)</span><br><span class="line">        &#123;</span><br><span class="line">            if(stoi(list.second)&lt;fenzhong)</span><br><span class="line">            &#123;</span><br><span class="line">              //  flag=3;</span><br><span class="line">                m=list.second;</span><br><span class="line">                cout&lt;&lt;h+&quot;:&quot;+m;</span><br><span class="line">                return 0;//结束了</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>哦豁</p>
<blockquote>
<p>18:52<br>输出21:11  </p>
<p>正确应该是18:55</p>
</blockquote>
<p>那就是针对小时的筛选，要大于等于当前小时，</p>
<p>trueh*60+truem&gt;curh*60+curm</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">for(pair&lt;string,string&gt;list:hh)</span><br><span class="line">       &#123;</span><br><span class="line">           if(stoi(list.second)&gt;=xiaoshi)</span><br><span class="line">           &#123;</span><br><span class="line">               flag=2;</span><br><span class="line">               h=list.second;</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       if(flag==2)//如果有满足的小时，找满足的分钟</span><br><span class="line">       &#123;</span><br><span class="line">            for(pair&lt;string,string&gt;list:mm)</span><br><span class="line">       &#123;</span><br><span class="line">           if(stoi(h)*60+stoi(list.second)&gt;xiaoshi*60+fenzhong)</span><br><span class="line">           &#123;</span><br><span class="line">               m=list.second;</span><br><span class="line">               cout&lt;&lt;h+&quot;:&quot;+m;</span><br><span class="line">               return 0;//结束了</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>07:08 又没值了? 真实时间应该是08</p>
</blockquote>
<p>因为逻辑是大于等于当前小时，真实小时用的是07.。。</p>
<p>还是要研判一下，小时，什么时候取相同的，什么时候取大一点的，什么时候取第二天的</p>
<p>取决于什么嘞。</p>
<h2 id="个人代码（最终）"><a href="#个人代码（最终）" class="headerlink" title="个人代码（最终）"></a>个人代码（最终）</h2><blockquote>
<p>思想：</p>
<p>1.看在相同小时下，能否获得比当前分钟大的真实分钟</p>
<p>2.看在稍大的小时下，能否使得trueh*60+truem&gt;curh*60+curm</p>
<p>3.看在第二天的时间下，是否有真实小时小于当前小时，真实分钟小于当前分钟的时间</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    /*思路1，</span><br><span class="line">    正常情况下：组合遍历，结果为大于原时间中，最小的那个时间</span><br><span class="line">    特殊情况下：第二天的时间，最小于的时间</span><br><span class="line">    */</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    </span><br><span class="line">      if(s==&quot;00:00&quot;) </span><br><span class="line">    &#123;</span><br><span class="line">    cout&lt;&lt;&quot;00:00&quot;;</span><br><span class="line">    return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    map&lt;char,int&gt; mp;</span><br><span class="line">    for(int i=0;i&lt;s.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(s[i]!=&#x27;:&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!mp.count(s[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                mp[s[i]]=s[i]-&#x27;0&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    map&lt;string,string&gt; hh,mm;</span><br><span class="line"> </span><br><span class="line">   </span><br><span class="line">   // 构造可能的HH</span><br><span class="line">    for(pair&lt;char,int&gt;list1:mp)</span><br><span class="line">    for(pair&lt;char,int&gt;list2:mp)</span><br><span class="line">    &#123;</span><br><span class="line">        string token=to_string(list1.second)+to_string(list2.second);</span><br><span class="line">        if(list1.second&lt;2)</span><br><span class="line">        &#123;</span><br><span class="line">         </span><br><span class="line">            if(!hh.count(hh[token]))</span><br><span class="line">            hh[token]=token;</span><br><span class="line">        &#125;</span><br><span class="line">        if(list1.second==2&amp;&amp;list2.second&lt;4)</span><br><span class="line">        &#123;</span><br><span class="line">           if(!hh.count(hh[token]))</span><br><span class="line">            hh[token]=token;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //构造可能的MM</span><br><span class="line">     for(pair&lt;char,int&gt;list1:mp)</span><br><span class="line">    for(pair&lt;char,int&gt;list2:mp)</span><br><span class="line">    &#123;</span><br><span class="line">        string token=to_string(list1.second)+to_string(list2.second);</span><br><span class="line">        if(list1.second&lt;7)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!mm.count(mm[token]))</span><br><span class="line">            mm[token]=token;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int fenzhong=stoi(s.substr(3,2));</span><br><span class="line">    int xiaoshi=stoi(s.substr(0,2));</span><br><span class="line">   // cout&lt;&lt;s.substr(3,2);</span><br><span class="line">    string h=&quot;&quot;,m=&quot;&quot;;</span><br><span class="line">    int flag=-1;</span><br><span class="line"></span><br><span class="line">//       for(pair&lt;string,string&gt;list:hh)</span><br><span class="line">//         cout&lt;&lt;list.second&lt;&lt;&quot; &quot;;</span><br><span class="line"></span><br><span class="line">//    for(pair&lt;string,string&gt;list:mm)</span><br><span class="line">//         cout&lt;&lt;list.second&lt;&lt;&quot; &quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//先看仅凭分钟能否解决 (即真实小时相同时)</span><br><span class="line">  for(pair&lt;string,string&gt;list:mm)</span><br><span class="line">        &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                 if(stoi(list.second)&gt;fenzhong)</span><br><span class="line">            &#123;</span><br><span class="line">                m=list.second;</span><br><span class="line">                cout&lt;&lt;s.substr(0,2)+&quot;:&quot;+m;</span><br><span class="line">                return 0;//结束了</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    //看小时里是否大于</span><br><span class="line">        for(pair&lt;string,string&gt;list:hh)</span><br><span class="line">        &#123;</span><br><span class="line">            if(stoi(list.second)&gt;xiaoshi)</span><br><span class="line">            &#123;</span><br><span class="line">                flag=2;</span><br><span class="line">                h=list.second;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       // cout&lt;&lt;h;</span><br><span class="line">        int diertian=-1;</span><br><span class="line">        if(flag&lt;0)//没有满足的小时，那就是第二天的小时了，要小于</span><br><span class="line">        &#123;</span><br><span class="line">             for(pair&lt;string,string&gt;list:hh)</span><br><span class="line">        &#123;</span><br><span class="line">            if(stoi(list.second)&lt;xiaoshi)//取个小的</span><br><span class="line">            &#123;</span><br><span class="line">                flag=2;</span><br><span class="line">                diertian=1;</span><br><span class="line">                h=list.second;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(flag==2)//如果有满足的小时，找满足的分钟</span><br><span class="line">        &#123;</span><br><span class="line">             for(pair&lt;string,string&gt;list:mm)</span><br><span class="line">        &#123;</span><br><span class="line">            if(diertian&lt;0) //不用到第二天</span><br><span class="line">            &#123;</span><br><span class="line">                 if(stoi(h)*60+stoi(list.second)&gt;xiaoshi*60+fenzhong)</span><br><span class="line">            &#123;</span><br><span class="line">                m=list.second;</span><br><span class="line">                cout&lt;&lt;h+&quot;:&quot;+m;</span><br><span class="line">                return 0;//结束了</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else //第二天</span><br><span class="line">            &#123;</span><br><span class="line">                if(stoi(list.second)&lt;=fenzhong)</span><br><span class="line">                &#123;</span><br><span class="line">                     m=list.second;</span><br><span class="line">                    cout&lt;&lt;h+&quot;:&quot;+m;</span><br><span class="line">                    return 0;//结束了</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试样例：</p>
<p><em><strong>20:12得到20:20</strong></em></p>
<p><em><strong>23:59得到22:22</strong></em></p>
<p><em><strong>12:58得到15:11</strong></em></p>
<p><em><strong>18:52得到18:55</strong></em></p>
<p><em><strong>23:52得到23:53</strong></em></p>
<p><em><strong>09:17得到09:19</strong></em></p>
<p><strong>07:08得到08:00</strong></p>
<p>噢，这个00:00，那就单独列出来输出00:00吧</p>
<h1 id="25求满足条件的最长子串的长度"><a href="#25求满足条件的最长子串的长度" class="headerlink" title="25求满足条件的最长子串的长度"></a>25求满足条件的最长子串的长度</h1><p>给定一个字符串，只包含字母和数字，按要求找出字符串中的最长（连续）子串的长度，字符串本身是其最长的子串，子串要求：<br>1、 只包含1个字母(a<del>z, A</del>Z)，其余必须是数字；<br>2、 字母可以在子串中的任意位置；<br>如果找不到满足要求的子串，如全是字母或全是数字，则返回-1。<br>输入描述：字符串(只包含字母和数字)<br>输出描述：子串的长度</p>
<h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><h2 id="个人代码-12"><a href="#个人代码-12" class="headerlink" title="个人代码"></a>个人代码</h2><p>输入 abC124ACb </p>
<p>输出 4</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line"></span><br><span class="line">    int flag=0,len=0,zimu,shuzi;//flag,子串中是否已经有一个字母了</span><br><span class="line">    string token=&quot;&quot;;</span><br><span class="line">    for(int i=0;i&lt;s.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(s[i]&lt;&#x27;0&#x27;||s[i]&gt;&#x27;9&#x27;)//非数字</span><br><span class="line">        &#123;</span><br><span class="line">            zimu++;</span><br><span class="line">            if(flag==0)//子串没有字母的话</span><br><span class="line">            &#123;</span><br><span class="line">                token+=s[i];   //</span><br><span class="line">                flag=1;</span><br><span class="line">            &#125;</span><br><span class="line">            else//如果遇到新的字母了，将之前的len更新，重置</span><br><span class="line">            &#123;</span><br><span class="line">                len=max(len,int(token.size()));</span><br><span class="line">                token=&quot;&quot;;</span><br><span class="line">                flag=0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else </span><br><span class="line">        &#123;</span><br><span class="line">            shuzi++;</span><br><span class="line">            token+=s[i];</span><br><span class="line">             len=max(len,int(token.size()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //cout&lt;&lt;token;</span><br><span class="line">    //全是字母 or 全是数字则为-1</span><br><span class="line">    if(zimu==token.size()||shuzi==token.size()) cout&lt;&lt;-1;</span><br><span class="line">    else cout&lt;&lt;len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="26-机器人走迷宫"><a href="#26-机器人走迷宫" class="headerlink" title="*26.机器人走迷宫"></a>*26.机器人走迷宫</h1><p>1、房间由X*Y的方格组成，例如下图为6*4的大小。每一个方格以坐标(x，y)描述。<br>2、机器人固定从方格(0，0)出发，只能向东或者向北前进。出口固定为房间的最东角，如下图的方格(5，3)。用例保证机器人可以从入口走到出口。<br>3、房间有些方格是墙壁，如(4，1)，机器人不能经过那儿。<br>4、有些地方是一旦到达就无法走到出口的,如标记为B的方格,称之为陷阱方格。<br>5、有些地方是机器人无法到达的的，如标记为A的方格，称之为不可达方格，不可达方格不包括墙壁所在的位置。<br>6、如下示例图中，陷阱方格有2个,不可达方格有3个。<br>7、请为该机器人实现路径规划功能:给定房间大小、墙壁位置，请计算出陷阱方格与不可达方格分别有多少个。</p>
<p><img src="/../../../Typora/img111/image-20230718181515105.png" alt="image-20230718181515105"></p>
<h2 id="输入-17"><a href="#输入-17" class="headerlink" title="输入"></a>输入</h2><p>第一行为房间的x,y</p>
<p>第二行为房间墙壁个数n</p>
<p>N行墙壁的坐标</p>
<h2 id="输入描述-20"><a href="#输入描述-20" class="headerlink" title="输入描述"></a>输入描述</h2><ol>
<li>第一行为房间的<code>x</code>和<code>y</code>(<code>0 &lt; x,y &lt;= 1000</code>)</li>
<li>第二行为房间中墙壁的个数<code>N</code> (<code>0 &lt;= N &lt; X*Y</code>)</li>
<li>接着下面会有<code>N</code>行墙壁的坐标<br>同一行中如果有多个数据以一个空格隔开，用例保证所有的输入数据均合法，(结尾不带回车换行)</li>
</ol>
<h2 id="输出描述-20"><a href="#输出描述-20" class="headerlink" title="输出描述"></a>输出描述</h2><ol>
<li>陷阱方格与不可达方格数量，两个信息在一行中输出，以一个空格隔开。(结尾不带回车换行)</li>
</ol>
<h2 id="示例一-11"><a href="#示例一-11" class="headerlink" title="示例一"></a>示例一</h2><h3 id="输入-18"><a href="#输入-18" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6 4</span><br><span class="line">5</span><br><span class="line">0 2</span><br><span class="line">1 2</span><br><span class="line">2 2</span><br><span class="line">4 1</span><br><span class="line">5 1</span><br></pre></td></tr></table></figure>

<h3 id="输出-17"><a href="#输出-17" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 3</span><br></pre></td></tr></table></figure>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>1.定义类o，接收x,y坐标</p>
<p>2.先接收wall坐标，o.x&#x3D;wall[i][0],o.y&#x3D;wall[i][1]，并赋值给set&lt;o&gt; wallset</p>
<p>3.set&lt;o&gt; checks，接收所有可走的坐标</p>
<p>​	set&lt;o&gt; finish;接收到达终点坐标时的所<strong>经过的有效坐标</strong></p>
<p>​	通过递归函数实现值的输入findout(0,0,wallset,checks,finish)</p>
<p>4.不可达坐标数&#x3D;x*y-checks.size()-wallset.size();</p>
<p>5.陷阱数计算：</p>
<p>​	遍历finish</p>
<p>​	findout(finish.x,finish.y，wallset,checksT,finishT)</p>
<p>​	如果在以finish.x和finish.y以起点的有效坐标中没找到可以到达终点的有效坐标，trap++</p>
<p>​	(if(!count(finishT.begin(),finishT.end(),终点坐标)))</p>
<p>​	</p>
<h1 id="27-高效的任务规划"><a href="#27-高效的任务规划" class="headerlink" title="**27.高效的任务规划"></a>**27.高效的任务规划</h1><p>你有 n 台机器编号为 1~n，每台都需要完成完成一项工作，机器经过配置后都能完成独立完成一项工作。假设第 i 台机器你需要花 B 分钟进行设置，然后开始运行，J 分钟后完成任务。现在，你需要选择布置工作的顺序，使得用最短的时间完成所有工作。注意，不能同时对两台进行配置，但配置完成的机器们可以同时执行他们各自的工作。</p>
<h2 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h2><p>第一行输入代表总共有 M 组任务数据（1 &lt; M &lt;&#x3D; 10）。<br>每组数据第一行为一个整数指定机器的数量 N（0 &lt; N &lt;&#x3D; 1000）。随后的 N 行每行两个整数，第一个表示B（0 &lt;&#x3D; B &lt;&#x3D; 10000），第二个表示 J（0 &lt;&#x3D; J &lt;&#x3D; 10000）。</p>
<p>每组数据连续输入，不会用空行分隔。各组任务单独计时。</p>
<h2 id="输出描述："><a href="#输出描述：" class="headerlink" title="输出描述："></a>输出描述：</h2><p>对于每组任务，输出最短完成时间，且每组的结果独占一行。例如，两组任务就应该有两行输出。</p>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入<br>1<br>1<br>2 2<br>输出<br>4</p>
<h2 id="示例2-2"><a href="#示例2-2" class="headerlink" title="示例2"></a>示例2</h2><p>输入</p>
<p>2</p>
<p>2</p>
<p>1 1</p>
<p>2 2</p>
<p>3 </p>
<p>1 1</p>
<p>2 2</p>
<p>3 3</p>
<p>输出</p>
<p>4</p>
<p>7</p>
<p>没读懂最短完成时间怎么来的</p>
<p>先配置工作时间最多的机器</p>
<p>当配置3，工作3的时候</p>
<p>可以顺便配置2，配置1</p>
<p>这时候只用了6分钟</p>
<p>那么在工作2和1并发的时候，只需要1分钟</p>
<p>总共7分钟</p>
<p><strong>贪心思想</strong>：经典问题就是，找零钱和活动选择(尽可能最优)</p>
<h2 id="参考wp-结果有误"><a href="#参考wp-结果有误" class="headerlink" title="参考wp(结果有误)"></a>参考wp(结果有误)</h2><p>这种输入输出方法值得借鉴，用类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">struct task&#123;</span><br><span class="line">    int tpei=0;</span><br><span class="line">    int tzuo=0;</span><br><span class="line">    task()&#123;&#125;</span><br><span class="line">    task(int x,int y):tpei(x),tzuo(y)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution&#123;</span><br><span class="line">    public:</span><br><span class="line">    int taskfinishi(vector&lt;task&gt; &amp;machine)&#123;</span><br><span class="line">        sort(machine.begin(),machine.end(),[](task &amp;a,task &amp;b)&#123;return a.tzuo&gt;b.tzuo;&#125;);</span><br><span class="line">      int last=0;</span><br><span class="line">     int N=machine.size();</span><br><span class="line">     vector&lt;int&gt; dp(N);</span><br><span class="line">      for(int i=0;i&lt;N;i++)//贪心</span><br><span class="line">      &#123;</span><br><span class="line">        dp[i]=last+machine[i].tpei+machine[i].tzuo;</span><br><span class="line">        last+=machine[i].tpei;</span><br><span class="line">      &#125;</span><br><span class="line">    int ans=0;</span><br><span class="line">    for(int i=0;i&lt;N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=max(ans,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int m,n;</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;m;//m组任务</span><br><span class="line">  //  vector&lt;int&gt; s(n);</span><br><span class="line">    //先执行工作时间最长的</span><br><span class="line">    // for(int j=0;j&lt;m;j++)</span><br><span class="line">    // &#123;</span><br><span class="line">    //     cin&gt;&gt;n;//第j组任务所需要机器数</span><br><span class="line">    // vector&lt;int&gt; a[n];//n行2列</span><br><span class="line">    //     for(int i=0;i&lt;n;i++)</span><br><span class="line">    // &#123;</span><br><span class="line">    //     int b1,b2;</span><br><span class="line">    //     cin&gt;&gt;b1&gt;&gt;b2;</span><br><span class="line">    //     a[i].push_back(b1);</span><br><span class="line">    //     a[i].push_back(b2);</span><br><span class="line">    // &#125;</span><br><span class="line"></span><br><span class="line">    // &#125;</span><br><span class="line">    Solution a;</span><br><span class="line">    while(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        int n;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        vector&lt;task&gt; machine(n);</span><br><span class="line">        for(int i=0;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;machine[i].tpei&gt;&gt;machine[i].tzuo;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;a.taskfinishi(machine)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来自<a target="_blank" rel="noopener" href="https://blog.csdn.net/zhizhengguan">OceanStar的学习笔记</a></p>
<p>&#x2F;&#x2F; [](task &amp;a,task &amp;b){return a.tzuo&gt;b.tzuo;})  λ表达式</p>
<h2 id="个人代码-13"><a href="#个人代码-13" class="headerlink" title="个人代码"></a>个人代码</h2><p>参考<a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/EC2mv8/">高效任务规划</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a,vector&lt;<span class="type">int</span>&gt; &amp;b)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if(a[1]&gt;b[1]) return true;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// else return false;</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// if(a[1]&gt;b[1]) return a&gt;b;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// else return a&lt;b;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> a[<span class="number">1</span>]&gt;b[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> m,n;</span><br><span class="line"></span><br><span class="line">  cin&gt;&gt;m;<span class="comment">//m组任务</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//vector&lt;int&gt; s(n);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先执行工作时间最长的</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">   cin&gt;&gt;n;<span class="comment">//第j组任务所需要机器数</span></span><br><span class="line"></span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;<span class="built_in">a</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>));<span class="comment">//n行2列</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> b1,b2;</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;b1&gt;&gt;b2;</span><br><span class="line"></span><br><span class="line">   a[i][<span class="number">0</span>]=b1;</span><br><span class="line"></span><br><span class="line">   a[i][<span class="number">1</span>]=b2;</span><br><span class="line"></span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),cmp);<span class="comment">//先排序，工作时间长的在前</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> time[<span class="number">1001</span>]=&#123;&#125;,last=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)  <span class="comment">//再贪心计算</span></span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    time[i]=last+a[i][<span class="number">0</span>]+a[i][<span class="number">1</span>]; </span><br><span class="line"></span><br><span class="line">	last+=a[i][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(res&lt;time[i]) res=time[i];</span><br><span class="line"></span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h1 id="28-二叉树中序遍历"><a href="#28-二叉树中序遍历" class="headerlink" title="28.二叉树中序遍历"></a>28.二叉树中序遍历</h1><p><strong>应该要正则的，感觉</strong></p>
<h2 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h2><p>根据给定的二叉树结构描述字符串，输出该二叉树按照中序遍历结果字符串。中序遍历顺序为:左子树，根结点，右子树。</p>
<h2 id="输入描述-21"><a href="#输入描述-21" class="headerlink" title="输入描述"></a>输入描述</h2><p>由大小写字母、左右大括号、逗号组成的字符串:<br>1、字母代表一个节点值，<strong>左右括号内包含该节点的子节点</strong>。<br>2、左右子节点使用逗号分隔，<strong>逗号前为空则表示左子节点为空</strong>,<strong>没有逗号则表示右子节点</strong><br><strong>为空</strong>。<br>3、二叉树节点数最大不超过100。<br>注:输入字符串格式是正确的，无需考虑格式错误的情况。</p>
<h2 id="输出描述-21"><a href="#输出描述-21" class="headerlink" title="输出描述"></a>输出描述</h2><p>输出一个字符串，为二叉树中序遍历各节点值的拼接结果。</p>
<h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><p>输入：a{b{d, e{g,h{,I}}},c{f}｝<br>输出：dbgehiafc</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">Treenode *build(Treenode *&amp; node,string s)</span><br><span class="line">&#123;</span><br><span class="line">    int index=0;</span><br><span class="line">   // Treenode *root;//主节点</span><br><span class="line">    // Treenode *temp;//临时结点</span><br><span class="line">    // queue&lt;Treenode* &gt;stk;//保存根节点</span><br><span class="line">    </span><br><span class="line">    // node=new Treenode(s[0]);//根节点</span><br><span class="line">    // temp=node;//指向该结点</span><br><span class="line">    // stk.push(temp);//存储该结点指针</span><br><span class="line">    node=new Treenode(s[0]);</span><br><span class="line">    index++;</span><br><span class="line">    queue&lt;Treenode *&gt; q;</span><br><span class="line">    q.push(node);</span><br><span class="line">    while(index&lt;s.size())</span><br><span class="line">    &#123;</span><br><span class="line">        Treenode *cur=q.front();</span><br><span class="line">        cout&lt;&lt;cur-&gt;val&lt;&lt;endl;</span><br><span class="line">        q.pop();</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">        ////a&#123;b&#123;d,e&#123;g,h&#123;,I&#125;&#125;&#125;,c&#123;f&#125;&#125;</span><br><span class="line">     </span><br><span class="line">            if(s[index]==&#x27;&#123;&#x27;)//</span><br><span class="line">        &#123;</span><br><span class="line">            index++;//略过&#123;</span><br><span class="line">            if(s[index]!=&#x27;,&#x27;)//&#123;b</span><br><span class="line">            &#123;</span><br><span class="line">            cur-&gt;left=new Treenode(s[index]);</span><br><span class="line">            q.push(cur-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            else //&#123;,i</span><br><span class="line">            &#123;</span><br><span class="line">            index++;//略过,</span><br><span class="line">            cur-&gt;right=new Treenode(s[index]);</span><br><span class="line">            q.push(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">           index++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(index&lt;s.size()&amp;&amp;s[index]==&#x27;,&#x27;)//,e or ,i  or ,c</span><br><span class="line">        &#123;</span><br><span class="line">            index++;//略过,</span><br><span class="line">            cur-&gt;right=new Treenode(s[index]);</span><br><span class="line">            q.push(cur-&gt;right);</span><br><span class="line">            index++;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        if(s[index]==&#x27;&#125;&#x27;)//&#125;</span><br><span class="line">        &#123;</span><br><span class="line">          index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//a&#123;b&#123;d, e&#123;g,h&#123;,I&#125;&#125;&#125;,c&#123;f&#125;&#125;</span><br><span class="line">  </span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void show(Treenode *node)</span><br><span class="line">&#123;</span><br><span class="line">    if(node==nullptr) return;</span><br><span class="line">    </span><br><span class="line">   cout&lt;&lt;node-&gt;val&lt;&lt;&quot; &quot;;</span><br><span class="line">    show(node-&gt;left);</span><br><span class="line">    show(node-&gt;right);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    Treenode *root;</span><br><span class="line">    root=build(root,s);</span><br><span class="line">    show(root);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我也是之后才意识到错误，构建树，塔喵的一个空指针都没有。</p>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="关于树的构造"><a href="#关于树的构造" class="headerlink" title="关于树的构造"></a>关于树的构造</h3><p>整棵树的构造&#x3D;根节点+构造左子树+构造右子树</p>
<p><strong>每一个结点都是其子树的根节点</strong></p>
<h4 id="654最大二叉树"><a href="#654最大二叉树" class="headerlink" title="654最大二叉树"></a>654最大二叉树</h4><p>给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:</p>
<p>创建一个根节点，其值为 nums 中的最大值。<br>递归地在最大值 左边 的 子数组前缀上 构建左子树。<br>递归地在最大值 右边 的 子数组后缀上 构建右子树。<br>返回 nums 构建的 最大二叉树 。</p>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,1,6,0,5]</span><br><span class="line">输出：[6,3,5,null,2,0,null,null,1]</span><br></pre></td></tr></table></figure>

<p>主要是确定根节点的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">      return build(nums,0,nums.size()-1);</span><br><span class="line">  &#125;</span><br><span class="line">  TreeNode * build(vector&lt;int&gt; nums,int lo,int hi)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">      if(lo&gt;hi) return nullptr; //递归终止条件</span><br><span class="line">      int maxn=-1,index=0;</span><br><span class="line">      for(int i=lo;i&lt;=hi;i++)//找最大值</span><br><span class="line">      &#123;</span><br><span class="line">          if(maxn&lt;nums[i])</span><br><span class="line">          &#123;</span><br><span class="line">              maxn=nums[i];</span><br><span class="line">              index=i;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  /*结构体定义了 TreeNode(int val):val(val),left(nullptr),right(nullptr)&#123;&#125;*/</span><br><span class="line">      TreeNode*root=new TreeNode(maxn);</span><br><span class="line"></span><br><span class="line">      root-&gt;left=build(nums,lo,index-1);</span><br><span class="line">      root-&gt;right=build(nums,index+1,hi);</span><br><span class="line"></span><br><span class="line">      return root;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="105-前序中序遍历结果构造二叉树"><a href="#105-前序中序遍历结果构造二叉树" class="headerlink" title="105 前序中序遍历结果构造二叉树"></a>105 前序中序遍历结果构造二叉树</h4><p>数据结构的手算方法都了解过，</p>
<p>第一次遍历</p>
<p>通过前序确定根节点，(根左右)</p>
<p>然后去中序找根节点，(左根右)，通过该节点分左右子树，</p>
<p>在左右子树中再找根节点</p>
<p>问题是，之后的前序遍历，怎么确定根节点</p>
<p>那就是中序遍历结果，找到根节点之后捏，左边这一块区域的长度，即为leftsize</p>
<p><img src="/../../../Typora/img111/image-20230719163004591.png" alt="图来自labuladong"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;</span><br><span class="line">    return build(preorder,0,preorder.size()-1,inorder,0,inorder.size()-1);</span><br><span class="line">&#125;</span><br><span class="line">TreeNode * build(vector&lt;int&gt; preorder,int lo1,int hi1,vector&lt;int&gt; inorder,int lo2,int hi2)</span><br><span class="line">&#123;</span><br><span class="line">        if(lo1&gt;hi1) return nullptr;</span><br><span class="line"></span><br><span class="line">        int rootval=preorder[lo1];</span><br><span class="line">        //lo1++;</span><br><span class="line">        int index=0,leftsize=0;</span><br><span class="line">        for(int i=lo2;i&lt;=hi2;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(rootval==inorder[i])</span><br><span class="line">            &#123;</span><br><span class="line">                index=i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line">        leftsize=index-lo2;</span><br><span class="line"></span><br><span class="line">        TreeNode *root=new TreeNode(rootval);</span><br><span class="line"></span><br><span class="line">        root-&gt;left=build(preorder,lo1+1,lo1+leftsize,inorder,lo2,index-1);</span><br><span class="line">         root-&gt;right=build(preorder,lo1+leftsize+1,hi1,inorder,index+1,hi2);</span><br><span class="line">        return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果无重复元素，可以map记录索引值，避免了for循环</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">map&lt;int,int&gt; mp;</span><br><span class="line">   TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;</span><br><span class="line">            for(int i=0;i&lt;inorder.size();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                mp[inorder[i]]=i;//值与索引映射</span><br><span class="line">            &#125;</span><br><span class="line">       return build(preorder,0,preorder.size()-1,inorder,0,inorder.size()-1);</span><br><span class="line">   &#125;</span><br><span class="line">   TreeNode * build(vector&lt;int&gt; preorder,int lo1,int hi1,vector&lt;int&gt; inorder,int lo2,int hi2)</span><br><span class="line">   &#123;</span><br><span class="line">           if(lo1&gt;hi1) return nullptr;</span><br><span class="line">      </span><br><span class="line">           int rootval=preorder[lo1];</span><br><span class="line">           //lo1++;</span><br><span class="line">           int index=mp[rootval];</span><br><span class="line">           int leftsize=index-lo2;</span><br><span class="line">		...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="106中序后续确认二叉树"><a href="#106中序后续确认二叉树" class="headerlink" title="106中序后续确认二叉树"></a>106中序后续确认二叉树</h4><p><img src="/../../../Typora/img111/image-20230719170651578.png" alt="image-20230719170651578"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">map&lt;int,int&gt; mp;</span><br><span class="line">   TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;</span><br><span class="line">       for(int i=0;i&lt;inorder.size();i++)</span><br><span class="line">       &#123;</span><br><span class="line">           mp[inorder[i]]=i;</span><br><span class="line">       &#125;</span><br><span class="line">       return build(inorder,0,inorder.size()-1,postorder,0,postorder.size()-1);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   TreeNode * build(vector&lt;int&gt;inorder,int lo1,int hi1,vector&lt;int&gt;postorder,int lo2,int hi2)</span><br><span class="line">   &#123;</span><br><span class="line">       if(lo1&gt;hi1) return nullptr;</span><br><span class="line"></span><br><span class="line">       int rootval=postorder[hi2];</span><br><span class="line">       int index=mp[rootval];</span><br><span class="line"></span><br><span class="line">       int leftsize=index-lo1;//中序的根节点位置</span><br><span class="line">       TreeNode* root=new TreeNode(rootval);</span><br><span class="line"></span><br><span class="line">       root-&gt;left=build(inorder,lo1,index-1,postorder,lo2,lo2+leftsize-1);</span><br><span class="line">       //后序的左子树区间lo2到lo2+leftsize-1;</span><br><span class="line">       root-&gt;right=build(inorder,index+1,hi1,postorder,lo2+leftsize,hi2-1);</span><br><span class="line">	 //后序的右子树区间lo2+leftsize到hi2-1;</span><br><span class="line">       return root;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h1 id="29-书本叠放"><a href="#29-书本叠放" class="headerlink" title="29.书本叠放"></a>29.书本叠放</h1><h2 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h2><p>书籍的长宽都是整数对应(<code>l</code>, <code>w</code>)<br>如果书A的长宽度都比<code>B</code>长宽大时，<br>则允许将B排列放在<code>A</code>上面，<br>现在有一组规格的书籍，<br>书籍叠放时要求,书籍不能做旋转，<br>请计算最多能有多少个规格书籍能叠放在一起。</p>
<h2 id="输入描述-22"><a href="#输入描述-22" class="headerlink" title="输入描述"></a>输入描述</h2><ul>
<li>输入:<code>books=[[20,16],[15,11],[10,10],[9,10]]</code></li>
<li>说明:总共有<code>4</code>本书，第一本长度为<code>20</code> 宽度为<code>16</code><br>第一本长度为<code>15</code> 宽度为<code>11</code><br>以此类推<br>最后一本书长度为<code>9</code> 宽度为<code>10</code></li>
</ul>
<h2 id="输出描述-22"><a href="#输出描述-22" class="headerlink" title="输出描述"></a>输出描述</h2><ul>
<li>输出:<code>3</code></li>
<li>说明: 最多三个规格的书籍可以叠放在一起 ，<br>从下到上依次是<code>[20,16],[15,11],[10,10]</code></li>
</ul>
<h2 id="示例一-12"><a href="#示例一-12" class="headerlink" title="示例一"></a>示例一</h2><h3 id="输入-19"><a href="#输入-19" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[20,16],[15,11],[10,10],[9,10]]</span><br></pre></td></tr></table></figure>

<p>Copy</p>
<h3 id="输出-18"><a href="#输出-18" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>主要是存储和比较，</p>
<p>存储嘛：要么用结构体，要么二维数组</p>
<p>比较方面：没有什么比得过sort函数了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">bool cmp(vector&lt;int&gt; &amp;a,vector&lt;int&gt; &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    return a[0]&gt;=b[0]&amp;&amp;a[1]&gt;=b[1];</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //若A书的长与宽大于B书，则将B书放置A上，即长宽越小越在高处</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt;a(4,vector&lt;int&gt;(2));</span><br><span class="line">    a[3][0]=20,a[3][1]=16;</span><br><span class="line">    a[1][0]=15,a[1][1]=11;</span><br><span class="line">    a[2][0]=10,a[2][1]=10; </span><br><span class="line">    a[0][0]=9,a[0][1]=10;</span><br><span class="line"></span><br><span class="line">    sort(a.begin(),a.end(),cmp);//越大越靠前</span><br><span class="line">    int maxlon=99999,maxwid=99999,num=0;</span><br><span class="line">    for(auto c:a)</span><br><span class="line">    &#123;</span><br><span class="line">        if(c[0]&lt;maxlon&amp;&amp;c[1]&lt;maxwid)</span><br><span class="line">            &#123;</span><br><span class="line">                maxlon=c[0];</span><br><span class="line">                maxwid=c[1];</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        cout&lt;&lt;c[0]&lt;&lt;&quot;,&quot;&lt;&lt;c[1]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;num;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正则用法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">string s=&quot;[[20,16],[15,11],[10,10],[9,10]]&quot;;</span><br><span class="line">  string s1=s.substr(1,s.size()-2);//[20,16],[15,11],[10,10],[9,10]</span><br><span class="line">  regex regex(&quot;\\[([^,]+),([^\\]]+)\\]&quot;);</span><br><span class="line"></span><br><span class="line">  sregex_iterator iter(s1.begin(),s1.end(),regex);</span><br><span class="line">  sregex_iterator end;</span><br><span class="line">  while(iter!=end)</span><br><span class="line">  &#123;</span><br><span class="line">      smatch match = *iter;</span><br><span class="line">      cout&lt;&lt;match[1]&lt;&lt;&quot;,&quot;&lt;&lt;match[2]&lt;&lt;endl;</span><br><span class="line">      iter++;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>\\[</code>：<code>\\</code>用于转义字符，<code>[</code>是正则表达式的特殊字符，所以使用<code>\\[</code>表示匹配一个左括号<code>[</code>。</li>
<li><code>([^,]+)</code>：这是一个捕获组，<code>()</code>用于创建捕获组。<code>[^,]+</code>表示匹配一个或多个非逗号字符。换句话说，它匹配括号内的第一个逗号之前的所有字符，并将匹配结果保存在捕获组1中。</li>
<li><code>,</code>：匹配一个逗号字符。</li>
<li><code>([^\\]]+)</code>：这也是一个捕获组，<code>[^\\]]+</code>表示匹配一个或多个非右括号字符。换句话说，它匹配括号内的第一个逗号之后到右括号之前的所有字符，并将匹配结果保存在捕获组2中。</li>
<li><code>\\]</code>：匹配一个右括号<code>]</code>。</li>
</ol>
<h2 id="个人代码-14"><a href="#个人代码-14" class="headerlink" title="个人代码"></a>个人代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">struct book&#123;</span><br><span class="line">    int len;</span><br><span class="line">    int wid;</span><br><span class="line">   // book()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">bool cmp(book &amp;a,book &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    return a.len&gt;=b.len&amp;&amp;a.wid&gt;=b.wid;</span><br><span class="line">&#125;</span><br><span class="line">int solution(vector&lt;book&gt; a)</span><br><span class="line">&#123;</span><br><span class="line">    int count=0,maxlen=9999999,maxwid=99999999;</span><br><span class="line">    for(book bk:a)</span><br><span class="line">    &#123;</span><br><span class="line">        if (maxlen&gt;bk.len&amp;&amp;maxwid&gt;bk.wid)//讲究一个“都”字</span><br><span class="line">        &#123;//10,10 与 9,10</span><br><span class="line">           </span><br><span class="line">            maxlen=bk.len;</span><br><span class="line">            maxwid=bk.wid;</span><br><span class="line">             count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //若A书的长与宽大于B书，则将B书放置A上，即长宽越小越在高处</span><br><span class="line"></span><br><span class="line">    string s=&quot;[[20,16],[15,11],[9,10],[10,10]]&quot;;</span><br><span class="line">    string s1=s.substr(1,s.size()-2);//[20,16],[15,11],[9,10],[10,10]</span><br><span class="line">    </span><br><span class="line">    stringstream ss(s1);</span><br><span class="line">    vector&lt;string&gt; list;</span><br><span class="line">    string token;</span><br><span class="line">    while(getline(ss,token,&#x27;,&#x27;))</span><br><span class="line">    &#123;</span><br><span class="line">        list.push_back(token);</span><br><span class="line">       // cout&lt;&lt;token&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    int n=list.size()/2; //4</span><br><span class="line">   // vector&lt;vector&lt;int&gt; &gt;a(n,vector&lt;int&gt;(2));</span><br><span class="line">   vector&lt;book&gt; bk(n);</span><br><span class="line">    for(int i=0;i&lt;list.size();i+=2)</span><br><span class="line">    &#123;</span><br><span class="line">        bk[i/2].len=stoi(list[i].substr(1));</span><br><span class="line">        bk[i/2].wid=stoi(list[i+1].substr(0,list[i+1].size()-1));</span><br><span class="line">    &#125;</span><br><span class="line">    // for(int i=0;i&lt;n;i++)</span><br><span class="line">    // cout&lt;&lt;bk[i].len&lt;&lt;&quot;,&quot;&lt;&lt;bk[i].wid&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    //排序后</span><br><span class="line">    sort(bk.begin(),bk.end(),cmp);</span><br><span class="line">    cout&lt;&lt;solution(bk);</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    //   for(int i=0;i&lt;n;i++)</span><br><span class="line">    // cout&lt;&lt;bk[i].len&lt;&lt;&quot;,&quot;&lt;&lt;bk[i].wid&lt;&lt;endl;</span><br><span class="line">   // cout&lt;&lt;s1;</span><br><span class="line">    // sort(a.begin(),a.end(),cmp);//越大越靠前</span><br><span class="line">    // int maxlon=99999,maxwid=99999,num=0;</span><br><span class="line">    // for(auto c:a)</span><br><span class="line">    // &#123;</span><br><span class="line">    //     if(c[0]&lt;maxlon&amp;&amp;c[1]&lt;maxwid)</span><br><span class="line">    //         &#123;</span><br><span class="line">    //             maxlon=c[0];</span><br><span class="line">    //             maxwid=c[1];</span><br><span class="line">    //             num++;</span><br><span class="line">    //         &#125;</span><br><span class="line">    //     cout&lt;&lt;c[0]&lt;&lt;&quot;,&quot;&lt;&lt;c[1]&lt;&lt;endl;</span><br><span class="line">    // &#125;</span><br><span class="line">    // cout&lt;&lt;num;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="30-区间交集"><a href="#30-区间交集" class="headerlink" title="***30.区间交集"></a>***30.区间交集</h1><p>给定一组闭区间，其中部分区间存在交集。任意两个给定区间的交集，称为公共区间(如:[1,2],[2,3]的公共区间为[2,2]，[3,5],[3,6]的公共区间为[3,5])。公共区间之间 若存在交集，则需要合并(如:[1,3],[3,5]区间存在交集[3,3]，需合并为[1,5])。按升序排列 输出合并后的区间列表。</p>
<h2 id="输入描述-23"><a href="#输入描述-23" class="headerlink" title="输入描述"></a>输入描述</h2><p> 一组区间列表，区间数为 N: 0&lt;&#x3D;N&lt;&#x3D;1000;区间元素为 X: -10000&lt;&#x3D;X&lt;&#x3D;10000。</p>
<h2 id="输出描述-23"><a href="#输出描述-23" class="headerlink" title="输出描述"></a>输出描述</h2><p> 升序排列的合并区间列表<br>备注:<br>1、区间元素均为数字，不考虑字母、符号等异常输入。<br>2、单个区间认定为无公共区间。</p>
<h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h2><p>输入<br>[[0, 3], [1, 3], [3, 5], [3, 6]]<br>输出<br>[[1, 5]]</p>
<h2 id="个人代码-15"><a href="#个人代码-15" class="headerlink" title="个人代码"></a>个人代码</h2><p>先找交集，能合并就合并，并输出最终交集</p>
<p>1.存储：用结构体</p>
<p>2.找交集：先按左端点排序，越小越前；</p>
<p>如何定义有交集，例如区间a,b；</p>
<p>若a的右端点大于等于b的左端点：说明a的左半边与b有重叠部分</p>
<p>若a的左端点小于等于b的右端点：说明a的右半边与b有重叠部分</p>
<p>两者一结合，满足重叠部分</p>
<p>3.交集合并，直接a,b两两比较，</p>
<p>如果a的右端点大于等于b的左端点</p>
<p>这个时候，右端点取决于这两个的最值&#x2F;&#x2F;（哎，昏了）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">struct qujian</span><br><span class="line">&#123;</span><br><span class="line">    int left;</span><br><span class="line">    int right;</span><br><span class="line"></span><br><span class="line">    bool operator&lt;(const qujian &amp;other) const&#123;</span><br><span class="line">        return left&lt;other.left||(left==other.left&amp;&amp;right&lt;other.right); //对于set，需要自定义弱排序</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">bool cmp(qujian &amp;a,qujian &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    return a.left&lt;b.left; //按开头排序</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;qujian&gt; jiaoji(vector&lt;qujian&gt; q,int n)//取交集</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   // vector&lt;qujian&gt; s;</span><br><span class="line">    set&lt;qujian&gt; quchong;     //2.交集的重复性</span><br><span class="line">    //int index=0;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    for(int j=i+1;j&lt;n;j++)</span><br><span class="line">    &#123;</span><br><span class="line">       //if(q[i].left&lt;=q[j].left&amp;&amp;q[i].right&lt;=q[j].right) //</span><br><span class="line">       if(q[i].right&gt;=q[j].left&amp;&amp;q[i].left&lt;=q[j].right)//1.这才是包含在另一个区间的状况</span><br><span class="line">        &#123;</span><br><span class="line">            qujian qu;</span><br><span class="line">            qu.left=max(q[i].left,q[j].left);</span><br><span class="line">            qu.right=min(q[i].right,q[j].right);</span><br><span class="line">           // index++;</span><br><span class="line">           quchong.insert(qu);</span><br><span class="line">         //  s.push_back(qu);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;qujian&gt; s(quchong.begin(),quchong.end());</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;qujian&gt; merge(vector&lt;qujian&gt; s)</span><br><span class="line">&#123;</span><br><span class="line">    qujian cur=s[0];</span><br><span class="line">    vector&lt;qujian&gt; wo;</span><br><span class="line">    for(int i=1;i&lt;s.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(cur.right&gt;=s[i].left)//至少说明从i的left到cur的right这部分有重叠</span><br><span class="line">        &#123;</span><br><span class="line">            cur.right=max(cur.right,s[i].right);</span><br><span class="line">        &#125;</span><br><span class="line">        else </span><br><span class="line">        &#123;</span><br><span class="line">            wo.push_back(cur);</span><br><span class="line">            cur=s[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    wo.push_back(cur);//最后的区间</span><br><span class="line">    return wo;</span><br><span class="line">&#125;</span><br><span class="line"> //合并公共区间</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s=&quot;[[0, 3], [1, 3], [3, 5], [3, 6]]&quot;;</span><br><span class="line">    string s1=s.substr(1,s.size()-2);</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    vector&lt;string&gt; n;</span><br><span class="line">    stringstream ss(s1);</span><br><span class="line">    string token;</span><br><span class="line">    while(getline(ss,token,&#x27;,&#x27;))</span><br><span class="line">    &#123;</span><br><span class="line">        if(token[0]==&#x27; &#x27;)</span><br><span class="line">        token=token.substr(1); //去掉前面的空格</span><br><span class="line">        n.push_back(token);</span><br><span class="line">      //  cout&lt;&lt;token&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    int len=n.size()/2;</span><br><span class="line"></span><br><span class="line">    vector&lt;qujian&gt; a(len);</span><br><span class="line">    //存进值</span><br><span class="line">    for(int i=0;i&lt;n.size();i+=2)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        a[i/2].left=stoi(n[i].substr(1));</span><br><span class="line">        a[i/2].right=stoi(n[i+1].substr(0,n[i+1].size()-1));</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a.begin(),a.end(),cmp);</span><br><span class="line"></span><br><span class="line">   vector&lt;qujian&gt; we=merge(jiaoji(a,len));</span><br><span class="line"></span><br><span class="line">   for(auto c:we)</span><br><span class="line">   cout&lt;&lt;c.left&lt;&lt;&quot;,&quot;&lt;&lt;c.right&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    //cout&lt;&lt;we.size();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"> // cout&lt;&lt;stoi(&quot; 123 &quot;);//有空格是可以stoi转化的</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;&quot;[&quot;;</span><br><span class="line">    string hebing=&quot;&quot;;</span><br><span class="line">   for(auto c:we)</span><br><span class="line">   hebing+=&quot;[&quot;+to_string(c.left)+&quot;, &quot;+to_string(c.right)+&quot;],&quot;;</span><br><span class="line">    hebing=hebing.substr(0,hebing.size()-1)+&quot;]&quot;;</span><br><span class="line">    cout&lt;&lt;hebing;</span><br><span class="line">    </span><br><span class="line">    输入 string s=&quot;[[0, 3], [1, 3], [3, 5], [3, 6], [6, 7]]&quot;;</span><br><span class="line">    输出 [[1, 5],[6, 6]]</span><br></pre></td></tr></table></figure>



<h2 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool operator&lt;(const qujian &amp;other) const&#123;</span><br><span class="line">     return left&lt;other.left||(left==other.left&amp;&amp;right&lt;other.right); //对于set，需要自定义弱排序</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>有||的结果</p>
<blockquote>
<p>1,3<br>3,3<br>3,5</p>
</blockquote>
<p>没有||的结果</p>
<blockquote>
<p>1,3<br>3,3</p>
</blockquote>
<p>为什么要用这个弱排序，set为了保证键唯一，而qujian又是个自定义类型，需要自定义比较函数</p>
<p>operator&lt;表示重定义小于，而const嘞，弱排序的硬性要求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">qujian qu;</span><br><span class="line">       qu.left=max(q[i].left,q[j].left);</span><br><span class="line">       qu.right=min(q[i].right,q[j].right);</span><br><span class="line">      // index++;</span><br><span class="line">      quchong.insert(qu);</span><br><span class="line">    //  s.push_back(qu);</span><br></pre></td></tr></table></figure>

<p>这一块的妙用</p>
<p>[a,b]与[c,d]</p>
<p>判断重叠区间</p>
<p>a&gt;&#x3D;c&amp;&amp;b&lt;&#x3D;d</p>
<p>a&lt;&#x3D;d&amp;&amp;b&gt;&#x3D;c</p>
<h3 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56.合并区间"></a>56.合并区间</h3><p>这道题只是合并，排好序后，更新右端为最大值即可</p>
<p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p>
<p><strong>示例 1：</strong></p>
<p>输入：intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]<br>输出：[[1,6],[8,10],[15,18]]<br>解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].<br><strong>示例 2：</strong></p>
<p>输入：intervals &#x3D; [[1,4],[4,5]]<br>输出：[[1,5]]<br>解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        </span><br><span class="line">        sort(intervals.begin(),intervals.end());</span><br><span class="line">         vector&lt;vector&lt;int&gt; &gt; result;</span><br><span class="line">        vector&lt;int&gt; cur=intervals[0];</span><br><span class="line"></span><br><span class="line">        for(int i=1;i&lt;intervals.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(cur[1]&gt;=intervals[i][0])</span><br><span class="line">            &#123;</span><br><span class="line">                cur[1]=max(cur[1],intervals[i][1]);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                result.push_back(cur);</span><br><span class="line">                cur=intervals[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result.push_back(cur);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>官方思想</strong></p>
<blockquote>
<p>1.按区间的左端点从小到大排序</p>
<p>2.对于交集的合并，左端点是相交区间最小的，右端点是相交区间最大的</p>
</blockquote>
<h3 id="986-区间的交集"><a href="#986-区间的交集" class="headerlink" title="986 区间的交集"></a>986 区间的交集</h3><p>给定两个由一些 闭区间 组成的列表，firstList 和 secondList ，其中 firstList[i] &#x3D; [starti, endi] 而 secondList[j] &#x3D; [startj, endj] 。每个区间列表都是成对 不相交 的，并且 已经排序 。</p>
<p>返回这 两个区间列表的交集 。</p>
<p>形式上，闭区间 [a, b]（其中 a &lt;&#x3D; b）表示实数 x 的集合，而 a &lt;&#x3D; x &lt;&#x3D; b 。</p>
<p>两个闭区间的 交集 是一组实数，要么为空集，要么为闭区间。例如，[1, 3] 和 [2, 4] 的交集为 [2, 3] 。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/interval-list-intersections">https://leetcode.cn/problems/interval-list-intersections</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：firstList = [[0,2],[5,10],[13,23],[24,25]], secondList = [[1,5],[8,12],[15,24],[25,26]]</span><br><span class="line">输出：[[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：firstList = [[1,3],[5,9]], secondList = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：firstList = [[1,7]], secondList = [[3,10]]</span><br><span class="line">输出：[[3,7]]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    vector&lt;vector&lt;int&gt;&gt; intervalIntersection(vector&lt;vector&lt;int&gt;&gt;&amp; firstList, vector&lt;vector&lt;int&gt;&gt;&amp; secondList) &#123;</span><br><span class="line">        //各自区间列表成对不相交，且排好序</span><br><span class="line">    </span><br><span class="line">        int i=0,j=0;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt;s;</span><br><span class="line">        while(i&lt;firstList.size()&amp;&amp;j&lt;secondList.size())</span><br><span class="line">        &#123;</span><br><span class="line">            if(firstList[i][0]&lt;=secondList[j][1]&amp;&amp;firstList[i][1]&gt;=secondList[j][0])//公共区间满足公式</span><br><span class="line">            &#123;</span><br><span class="line">                vector&lt;int&gt; a(2);</span><br><span class="line">                a[0]=max(firstList[i][0],secondList[j][0]);</span><br><span class="line">                a[1]=min(firstList[i][1],secondList[j][1]);</span><br><span class="line">				//i++;</span><br><span class="line">				//j++; //不是同时++，是[1,5]与[5,10]还有公共点</span><br><span class="line">                s.push_back(a);</span><br><span class="line">            &#125;</span><br><span class="line">            if(firstList[i][1]&gt;secondList[j][1]) j++;//如果f列表的i元素右端点比s列表的j元素的右端点大，说明j元素太窄了</span><br><span class="line">            else i++;</span><br><span class="line">        &#125;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>双for也能通过，只不过耗时点</p>
<p>关键在于理解重叠区间的逻辑。两个区间中有重叠区间，即左端点最大，右端点最小</p>
<h3 id="1288-删除被覆盖区间"><a href="#1288-删除被覆盖区间" class="headerlink" title="1288 删除被覆盖区间"></a>1288 删除被覆盖区间</h3><p>给你一个区间列表，请你删除列表中被其他区间所覆盖的区间。</p>
<p>只有当 c &lt;&#x3D; a 且 b &lt;&#x3D; d 时，我们才认为区间 [a,b) 被区间 [c,d) 覆盖。</p>
<p>在完成所有删除操作后，请你返回列表中剩余区间的数目。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-covered-intervals">https://leetcode.cn/problems/remove-covered-intervals</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,4],[3,6],[2,8]]</span><br><span class="line">输出：2</span><br><span class="line">解释：区间 [3,6] 被区间 [2,8] 覆盖，所以它被删除了。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> int removeCoveredIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        sort(intervals.begin(),intervals.end(),[](vector&lt;int&gt; &amp;a,vector&lt;int&gt; &amp;b)&#123;</span><br><span class="line">            if(a[0]==b[0]) return a[1]&gt;b[1];</span><br><span class="line">            return a[0]&lt;b[0];</span><br><span class="line">        &#125;);//lamda表达式，从小到大排序</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; s=intervals[0];</span><br><span class="line">        int co=0;</span><br><span class="line">        for(int i=1;i&lt;intervals.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            //重叠部分</span><br><span class="line">            if(s[1]&gt;=intervals[i][1]&amp;&amp;s[0]&lt;=intervals[i][0])</span><br><span class="line">            &#123;</span><br><span class="line">            //intervals[i]包含于s</span><br><span class="line">                co++;</span><br><span class="line">            &#125;</span><br><span class="line">            //有相交区间 [a,b]与[c,d] 即b&gt;=c</span><br><span class="line">            if(s[1]&gt;=intervals[i][0])</span><br><span class="line">            &#123;</span><br><span class="line">                s[1]=max(s[1],intervals[i][1]);//更新</span><br><span class="line">            &#125;</span><br><span class="line">            //不相交部分，则更新</span><br><span class="line">            if(s[1]&lt;intervals[i][0])</span><br><span class="line">            &#123;</span><br><span class="line">                s[0]=intervals[i][0];</span><br><span class="line">                s[1]=intervals[i][1];</span><br><span class="line">            &#125;</span><br><span class="line">                 </span><br><span class="line">        &#125;</span><br><span class="line">        return intervals.size()-co;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="31-分月饼"><a href="#31-分月饼" class="headerlink" title="***31.分月饼"></a>***31.分月饼</h1><h2 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h2><p>中秋节，公司分月饼，m个员工，买了n个月饼，m&lt;&#x3D;n，每个员工至少分1个月饼，但可以分多个，单人分到最多月饼的个数是Max1，单人分到第二多月饼个数是Max2，Max1-Max2 &lt;&#x3D; 3，单人分到第n-1多月饼个数是Max(n-1)，单人分到第n多月饼个数是Max(n)，Max(n-1) – Max(n) &lt;&#x3D; 3, 问有多少种分月饼的方法？</p>
<h2 id="输入描述：-1"><a href="#输入描述：-1" class="headerlink" title="输入描述："></a>输入描述：</h2><p>每一行输入m n，表示m个员工，n个月饼，m&lt;&#x3D;n</p>
<h2 id="输出描述：-1"><a href="#输出描述：-1" class="headerlink" title="输出描述："></a>输出描述：</h2><p>输出有多少种月饼分法</p>
<p>示例1：</p>
<p>输入</p>
<p>2 4</p>
<p>输出</p>
<p>2<br>————————————————<br>版权声明：本文为CSDN博主「晓佰阳孖」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41542580/article/details/127104240">https://blog.csdn.net/qq_41542580/article/details/127104240</a></p>
<h2 id="wp-3"><a href="#wp-3" class="headerlink" title="wp"></a>wp</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">vector&lt;int&gt; s;</span><br><span class="line">int fenyuebing(int m,int n,int nmin)//剩余人数 月饼 最小月饼数</span><br><span class="line">&#123;</span><br><span class="line">    if(m&lt;=0) return 0;</span><br><span class="line">    if(n&lt;=0) return 0;</span><br><span class="line">    if(m==1) //就一个人了</span><br><span class="line">    &#123;</span><br><span class="line">        if(n&gt;=nmin&amp;&amp;n&lt;=nmin+3)//题目要求了次大者与最大者之间的关系max(i)-max(i+1)&lt;=3</span><br><span class="line">        &#123;</span><br><span class="line">          return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int co=0;</span><br><span class="line">    for(int k=nmin;k&lt;=nmin+3;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        //s.push_back(k);</span><br><span class="line">        cout&lt;&lt;co+1&lt;&lt;endl;</span><br><span class="line">        co+=fenyuebing(m-1,n-k,k);</span><br><span class="line">       // s.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    return co;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int m=2,n=4;//m&lt;=n</span><br><span class="line">  </span><br><span class="line">   int co=0;</span><br><span class="line">    for(int i=0;i&lt;=n-m;i++)//已经分出去了m个月饼</span><br><span class="line">    &#123;</span><br><span class="line">      //  s.push_back(i);</span><br><span class="line">        co+=fenyuebing(m-1,n-i,i);//给m-1个人分n-i个月饼，最少分i个</span><br><span class="line">       // s.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;&quot;总共&quot;&lt;&lt;co;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="32-找最小数"><a href="#32-找最小数" class="headerlink" title="*32.找最小数"></a>*32.找最小数</h1><p>给一个正整数NUM1，计算出新正整数NUM2，NUM2为NUM1中移除N位数字后的结果，需要使得NUM2的值最小。 输入描述：<br>1.输入的第一行为一个字符串，字符串由0-9字符组成，记录正整数NUM1，NUM1长度小于32。<br>2.输入的第二行为需要移除的数字的个数，小于NUM1长度。<br>如：<br>2615371<br>4<br>输出描述：<br>输出一个数字字符串，记录最小值NUM2。<br>如：131<br>————————————————<br>版权声明：本文为CSDN博主「weixin_41934659」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41934659/article/details/125888138">https://blog.csdn.net/weixin_41934659/article/details/125888138</a></p>
<h2 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h2><p><strong>单调栈（双端队列实现）</strong></p>
<p>维持一个递增队列，一旦遇到将入队的值比队尾<strong>小</strong>，马上弹出队尾的值，同时统计删去的个数</p>
<p>额外处理：</p>
<p>1.如果删去的个数不够要求，继续删。</p>
<p>2.如果有前导0，处理一下，00456，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//目的，对s删掉n位后，不改变原位置，找到最小值</span><br><span class="line">   string s=&quot;261053718&quot;;</span><br><span class="line">   s=&quot;123245&quot;;</span><br><span class="line">   s=&quot;12300456&quot;;</span><br><span class="line">   int n=4;//小于s的个数</span><br><span class="line">   int len=s.size()-n;</span><br><span class="line">    deque&lt;char&gt; dq;</span><br><span class="line">    for(int i=0;i&lt;s.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">       while(!dq.empty()&amp;&amp;n&gt;0&amp;&amp;dq.back()&gt;s[i])//删除n位数字</span><br><span class="line">       &#123;</span><br><span class="line">           dq.pop_back();//如果引进来的值小于队尾，弹出</span><br><span class="line">           n--;//维护了一个递增栈</span><br><span class="line">       &#125;</span><br><span class="line">       dq.push_back(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">   //  for(auto c:dq)</span><br><span class="line">   //  cout&lt;&lt;c&lt;&lt;&quot; &quot;;</span><br><span class="line">    for(int i=0;i&lt;n;i++)//如果删除了m个数字，删除个数不够n个，继续删，比如123245，要求删4个，删除了一个3，即还有12245，继续删3个</span><br><span class="line">    &#123;</span><br><span class="line">       dq.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   string result=&quot;&quot;;</span><br><span class="line">    bool iszero=true;</span><br><span class="line">     for(auto c1:dq)</span><br><span class="line">     &#123;</span><br><span class="line">       if(iszero&amp;&amp;c1==&#x27;0&#x27;) continue; //避免了前导0，比如261053718 删4位，最小的值是03718而不是10537</span><br><span class="line">       iszero=false;</span><br><span class="line">       result+=c1;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">   if(result.size()&gt;0) cout&lt;&lt;result;</span><br><span class="line">   else cout&lt;&lt;&quot;0&quot;;</span><br><span class="line">   return 0;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="33-简易内存池"><a href="#33-简易内存池" class="headerlink" title="33.简易内存池"></a>33.简易内存池</h1><h2 id="题目描述-17"><a href="#题目描述-17" class="headerlink" title="题目描述"></a>题目描述</h2><p>有一个简易内存池，内存按照大小粒度分类，每个粒度有若干个可用内存资源。<br>用户会进行一系列内存申请，需要按需分配内存池中的资源，返回申请结果成功失败列表。<br>分配规则如下：</p>
<ol>
<li>分配的内存要大于等于内存的申请量<br>存在满足需求的内存就必须分配<br>优先分配粒度小的，但内存不能拆分使用</li>
<li>需要按申请顺序分配<br>先申请的先分配，有可用内存分配则申请结果为<code>true</code><br>没有可用则返回<code>false</code></li>
</ol>
<ul>
<li>注释：不考虑内存释放</li>
</ul>
<h2 id="输入描述-24"><a href="#输入描述-24" class="headerlink" title="输入描述"></a>输入描述</h2><p>输入为两行字符串:<br>第一行为内存池资源列表，<br>包含内存粒度数据信息，粒度数据间用逗号分割，<br>一个粒度信息内用冒号分割，冒号前为内存粒度大小，冒号后为数量，<br>资源列表不大于<code>1024</code><br>每个粒度的数量不大于<code>4096</code><br>第二行为申请列表，<br>申请的内存大小间用逗号分割，申请列表不大于<code>100000</code><br>如<br><code>64:2,128:1,32:4,1:128</code><br><code>50,36,64,128,127</code></p>
<h2 id="输出描述-24"><a href="#输出描述-24" class="headerlink" title="输出描述"></a>输出描述</h2><p>输出为内存池分配结果<br>如<code>true,true,true,false,false</code></p>
<h2 id="说明-4"><a href="#说明-4" class="headerlink" title="说明"></a>说明</h2><p>内存池资源包含：<code>64k</code>共<code>2</code>个、<code>128k</code>共<code>1</code>个、<code>32k</code>共<code>4</code>个、<code>1k</code>共<code>128</code>个的内存资源<br>针对<code>50,36,64,128,127</code>的内存申请序列，<br>分配的内存依次是，<code>64,64,128,null,null</code><br>第三次申请内存时已经将<code>128</code>分配出去，因此输出的结果是<br><code>true,true,true,false,false</code></p>
<h2 id="个人代码-16"><a href="#个人代码-16" class="headerlink" title="个人代码"></a>个人代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s,t;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    stringstream ss(s);</span><br><span class="line">    //map&lt;int,int&gt; mp;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; v;</span><br><span class="line">    while(getline(ss,t,&#x27;,&#x27;))</span><br><span class="line">    &#123;</span><br><span class="line">    for(int i=0;i&lt;t.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(t[i]==&#x27;:&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;int&gt; a(2);</span><br><span class="line">            a[0]=stoi(t.substr(0,i));</span><br><span class="line">            a[1]=stoi(t.substr(i+1));</span><br><span class="line">            v.push_back(&#123;a[0],a[1]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    string yaoqiu,to;</span><br><span class="line">    cin&gt;&gt;yaoqiu;</span><br><span class="line">    stringstream ss2(yaoqiu);</span><br><span class="line">    vector&lt;int&gt; arr;</span><br><span class="line">    while(getline(ss2,to,&#x27;,&#x27;))&#123;</span><br><span class="line">        arr.push_back(stoi(to));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> int i=0,j=0,flag=0;</span><br><span class="line">while(i&lt;arr.size())</span><br><span class="line">  &#123;</span><br><span class="line">      flag=1;</span><br><span class="line">      for(int j=0;j&lt;v.size();j++)</span><br><span class="line">      &#123;</span><br><span class="line">          if(arr[i]&lt;=v[j][0]&amp;&amp;v[j][1]&gt;0)</span><br><span class="line">          &#123;</span><br><span class="line">              v[j][1]--;</span><br><span class="line">              cout&lt;&lt;&quot;true&quot;;</span><br><span class="line">              flag=-1;</span><br><span class="line">              break;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if(flag&gt;0) cout&lt;&lt;&quot;false&quot;;</span><br><span class="line">       if(i!=arr.size()-1) cout&lt;&lt;&quot;,&quot;;    </span><br><span class="line">      i++;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>题中貌似说了</strong>优先最小粒度排序，那就用map吧，它自带键排序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">  int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s,t;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    stringstream ss(s);</span><br><span class="line">    map&lt;int,int&gt; mp;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; v;</span><br><span class="line">    while(getline(ss,t,&#x27;,&#x27;))</span><br><span class="line">    &#123;</span><br><span class="line">    for(int i=0;i&lt;t.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(t[i]==&#x27;:&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            mp[stoi(t.substr(0,i))]=stoi(t.substr(i+1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string yaoqiu,to;</span><br><span class="line">    cin&gt;&gt;yaoqiu;</span><br><span class="line">    stringstream ss2(yaoqiu);</span><br><span class="line">    vector&lt;int&gt; arr;</span><br><span class="line">    while(getline(ss2,to,&#x27;,&#x27;))&#123;</span><br><span class="line">        arr.push_back(stoi(to));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> int i=0,j=0,flag=0;</span><br><span class="line">while(i&lt;arr.size())</span><br><span class="line">  &#123;</span><br><span class="line">      flag=1;</span><br><span class="line">      for(map&lt;int,int&gt;::iterator it=mp.begin();it!=mp.end();it++)</span><br><span class="line">      &#123;</span><br><span class="line">          if(arr[i]&lt;=it-&gt;first&amp;&amp;it-&gt;second&gt;0)</span><br><span class="line">          &#123;</span><br><span class="line">              it-&gt;second--;</span><br><span class="line">              cout&lt;&lt;&quot;true &quot;;</span><br><span class="line">              flag=-1;</span><br><span class="line">              break;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if(flag&gt;0) cout&lt;&lt;&quot;false &quot;;</span><br><span class="line">       if(i!=arr.size()-1) cout&lt;&lt;&quot;,&quot;;    </span><br><span class="line">      i++;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内存池2"><a href="#内存池2" class="headerlink" title="*内存池2"></a>*内存池2</h2><h3 id="题目描述-18"><a href="#题目描述-18" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个简易内存池<br>根据请求命令完成内存分配和释放<br>内存池支持两种操作命令<br><code>REQUEST</code>和<code>RELEASE</code>其格式为<br><code>REQUEST=请求的内存大小</code><br>表示请求分配指定大小内存<br>如果分配成功，返回分配到的内存首地址<br>如果内存不足，或指定的大小为零则输出<code>error</code><br><code>RELEASE=释放的内存首地址</code><br>表示释放掉之前分配的内存<br>释放成功无需输出<br>如果释放不存在的首地址<br>则输出<code>error</code></p>
<p>注意：</p>
<ol>
<li>内存池总大小为100字节</li>
<li>内存池地址分配必须是连续内存，并优先从低地址分配</li>
<li>内存释放后可被再次分配，已释放的内存在空闲时不能被二次释放</li>
<li>不会释放已申请的内存块的中间地址</li>
<li>释放操作只是针对首地址所对应的单个内存块进行操作，不会影响其他内存块</li>
</ol>
<h3 id="输入描述-25"><a href="#输入描述-25" class="headerlink" title="输入描述"></a>输入描述</h3><p>首行为整数<code>N</code><br>表示操作命令的个数<br>取值范围<code>0&lt;N&lt;=100</code><br>接下来的<code>N</code>行<br>每行将给出一个操作命令<br>操作命令和参数之间用<code>”=“</code>分割<br>输出描述见题目输出要求</p>
<h3 id="输出描述-25"><a href="#输出描述-25" class="headerlink" title="输出描述"></a>输出描述</h3><h3 id="示例一-13"><a href="#示例一-13" class="headerlink" title="示例一"></a>示例一</h3><p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">REQUEST=10</span><br><span class="line">REQUEST=20</span><br></pre></td></tr></table></figure>

<p>Copy</p>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<p>不知道怎么模拟0-100的内存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">map&lt;int,int&gt;mp;</span><br><span class="line">string request(int size);</span><br><span class="line">bool release(int addr);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  // vector&lt;int&gt; a(101);</span><br><span class="line">   int num=100;</span><br><span class="line">   int n;</span><br><span class="line">   cin&gt;&gt;n;</span><br><span class="line">   vector&lt;string&gt; s;</span><br><span class="line">   string t;</span><br><span class="line">   for(int i=0;i&lt;n;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       cin&gt;&gt;t;</span><br><span class="line">       s.push_back(t);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">//   for(auto a:s)</span><br><span class="line">//   cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    for(int i=0;i&lt;s.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(s[i][2]==&#x27;Q&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;request(stoi(s[i].substr(8)))&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        if(s[i][2]==&#x27;L&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            bool res= release(stoi(s[i].substr(8)));</span><br><span class="line">            if(!res) cout&lt;&lt;&quot;error&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">string request(int size)</span><br><span class="line">&#123;</span><br><span class="line">    int start=0,end=100;</span><br><span class="line">    int add1=start,add2=end;</span><br><span class="line">   </span><br><span class="line">    if(size&lt;=0||size&gt;100) return &quot;error&quot;;</span><br><span class="line">    //mp键存首地址，值为大小</span><br><span class="line">     if(mp.empty())</span><br><span class="line">     &#123;</span><br><span class="line">        cout&lt;&lt;&quot;add:&quot;&lt;&lt;add1&lt;&lt;&quot;,size:&quot;&lt;&lt;size&lt;&lt;endl;</span><br><span class="line">        mp[add1]=size;</span><br><span class="line">     &#125; </span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;int&gt; a;</span><br><span class="line">        //遍历vector获取mp的键</span><br><span class="line">        for(auto c:mp)</span><br><span class="line">        &#123;</span><br><span class="line">            a.push_back(c.first);</span><br><span class="line">        &#125;</span><br><span class="line">        //遍历vector</span><br><span class="line">        for(auto num:a)</span><br><span class="line">        &#123;</span><br><span class="line">            //计算首地址的差值，如果&gt;=要填的size</span><br><span class="line">            //更新mp</span><br><span class="line">            //否则就是该首地址被占用了</span><br><span class="line">            //更新首地址</span><br><span class="line">            if(num-add1&gt;=size)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;&quot;num:&quot;&lt;&lt;num&lt;&lt;&quot;-add:&quot;&lt;&lt;add1&lt;&lt;&quot;&gt;=size:&quot;&lt;&lt;size&lt;&lt;endl;</span><br><span class="line">                mp[add1]=size+add1;</span><br><span class="line">                cout&lt;&lt;&quot;add:&quot;&lt;&lt;add1&lt;&lt;&quot;,size:&quot;&lt;&lt;size+add1&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;&quot;num:&quot;&lt;&lt;num&lt;&lt;&quot;-add:&quot;&lt;&lt;add1&lt;&lt;&quot;&lt;size:&quot;&lt;&lt;size&lt;&lt;endl;</span><br><span class="line">                add1=mp[num];</span><br><span class="line">                cout&lt;&lt;&quot;update add:&quot;&lt;&lt;add1&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(size&lt;=end-add1)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;&quot;size:&quot;&lt;&lt;size&lt;&lt;&quot;&lt;=&quot;&lt;&lt;&quot;end-add1:&quot;&lt;&lt;end&lt;&lt;&quot;-&quot;&lt;&lt;add1&lt;&lt;endl;</span><br><span class="line">            mp[add1]=add1+size;</span><br><span class="line">            cout&lt;&lt;&quot;add:&quot;&lt;&lt;add1&lt;&lt;&quot;,size:&quot;&lt;&lt;add1+size&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        else return &quot;error&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return to_string(add1);</span><br><span class="line">&#125;</span><br><span class="line">bool release(int addr)</span><br><span class="line">&#123;</span><br><span class="line">    if(mp.count(addr))</span><br><span class="line">    &#123;</span><br><span class="line">        mp.erase(addr);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>5<br>REQUEST&#x3D;10<br>REQUEST&#x3D;20<br>RELEASE&#x3D;0<br>REQUEST&#x3D;20<br>REQUEST&#x3D;10<br>add:0,size:10<br>0<br>num:0-add:0&lt;size:20<br>update add:10<br>size:20&lt;&#x3D;end-add1:100-10<br>add:10,size:30<br>10<br>num:10-add:0&lt;size:20<br>update add:30<br>size:20&lt;&#x3D;end-add1:100-30<br>add:30,size:50<br>30<br>num:10-add:0&gt;&#x3D;size:10<br>add:0,size:10<br>num:30-add:0&gt;&#x3D;size:10<br>add:0,size:10<br>size:10&lt;&#x3D;end-add1:100-0<br>add:0,size:10<br>0</p>
</blockquote>
<h1 id="34-服务失效"><a href="#34-服务失效" class="headerlink" title="34.服务失效"></a>34.服务失效</h1><h2 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h2><p>某系统中有众多服务，每个服务用字符串（只包含字母和数字，长度&lt;&#x3D;10）唯一标识，服务间可能有依赖关系，如A依赖B，则当B故障时导致A也故障。</p>
<p>依赖具有传递性，如A依赖B，B依赖C，当C故障时导致B故障，也导致A故障。</p>
<p>给出所有依赖关系，以及当前已知故障服务，要求输出所有正常服务。</p>
<p>依赖关系：服务1-服务2 表示“服务1”依赖“服务2”</p>
<p>不必考虑输入异常，用例保证：依赖关系列表、故障列表非空，且依赖关系数，故障服务数都不会超过3000，服务标识格式正常。</p>
<h2 id="输入描述-26"><a href="#输入描述-26" class="headerlink" title="输入描述:"></a><strong>输入描述:</strong></h2><p>半角逗号分隔的依赖关系列表（换行）</p>
<p>半角逗号分隔的故障服务列表</p>
<h2 id="输出描述-26"><a href="#输出描述-26" class="headerlink" title="输出描述:"></a><strong>输出描述:</strong></h2><p>依赖关系列表中提及的所有服务中可以正常工作的服务列表，用半角逗号分隔，按依赖关系列表中出现的次序排序。</p>
<p>特别的，没有正常节点输出单独一个半角逗号。</p>
<h2 id="示例1-3"><a href="#示例1-3" class="headerlink" title="示例1"></a><strong>示例1</strong></h2><h3 id="输入-20"><a href="#输入-20" class="headerlink" title="输入"></a>输入</h3><blockquote>
<p>a1-a2,a5-a6,a2-a3</p>
<p>a5,a2</p>
</blockquote>
<h3 id="输出-19"><a href="#输出-19" class="headerlink" title="输出"></a>输出</h3><blockquote>
<p>a6,a3</p>
</blockquote>
<h2 id="个人代码1-输出有序"><a href="#个人代码1-输出有序" class="headerlink" title="个人代码1(输出有序)"></a>个人代码1(输出有序)</h2><p>有个问题，因为用了map，所以输出时的顺序是按字典序排列的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    </span><br><span class="line">    stringstream ss(s);</span><br><span class="line">    string t;</span><br><span class="line">    vector&lt;string&gt; serve;</span><br><span class="line">    while(getline(ss,t,&#x27;,&#x27;))</span><br><span class="line">    &#123;</span><br><span class="line">        serve.push_back(t);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;string&gt; bad;</span><br><span class="line">    string t1;</span><br><span class="line">    cin&gt;&gt;t1;</span><br><span class="line">    stringstream ss1(t1);</span><br><span class="line">    string t2;</span><br><span class="line">    while(getline(ss1,t2,&#x27;,&#x27;))</span><br><span class="line">     bad.push_back(t2);</span><br><span class="line">     </span><br><span class="line">     //如果是右边必坏，左边必坏，如果左边必坏，右边不坏</span><br><span class="line">     //搞一个bool记录下？</span><br><span class="line"> </span><br><span class="line">    map&lt;string,string&gt; mp1;</span><br><span class="line">    map&lt;string,bool&gt; mp2;//记录哈</span><br><span class="line">    //vector&lt;string&gt; </span><br><span class="line">     for(auto c:serve)</span><br><span class="line">     &#123;</span><br><span class="line">         for(int i=0;i&lt;c.size();i++)</span><br><span class="line">         &#123;</span><br><span class="line">             if(c[i]==&#x27;-&#x27;)</span><br><span class="line">             &#123;</span><br><span class="line">                //  mp[c.substr(0,i)]=c.substr(0,i);</span><br><span class="line">                //  mp[c.substr(i+1)]=c.substr(i+1);</span><br><span class="line">                 mp1[c.substr(0,i)]=c.substr(i+1);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">     &#125;</span><br><span class="line">     for(auto a:mp1) //提前记录一下</span><br><span class="line">     &#123;</span><br><span class="line">         mp2[a.first]=true;</span><br><span class="line">         mp2[a.second]=true;</span><br><span class="line">     &#125;</span><br><span class="line">    //  for(auto a:bad)</span><br><span class="line">    //  cout&lt;&lt;a&lt;&lt;&quot;,&quot;;</span><br><span class="line">    //  cout&lt;&lt;endl;</span><br><span class="line">    //  for(auto c:mp1)</span><br><span class="line">    //  cout&lt;&lt;c.first&lt;&lt;&quot;,&quot;&lt;&lt;c.second&lt;&lt;endl;</span><br><span class="line">     //现在，干什么，先遍历bad，再遍历mp，如果是键=bad，如果是值=bad，对应bool false</span><br><span class="line">     </span><br><span class="line">    //  for(auto a:mp2)</span><br><span class="line">    //  &#123;</span><br><span class="line">    //      cout&lt;&lt;a.first&lt;&lt;&quot;,&quot;&lt;&lt;a.second&lt;&lt;endl;</span><br><span class="line">    //  &#125;</span><br><span class="line">     for(auto a:bad)</span><br><span class="line">     for(auto c:mp1)</span><br><span class="line">     &#123;</span><br><span class="line">         if(a==c.first&amp;&amp;mp2[c.first]==true)//等于左边，左边false</span><br><span class="line">         &#123;</span><br><span class="line">             mp2[c.first]=false;</span><br><span class="line">         &#125;</span><br><span class="line">         if(a==c.second&amp;&amp;mp2[c.second]==true)//等于右边，左右都false</span><br><span class="line">         &#123;</span><br><span class="line">             mp2[c.first]=false;</span><br><span class="line">             mp2[c.second]=false;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     int flag=-1;</span><br><span class="line">    //   for(auto a:mp2)</span><br><span class="line">    //  &#123;</span><br><span class="line">    //      cout&lt;&lt;a.first&lt;&lt;&quot;,&quot;&lt;&lt;a.second&lt;&lt;endl;</span><br><span class="line">    //  &#125;</span><br><span class="line">    </span><br><span class="line">    int co=0;</span><br><span class="line">     for(auto a:mp2)</span><br><span class="line">     &#123;</span><br><span class="line">         if(a.second==true)</span><br><span class="line">         &#123;</span><br><span class="line">             flag=1;</span><br><span class="line">            cout&lt;&lt;a.first;</span><br><span class="line">            if(co!=mp2.size()-1) cout&lt;&lt;&quot;,&quot;;</span><br><span class="line">         &#125;</span><br><span class="line">          co++;</span><br><span class="line">         </span><br><span class="line">        </span><br><span class="line">     &#125;</span><br><span class="line">     if(flag&lt;0) cout&lt;&lt;&quot;,&quot;&lt;&lt;endl;</span><br><span class="line">     </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>unorderd_map 是哈希表，塔喵的是胡乱排序</p>
<p>可是如果按照vector&lt;pair&lt;string,bool&gt; &gt;mp2，我到时候就不能直接mp2[键]这样访问了诶</p>
<h2 id="个人代码2-按插入顺序输出"><a href="#个人代码2-按插入顺序输出" class="headerlink" title="个人代码2(按插入顺序输出)"></a>个人代码2(按插入顺序输出)</h2><p>思路是这样</p>
<p>1.首先定义两数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; serve; //用于接收服务输入以逗号分割的值，如a1-a2</span><br><span class="line">vector&lt;string&gt; bad;//用于接收故障输入，如a5</span><br></pre></td></tr></table></figure>

<p>2.遍历serve数组，先筛选一遍，不是故障的服务（初次筛选）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">stringstream ss;</span><br><span class="line">string t;</span><br><span class="line">vector&lt;string&gt; chushai;</span><br><span class="line">for(auto a:serve)</span><br><span class="line">&#123;</span><br><span class="line">	ss.str(a);</span><br><span class="line">	vector&lt;string&gt; temp;</span><br><span class="line">	while(getline(ss,t,&#x27;-&#x27;))</span><br><span class="line">	&#123;</span><br><span class="line">		temp.push_back(t);</span><br><span class="line">	&#125;</span><br><span class="line">	string a=temp[0];</span><br><span class="line">	string b=temp[1];</span><br><span class="line">	</span><br><span class="line">	if(!count(bad.begin(),bad.end(),a)&amp;&amp;!count(chushai.begin(),chushai.end(),a))//既无故障，也不重复</span><br><span class="line">	&#123;</span><br><span class="line">		chushai.push_back(a);</span><br><span class="line">	&#125;</span><br><span class="line">	if(!count(bad.begin(),bad.end(),b)&amp;&amp;!count(chushai.begin(),chushai.end(),b))//既无故障，也不重复</span><br><span class="line">	&#123;</span><br><span class="line">		chushai.push_back(b);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在遍历serve过程中，对每个元素值单独处理</p>
<p>（这一块不知道怎么描述，我觉得是关键之处）</p>
<p>（将一些待处理的值，比如”a1-a2 a5-a6…”，提前处理成”a1”,”a2”,”a5”,”a6”<strong>完成后</strong>，再对”a1”,”a2”,”a5”,”a6”统一进行下一步操作，如对比筛选）</p>
<p><strong>不见得比下述方式好</strong></p>
<p>（遍历的时候，先处理”a1-a2”，变成”a1”,”a2”，先不急着处理”a5-a6”，反而接着就”a1”,”a2”，先进行一遍筛选和处理）</p>
<p>然后这里的count()函数，需要头文件<code>&lt;algorithm&gt;</code></p>
<p>3.进行二筛</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; ershai;</span><br><span class="line">for(auto a:chushai)</span><br><span class="line">&#123;</span><br><span class="line">	if(!isGZ(a))</span><br><span class="line">	ershai.push_back(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>isGZ内容为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bool isGZ(string s)</span><br><span class="line">&#123;</span><br><span class="line">	//它是故障</span><br><span class="line">	if(count(bad.begin(),bad.end(),s))</span><br><span class="line">	return true;</span><br><span class="line">	</span><br><span class="line">	//它不是故障，看它的依赖是否是故障</span><br><span class="line">	for(auto item:mp)</span><br><span class="line">	&#123;</span><br><span class="line">	if(item[0]==s&amp;&amp;isGZ(item[1])) return true;</span><br><span class="line">	&#125;</span><br><span class="line">	//否则不是故障</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的mp有门道，其定义为vector&lt;vector&lt;string&gt; &gt; mp;</p>
<p>类似于map的键值对的效果，但是呢，map是字典序排序的，不符合题意</p>
<p>所以在第2步，初筛的时候，我们需要将每次处理后的temp，还是要push_back到mp里，mp里，包含了依赖关系</p>
<p>所以加上一行 <code>mp.push_back(temp)</code>;</p>
<p>反正ershai的元素即为最终输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// Online IDE - Code Editor, Compiler, Interpreter</span><br><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;unordered_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; bad;//故障</span><br><span class="line">vector&lt;vector&lt;string&gt; &gt;mp;//处理好的依赖关系</span><br><span class="line">vector&lt;string&gt; serve; //待处理的依赖关系a1-a2</span><br><span class="line"></span><br><span class="line">bool isGZ(string s)</span><br><span class="line">&#123;</span><br><span class="line">   if(count(bad.begin(),bad.end(),s)) //该服务故障</span><br><span class="line">   return true;//有故障</span><br><span class="line">   </span><br><span class="line">   //如果这个服务没有故障，看下它的依赖</span><br><span class="line">   for(auto item:mp)</span><br><span class="line">   &#123;</span><br><span class="line">       if(item[0]==s&amp;&amp;isGZ(item[1]))//左边是s，看下右边的依赖是否故障</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br><span class="line">   return false;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    </span><br><span class="line">    stringstream ss(s);</span><br><span class="line">    string t;</span><br><span class="line">  </span><br><span class="line">    while(getline(ss,t,&#x27;,&#x27;))</span><br><span class="line">    &#123;</span><br><span class="line">        serve.push_back(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string t1;</span><br><span class="line">    cin&gt;&gt;t1;</span><br><span class="line">    stringstream ss1(t1);</span><br><span class="line">    string t2;</span><br><span class="line">    while(getline(ss1,t2,&#x27;,&#x27;))</span><br><span class="line">     bad.push_back(t2);</span><br><span class="line">   </span><br><span class="line">    vector&lt;string&gt; set1;//剔除了故障的服务</span><br><span class="line">    for(auto st:serve)</span><br><span class="line">    &#123;</span><br><span class="line">        ss.clear();</span><br><span class="line">        ss.str(st);</span><br><span class="line">        vector&lt;string&gt; temp;</span><br><span class="line">        while(getline(ss,t1,&#x27;-&#x27;))</span><br><span class="line">        &#123;</span><br><span class="line">            temp.push_back(t1);</span><br><span class="line">        &#125;</span><br><span class="line">        mp.push_back(temp);</span><br><span class="line">        string a=temp[0];</span><br><span class="line">        string b=temp[1];</span><br><span class="line">        </span><br><span class="line">        //故障列表里没有a</span><br><span class="line">        if(!count(bad.begin(),bad.end(),a)&amp;&amp;!count(set1.begin(),set1.end(),a))//bad里没有set1里也没有</span><br><span class="line">        &#123;</span><br><span class="line">            set1.push_back(a);</span><br><span class="line">        &#125;</span><br><span class="line">         //故障列表里没有b</span><br><span class="line">         if(!count(bad.begin(),bad.end(),b)&amp;&amp;!count(set1.begin(),set1.end(),b))</span><br><span class="line">        &#123;</span><br><span class="line">            set1.push_back(b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      for(auto a:mp)</span><br><span class="line">  cout&lt;&lt;a[0]&lt;&lt;&quot;,&quot;&lt;&lt;a[1]&lt;&lt;endl;</span><br><span class="line">  for(auto a:set1)</span><br><span class="line">  cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    vector&lt;string&gt; listzc;//正常服务</span><br><span class="line">    </span><br><span class="line">    //再筛选一遍</span><br><span class="line">    for(auto a:set1)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!isGZ(a))</span><br><span class="line">        listzc.push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    int len=listzc.size();</span><br><span class="line">    string res=&quot;&quot;;</span><br><span class="line">    if(len==0) cout&lt;&lt;&quot;,&quot;;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=0;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res+=listzc[i];</span><br><span class="line">            if(i!=len-1) res+=&quot;,&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>stringstream ss(t);</p>
<p>等价于</p>
<p> stringstream ss;</p>
<p>ss.str(t);</p>
<p>如果要重复利用ss，可以再声明之后，ss.clear();</p>
</blockquote>
<h1 id="35-图像物体的边界"><a href="#35-图像物体的边界" class="headerlink" title="35.图像物体的边界"></a>35.图像物体的边界</h1><p>给定一个二维数组M行N列，二维数组里的数字代表图片的像素，为了简化问题，仅包含像素1和5两种像素，每种像素代表一个物体，2个物体相邻的格子为边界，求像素1代表的物体的边界个数。<br>像素1代表的物体的边界指与像素5相邻的像素1的格子，边界相邻的属于同一个边界，相邻需要考虑8个方向（上，下，左，右，左上，左下，右上，右下）。<br>其他约束：<br>地图规格约束为：<br>0&lt;M&lt;100<br>0&lt;N&lt;100</p>
<p>1）如下图，与像素5的格子相邻的像素1的格子（0,0）、（0,1）、（0,2）、（1,0）、（1,2）、（2,0）、（2,1）、（2,2）、（4,4）、（4,5）、（5,4）为边界，另（0,0）、（0,1）、（0,2）、（1,0）、（1,2）、（2,0）、（2,1）、（2,2）相邻，为1个边界，（4,4）、（4,5）、（5,4）相邻，为1个边界，所以下图边界个数为2。</p>
<p>输入示例</p>
<p>6 6</p>
<p><strong>1 1 1</strong> 1 1 1</p>
<p><strong>1</strong> 5 <strong>1</strong> 1 1 1</p>
<p><strong>1</strong> <strong>1 1</strong> 1 1 1</p>
<p>1 1 1 1 1 1</p>
<p>1 1 1 1 <strong>1 1</strong></p>
<p>1 1 1 1 <strong>1</strong> 5</p>
<p>输出</p>
<p>2</p>
<p><strong>说明：就是1作为围墙，能把中间的5围死，加粗部分</strong></p>
<p>输入描述:</p>
<ul>
<li>第一行，行数M，列数N 第二行开始，是M行N列的像素的二维数组，仅包含像素1和5</li>
</ul>
<p>输出描述:</p>
<ul>
<li>像素1代表的物体的边界个数。如果没有边界输出0（比如只存在像素1，或者只存在像素5）。</li>
</ul>
<h2 id="个人代码-17"><a href="#个人代码-17" class="headerlink" title="个人代码"></a>个人代码</h2><p>我就是笨办法</p>
<p>考虑情况为：</p>
<p>1.四个角落，需要判断3个值</p>
<p>2.除开四个角落的地方（第一行，最后一行，第一列，最后一列）考虑5个值</p>
<p>3.其余为8个值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// Online IDE - Code Editor, Compiler, Interpreter</span><br><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int solution(vector&lt;vector&lt;int&gt; &gt;a,int n,int m)</span><br><span class="line">&#123;</span><br><span class="line">    int co=0;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt;v;</span><br><span class="line">    int x=0,y=0,flag1=0,flag5=0;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    for(int j=0;j&lt;m;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a[i][j]==5)</span><br><span class="line">        &#123;</span><br><span class="line">            flag5=1;</span><br><span class="line">            vector&lt;int&gt; temp;</span><br><span class="line">            temp.push_back(i);</span><br><span class="line">            temp.push_back(j);</span><br><span class="line">              v.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        else flag1=1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">      for(auto m:v)</span><br><span class="line">    cout&lt;&lt;m[0]&lt;&lt;&quot; &quot;&lt;&lt;m[1]&lt;&lt;endl;</span><br><span class="line">    if(flag1==0||flag5==0) return 0;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">    for(auto temp:v)</span><br><span class="line">    &#123;</span><br><span class="line">        int p=temp[0],q=temp[1];</span><br><span class="line">        if(p==0) //第一行</span><br><span class="line">        &#123;</span><br><span class="line">            if(q==0)//只要三个</span><br><span class="line">            &#123;</span><br><span class="line">                if(a[0][1]==1&amp;&amp;a[1][1]==1&amp;&amp;a[1][0]==1) co++;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(q==m-1)//只要三个</span><br><span class="line">            &#123;</span><br><span class="line">                if(a[0][m-2]==1&amp;&amp;a[1][m-2]==1&amp;&amp;a[1][m-1]==1) co++;</span><br><span class="line">            &#125;</span><br><span class="line">            else //五个 </span><br><span class="line">            &#123;</span><br><span class="line">                if(a[0][q-1]==1&amp;&amp;a[0][q+1]==1&amp;&amp;a[1][q-1]==1&amp;&amp;a[1][q]==1&amp;&amp;a[1][q+1]==1) co++;</span><br><span class="line">            &#125;</span><br><span class="line">       </span><br><span class="line">        &#125;</span><br><span class="line">        else if(q==0) //第一列</span><br><span class="line">        &#123;</span><br><span class="line">    </span><br><span class="line">             if(p==n-1)//只要三个</span><br><span class="line">             &#123;</span><br><span class="line">                 if(a[n-2][0]==1&amp;&amp;a[n-2][1]==1&amp;&amp;a[n-1][1]==1) co++;</span><br><span class="line">             &#125;</span><br><span class="line">             else //五个 </span><br><span class="line">            &#123;</span><br><span class="line">                 if(a[p-1][0]==1&amp;&amp;a[p+1][0]==1&amp;&amp;a[p-1][1]==1&amp;&amp;a[p][1]==1&amp;&amp;a[p+1][1]==1) co++;</span><br><span class="line">            &#125;</span><br><span class="line">       </span><br><span class="line">        &#125;</span><br><span class="line">      else  if(p==n-1)//最后一行</span><br><span class="line">        &#123;</span><br><span class="line">           // if(q==0)//只要三个</span><br><span class="line">            if(q==m-1) //只要三个</span><br><span class="line">            &#123;</span><br><span class="line">                if(a[p-1][q]==1&amp;&amp;a[p-1][q-1]==1&amp;&amp;a[p][q-1]==1) co++;</span><br><span class="line">            &#125;</span><br><span class="line">            else //只要五个</span><br><span class="line">            &#123;</span><br><span class="line">                if(a[p-1][q]==1&amp;&amp;a[p+1][q]==1&amp;&amp;a[p-1][q-1]==1&amp;&amp;a[p][q-1]==1&amp;&amp;a[p+1][q-1]==1) co++;</span><br><span class="line">            &#125;</span><br><span class="line">         </span><br><span class="line">        &#125;</span><br><span class="line">       else  if(q==m-1)//最后一行</span><br><span class="line">        &#123;</span><br><span class="line">            if(a[p-1][q-1]==1&amp;&amp;a[p-1][q]==1&amp;&amp;a[p-1][q+1]==1&amp;&amp;a[p][q-1]==1&amp;&amp;a[p][q+1]==1) co++;</span><br><span class="line">       </span><br><span class="line">        &#125;</span><br><span class="line">        else //八个</span><br><span class="line">        &#123;</span><br><span class="line">            if(a[p-1][q-1]==1&amp;&amp;a[p-1][q]==1&amp;&amp;a[p-1][q+1]==1&amp;&amp;a[p][q-1]==1&amp;&amp;a[p][q+1]==1&amp;&amp;a[p+1][q-1]==1&amp;&amp;a[p+1][q]==1&amp;&amp;a[p+1][q+1]==1)</span><br><span class="line">            co++;</span><br><span class="line">     </span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line">    return co;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    /*</span><br><span class="line">    6 6</span><br><span class="line"></span><br><span class="line">1 1 1 1 1 1</span><br><span class="line"></span><br><span class="line">1 5 1 1 1 1</span><br><span class="line"></span><br><span class="line">1 1 1 1 1 1</span><br><span class="line"></span><br><span class="line">1 1 1 1 1 1</span><br><span class="line"></span><br><span class="line">1 1 1 1 1 1</span><br><span class="line"></span><br><span class="line">1 1 1 1 1 5</span><br><span class="line"></span><br><span class="line">初步想法是先找5，然后探索它的八个方向是否都是1</span><br><span class="line">    */</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt;a(n,vector&lt;int&gt;(m));</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    for(int j=0;j&lt;m;j++)</span><br><span class="line">    cin&gt;&gt;a[i][j];</span><br><span class="line">    cout&lt;&lt;solution(a,n,m);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>4 4<br>1 1 1 1<br>1 1 5 5<br>1 1 1 5<br>1 1 1 1<br>1 2<br>1 3<br>2 3<br>0</p>
</blockquote>
<h1 id="36-跳格子"><a href="#36-跳格子" class="headerlink" title="36.跳格子"></a>36.跳格子</h1><p>地上共有N个格子，你需要跳完地上所有的格子，但是格子间是有强依赖关系的，跳完前一个格子后，后续的格子才会被开启，格子间的依赖关系由多组steps数组给出，steps[0]表示前一个格子，step[1]表示steps[0]可以开启的格子<br>比如[0,1]表示从跳完第0个格子以后第1个格子就开启了，比如[2,1],[2,3]表示跳完第2个格子后第1个格子和第3个格子就被开启了。<br>请你计算是否能由给出的steps数组跳完所有的格子，如果可以输出yes，否则输出no<br>说明：</p>
<p>1.你可以从一个格子调到任意一个开启的格子<br>2.没有前置依赖条件默认就是开启的<br>3.如果总数是N，则所有的格子编号为[0,1,2,3….N-1]l连续的数组<br>输入描述<br>输入一个整数N表示总共有多少个格子，接着输入多组二维数组steps表示所有格子之间的依赖关系。<br>输出描述<br>如果能按照steps给定的依赖顺序跳完所有的格子输出yes,否则输出no.</p>
<h2 id="输入-21"><a href="#输入-21" class="headerlink" title="输入"></a>输入</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">0 1</span><br><span class="line">0 2</span><br></pre></td></tr></table></figure>

<h3 id="输出-20"><a href="#输出-20" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yes</span><br></pre></td></tr></table></figure>

<h2 id="个人代码（有误）-1"><a href="#个人代码（有误）-1" class="headerlink" title="个人代码（有误）"></a>个人代码（有误）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// Online IDE - Code Editor, Compiler, Interpreter</span><br><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">bool isbihuan(vector&lt;vector&lt;int&gt; &gt;&amp;gezi,vector&lt;int&gt; &amp;agezi)</span><br><span class="line">&#123;</span><br><span class="line">    for(auto temp:gezi)</span><br><span class="line">    &#123;</span><br><span class="line">        if(temp[0]==agezi[agezi.size()-1])//</span><br><span class="line">        &#123;</span><br><span class="line">         if(find(agezi.begin(),agezi.end(),temp[1])!=agezi.end())</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        agezi.push_back(temp[0]);</span><br><span class="line">        agezi.push_back(temp[1]);</span><br><span class="line">       </span><br><span class="line">        if(isbihuan(gezi,agezi)) return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">     </span><br><span class="line">    /*</span><br><span class="line">     根据示例来看，走完所有格子就是保持线性关系咯，如果闭环那就不可以咯</span><br><span class="line">    0 1 </span><br><span class="line">    1 0 也就是没提，默认开启，比如单个0,1；但如果像这种0,1互依赖情况，</span><br><span class="line">    那么用一个vector去存储成对的依赖关系 vector&lt;vector&lt;int&gt; &gt;</span><br><span class="line">    另一个vector也存储依赖关系，但是保持在一行上vector&lt;int&gt;</span><br><span class="line">    遍历第一个vector，取它每个元素的第一个与第二个vector的最后一个元素去判断相等，若相等则闭环</span><br><span class="line">    */</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;//格子数</span><br><span class="line">    cin.ignore();</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt;gezi;//依赖关系</span><br><span class="line">  //  map&lt;int,int&gt; m;//</span><br><span class="line">   // map&lt;int,int&gt;mp;//计数</span><br><span class="line">  //  int a,b;</span><br><span class="line">  string input,t;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        getline(cin,input);</span><br><span class="line">         if(input.empty()) break;//多输入一遍空格即可</span><br><span class="line">     //   m[a]=a;</span><br><span class="line">      //  m[b]=b;</span><br><span class="line">        stringstream ss(input);</span><br><span class="line">         vector&lt;int&gt; a;</span><br><span class="line">        while(getline(ss,t,&#x27; &#x27;))</span><br><span class="line">        &#123;</span><br><span class="line">           </span><br><span class="line">            a.push_back(stoi(t));</span><br><span class="line">        &#125;</span><br><span class="line">          gezi.push_back(a);</span><br><span class="line">       // if(m.size()==n) break;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">//    for(auto a:m)</span><br><span class="line">//    cout&lt;&lt;a.first&lt;&lt;endl;</span><br><span class="line">//    for(auto a:gezi)</span><br><span class="line">//    cout&lt;&lt;a[0]&lt;&lt;&quot;,&quot;&lt;&lt;a[1]&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">    bool istrue=true;//可以成功</span><br><span class="line">    for(auto list:gezi)</span><br><span class="line">    &#123;</span><br><span class="line">      if(isbihuan(gezi,list))</span><br><span class="line">      &#123;</span><br><span class="line">          istrue=false;</span><br><span class="line">          break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(istrue) cout&lt;&lt;&quot;yes&quot;;</span><br><span class="line">    else cout&lt;&lt;&quot;no&quot;;</span><br><span class="line">    /*</span><br><span class="line">    0 1</span><br><span class="line">    0 2</span><br><span class="line">    */</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="wp-4"><a href="#wp-4" class="headerlink" title="wp"></a>wp</h2><p>利用图及深度遍历 </p>
<p>来自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/BYZLZ119/article/details/131076746">GHHIAS</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">enum status &#123;unv,ving,ved&#125;;//遍历状态,不能用数字</span><br><span class="line">void dfs(int node,vector&lt;status&gt;&amp; visit,vector&lt;vector&lt;int&gt; &gt;&amp; edges,bool &amp; stepall)</span><br><span class="line">&#123;</span><br><span class="line">    visit[node]=ving;//正在遍历</span><br><span class="line"></span><br><span class="line">    for(int neighbor:edges[node])//遍历邻居节点</span><br><span class="line">    &#123;</span><br><span class="line">        if(visit[neighbor]==unv)//没访问</span><br><span class="line">        &#123;</span><br><span class="line">             dfs(neighbor,visit,edges,stepall);//递归遍历邻居节点</span><br><span class="line"></span><br><span class="line">                //能跳完所有格子</span><br><span class="line">             if(!stepall) return;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        else if(visit[neighbor]==unv)//若邻居节点正在遍历，但未完成遍历</span><br><span class="line">        &#123;</span><br><span class="line">            stepall=false;//无法跳完所有格子</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    visit[node]=ved;//访问过，即遍历完成</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">     </span><br><span class="line">   int n;</span><br><span class="line">   cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">   cin.ignore();</span><br><span class="line">    </span><br><span class="line">    //初始化边</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt;edges(n);</span><br><span class="line">    //vector&lt;status&gt; visit(n,0);//enum不支持数字</span><br><span class="line">    vector&lt;status&gt; visit(n,unv);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    bool stepall=false;</span><br><span class="line">    string s;</span><br><span class="line">    while(getline(cin,s))</span><br><span class="line">    &#123;</span><br><span class="line">        if(s.empty()) break;</span><br><span class="line"></span><br><span class="line">        int a,b;</span><br><span class="line">        stringstream ss(s);</span><br><span class="line">        ss&gt;&gt;a&gt;&gt;b;//解析输入的两个数字</span><br><span class="line">        edges[b].push_back(a);//记录边</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;n&amp;&amp;stepall;i++)//遍历所有节点</span><br><span class="line">    &#123;</span><br><span class="line">        if(visit[i]==unv)//如果节点未被遍历</span><br><span class="line">        dfs(i,visit,edges,stepall);//从该结点开始遍历</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;(stepall?&quot;yes&quot;:&quot;no&quot;)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="37-数组二叉树"><a href="#37-数组二叉树" class="headerlink" title="37.数组二叉树"></a>37.数组二叉树</h1><p>二叉树也可以用数组来存储 给定一个数组 </p>
<p>树的根节点的值储存在下标1</p>
<p> 对于储存在下标n的节点，他的左子节点和右子节点分别储存在下标2<em>n和2</em>n+1 </p>
<p>并且我们用-1代表一个节点为空 </p>
<p>给定一个数组存储的二叉树 </p>
<p>试求从根节点到最小的叶子节点的路径 </p>
<p>路径由节点的值组成 </p>
<h2 id="输入描述-27"><a href="#输入描述-27" class="headerlink" title="输入描述"></a>输入描述</h2><p>输入一行为数组的内容 数组的每个元素都是正整数，元素间用空格分割 注意第一个元素即为根节点的值 即数组的第n元素对应下标n 下标0在树的表示中没有使用 所以我们省略了 输入的树最多为7层 </p>
<h2 id="输出描述-27"><a href="#输出描述-27" class="headerlink" title="输出描述"></a>输出描述</h2><p>输出从根节点到最小叶子节点的路径上各个节点的值 由空格分割 用例保证最小叶子节点只有一个  </p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="输入-22"><a href="#输入-22" class="headerlink" title="输入"></a>输入</h3><p> 3 5 7 -1 -1 2 4 </p>
<h3 id="输出-21"><a href="#输出-21" class="headerlink" title="输出"></a>输出</h3><p>3 7 2</p>
<p>下面两条wp的思路都是，先找到最小的叶结点，那么从根节点到它的路径就唯一确定了。</p>
<p>最小叶结点的要求，它首先不是-1，其值最小，它左孩子下标溢出</p>
<p>从它开始倒着找父节点就行了。</p>
<h2 id="wp1"><a href="#wp1" class="headerlink" title="wp1"></a>wp1</h2><p>来自<a target="_blank" rel="noopener" href="http://t.csdn.cn/vG8M3">CSDN巨坚强</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> vector&lt;int&gt; a;</span><br><span class="line">    a.push_back(0);//先占用一个</span><br><span class="line">    int b;</span><br><span class="line">    while(cin&gt;&gt;b)</span><br><span class="line">    &#123;</span><br><span class="line">        a.push_back(b);</span><br><span class="line">        if(cin.get()==&#x27;\n&#x27;) break;</span><br><span class="line">    &#125;</span><br><span class="line">    //先找到最小叶子结点，即i有值但2i和2i+1处无值</span><br><span class="line">    int min_1=99999999,min_index=1;</span><br><span class="line">    for(int i=1;i&lt;a.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int cur=a[i];</span><br><span class="line"></span><br><span class="line">        if(cur==-1||cur&gt;min_1) continue;//当前节点无或比记录的值大</span><br><span class="line">        if(a[2*i]==-1&amp;&amp;a[2*i+1]==-1)//如果没有孩子</span><br><span class="line">        &#123;</span><br><span class="line">            min_1=cur;</span><br><span class="line">            min_index=i;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(2*i&gt;a.size())//或者如果左孩子下标超出</span><br><span class="line">        &#123;</span><br><span class="line">            min_1=cur;</span><br><span class="line">            min_index=i;</span><br><span class="line">        &#125;</span><br><span class="line">       // i=i+3;</span><br><span class="line">    &#125;</span><br><span class="line">  //  cout&lt;&lt;min_1&lt;&lt;&quot;,&quot;&lt;&lt;min_index&lt;&lt;&quot;,&quot;&lt;&lt;a[min_index];</span><br><span class="line">  //再逆序从叶子结点找到根节点</span><br><span class="line">  string t=&quot;&quot;;</span><br><span class="line">  while(min_index!=0)</span><br><span class="line">  &#123;</span><br><span class="line">        t+=to_string(a[min_index]);</span><br><span class="line">        if(min_index!=1) t+=&quot; &quot;;</span><br><span class="line">        min_index/=2;</span><br><span class="line">  &#125;</span><br><span class="line">  reverse(t.begin(),t.end());</span><br><span class="line">  cout&lt;&lt;t;   </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="wp2"><a href="#wp2" class="headerlink" title="wp2"></a>wp2</h2><p>来自<a target="_blank" rel="noopener" href="https://wiki.amoscloud.com/">AmosCloud</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">void back(vector&lt;int&gt; a,int minpos,vector&lt;int&gt; &amp;path);</span><br><span class="line">void solution(vector&lt;int&gt; a);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; a;</span><br><span class="line">    a.push_back(0);//先占用一个</span><br><span class="line">    int b;</span><br><span class="line">    while(cin&gt;&gt;b)</span><br><span class="line">    &#123;</span><br><span class="line">        a.push_back(b);</span><br><span class="line">        if(cin.get()==&#x27;\n&#x27;) break;</span><br><span class="line">    &#125;</span><br><span class="line">    solution(a);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">void solution(vector&lt;int&gt; a)</span><br><span class="line">&#123;</span><br><span class="line">    int min_1=999999;</span><br><span class="line">    int minpos=1;</span><br><span class="line">    for(int i=1;i&lt;a.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int tmp=a[i];</span><br><span class="line">        if(tmp!=-1&amp;&amp;tmp&lt;min_1&amp;&amp;2*i&gt;a.size())//当前值不为-1，当前值较小，左孩子下标溢出</span><br><span class="line">        &#123;</span><br><span class="line">            //叶子结点</span><br><span class="line">            min_1=tmp;</span><br><span class="line">            minpos=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; path;</span><br><span class="line">    back(a,minpos,path);</span><br><span class="line">    for(int i=path.size()-1;i&gt;=0;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;path[i];</span><br><span class="line">        if(i!=0)</span><br><span class="line">        cout&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void back(vector&lt;int&gt; a,int minpos,vector&lt;int&gt; &amp;path)</span><br><span class="line">&#123;</span><br><span class="line">//从最后的叶子结点倒着找父节点，直到找到根节点</span><br><span class="line">    path.push_back(a[minpos]);</span><br><span class="line">    if(minpos==1) return;</span><br><span class="line">    if(minpos%2==0)//是左孩子，求其父节点</span><br><span class="line">    back(a,minpos/2,path);</span><br><span class="line">    else back(a,(minpos-1)/2,path);//是右孩子，求其父节点</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好吧，不需要真的用结构体来做</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">struct tree</span><br><span class="line">&#123;</span><br><span class="line">    int val;</span><br><span class="line">    tree *left,*right;</span><br><span class="line">    tree():val(-1),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">    tree(int x):val(x),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;tree&gt; node(99999);</span><br><span class="line">void build(int index)</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    cin&gt;&gt;a;</span><br><span class="line">    if(cin.get()==&#x27;\n&#x27;) return;</span><br><span class="line">    node[index]= tree(a);</span><br><span class="line"></span><br><span class="line">    build(2*index);</span><br><span class="line">    build(2*index+1);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int i=1;</span><br><span class="line"></span><br><span class="line">    string line;</span><br><span class="line">  </span><br><span class="line">        build(i); </span><br><span class="line">   </span><br><span class="line">   for(auto a:node)</span><br><span class="line">   cout&lt;&lt;a.val&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="38-考古学家-全排列"><a href="#38-考古学家-全排列" class="headerlink" title="38.考古学家(全排列)"></a>38.考古学家(全排列)</h1><h2 id="题目描述-19"><a href="#题目描述-19" class="headerlink" title="题目描述"></a>题目描述</h2><p>有一个考古学家发现一个石碑<br>但是很可惜 发现时其已经断成多段<br>原地发现<code>N</code>个断口整齐的石碑碎片<br>为了破解石碑内容<br>考古学家希望有程序能帮忙计算复原后的石碑文字组合数</p>
<p>备注： 如果存在石碑碎片内容完全相同，则由于碎片间的顺序不影响复原后的碑文内容，<br>仅相同碎片间的位置变化不影响组合</p>
<h2 id="输入描述-28"><a href="#输入描述-28" class="headerlink" title="输入描述"></a>输入描述</h2><p>第一行输入<code>N</code>，<code>N</code>表示石碑碎片的个数<br>第二行依次输入石碑碎片上的文字内容<code>S</code>共有<code>N</code>组</p>
<h2 id="输出描述-28"><a href="#输出描述-28" class="headerlink" title="输出描述"></a>输出描述</h2><p>输出石碑文字的组合(按照升序排列)，行尾无多余空格</p>
<h2 id="示例一-14"><a href="#示例一-14" class="headerlink" title="示例一"></a>示例一</h2><h3 id="输入-23"><a href="#输入-23" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">a b c</span><br></pre></td></tr></table></figure>

<h3 id="输出-22"><a href="#输出-22" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">abc</span><br><span class="line">acb</span><br><span class="line">bac</span><br><span class="line">bca</span><br><span class="line">cab</span><br><span class="line">cba</span><br></pre></td></tr></table></figure>

<h2 id="个人代码-18"><a href="#个人代码-18" class="headerlink" title="个人代码"></a>个人代码</h2><p><strong>回溯算法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">set&lt;string&gt; list;</span><br><span class="line">string result=&quot;&quot;;</span><br><span class="line">void back(vector&lt;string&gt; &amp;s,int start,int end)</span><br><span class="line">&#123;</span><br><span class="line">    if(start==end) </span><br><span class="line">    &#123;</span><br><span class="line">       for(auto a:s)</span><br><span class="line">          result+=a;</span><br><span class="line">         //  cout&lt;&lt;a;</span><br><span class="line">        </span><br><span class="line">        list.insert(result);</span><br><span class="line">         result=&quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=start;i&lt;=end;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(s[start],s[i]);//第一次s[0]与s[0]</span><br><span class="line">        back(s,start+1,end);</span><br><span class="line">        swap(s[start],s[i]);//还原</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //全排列</span><br><span class="line">    int n;</span><br><span class="line">    vector&lt;string&gt; s(n);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    //cin.ignore();</span><br><span class="line">    string t;</span><br><span class="line">    while(cin&gt;&gt;t)</span><br><span class="line">    &#123;</span><br><span class="line">    s.push_back(t);</span><br><span class="line">    if(cin.get()==&#x27;\n&#x27;) break; //所以是一行输完</span><br><span class="line">    &#125;</span><br><span class="line">    // for(auto list:s)</span><br><span class="line">    // cout&lt;&lt;list&lt;&lt;&quot;,&quot;;</span><br><span class="line">    back(s,0,s.size()-1);</span><br><span class="line">    //排序</span><br><span class="line">    //去重 set</span><br><span class="line">    for(auto a:list)</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="39-解压报文"><a href="#39-解压报文" class="headerlink" title="39*解压报文"></a>39*解压报文</h1><p>为了提升数据传输的效率，会对传输的报文进行压缩处理。输入一个压缩后的报文，请返回它解压后的原始报文。<br>压缩规则：n[str]，表示方括号内部的 str 正好重复 n 次。注意 n 为正整数（0 &lt; n &lt;&#x3D; 100），str只包含小写英文字母，不考虑异常情况。<br>“ “输入描述:<br>输入压缩后的报文：<br>1）不考虑无效的输入，报文没有额外的空格，方括号总是符合格式要求的；<br>2）原始报文不包含数字，所有的数字只表示重复的次数 n ，例如不会出现像 5b 或 3[8] 的输入；<br>输出描述:<br>解压后的原始报文<br>注：<br>1）原始报文长度不会超过1000，不考虑异常的情况<br>示例1<br>输入<br>3[k]2[mn]<br>输出<br>kkkmnmn</p>
<h2 id="个人代码（有误）-2"><a href="#个人代码（有误）-2" class="headerlink" title="个人代码（有误）"></a>个人代码（有误）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"> string s;</span><br><span class="line">  cin&gt;&gt;s;</span><br><span class="line">  stack&lt;string&gt; wu;</span><br><span class="line"> // string t=&quot;&quot;;</span><br><span class="line">  int index=0;</span><br><span class="line">  for(int i=0;i&lt;s.size();i++)</span><br><span class="line">  &#123;</span><br><span class="line">    //cout&lt;&lt;s[i-1]&lt;&lt;endl;</span><br><span class="line">       char t=s[i];</span><br><span class="line">      if(t==&#x27;[&#x27;)//左边可能是数字</span><br><span class="line">      &#123;</span><br><span class="line">          wu.push(s.substr(index,i-index));</span><br><span class="line">          index=i+1;</span><br><span class="line">        //  cout&lt;&lt;t;</span><br><span class="line">        //  t=&quot;&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">    if(t==&#x27;]&#x27;)//字母</span><br><span class="line">    &#123;</span><br><span class="line">        string t=s.substr(index,i-index);</span><br><span class="line">        string qianzhui=wu.top();//比如k2</span><br><span class="line">        cout&lt;&lt;qianzhui&lt;&lt;endl;</span><br><span class="line">        wu.pop();//弹出k2</span><br><span class="line">        string num=&quot;&quot;,zimu=&quot;&quot;;</span><br><span class="line">        //找出重复次数</span><br><span class="line">        for(int i=0;i&lt;qianzhui.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(isdigit(qianzhui[i]))</span><br><span class="line">                num+=qianzhui[i];</span><br><span class="line">            else zimu+=qianzhui[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //if(zimu.size()!=0) wu.push(zimu);</span><br><span class="line">      //  cout&lt;&lt;zimu&lt;&lt;endl;</span><br><span class="line">      if(j.size()!=0)</span><br><span class="line">      &#123;</span><br><span class="line">        int j=stoi(num);</span><br><span class="line">       </span><br><span class="line">        cout&lt;&lt;j;</span><br><span class="line">        </span><br><span class="line">        string result=&quot;&quot;;</span><br><span class="line">        while(j&gt;0)</span><br><span class="line">        &#123;</span><br><span class="line">          result+=t;</span><br><span class="line">          //t+=t; 不可取</span><br><span class="line">          j--;</span><br><span class="line">        &#125;</span><br><span class="line">       //  return 0;</span><br><span class="line">     //   cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">     if(zimu.size()!=0) result=zimu+result;</span><br><span class="line">        wu.push(result);</span><br><span class="line">      &#125;</span><br><span class="line">        </span><br><span class="line">       </span><br><span class="line">        index=i+1;</span><br><span class="line">    &#125;</span><br><span class="line">    //   else if(s[i]==&#x27;]&#x27;)</span><br><span class="line">    //   &#123;</span><br><span class="line">    //       wu.pop();//此时还是[，字母还没放进去，t就是字母</span><br><span class="line">    //       int num=stoi(wu.top());</span><br><span class="line">    //       while(num&gt;1)//重复num次</span><br><span class="line">    //       &#123;</span><br><span class="line">    //          t+=t;</span><br><span class="line">    //          num--;</span><br><span class="line">    //       &#125;</span><br><span class="line">    //       wu.pop();//弹出数字</span><br><span class="line">    //       cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">    //       wu.push(t);</span><br><span class="line">    //       t=&quot;&quot;;</span><br><span class="line">    //   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   while(!wu.empty())</span><br><span class="line">   &#123;</span><br><span class="line">       cout&lt;&lt;wu.top()&lt;&lt;endl;</span><br><span class="line">       wu.pop();</span><br><span class="line">   &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>3[km23[a]]<br>km23<br>23aaaaaaaaaaaaaaaaaaaaaaa<br>terminate called after throwing an instance of ‘std::invalid_argument’<br>  what():  stoi</p>
</blockquote>
<p>3[kmaaa..aa]又遇到了]，所以wu.top()即kmaaa..a当做了数字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">  string s;</span><br><span class="line">  cin&gt;&gt;s;</span><br><span class="line">  stack&lt;string&gt; cishu;</span><br><span class="line">  stack&lt;string&gt; zifu;//记录[]以外的值</span><br><span class="line"> // string t=&quot;&quot;;</span><br><span class="line">  int index=0;</span><br><span class="line">  for(int i=0;i&lt;s.size();i++)</span><br><span class="line">  &#123;</span><br><span class="line">    //cout&lt;&lt;s[i-1]&lt;&lt;endl;</span><br><span class="line">       char t=s[i];</span><br><span class="line">      if(t==&#x27;[&#x27;)//左边可能是数字</span><br><span class="line">      &#123;</span><br><span class="line">          cishu.push(s.substr(index,i-index));</span><br><span class="line">          </span><br><span class="line">          index=i+1;</span><br><span class="line">        //  cout&lt;&lt;t;</span><br><span class="line">        //  t=&quot;&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">    if(t==&#x27;]&#x27;)//字母</span><br><span class="line">    &#123;</span><br><span class="line">     </span><br><span class="line">      cout&lt;&lt;index&lt;&lt;&quot;,&quot;&lt;&lt;i-index&lt;&lt;endl;</span><br><span class="line">       // if(i-index!=0)//不是最后一个]</span><br><span class="line">        string t=s.substr(index,i-index);</span><br><span class="line">        if(i-index==0)</span><br><span class="line">        &#123;</span><br><span class="line">        t=zifu.top();</span><br><span class="line">        zifu.pop();</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">     </span><br><span class="line">     //   cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">        string qianzhui=cishu.top();//比如k2</span><br><span class="line">   //     cout&lt;&lt;qianzhui&lt;&lt;endl;</span><br><span class="line">        cishu.pop();//弹出k2</span><br><span class="line">        string num=&quot;&quot;,zimu=&quot;&quot;;</span><br><span class="line">        //找出重复次数</span><br><span class="line">        for(int i=0;i&lt;qianzhui.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(isdigit(qianzhui[i]))</span><br><span class="line">                num+=qianzhui[i];</span><br><span class="line">            else zimu+=qianzhui[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //if(zimu.size()!=0) wu.push(zimu);</span><br><span class="line">      //  cout&lt;&lt;zimu&lt;&lt;endl;</span><br><span class="line">        int j=stoi(num);</span><br><span class="line">     //  cout&lt;&lt;j&lt;&lt;endl;</span><br><span class="line">       // cout&lt;&lt;j;</span><br><span class="line">        </span><br><span class="line">        string result=&quot;&quot;;</span><br><span class="line">        while(j&gt;0)</span><br><span class="line">        &#123;</span><br><span class="line">          result+=t;</span><br><span class="line">          //t+=t; 不可取</span><br><span class="line">          j--;</span><br><span class="line">        &#125;</span><br><span class="line">       //  return 0;</span><br><span class="line">     //   cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">     if(zimu.size()!=0) result=zimu+result;</span><br><span class="line">        zifu.push(result);</span><br><span class="line"></span><br><span class="line">          index=i+1;</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">  &#125;</span><br><span class="line">   while(!zifu.empty())</span><br><span class="line">   &#123;</span><br><span class="line">       cout&lt;&lt;zifu.top()&lt;&lt;endl;</span><br><span class="line">       zifu.pop();</span><br><span class="line">   &#125;</span><br><span class="line">    while(!cishu.empty())</span><br><span class="line">   &#123;</span><br><span class="line">       cout&lt;&lt;cishu.top()&lt;&lt;endl;</span><br><span class="line">       cishu.pop();</span><br><span class="line">   &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"> string s;</span><br><span class="line">  cin&gt;&gt;s;</span><br><span class="line">  stack&lt;string&gt; cishu;//记录[左边的值</span><br><span class="line">  stack&lt;string&gt; zifu;//记录[]中间的值</span><br><span class="line"> // string t=&quot;&quot;;</span><br><span class="line">  int index=0;</span><br><span class="line">  for(int i=0;i&lt;s.size();i++)</span><br><span class="line">  &#123;</span><br><span class="line">    //cout&lt;&lt;s[i-1]&lt;&lt;endl;</span><br><span class="line">       char t=s[i];</span><br><span class="line">      if(t==&#x27;[&#x27;)//左边可能是数字</span><br><span class="line">      &#123;</span><br><span class="line">          cishu.push(s.substr(index,i-index));</span><br><span class="line">          </span><br><span class="line">          index=i+1;</span><br><span class="line">        //  cout&lt;&lt;t;</span><br><span class="line">        //  t=&quot;&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">    if(t==&#x27;]&#x27;)//字母</span><br><span class="line">    &#123;</span><br><span class="line">     </span><br><span class="line">    //  cout&lt;&lt;index&lt;&lt;&quot;,&quot;&lt;&lt;i-index&lt;&lt;endl;</span><br><span class="line">       // if(i-index!=0)//不是最后一个]</span><br><span class="line">        string t=s.substr(index,i-index);//bug利用1</span><br><span class="line">        // if(i-index==0)</span><br><span class="line">        // &#123;</span><br><span class="line">        // t=zifu.top();</span><br><span class="line">        // zifu.pop();</span><br><span class="line">        // &#125;</span><br><span class="line">      </span><br><span class="line">     </span><br><span class="line">     //   cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">        string qianzhui=cishu.top();//比如k2</span><br><span class="line">   //     cout&lt;&lt;qianzhui&lt;&lt;endl;</span><br><span class="line">        if(cishu.size()&gt;1)</span><br><span class="line">        cishu.pop();// bug利用2</span><br><span class="line">        string num=&quot;&quot;,zimu=&quot;&quot;;</span><br><span class="line">        //找出重复次数</span><br><span class="line">        for(int i=0;i&lt;qianzhui.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(isdigit(qianzhui[i]))</span><br><span class="line">                num+=qianzhui[i];</span><br><span class="line">            else zimu+=qianzhui[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //if(zimu.size()!=0) wu.push(zimu);</span><br><span class="line">      //  cout&lt;&lt;zimu&lt;&lt;endl;</span><br><span class="line">        int j=stoi(num);</span><br><span class="line">     //  cout&lt;&lt;j&lt;&lt;endl;</span><br><span class="line">       // cout&lt;&lt;j;</span><br><span class="line">        </span><br><span class="line">        string result=&quot;&quot;;</span><br><span class="line">        while(j&gt;0)</span><br><span class="line">        &#123;</span><br><span class="line">          result+=t;</span><br><span class="line">          //t+=t; 不可取</span><br><span class="line">          j--;</span><br><span class="line">        &#125;</span><br><span class="line">       //  return 0;</span><br><span class="line">     //   cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">     if(zimu.size()!=0) result=zimu+result;</span><br><span class="line">        zifu.push(result);</span><br><span class="line"></span><br><span class="line">          index=i+1;</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">  &#125;</span><br><span class="line">    /*有一个bug的利用就是:</span><br><span class="line">    如果没有嵌套的[]，如3[k]2[mn]，zifu栈不会有多余的值</span><br><span class="line">    如果有嵌套的[]，如3[k2[mn]]，zifu栈会有个多余值空值</span><br><span class="line">    因为string t=s.substr(8,0);执行了这个，赋值了空值</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    s=&quot;&quot;;</span><br><span class="line">    int flag=-1;</span><br><span class="line">   while(!zifu.empty())</span><br><span class="line">   &#123;</span><br><span class="line">       if(zifu.top()==&quot;&quot;) flag=1;//一旦有嵌套</span><br><span class="line">       s=zifu.top()+s;</span><br><span class="line">       zifu.pop();</span><br><span class="line">   &#125;</span><br><span class="line">   if(flag&gt;0)</span><br><span class="line">   &#123;</span><br><span class="line">     flag=stoi(cishu.top());</span><br><span class="line">     while(flag&gt;0)</span><br><span class="line">     &#123;</span><br><span class="line">        cout&lt;&lt;s;</span><br><span class="line">        flag--;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   else  cout&lt;&lt;s;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>3[k2[m]3[i]2[i2[p]]]<br>kmmiiiippkmmiiiippkmmiiiipp</p>
<p>2[k2[m]3[w2[p]]]<br>kmmwppkmmwpp</p>
<p>多于两层嵌套就有问题</p>
</blockquote>
<h2 id="个人代码2-处理不了非嵌套括号"><a href="#个人代码2-处理不了非嵌套括号" class="headerlink" title="个人代码2(处理不了非嵌套括号)"></a>个人代码2(处理不了非嵌套括号)</h2><p><strong>正则匹配</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;regex&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">regex PATTERN(&quot;\\d+\\[[a-z]+]&quot;);</span><br><span class="line">//  \d匹配数字，+一到无穷个前方元素</span><br><span class="line">// [ [a-z]+ ]  外括号里的内容，匹配a-z</span><br><span class="line">string solution(const string&amp; line) &#123;</span><br><span class="line">    smatch match;</span><br><span class="line">    if (regex_search(line, match, PATTERN)) &#123;</span><br><span class="line">        for(auto a:match)</span><br><span class="line">        cout&lt;&lt;a&lt;&lt;&quot; &quot;;</span><br><span class="line"></span><br><span class="line">        string group = match[0];</span><br><span class="line">        int pos = group.find(&#x27;[&#x27;);</span><br><span class="line">        //重复次数</span><br><span class="line">        int times = stoi(group.substr(0, pos));</span><br><span class="line">       </span><br><span class="line">        int endpos=group.find(&#x27;]&#x27;);</span><br><span class="line">         //待重复字母</span><br><span class="line">        string words = group.substr(pos + 1, endpos-pos-1);</span><br><span class="line">       // cout&lt;&lt;words&lt;&lt;endl;</span><br><span class="line">        //记录重复字符</span><br><span class="line">        string builder;</span><br><span class="line">        for (int i = 0; i &lt; times; i++) &#123;</span><br><span class="line">            builder += words;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //3[m2[k]]</span><br><span class="line">       // string fixed = line.replace(,group.size(),builder);</span><br><span class="line">       string fixed=regex_replace(line,PATTERN,builder);</span><br><span class="line">       //3[mkk]</span><br><span class="line">      // cout&lt;&lt;fixed&lt;&lt;endl;</span><br><span class="line">       if(fixed==line)</span><br><span class="line">       return fixed;</span><br><span class="line">    &#125; </span><br><span class="line">     return solution(fixed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string line;</span><br><span class="line">    // = &quot;3[k]2[mn]&quot;</span><br><span class="line">    cin&gt;&gt;line;</span><br><span class="line">    cout&lt;&lt;solution(line) ;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个可以处理非嵌套括号，emmmm</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void solution( string&amp; line) &#123;</span><br><span class="line">    smatch match;</span><br><span class="line">  //  if (regex_search(line, match, PATTERN)) &#123; //它只查找到第一个匹配项就停止</span><br><span class="line">  // 3[k]2[mn] 找到3[k]就完了</span><br><span class="line">  sregex_iterator rit(line.begin(),line.end(),PATTERN);</span><br><span class="line">  sregex_iterator rend;</span><br><span class="line">        while(rit!=rend)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;rit-&gt;str()&lt;&lt;endl;</span><br><span class="line">            rit++;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最终代码-1"><a href="#最终代码-1" class="headerlink" title="最终代码"></a>最终代码</h2><p>问了chatgpt，它说用递归</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">string solution(const string&amp; s, int &amp;i) &#123;</span><br><span class="line">    string result;</span><br><span class="line">    int count=0;</span><br><span class="line">    while(i&lt;s.size())&#123;</span><br><span class="line">        char c=s[i++];</span><br><span class="line"></span><br><span class="line">        if(isdigit(c))</span><br><span class="line">        &#123;</span><br><span class="line">            count=count*10+(c-&#x27;0&#x27;);//妙哇</span><br><span class="line">        &#125;</span><br><span class="line">        else if(isalpha(c))</span><br><span class="line">        &#123;</span><br><span class="line">            result+=c;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(c==&#x27;[&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            string decode=solution(s,i);</span><br><span class="line">            for(int j=0;j&lt;count;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                result+=decode;</span><br><span class="line">            &#125;</span><br><span class="line">            count=0;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(c==&#x27;]&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string line;</span><br><span class="line">    // = &quot;3[k]2[mn]&quot;</span><br><span class="line">    //3[k2[mn]]</span><br><span class="line">   cin&gt;&gt;line;</span><br><span class="line">   int index=0;</span><br><span class="line">   cout&lt;&lt;solution(line,index);//不能直接赋值0</span><br><span class="line">  </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cout一下过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">string solution(const string&amp; s, int &amp;i) &#123;</span><br><span class="line">    string result;</span><br><span class="line">    int count=0;</span><br><span class="line">    while(i&lt;s.size())&#123;</span><br><span class="line">        char c=s[i++];</span><br><span class="line">        cout&lt;&lt;&quot;第&quot;&lt;&lt;i&lt;&lt;&quot;个字符&quot;&lt;&lt;endl;</span><br><span class="line">        if(isdigit(c))</span><br><span class="line">        &#123;</span><br><span class="line">            count=count*10+(c-&#x27;0&#x27;);</span><br><span class="line">            cout&lt;&lt;&quot;遇到了字符:&quot;&lt;&lt;c&lt;&lt;&quot;变成数字 &quot;&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(isalpha(c))</span><br><span class="line">        &#123;</span><br><span class="line">            result+=c;</span><br><span class="line">             cout&lt;&lt;&quot;遇到了字符:&quot;&lt;&lt;c&lt;&lt;&quot;加和字母 &quot;&lt;&lt;result&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(c==&#x27;[&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;&quot;遇到了[ : &quot;&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;&quot;递归调用solution(s,i)&quot;&lt;&lt;&quot; 此时i为 &quot;&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">            string decode=solution(s,i);</span><br><span class="line">            cout&lt;&lt;&quot;调用后的 decode 为:&quot;&lt;&lt;decode&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">              cout&lt;&lt;&quot;经过count &quot;&lt;&lt;count&lt;&lt;&quot;和result &quot;&lt;&lt;result;</span><br><span class="line">            for(int j=0;j&lt;count;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                result+=decode;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;&quot;处理后的result为 &quot;&lt;&lt;result&lt;&lt;endl;</span><br><span class="line">            count=0;</span><br><span class="line">            cout&lt;&lt;&quot;count归零&quot;&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(c==&#x27;]&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;&quot;遇到了] :&quot;&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;&quot;return result &quot;&lt;&lt;result&lt;&lt;endl;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;&quot;循环完毕，return result &quot;&lt;&lt;result&lt;&lt;endl;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p>3[k2[mn]]<br>第1个字符<br>遇到了字符:3变成数字 3<br>第2个字符<br>遇到了[ :<br>递归调用solution(s,i) 此时i为 2<br>第3个字符<br>遇到了字符:k加和字母 k<br>第4个字符<br>遇到了字符:2变成数字 2<br>第5个字符<br>遇到了[ :<br>递归调用solution(s,i) 此时i为 5<br>第6个字符<br>遇到了字符:m加和字母 m<br>第7个字符<br>遇到了字符:n加和字母 mn<br>第8个字符<br>遇到了] :<br>return result mn<br>调用后的 decode 为:mn<br>经过count 2和result k处理后的result为 kmnmn<br>count归零<br>第9个字符<br>遇到了] :<br>return result kmnmn<br>调用后的 decode 为:kmnmn<br>经过count 3和result 处理后的result为 kmnmnkmnmnkmnmn<br>count归零<br>循环完毕，return result kmnmnkmnmnkmnmn<br>kmnmnkmnmnkmnmn</p>
</blockquote>
<blockquote>
<p>3[k]2[mn]<br>第1个字符<br>遇到了字符:3变成数字 3<br>第2个字符<br>遇到了[ :<br>递归调用solution(s,i) 此时i为 2<br>第3个字符<br>遇到了字符:k加和字母 k<br>第4个字符<br>遇到了] :<br>return result k<br>调用后的 decode 为:k<br>经过count 3和result 处理后的result为 kkk<br>count归零<br>第5个字符<br>遇到了字符:2变成数字 2<br>第6个字符<br>遇到了[ :<br>递归调用solution(s,i) 此时i为 6<br>第7个字符<br>遇到了字符:m加和字母 m<br>第8个字符<br>遇到了字符:n加和字母 mn<br>第9个字符<br>遇到了] :<br>return result mn<br>调用后的 decode 为:mn<br>经过count 2和result kkk处理后的result为 kkkmnmn<br>count归零<br>循环完毕，return result kkkmnmn<br>kkkmnmn</p>
</blockquote>
<p>注意的点：</p>
<blockquote>
<p>1.参数为int &amp;n，实参不能直接给数字，需要通过一个变量声明</p>
<p>2.const int &amp;n，虽然可以解决上述问题，但是，如果只能对n只读访问了，不可修改</p>
</blockquote>
<h1 id="40-最长的元音字符串"><a href="#40-最长的元音字符串" class="headerlink" title="40.最长的元音字符串"></a>40.最长的元音字符串</h1><h2 id="题目描述-20"><a href="#题目描述-20" class="headerlink" title="题目描述"></a>题目描述</h2><p>定义当一个字符串只有元音字母<code>(a,e,i,o,u,A,E,I,O,U)</code>组成,<br>称为元音字符串，现给定一个字符串，请找出其中最长的元音字符串，<br>并返回其长度，如果找不到请返回<code>0</code>，<br>字符串中任意一个连续字符组成的子序列称为该字符串的子串</p>
<h2 id="输入描述-29"><a href="#输入描述-29" class="headerlink" title="输入描述"></a>输入描述</h2><p>一个字符串其长度 <code>0 &lt; length</code> ,字符串仅由字符<code>a-z</code>或<code>A-Z</code>组成</p>
<h2 id="输出描述-29"><a href="#输出描述-29" class="headerlink" title="输出描述"></a>输出描述</h2><p>一个整数，表示最长的元音字符子串的长度</p>
<h2 id="示例一-15"><a href="#示例一-15" class="headerlink" title="示例一"></a>示例一</h2><h3 id="输入-24"><a href="#输入-24" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asdbuiodevauufgh</span><br></pre></td></tr></table></figure>

<h3 id="输出-23"><a href="#输出-23" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<h2 id="个人代码-19"><a href="#个人代码-19" class="headerlink" title="个人代码"></a>个人代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> vector&lt;char&gt; yuanyin=&#123;&#x27;a&#x27;,&#x27;e&#x27;,&#x27;i&#x27;,&#x27;o&#x27;,&#x27;u&#x27;,&#x27;A&#x27;,&#x27;E&#x27;,&#x27;I&#x27;,&#x27;O&#x27;,&#x27;U&#x27;&#125;;</span><br><span class="line"> string s;</span><br><span class="line"> cin&gt;&gt;s;</span><br><span class="line"></span><br><span class="line">int len=0,co=0,flag=-1;</span><br><span class="line"> for(int i=0;i&lt;s.size();i++)</span><br><span class="line"> &#123;</span><br><span class="line"></span><br><span class="line">    char cur=s[i];</span><br><span class="line">    for(auto a:yuanyin)</span><br><span class="line">    &#123;</span><br><span class="line">        if(cur==a)</span><br><span class="line">        &#123;</span><br><span class="line">           flag=1;</span><br><span class="line">           break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(flag&gt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        co++;</span><br><span class="line">        len=max(len,co);</span><br><span class="line">        flag=-9;</span><br><span class="line">    &#125;</span><br><span class="line">    else co=0;</span><br><span class="line"> &#125;</span><br><span class="line"> cout&lt;&lt;len;</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="41-删除目录"><a href="#41-删除目录" class="headerlink" title="41.*删除目录"></a>41.*删除目录</h1><h2 id="题目描述-21"><a href="#题目描述-21" class="headerlink" title="题目描述"></a>题目描述</h2><p>某文件系统中有N个目录，<br>每个目录都一个独一无二的ID。<br>每个目录只有一个父目录，<br>但每个目录下可以有零个或多个子目录，<br>目录结构呈树状结构。<br>假设 根目录的ID为<code>0</code>，且根目录没有父目录<br>ID用唯一的正整数表示，并统一编号<br>现给定目录ID和其付目录ID的对应父子关系表<br><code>[子目录ID,父目录ID]</code>，以及一个待删除的目录ID，<br>请计算并返回一个ID序列，<br>表示因为删除指定目录后剩下的所有目录，<br>返回的ID序列以递增序输出<br>注意：<br>1、被删除的目录或文件编号一定在输入的ID序列中；<br>2、当一个目录删除时，它所有的子目录都会被删除。</p>
<h2 id="输入描述-30"><a href="#输入描述-30" class="headerlink" title="输入描述"></a>输入描述</h2><p>输入的第一行为父子关系表的长度<code>m</code>；接下来的<code>m</code>行为<code>m</code>个父子关系对；<br>最后一行为待删除的ID。<br>序列中的元素以空格分割，<br>参见样例。</p>
<h2 id="输出描述-30"><a href="#输出描述-30" class="headerlink" title="输出描述"></a>输出描述</h2><p>输出一个序列，表示因为删除指定目录后，剩余的目录ID。</p>
<h2 id="示例一-16"><a href="#示例一-16" class="headerlink" title="示例一"></a>示例一</h2><h3 id="输入-25"><a href="#输入-25" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">8 6</span><br><span class="line">10 8</span><br><span class="line">6 0</span><br><span class="line">20 8</span><br><span class="line">2 6</span><br><span class="line">8</span><br></pre></td></tr></table></figure>

<h3 id="输出-24"><a href="#输出-24" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 6</span><br></pre></td></tr></table></figure>

<h2 id="个人代码-20"><a href="#个人代码-20" class="headerlink" title="个人代码"></a>个人代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">set&lt;int&gt; list;</span><br><span class="line">void zimulu(int a,map&lt;int,int&gt; s)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    for(auto sm:s) </span><br><span class="line">    &#123;</span><br><span class="line">        //</span><br><span class="line">        //</span><br><span class="line">        if(sm.second!=a&amp;&amp;sm.second!=0&amp;&amp;sm.first==a) list.insert(sm.second);</span><br><span class="line">        if(sm.second!=a&amp;&amp;sm.first!=a) list.insert(sm.first);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //[子，父]</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    map&lt;int,int&gt; mp;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        mp[a]=b;</span><br><span class="line">    &#125;</span><br><span class="line">    int m;//待删除目录ID</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    zimulu(m,mp);</span><br><span class="line"></span><br><span class="line">    for(auto w:list)</span><br><span class="line">    &#123;</span><br><span class="line">         cout&lt;&lt;w&lt;&lt;&quot; &quot;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    //cout&lt;&lt;w.first&lt;&lt;&quot;,&quot;&lt;&lt;w.second&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="42-吃火锅"><a href="#42-吃火锅" class="headerlink" title="42.吃火锅"></a>42.吃火锅</h1><h2 id="题目描述-22"><a href="#题目描述-22" class="headerlink" title="题目描述"></a>题目描述</h2><p>入职后，导师会请你吃饭，你选择了火锅，<br>火锅里会在不同时间下很多菜，<br>不同食材要煮不同时间，才能变得刚好合适，<br>你希望吃到最多的刚好合适的菜，<br>但是你的手速不够快用<code>m</code>代替手速，<br>每次下手捞菜后至少要过<code>m</code>秒，<br>才能再捞（每次只能捞一个）那么用最合理的策略，<br>最多能吃到多少，刚好合适的菜</p>
<h2 id="输入描述-31"><a href="#输入描述-31" class="headerlink" title="输入描述"></a>输入描述</h2><p>第一行两个整数<code>n</code>，<code>m</code><br>其中<code>n</code>代表往锅里下菜的个数<br><code>m</code>代表手速<br>接下来有<code>n</code>行，<br>每行有两个数<code>x</code>，<code>y</code><br>代表第<code>x</code>秒下的菜过<code>y</code>秒才能变得刚好合适（<code>1 &lt; mn &lt; 1000</code>），（<code>1 &lt; xy &lt; 1000</code>）</p>
<h2 id="输出描述-31"><a href="#输出描述-31" class="headerlink" title="输出描述"></a>输出描述</h2><p>输出一个整数代表用最合理的策略，最多能吃到刚好合适的菜的数量</p>
<h2 id="示例一-17"><a href="#示例一-17" class="headerlink" title="示例一"></a>示例一</h2><h3 id="输入-26"><a href="#输入-26" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 1</span><br><span class="line">1 2</span><br><span class="line">2 1</span><br></pre></td></tr></table></figure>

<h3 id="输出-25"><a href="#输出-25" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<h2 id="个人代码（待测试）"><a href="#个人代码（待测试）" class="headerlink" title="个人代码（待测试）"></a>个人代码（待测试）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m;//菜的个数，手速</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    vector&lt;pair&lt;int,int&gt; &gt;a(n);</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int b,c;</span><br><span class="line">        cin&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        a[i]=make_pair(b,c);//第bs的菜要cs才能吃</span><br><span class="line">    &#125;</span><br><span class="line">    //那就是看间隔咯？ b+c与之前的相减,&gt;=m那就是可以咯</span><br><span class="line">    int pre=a[0].first+a[0].second;</span><br><span class="line">    </span><br><span class="line">    int co=0;</span><br><span class="line">      for(auto list:a)</span><br><span class="line">    &#123;</span><br><span class="line">        int cur=list.second+list.first;</span><br><span class="line">        if(cur-pre&gt;=m) co++;</span><br><span class="line">        pre=cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;co+1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="65-服务器广播"><a href="#65-服务器广播" class="headerlink" title="65.服务器广播"></a>65.服务器广播</h1><h2 id="题目描述-23"><a href="#题目描述-23" class="headerlink" title="题目描述"></a>题目描述</h2><p>服务器连接方式包括直接相连，间接连接。<br><code>A</code>和<code>B</code>直接连接，<code>B</code>和<code>C</code>直接连接，则<code>A</code>和<code>C</code>间接连接。<br>直接连接和间接连接都可以发送广播。<br>给出一个<code>N*N</code>数组，代表<code>N</code>个服务器，<code>matrix[i][j] == 1</code>，<br>则代表<code>i</code>和<code>j</code>直接连接；不等于1时，代表<code>i</code>和<code>j</code>不直接连接。<br><code>matrix[i][i] == 1</code>，<br>即自己和自己直接连接。<code>matrix[i][j] == matrix[j][i]</code>。<br>计算初始需要给几台服务器广播，<br>才可以使每个服务器都收到广播。</p>
<h2 id="输入描述-32"><a href="#输入描述-32" class="headerlink" title="输入描述"></a>输入描述</h2><p>输入为<code>N</code>行，每行有<code>N</code>个数字，为<code>0</code>或<code>1</code>，由空格分隔，<br>构成<code>N*N</code>的数组，<code>N</code>的范围为 <code>1 &lt;= N &lt;= 40</code></p>
<h2 id="输出描述-32"><a href="#输出描述-32" class="headerlink" title="输出描述"></a>输出描述</h2><p>输出一个数字，为需要广播的服务器的数量</p>
<h2 id="示例一-18"><a href="#示例一-18" class="headerlink" title="示例一"></a>示例一</h2><h3 id="输入-27"><a href="#输入-27" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 0 0</span><br><span class="line">0 1 0</span><br><span class="line">0 0 1</span><br></pre></td></tr></table></figure>

<p>Copy</p>
<h3 id="输出-26"><a href="#输出-26" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<h2 id="代码-有误"><a href="#代码-有误" class="headerlink" title="代码(有误)"></a>代码(有误)</h2><p>本质是映射map&lt;int,vector&lt;int&gt;&gt; 0,1,2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void solution(int **a,int n)</span><br><span class="line">&#123;</span><br><span class="line">   /*</span><br><span class="line">   0 1</span><br><span class="line">   1 0</span><br><span class="line">   */</span><br><span class="line">  map&lt;int,vector&lt;int&gt; &gt;mp;</span><br><span class="line">  int mpkey=0;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">   &#123;</span><br><span class="line">    cout&lt;&lt;&quot;now &quot;&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">    bool isexist=false;</span><br><span class="line">    for(auto &amp;item:mp)//加个&amp;，表示可修改</span><br><span class="line">    for(int &amp;it:item.second)</span><br><span class="line">    &#123;</span><br><span class="line">        if(it==i)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;it&lt;&lt;endl;</span><br><span class="line">            isexist=true;</span><br><span class="line">            mpkey=item.first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!isexist)//不包含，新开一项</span><br><span class="line">    &#123;</span><br><span class="line">      //  vector&lt;int&gt; list;</span><br><span class="line">        mp[i]= vector&lt;int&gt;();</span><br><span class="line">        mpkey=i;</span><br><span class="line">        cout&lt;&lt;&quot;now key&quot;&lt;&lt;mpkey&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int k=i;k&lt;n;k++)</span><br><span class="line">    &#123;</span><br><span class="line">       // vector&lt;int&gt; tem;</span><br><span class="line">        if(i!=k &amp;&amp; a[i][k]==1)</span><br><span class="line">        &#123;</span><br><span class="line">             mp[mpkey].push_back(k);</span><br><span class="line">           // tem.push_back(k);</span><br><span class="line">        &#125;</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   cout&lt;&lt;mp.size();</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s,t;</span><br><span class="line">    vector&lt;int&gt; a;</span><br><span class="line">    getline(cin,s);</span><br><span class="line">    cout&lt;&lt;s.size()&lt;&lt;endl;</span><br><span class="line">    for(int i=0;i&lt;s.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(s[i]!=&#x27; &#x27;) a.push_back(s[i]-&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    int n=a.size();//n维</span><br><span class="line">    cout&lt;&lt;a.size()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    //int an[n][n];</span><br><span class="line">    int **an=new int*[n];</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;n;i++)// 第一行</span><br><span class="line">        an[0][i]=a[i];</span><br><span class="line">    for(int i=1;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        string t;</span><br><span class="line">        getline(cin,s);</span><br><span class="line">        stringstream ss(s);</span><br><span class="line">        int co=0;</span><br><span class="line">        while(getline(ss,t,&#x27; &#x27;))</span><br><span class="line">        &#123;</span><br><span class="line">            an[i][co]=t[0]-&#x27;0&#x27;;</span><br><span class="line">            co++;</span><br><span class="line">            if(co==n) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    solution(an,n);</span><br><span class="line">    // for(int i=0;i&lt;n;i++)</span><br><span class="line">    // &#123;</span><br><span class="line">    //     for(int j=0;j&lt;n;j++)</span><br><span class="line">    //     cout&lt;&lt;an[i][j]&lt;&lt;&quot;,&quot;;</span><br><span class="line"></span><br><span class="line">    //     cout&lt;&lt;endl;</span><br><span class="line">    // &#125;</span><br><span class="line">   </span><br><span class="line">    /*</span><br><span class="line">    a[i][j]即a[j][i]为1表示直接相连 a[i][i]自己相连</span><br><span class="line">    </span><br><span class="line">    既然是广播，那就是第一行与每一列</span><br><span class="line">    */</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="66-二叉树广度优先遍历"><a href="#66-二叉树广度优先遍历" class="headerlink" title="66.二叉树广度优先遍历"></a>66.二叉树广度优先遍历</h1><p>即层序遍历。</p>
<p>从上到下，从左到右依次打印出来，就是ABCDEFG。</p>
<p>实现思路，用队列实现。A入队，从根结点开始。接着A的两个孩子不空，BC入队（A出队，队头指向B）；然后B的两个孩子DE入队，B出队，队头指向C；C的两个孩子FG进入，C出队；最后将DEFG输出。</p>
<p>深度优先遍历就是，前中后序遍历</p>
<h1 id="67-找单词"><a href="#67-找单词" class="headerlink" title="67.找单词"></a>67.找单词</h1><h2 id="题目描述-24"><a href="#题目描述-24" class="headerlink" title="题目描述"></a>题目描述</h2><p>给一个字符串和一个二维字符数组，如果该字符串存在于该数组中，则按字符串的字符顺序输出字符串每个字符所在单元格的位置下标字符串，如果找不到返回字符串<code>N</code>。</p>
<ol>
<li>需要按照字符串的字符组成顺序搜索，且搜索到的位置必须是相邻单元格，其中“相邻单元格”是指那些水平相邻或垂直相邻的单元格。</li>
<li>同一个单元格内的字母不允许被重复使用。</li>
<li>假定在数组中最多只存在一个可能的匹配。</li>
</ol>
<h2 id="输入描述-33"><a href="#输入描述-33" class="headerlink" title="输入描述"></a>输入描述</h2><ol>
<li>第1行为一个数字<code>N</code>指示二维数组在后续输入所占的行数。</li>
<li>第2行到第<code>N+1</code>行输入为一个二维大写字符数组，每行字符用半角,分割。</li>
<li>第<code>N+2</code>行为待查找的字符串，由大写字符组成。</li>
<li>二维数组的大小为<code>N*N</code>，<code>0 &lt; N &lt;= 100</code>。</li>
<li>单词长度<code>K</code>，<code>0 &lt; K &lt; 1000</code>。</li>
</ol>
<h2 id="输出描述-33"><a href="#输出描述-33" class="headerlink" title="输出描述"></a>输出描述</h2><p>输出一个位置下标字符串，拼接格式为：第1个字符行下标+”,”+第1个字符列下标+”,”+第2个字符行下标+”,”+第2个字符列下标…+”,”+第N个字符行下标+”,”+第N个字符列下标示例1</p>
<h2 id="示例一-19"><a href="#示例一-19" class="headerlink" title="示例一"></a>示例一</h2><h3 id="输入-28"><a href="#输入-28" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">A,C,C,F</span><br><span class="line">C,D,E,D</span><br><span class="line">B,E,S,S</span><br><span class="line">F,E,C,A</span><br><span class="line">ACCESS</span><br></pre></td></tr></table></figure>

<h3 id="输出-27"><a href="#输出-27" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0,0,0,1,0,2,1,2,2,2,2,3</span><br></pre></td></tr></table></figure>

<h2 id="代码1（不符题意）"><a href="#代码1（不符题意）" class="headerlink" title="代码1（不符题意）"></a>代码1（不符题意）</h2><p>哦，这个顺序搜索有说法的</p>
<p>**A,C,C,**F<br>        C,D,**E,**D<br>        B,E,<strong>S</strong>,<strong>S</strong><br>        F,E,C,A<br>ACCESS</p>
<p>反正最终路径有横有折，一点点斜的都不要</p>
<p>这玩意儿想到了什么，走迷宫哇。只能横向，竖向</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    cin.ignore();</span><br><span class="line">    string s,t;</span><br><span class="line">    vector&lt;vector&lt;string&gt; &gt;a(n,vector&lt;string&gt;(n,&quot;&quot;));</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">         cin&gt;&gt;s;</span><br><span class="line">         stringstream ss(s);</span><br><span class="line">         int j=0;</span><br><span class="line">      //   vector&lt;string&gt; aa;</span><br><span class="line">         while(getline(ss,t,&#x27;,&#x27;))</span><br><span class="line">         &#123;</span><br><span class="line">            //aa.push_back(t);</span><br><span class="line">            if(j==n) break;//退出循环</span><br><span class="line">            a[i][j]=t;</span><br><span class="line">           // cout&lt;&lt;j&lt;&lt;endl;</span><br><span class="line">            j++;</span><br><span class="line">          </span><br><span class="line">         &#125;</span><br><span class="line">      //  a.push_back(aa);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // for(int i=0;i&lt;n;i++)</span><br><span class="line">    // &#123;</span><br><span class="line">    //     for(int j=0;j&lt;n;j++)</span><br><span class="line">    // &#123;</span><br><span class="line">    //     cout&lt;&lt;a[i][j];</span><br><span class="line">    // &#125;</span><br><span class="line">    // cout&lt;&lt;endl;</span><br><span class="line">    // &#125;</span><br><span class="line">  </span><br><span class="line">    string tt;</span><br><span class="line">    cin&gt;&gt;tt;</span><br><span class="line"></span><br><span class="line">    int x=0,y=0,i=0,len=tt.size();</span><br><span class="line">    string tem=&quot;&quot;,result=&quot;&quot;;</span><br><span class="line">    while(i&lt;len)</span><br><span class="line">    &#123;</span><br><span class="line">        tem=tt[i];</span><br><span class="line">     //   cout&lt;&lt;a[x][y]&lt;&lt;endl;</span><br><span class="line">        if(a[x][y]==tem)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            // cout&lt;&lt;x&lt;&lt;&quot;,&quot;&lt;&lt;y;</span><br><span class="line">            // if(i!=len-1) cout&lt;&lt;&quot;,&quot;;</span><br><span class="line">            result+=to_string(x)+&quot;,&quot;+to_string(y)+&quot;,&quot;;</span><br><span class="line">            tem=&quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">         y++;//列坐标移动</span><br><span class="line">         if(y==n)</span><br><span class="line">         &#123;</span><br><span class="line">            y=0;</span><br><span class="line">            x++;</span><br><span class="line">         &#125;</span><br><span class="line">       //  if(x==n) break;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    // cout&lt;&lt;a[0][1];</span><br><span class="line">    cout&lt;&lt;result.substr(0,result.size()-1);</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; res;</span><br><span class="line">int check(vector&lt;vector&lt;string&gt; &gt; a,int r,int c,string s,int i)</span><br><span class="line">&#123;</span><br><span class="line">       // int j=a.size();</span><br><span class="line">    string next=&quot;&quot;;</span><br><span class="line">          next=s[i];</span><br><span class="line">        if(r+1&lt;a.size()&amp;&amp;c+1&lt;a.size())</span><br><span class="line">      &#123;</span><br><span class="line">         if(a[r+1][c]==next) return 1;</span><br><span class="line">         else if(a[r][c+1]==next) return 2;</span><br><span class="line">      &#125;</span><br><span class="line">      return 0;</span><br><span class="line">&#125;</span><br><span class="line">void search(vector&lt;vector&lt;string&gt; &gt; a,string s,int row,int col,int i)</span><br><span class="line">&#123;</span><br><span class="line">        if(i&gt;s.size()) </span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      string cur=&quot;&quot;;</span><br><span class="line">      cur+=s[i];</span><br><span class="line"></span><br><span class="line">      if(i==0)</span><br><span class="line">      &#123;</span><br><span class="line">         for(int i=0;i&lt;a.size();i++)</span><br><span class="line">         for(int j=0;j&lt;a.size();j++)</span><br><span class="line">         &#123;</span><br><span class="line">            if(a[i][j]==cur)</span><br><span class="line">            &#123;</span><br><span class="line">               row=i;</span><br><span class="line">               col=j;</span><br><span class="line">               cout&lt;&lt;row&lt;&lt;&quot;,&quot;&lt;&lt;col&lt;&lt;endl;</span><br><span class="line">               break;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      res.push_back(row);</span><br><span class="line">      res.push_back(col);</span><br><span class="line"></span><br><span class="line">          if(check(a,row,col,s,i+1)==1)//往下走</span><br><span class="line">      &#123;</span><br><span class="line">         search(a,s,row+1,col,i+1);</span><br><span class="line">      &#125;  </span><br><span class="line">      else if(check(a,row,col,s,i+1)==2)//往右走</span><br><span class="line">      &#123;</span><br><span class="line">         search(a,s,row,col+1,i+1);</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">   </span><br><span class="line">      //N情况没有考虑</span><br><span class="line">      //有多个首值，第一个首值不一定成功，没有考虑</span><br><span class="line">      //行和列值相同时，先取哪一个没有考虑</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    cin.ignore();</span><br><span class="line">    string s,t;</span><br><span class="line">    vector&lt;vector&lt;string&gt; &gt;a(n,vector&lt;string&gt;(n,&quot;&quot;));</span><br><span class="line">   //vector&lt;string&gt; a(n);</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">         cin&gt;&gt;s;</span><br><span class="line">         stringstream ss(s);</span><br><span class="line">         int j=0;</span><br><span class="line">        // string tt=&quot;&quot;;</span><br><span class="line"></span><br><span class="line">         while(getline(ss,t,&#x27;,&#x27;))</span><br><span class="line">         &#123;</span><br><span class="line">            a[i][j]=t;</span><br><span class="line">            j++;</span><br><span class="line">            if(j&gt;n) break;</span><br><span class="line">          // tt+=t;</span><br><span class="line">         &#125;</span><br><span class="line">      //  a.push_back(tt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   // if(a[0][0]==&#x27;A&#x27;) cout&lt;&lt;&quot;erer&quot;&lt;&lt;endl;</span><br><span class="line">    if(a[0][0]==&quot;A&quot;) cout&lt;&lt;&quot;~~~&quot;&lt;&lt;endl;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    string tt;</span><br><span class="line">    cin&gt;&gt;tt;</span><br><span class="line"></span><br><span class="line">    int x=0,y=0,i=0,len=tt.size();</span><br><span class="line">    string tem=&quot;&quot;,result=&quot;&quot;;</span><br><span class="line">    </span><br><span class="line">    search(a,tt,0,0,0);</span><br><span class="line">   // cout&lt;&lt;a[0][1];</span><br><span class="line">    for(int li:res)</span><br><span class="line">    cout&lt;&lt;li&lt;&lt;&quot;,&quot;;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二维数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  char a[n][n];</span><br><span class="line">   //vector&lt;string&gt; a(n);</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">         cin&gt;&gt;s;</span><br><span class="line">         int j=0;</span><br><span class="line">        for(int k=0;k&lt;s.size();k++)</span><br><span class="line">        &#123;</span><br><span class="line">          if(s[k]!=&#x27;,&#x27;)</span><br><span class="line">          &#123;</span><br><span class="line">            a[i][j]=s[k];</span><br><span class="line">            j++;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      //  a.push_back(tt);</span><br><span class="line">    &#125;</span><br><span class="line">但是作为函数调用的参数，报错的比较多，还是用vector吧</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">A,C,C,F</span><br><span class="line">C,D,E,D</span><br><span class="line">B,E,S,S</span><br><span class="line">F,E,C,A</span><br><span class="line">ACCESS</span><br><span class="line">move to 0,0</span><br><span class="line">now s[i] is A i: 0</span><br><span class="line">move to 1,0</span><br><span class="line">now s[i] is C i: 1</span><br><span class="line">move to 0,1</span><br><span class="line">now s[i] is C i: 1</span><br><span class="line">move to 0,2</span><br><span class="line">now s[i] is C i: 2</span><br><span class="line">move to 1,2</span><br><span class="line">now s[i] is E i: 3</span><br><span class="line">move to 2,2</span><br><span class="line">now s[i] is S i: 4</span><br><span class="line">move to 2,3</span><br><span class="line">now s[i] is S i: 5</span><br><span class="line">move to 3,3</span><br><span class="line">now s[i] is A i: 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">是什么导致这个i，往回去了嘞，我把主函数的双for循环去掉了，没必要，直接从0开始即可</span><br></pre></td></tr></table></figure>

<h2 id="分析阶段"><a href="#分析阶段" class="headerlink" title="分析阶段"></a>分析阶段</h2><h3 id="代码片段1"><a href="#代码片段1" class="headerlink" title="代码片段1"></a>代码片段1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">bool check(vector&lt;vector&lt;char&gt; &gt;a,int row,int col,string s,int i,vector&lt;vector&lt;int&gt; &gt;visit,vector&lt;int&gt; &amp;res)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">      if(a[row][col]!=s[i]) return false;</span><br><span class="line">    //  else  if(i==s.size()-1) return true;这样会导致最后一个不执行的哇</span><br><span class="line">   // else if(i==s.size()-1) return true;//把s的字符都找到了</span><br><span class="line">      if(i==s.size())</span><br><span class="line">      &#123;</span><br><span class="line">         cout&lt;&lt;&quot;end now&quot;&lt;&lt;endl;</span><br><span class="line">         return true;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;&quot;move to &quot;&lt;&lt;row&lt;&lt;&quot;,&quot;&lt;&lt;col&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;&quot;now s[i] is &quot;&lt;&lt;s[i]&lt;&lt;&quot; i: &quot;&lt;&lt;i&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">          res.push_back(row);</span><br><span class="line">          res.push_back(col);</span><br><span class="line">         cout&lt;&lt;&quot;insert &quot;&lt;&lt;row&lt;&lt;&quot;,&quot;&lt;&lt;col&lt;&lt;endl;</span><br><span class="line">         visit[row][col]=1;</span><br><span class="line">        // if(row-1&gt;=0&amp;&amp;a[row-1][col]==s[i+1]&amp;&amp;visit[row-1][col]==0)//上</span><br><span class="line"></span><br><span class="line">        if(row-1&gt;=0&amp;&amp;visit[row-1][col]==0)//上</span><br><span class="line">         &#123;</span><br><span class="line">            check(a,row-1,col,s,i+1,visit,res);</span><br><span class="line"></span><br><span class="line">           // return true;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">       if(row&lt;=a.size()-1&amp;&amp;visit[row+1][col]==0)//下</span><br><span class="line">         &#123;</span><br><span class="line">            check(a,row+1,col,s,i+1,visit,res);</span><br><span class="line">   </span><br><span class="line">           // return true;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">        if(col-1&gt;=0&amp;&amp;visit[row][col-1]==0)//左</span><br><span class="line">         &#123;</span><br><span class="line">            check(a,row,col-1,s,i+1,visit,res);</span><br><span class="line">    </span><br><span class="line">           // return true;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">        if(col&lt;=a.size()-1&amp;&amp;visit[row][col+1]==0)//右</span><br><span class="line">         &#123;</span><br><span class="line">            check(a,row,col+1,s,i+1,visit,res);</span><br><span class="line">      </span><br><span class="line">          //  return true;</span><br><span class="line">         &#125;</span><br><span class="line">/*认为如果res长度够，那就不用回退，</span><br><span class="line">那塔喵取决于字符串长度了*/</span><br><span class="line">      // if(res.size()!=s.size()*2)</span><br><span class="line">     //  &#123;</span><br><span class="line">          res.pop_back();</span><br><span class="line">          res.pop_back();</span><br><span class="line">          cout&lt;&lt;&quot;delete&quot;&lt;&lt;row&lt;&lt;&quot;,&quot;&lt;&lt;col&lt;&lt;endl;</span><br><span class="line">      // &#125;</span><br><span class="line">         </span><br><span class="line">  </span><br><span class="line">         //递归完执行到这里说明走不完</span><br><span class="line">         visit[row][col]=0;</span><br><span class="line">       //  return result;</span><br><span class="line">       return false;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">move to 0,0</span><br><span class="line">now s[i] is A i: 0</span><br><span class="line">move to 1,0</span><br><span class="line">now s[i] is C i: 1</span><br><span class="line">move to 0,1</span><br><span class="line">now s[i] is C i: 1</span><br><span class="line">move to 0,2</span><br><span class="line">now s[i] is C i: 2</span><br><span class="line">move to 1,2</span><br><span class="line">now s[i] is E i: 3</span><br><span class="line">move to 2,2</span><br><span class="line">now s[i] is S i: 4</span><br><span class="line">move to 2,3</span><br><span class="line">now s[i] is S i: 5</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">现在的问题是，全局变量res，加不进去坐标嘞</span><br><span class="line"></span><br><span class="line">详细点</span><br><span class="line">move to 0,0</span><br><span class="line">now s[i] is A i: 0</span><br><span class="line">insert 0,0</span><br><span class="line">move to 1,0</span><br><span class="line">now s[i] is C i: 1</span><br><span class="line">insert 1,0</span><br><span class="line">delete1,0</span><br><span class="line">move to 0,1</span><br><span class="line">now s[i] is C i: 1</span><br><span class="line">insert 0,1</span><br><span class="line">move to 0,2</span><br><span class="line">now s[i] is C i: 2</span><br><span class="line">insert 0,2</span><br><span class="line">move to 1,2</span><br><span class="line">now s[i] is E i: 3</span><br><span class="line">insert 1,2</span><br><span class="line">move to 2,2</span><br><span class="line">now s[i] is S i: 4</span><br><span class="line">insert 2,2</span><br><span class="line">move to 2,3</span><br><span class="line">now s[i] is S i: 5</span><br><span class="line">insert 2,3</span><br><span class="line">delete2,3</span><br><span class="line">delete2,2</span><br><span class="line">delete1,2</span><br><span class="line">delete0,2</span><br><span class="line">delete0,1</span><br><span class="line">delete0,0</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">它这相当于回退完了，按理说都执行i==s.size()，return true了，都终止条件了，为什么还回溯</span><br></pre></td></tr></table></figure>

<p>怎么说呢，当前实例的问题，更深层次的递归达到条件了，它要释放，那么次深层的也要释放，直到第一次递归释放为止，所以要对每一次递归进行判断，而不是只对结果判断，<strong>塔喵的！！</strong></p>
<h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">bool check(vector&lt;vector&lt;char&gt; &gt;a,int row,int col,string s,int i,vector&lt;vector&lt;int&gt; &gt;visit,vector&lt;int&gt; &amp;res)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">      if(a[row][col]!=s[i]) return false;</span><br><span class="line">    //  else  if(i==s.size()-1) return true;这样会导致最后一个不执行的哇</span><br><span class="line">   // else if(i==s.size()-1) return true;//把s的字符都找到了</span><br><span class="line">      if(i==s.size())</span><br><span class="line">      &#123;</span><br><span class="line">         cout&lt;&lt;&quot;end now&quot;&lt;&lt;endl;</span><br><span class="line">         return true;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;&quot;move to &quot;&lt;&lt;row&lt;&lt;&quot;,&quot;&lt;&lt;col&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;&quot;now s[i] is &quot;&lt;&lt;s[i]&lt;&lt;&quot; i: &quot;&lt;&lt;i&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">          res.push_back(row);</span><br><span class="line">          res.push_back(col);</span><br><span class="line">         cout&lt;&lt;&quot;insert &quot;&lt;&lt;row&lt;&lt;&quot;,&quot;&lt;&lt;col&lt;&lt;endl;</span><br><span class="line">         visit[row][col]=1;</span><br><span class="line">        // if(row-1&gt;=0&amp;&amp;a[row-1][col]==s[i+1]&amp;&amp;visit[row-1][col]==0)//上</span><br><span class="line"></span><br><span class="line">        if(row-1&gt;=0&amp;&amp;visit[row-1][col]==0)//上</span><br><span class="line">         &#123;</span><br><span class="line">            if(check(a,row-1,col,s,i+1,visit,res))</span><br><span class="line">               return true;</span><br><span class="line"></span><br><span class="line">           // return true;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">       if(row&lt;=a.size()-1&amp;&amp;visit[row+1][col]==0)//下</span><br><span class="line">         &#123;</span><br><span class="line">           if(check(a,row+1,col,s,i+1,visit,res))</span><br><span class="line">            return true;</span><br><span class="line">   </span><br><span class="line">           // return true;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">        if(col-1&gt;=0&amp;&amp;visit[row][col-1]==0)//左</span><br><span class="line">         &#123;</span><br><span class="line">            if(check(a,row,col-1,s,i+1,visit,res))</span><br><span class="line">            return true;</span><br><span class="line">    </span><br><span class="line">           // return true;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">        if(col&lt;=a.size()-1&amp;&amp;visit[row][col+1]==0)//右</span><br><span class="line">         &#123;</span><br><span class="line">            if(check(a,row,col+1,s,i+1,visit,res))</span><br><span class="line">            return true;</span><br><span class="line">      </span><br><span class="line">          //  return true;</span><br><span class="line">         &#125;</span><br><span class="line">/*认为如果res长度够，那就不用回退，</span><br><span class="line">那塔喵取决于字符串长度了*/</span><br><span class="line">      // if(res.size()!=s.size()*2)</span><br><span class="line">     //  &#123;</span><br><span class="line">          res.pop_back();</span><br><span class="line">          res.pop_back();</span><br><span class="line">          cout&lt;&lt;&quot;delete&quot;&lt;&lt;row&lt;&lt;&quot;,&quot;&lt;&lt;col&lt;&lt;endl;</span><br><span class="line">      // &#125;</span><br><span class="line">         </span><br><span class="line">  </span><br><span class="line">         //递归完执行到这里说明走不完</span><br><span class="line">         visit[row][col]=0;</span><br><span class="line">       //  return result;</span><br><span class="line">       return false;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="错误代码1"><a href="#错误代码1" class="headerlink" title="错误代码1"></a>错误代码1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// vector&lt;int&gt; res1;</span><br><span class="line">bool check(vector&lt;vector&lt;char&gt;&gt; a, int row, int col, string s, int i, vector&lt;vector&lt;int&gt;&gt; visit, vector&lt;int&gt; &amp;res)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   if (a[row][col] != s[i])</span><br><span class="line">      return false;</span><br><span class="line">   //  else  if(i==s.size()-1) return true;这样会导致最后一个不执行的哇</span><br><span class="line">   // else if(i==s.size()-1) return true;//把s的字符都找到了</span><br><span class="line">   if (i == s.size())</span><br><span class="line">   &#123;</span><br><span class="line">      cout &lt;&lt; &quot;end now&quot; &lt;&lt; endl;</span><br><span class="line">      return true;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; &quot;move to &quot; &lt;&lt; row &lt;&lt; &quot;,&quot; &lt;&lt; col &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; &quot;now s[i] is &quot; &lt;&lt; s[i] &lt;&lt; &quot; i: &quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   res.push_back(row);</span><br><span class="line">   res.push_back(col);</span><br><span class="line">   cout &lt;&lt; &quot;insert &quot; &lt;&lt; row &lt;&lt; &quot;,&quot; &lt;&lt; col &lt;&lt; endl;</span><br><span class="line">   visit[row][col] = 1;</span><br><span class="line">   // if(row-1&gt;=0&amp;&amp;a[row-1][col]==s[i+1]&amp;&amp;visit[row-1][col]==0)//上</span><br><span class="line"></span><br><span class="line">   if (row - 1 &gt;= 0 &amp;&amp; visit[row - 1][col] == 0) // 上</span><br><span class="line">   &#123;</span><br><span class="line">      if (check(a, row - 1, col, s, i + 1, visit, res))</span><br><span class="line">         return true;</span><br><span class="line"></span><br><span class="line">      // return true;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (row &lt;= a.size() - 1 &amp;&amp; visit[row + 1][col] == 0) // 下</span><br><span class="line">   &#123;</span><br><span class="line">      if (check(a, row + 1, col, s, i + 1, visit, res))</span><br><span class="line">         return true;</span><br><span class="line"></span><br><span class="line">      // return true;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (col - 1 &gt;= 0 &amp;&amp; visit[row][col - 1] == 0) // 左</span><br><span class="line">   &#123;</span><br><span class="line">      if (check(a, row, col - 1, s, i + 1, visit, res))</span><br><span class="line">         return true;</span><br><span class="line"></span><br><span class="line">      // return true;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (col &lt;= a.size() - 1 &amp;&amp; visit[row][col + 1] == 0) // 右</span><br><span class="line">   &#123;</span><br><span class="line">      if (check(a, row, col + 1, s, i + 1, visit, res))</span><br><span class="line">         return true;</span><br><span class="line"></span><br><span class="line">      //  return true;</span><br><span class="line">   &#125;</span><br><span class="line">   /*认为如果res长度够，那就不用回退，</span><br><span class="line">   那塔喵取决于字符串长度了*/</span><br><span class="line">   // if(res.size()!=s.size()*2)</span><br><span class="line">   //  &#123;</span><br><span class="line">   res.pop_back();</span><br><span class="line">   res.pop_back();</span><br><span class="line">   cout &lt;&lt; &quot;delete&quot; &lt;&lt; row &lt;&lt; &quot;,&quot; &lt;&lt; col &lt;&lt; endl;</span><br><span class="line">   // &#125;</span><br><span class="line"></span><br><span class="line">   // 递归完执行到这里说明走不完</span><br><span class="line">   visit[row][col] = 0;</span><br><span class="line">   //  return result;</span><br><span class="line">   return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   int n;</span><br><span class="line">   cin &gt;&gt; n;</span><br><span class="line">   cin.ignore();</span><br><span class="line">   string s, t;</span><br><span class="line">   vector&lt;vector&lt;char&gt;&gt; a(n, vector&lt;char&gt;(n));</span><br><span class="line">   // vector&lt;string&gt; a(n);</span><br><span class="line">   for (int i = 0; i &lt; n; i++)</span><br><span class="line">   &#123;</span><br><span class="line">      cin &gt;&gt; s;</span><br><span class="line">      int j = 0;</span><br><span class="line">      for (int k = 0; k &lt; s.size(); k++)</span><br><span class="line">      &#123;</span><br><span class="line">         if (s[k] != &#x27;,&#x27;)</span><br><span class="line">         &#123;</span><br><span class="line">            a[i][j] = s[k];</span><br><span class="line">            j++;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      //  a.push_back(tt);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   string tt;</span><br><span class="line">   cin &gt;&gt; tt;</span><br><span class="line"></span><br><span class="line">   //  search(a,tt,0,0,0);</span><br><span class="line">   // cout&lt;&lt;a[0][1];</span><br><span class="line">   int flag = 1;</span><br><span class="line">   vector&lt;vector&lt;int&gt;&gt; visit(n, vector&lt;int&gt;(n, 0));</span><br><span class="line"></span><br><span class="line">   int i = 0, j = 0;</span><br><span class="line">   vector&lt;int&gt; res; // 记录坐标</span><br><span class="line">   bool found = check(a, i, j, tt, 0, visit, res);</span><br><span class="line">   if (!found)</span><br><span class="line">      cout &lt;&lt; &quot;N&quot;;</span><br><span class="line">   else</span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">      for (int i = 0; i &lt; res.size(); i++)</span><br><span class="line">      &#123;</span><br><span class="line">         cout &lt;&lt; res[i];</span><br><span class="line">         if (i != res.size() - 1)</span><br><span class="line">            cout &lt;&lt; &quot;,&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="错误代码2"><a href="#错误代码2" class="headerlink" title="错误代码2"></a>错误代码2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; res; // 记录坐标</span><br><span class="line">vector&lt;int&gt; path;</span><br><span class="line">bool check(vector&lt;vector&lt;char&gt;&gt; a, int row, int col, string s, int i, vector&lt;vector&lt;int&gt;&gt; &amp;visit)</span><br><span class="line">&#123;</span><br><span class="line">   if (a[row][col] != s[i])</span><br><span class="line">      return false;</span><br><span class="line">   //  else  if(i==s.size()-1) return true;这样会导致最后一个坐标不执行的哇</span><br><span class="line">   // else if(i==s.size()-1) return true;//把s的字符都找到了</span><br><span class="line">   else if (i == s.size()-1)//关于这个i==s.size()-1 和i==s.size() </span><br><span class="line">   &#123;</span><br><span class="line">      return true;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; &quot;move to &quot; &lt;&lt; row &lt;&lt; &quot;,&quot; &lt;&lt; col &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; &quot;now s[i] is &quot; &lt;&lt; s[i] &lt;&lt; &quot; i: &quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   // res.push_back(row);</span><br><span class="line">   // res.push_back(col);</span><br><span class="line">   cout &lt;&lt; &quot;insert &quot; &lt;&lt; row &lt;&lt; &quot;,&quot; &lt;&lt; col &lt;&lt; endl;</span><br><span class="line">   visit[row][col] = 1;</span><br><span class="line">   bool result=false;</span><br><span class="line">   // if(row-1&gt;=0&amp;&amp;a[row-1][col]==s[i+1]&amp;&amp;visit[row-1][col]==0)//上</span><br><span class="line"></span><br><span class="line">   if (row - 1 &gt;= 0&amp;&amp;visit[row-1][col]==0) // 上</span><br><span class="line">   &#123;</span><br><span class="line">      if(check(a, row - 1, col, s, i + 1, visit))</span><br><span class="line">         result=true;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> if (row &lt; a.size()  &amp;&amp;visit[row+1][col]==0) // 下</span><br><span class="line">   &#123;</span><br><span class="line">      if(check(a, row + 1, col, s, i + 1, visit))</span><br><span class="line">        result=true;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (col - 1 &gt;= 0 &amp;&amp;visit[row][col-1]==0) // 左</span><br><span class="line">   &#123;</span><br><span class="line">      if(check(a, row, col - 1, s, i + 1, visit))</span><br><span class="line">        result=true;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  if (col &lt; a.size() &amp;&amp;visit[row][col+1]==0) // 右</span><br><span class="line">   &#123;</span><br><span class="line">      if(check(a, row, col + 1, s, i + 1, visit))</span><br><span class="line">         result=true;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; &quot;delete&quot; &lt;&lt; row &lt;&lt; &quot;,&quot; &lt;&lt; col &lt;&lt; endl;</span><br><span class="line">      // 递归完执行到这里说明走不完</span><br><span class="line">   visit[row][col] = 0;</span><br><span class="line"></span><br><span class="line">   // &#125;</span><br><span class="line">   cout&lt;&lt;&quot;do the successs&quot;&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">   return result;</span><br><span class="line">&#125;</span><br><span class="line">bool exist(vector&lt;vector&lt;char&gt;&gt; a,string s)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   int n=a.size();</span><br><span class="line">   vector&lt;vector&lt;int&gt;&gt; visit(n, vector&lt;int&gt;(n, 0));</span><br><span class="line">   for(int i=0;i&lt;n;i++)</span><br><span class="line">   for(int j=0;j&lt;n;j++)</span><br><span class="line">   &#123;</span><br><span class="line">      bool found = check(a, i, j, s, 0, visit);</span><br><span class="line">      if(found)</span><br><span class="line">      &#123;  </span><br><span class="line">         res.push_back(i);</span><br><span class="line">         res.push_back(j);</span><br><span class="line">         return found;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   int n;</span><br><span class="line">   cin &gt;&gt; n;</span><br><span class="line">   cin.ignore();</span><br><span class="line">   string s, t;</span><br><span class="line">   vector&lt;vector&lt;char&gt;&gt; a(n, vector&lt;char&gt;(n));</span><br><span class="line">   // vector&lt;string&gt; a(n);</span><br><span class="line"></span><br><span class="line">   for (int i = 0; i &lt; n; i++)</span><br><span class="line">   &#123;</span><br><span class="line">      cin &gt;&gt; s;</span><br><span class="line">      int j = 0;</span><br><span class="line">      for (int k = 0; k &lt; s.size(); k++)</span><br><span class="line">      &#123;</span><br><span class="line">         if (s[k] != &#x27;,&#x27;)</span><br><span class="line">         &#123;</span><br><span class="line">            a[i][j] = s[k];</span><br><span class="line">            j++;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      //  a.push_back(tt);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   string tt;</span><br><span class="line">   cin &gt;&gt; tt;</span><br><span class="line"></span><br><span class="line">   //  search(a,tt,0,0,0);</span><br><span class="line">   // cout&lt;&lt;a[0][1];</span><br><span class="line">   int flag = 1;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">   //int i = 0, j = 0;</span><br><span class="line">   //bool found = check(a, i, j, tt, 0, visit);//2.只能保证开头0,0是入口的情况</span><br><span class="line">   //若在主程序中使用exsit函数的内容，它是不会适可而止的，即迷宫走完，它也会循环从入口继续走</span><br><span class="line">   //所以接收返回值</span><br><span class="line">   bool found=exist(a,tt);</span><br><span class="line">   for(int i=0;i&lt;res.size();i++)</span><br><span class="line">   &#123;</span><br><span class="line">      cout&lt;&lt;res[i];</span><br><span class="line">      if(i!=res.size()-1) cout&lt;&lt;&quot;,&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>非递归尝试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">int n=a.size();</span><br><span class="line">  vector&lt;vector&lt;int&gt;&gt; visit(n,vector&lt;int&gt;(n,0));</span><br><span class="line">  int i=0;</span><br><span class="line">  while(i&lt;s.size())</span><br><span class="line">  &#123;</span><br><span class="line">     if(col&gt;=a.size()||row&gt;=a.size()||col&lt;0||row&lt;0)</span><br><span class="line">     &#123;</span><br><span class="line">        break;</span><br><span class="line">     &#125;</span><br><span class="line">     if(a[row][col]!=s[i])//找入口</span><br><span class="line">     &#123;</span><br><span class="line">        col++;</span><br><span class="line">        if(col==a.size())</span><br><span class="line">        &#123;</span><br><span class="line">           row++;</span><br><span class="line">           col=0;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     else if(a[row][col]==s[i])//找到了</span><br><span class="line">     &#123;</span><br><span class="line">        res.push_back(row);</span><br><span class="line">        res.push_back(col);</span><br><span class="line"></span><br><span class="line">       // i++;</span><br><span class="line">        visit[row][col]=1;</span><br><span class="line"></span><br><span class="line">        if(row-1&gt;=0&amp;&amp;visit[row-1][col]==0)//上</span><br><span class="line">        &#123;</span><br><span class="line">           row=row-1;</span><br><span class="line">           i++;</span><br><span class="line">        &#125;</span><br><span class="line">       else if(row+1&lt;=a.size()&amp;&amp;visit[row+1][col]==0)//下</span><br><span class="line">        &#123;</span><br><span class="line">            row=row+1;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">     else if(col-1&gt;=0&amp;&amp;visit[row][col-1]==0)//左</span><br><span class="line">        &#123;</span><br><span class="line">           col=col-1;</span><br><span class="line">           i++;</span><br><span class="line">        &#125;</span><br><span class="line">     else if(col+1&lt;=a.size()&amp;&amp;visit[row][col+1]==0)//右</span><br><span class="line">        &#123;</span><br><span class="line">           col=col+1;</span><br><span class="line">           i++;</span><br><span class="line">        &#125;</span><br><span class="line">     else</span><br><span class="line">     &#123;</span><br><span class="line">        res.pop_back();</span><br><span class="line">        res.pop_back();</span><br><span class="line">        i--;</span><br><span class="line">        visit[row][col]=0;</span><br><span class="line">     &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>遇到的问题有：</p>
<p>1.还原的问题</p>
<p>2.然后是一条道走到底的问题</p>
<p>所以为什么递归很香。。。。</p>
<h3 id="关键之处"><a href="#关键之处" class="headerlink" title="关键之处"></a>关键之处</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">A,C,C,F</span><br><span class="line">C,D,E,D</span><br><span class="line">B,E,S,S</span><br><span class="line">F,E,C,A</span><br><span class="line">ACCESS</span><br><span class="line">input row 0,col 0</span><br><span class="line">input row 1,col 0</span><br><span class="line">no match~~~~</span><br><span class="line">2,0 B, s[i]2 C</span><br><span class="line">no match~~~~</span><br><span class="line">1,1 D, s[i]2 C</span><br><span class="line">delete row 1,col 0</span><br><span class="line">input row 0,col 1</span><br><span class="line">no match~~~~</span><br><span class="line">1,1 D, s[i]2 C</span><br><span class="line">input row 0,col 2</span><br><span class="line">input row 1,col 2</span><br><span class="line">input row 2,col 2</span><br><span class="line">no match~~~~</span><br><span class="line">3,2 C, s[i]5 S</span><br><span class="line">no match~~~~</span><br><span class="line">2,1 E, s[i]5 S</span><br><span class="line">input row 2,col 3</span><br><span class="line">end now!!!!</span><br><span class="line">end now!!!! /////好，主要看下这后面是什么情况，他喵的都return true啦</span><br><span class="line">delete row 2,col 3</span><br><span class="line">delete row 2,col 2</span><br><span class="line">no match~~~~</span><br><span class="line">1,1 D, s[i]4 S</span><br><span class="line">no match~~~~</span><br><span class="line">1,3 D, s[i]4 S</span><br><span class="line">delete row 1,col 2</span><br><span class="line">no match~~~~</span><br><span class="line">0,3 F, s[i]3 E</span><br><span class="line">delete row 0,col 2</span><br><span class="line">delete row 0,col 1</span><br><span class="line">delete row 0,col 0</span><br><span class="line">1,0,2,3,2,2,1,2,0,2,0,1,0,0</span><br></pre></td></tr></table></figure>

<p>既然这样，我就在return true的时候，将那个res(终会pop完的)，复制给一个新的vector，path;对吧，在res它pop完之前，完整交给另一个数组即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">bool check(vector&lt;vector&lt;char&gt;&gt; a, int row, int col, string s, int i,  vector&lt;vector&lt;int&gt;&gt;&amp; visit)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">      int n=a.size();</span><br><span class="line">      if(col&gt;=a.size()||row&gt;=a.size()||col&lt;0||row&lt;0)</span><br><span class="line">      &#123;</span><br><span class="line">         return false;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if(i==s.size()) </span><br><span class="line">      &#123;</span><br><span class="line">         cout&lt;&lt;&quot;end now!!!!&quot;&lt;&lt;endl;</span><br><span class="line">         path=res; ////我不管，点睛之笔</span><br><span class="line">         return true;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      bool result=false;</span><br><span class="line"></span><br><span class="line">      if(a[row][col]!=s[i])//判断找到了没</span><br><span class="line">      &#123;</span><br><span class="line">         cout&lt;&lt;&quot;no match~~~~&quot;&lt;&lt;endl;</span><br><span class="line">         cout&lt;&lt;row&lt;&lt;&quot;,&quot;&lt;&lt;col&lt;&lt;&quot; &quot;&lt;&lt;a[row][col]&lt;&lt;&quot;, s[i]&quot;&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;s[i]&lt;&lt;endl;</span><br><span class="line">      //  res.clear(); //我在这里清空</span><br><span class="line">         return false;</span><br><span class="line">      &#125;</span><br><span class="line">         res.push_back(row);</span><br><span class="line">         res.push_back(col);</span><br><span class="line">      // else if(a[row][col]==s[i])//找到了</span><br><span class="line">      // &#123;</span><br><span class="line">         //  res.push_back(row);</span><br><span class="line">         //  res.push_back(col);</span><br><span class="line">         cout&lt;&lt;&quot;input row &quot;&lt;&lt;row&lt;&lt;&quot;,col &quot;&lt;&lt;col&lt;&lt;endl;</span><br><span class="line">        // i++;</span><br><span class="line">         visit[row][col]=1;</span><br><span class="line"></span><br><span class="line">         if(row-1&gt;=0&amp;&amp;visit[row-1][col]==0)//上</span><br><span class="line">         &#123;</span><br><span class="line">           // check(a,row-1,col,s,i+1,visit);</span><br><span class="line"></span><br><span class="line">           if(check(a,row-1,col,s,i+1,visit))</span><br><span class="line">             result=true;</span><br><span class="line">         &#125;</span><br><span class="line">       // else if(row+1&lt;=a.size()&amp;&amp;visit[row+1][col]==0)//下</span><br><span class="line">       if(row+1&lt;=a.size()&amp;&amp;visit[row+1][col]==0)//下</span><br><span class="line">         &#123;</span><br><span class="line">            //  row=row+1;</span><br><span class="line">            //  i++;</span><br><span class="line">           //  check(a,row+1,col,s,i+1,visit);</span><br><span class="line">           if(check(a,row+1,col,s,i+1,visit))</span><br><span class="line">              result=true;</span><br><span class="line">         &#125;</span><br><span class="line">      //else if(col-1&gt;=0&amp;&amp;visit[row][col-1]==0)//左</span><br><span class="line">       if(col-1&gt;=0&amp;&amp;visit[row][col-1]==0)//左</span><br><span class="line">         &#123;</span><br><span class="line">            // check(a,row,col-1,s,i+1,visit);</span><br><span class="line">            if(check(a,row,col-1,s,i+1,visit))</span><br><span class="line">            result=true;</span><br><span class="line">         &#125;</span><br><span class="line">     // else if(col+1&lt;=a.size()&amp;&amp;visit[row][col+1]==0)//右</span><br><span class="line">     if(col+1&lt;=a.size()&amp;&amp;visit[row][col+1]==0)//右</span><br><span class="line">         &#123;</span><br><span class="line">           // check(a,row,col+1,s,i+1,visit);</span><br><span class="line">           if(check(a,row,col+1,s,i+1,visit))</span><br><span class="line">           result=true;</span><br><span class="line">         &#125;</span><br><span class="line">   //   else</span><br><span class="line">     // &#123;</span><br><span class="line">    </span><br><span class="line">      // &#125;</span><br><span class="line">          cout&lt;&lt;&quot;delete row &quot;&lt;&lt;row&lt;&lt;&quot;,col &quot;&lt;&lt;col&lt;&lt;endl;</span><br><span class="line">          res.pop_back();</span><br><span class="line">          res.pop_back();</span><br><span class="line">       </span><br><span class="line">           visit[row][col]=0;</span><br><span class="line">         </span><br><span class="line">          return result;</span><br><span class="line">     // &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好的，新问题出现，这只适用于入口在0,0的地方，如果是其它地方嘞</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">A,C,C,F</span><br><span class="line">C,D,E,D</span><br><span class="line">B,E,S,S</span><br><span class="line">F,E,C,A</span><br><span class="line">FDSA</span><br><span class="line">no match~~~~</span><br><span class="line">0,0 A, s[i]0 F</span><br><span class="line">no match~~~~</span><br><span class="line">0,1 C, s[i]0 F</span><br><span class="line">no match~~~~</span><br><span class="line">0,2 C, s[i]0 F</span><br><span class="line">input row 0,col 3</span><br><span class="line">input row 1,col 3</span><br><span class="line">input row 2,col 3</span><br><span class="line">input row 3,col 3</span><br><span class="line">//哦豁？？？？？？？？？？？？？</span><br><span class="line">//1.都没有写进去咩？</span><br><span class="line">//2.不回溯啦？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">很好，试探了一下，if(i==s.size()-1)才会执行，塔喵的，那不就少一个坐标了</span><br><span class="line">所以是什么导致i不加了，使得不能=s.size()了</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">问题在这里 if(col+1&lt;=a.size()&amp;&amp;visit[row][col+1]==0)//右</span><br><span class="line"></span><br><span class="line">如果a是4行4列</span><br><span class="line">现在已经是a[3][3]的位置了，那就是最右下角了</span><br><span class="line">这个时候因为3+1==4，是满足滴，所以可以继续执行函数，但是嘞a[3][4]是溢出了滴，懂了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这样改</span><br><span class="line">if(col+1&lt;a.size()&amp;&amp;visit[row][col+1]==0)//右</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int n=a.size();</span><br><span class="line">  vector&lt;vector&lt;int&gt;&gt; visit(n, vector&lt;int&gt;(n, 0));</span><br><span class="line">  for(int i=0;i&lt;n;i++)</span><br><span class="line">  for(int j=0;j&lt;n;j++)//....这没用咩？</span><br><span class="line">  &#123;</span><br><span class="line">     bool found = check(a, i, j, s, 0, visit);</span><br><span class="line">     return found;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="最终代码-啧，不容易"><a href="#最终代码-啧，不容易" class="headerlink" title="最终代码(啧，不容易)"></a>最终代码(啧，不容易)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; res; // 记录坐标</span><br><span class="line">vector&lt;int&gt; path;</span><br><span class="line">bool check(vector&lt;vector&lt;char&gt;&gt; a, int row, int col, string s, int i, vector&lt;vector&lt;int&gt;&gt; &amp;visit)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   int n = a.size();</span><br><span class="line">   if (col &gt;= a.size() || row &gt;= a.size() || col &lt; 0 || row &lt; 0)</span><br><span class="line">   &#123;</span><br><span class="line">      return false;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (i == s.size())</span><br><span class="line">   &#123;</span><br><span class="line">      cout &lt;&lt; &quot;end now!!!!&quot; &lt;&lt; endl;</span><br><span class="line">      path = res;</span><br><span class="line">      return true;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   bool result = false;</span><br><span class="line"></span><br><span class="line">   if (a[row][col] != s[i]) // 判断找到了没</span><br><span class="line">   &#123;</span><br><span class="line">      cout &lt;&lt; &quot;no match~~~~&quot; &lt;&lt; endl;</span><br><span class="line">      cout &lt;&lt; row &lt;&lt; &quot;,&quot; &lt;&lt; col &lt;&lt; &quot; &quot; &lt;&lt; a[row][col] &lt;&lt; &quot;, s[i]&quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; s[i] &lt;&lt; endl;</span><br><span class="line">      //  res.clear(); //我在这里清空</span><br><span class="line">      return false;</span><br><span class="line">   &#125;</span><br><span class="line">   res.push_back(row);</span><br><span class="line">   res.push_back(col);</span><br><span class="line">   // else if(a[row][col]==s[i])//找到了</span><br><span class="line">   // &#123;</span><br><span class="line">   //  res.push_back(row);</span><br><span class="line">   //  res.push_back(col);</span><br><span class="line">   cout &lt;&lt; &quot;input row &quot; &lt;&lt; row &lt;&lt; &quot;,col &quot; &lt;&lt; col &lt;&lt; endl;</span><br><span class="line">   // i++;</span><br><span class="line">   visit[row][col] = 1;</span><br><span class="line"></span><br><span class="line">   if (row - 1 &gt;= 0 &amp;&amp; visit[row - 1][col] == 0) // 上</span><br><span class="line">   &#123;</span><br><span class="line">      // check(a,row-1,col,s,i+1,visit);</span><br><span class="line"></span><br><span class="line">      if (check(a, row - 1, col, s, i + 1, visit))</span><br><span class="line">         result = true;</span><br><span class="line">   &#125;</span><br><span class="line">   // else if(row+1&lt;=a.size()&amp;&amp;visit[row+1][col]==0)//下</span><br><span class="line">   if (row + 1 &lt; a.size() &amp;&amp; visit[row + 1][col] == 0) // 下</span><br><span class="line">   &#123;</span><br><span class="line">      //  row=row+1;</span><br><span class="line">      //  i++;</span><br><span class="line">      //  check(a,row+1,col,s,i+1,visit);</span><br><span class="line">      if (check(a, row + 1, col, s, i + 1, visit))</span><br><span class="line">         result = true;</span><br><span class="line">   &#125;</span><br><span class="line">   // else if(col-1&gt;=0&amp;&amp;visit[row][col-1]==0)//左</span><br><span class="line">   if (col - 1 &gt;= 0 &amp;&amp; visit[row][col - 1] == 0) // 左</span><br><span class="line">   &#123;</span><br><span class="line">      // check(a,row,col-1,s,i+1,visit);</span><br><span class="line">      if (check(a, row, col - 1, s, i + 1, visit))</span><br><span class="line">         result = true;</span><br><span class="line">   &#125;</span><br><span class="line">   // else if(col+1&lt;=a.size()&amp;&amp;visit[row][col+1]==0)//右</span><br><span class="line">   if (col + 1 &lt; a.size() &amp;&amp; visit[row][col + 1] == 0) // 右</span><br><span class="line">   &#123;</span><br><span class="line">      // check(a,row,col+1,s,i+1,visit);</span><br><span class="line">      if (check(a, row, col + 1, s, i + 1, visit))</span><br><span class="line">         result = true;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; &quot;delete row &quot; &lt;&lt; row &lt;&lt; &quot;,col &quot; &lt;&lt; col &lt;&lt; endl;</span><br><span class="line">   res.pop_back();</span><br><span class="line">   res.pop_back();</span><br><span class="line"></span><br><span class="line">   // 那我不pop了好吧，我直接添加，大不了倒叙排列</span><br><span class="line">   // 但是这等于添加了所有路径,怎么筛选嘞</span><br><span class="line">   // 我武断地讲，找个时机，遇到false了,清除一下res，</span><br><span class="line">   // 要么把所有路径存起来咯</span><br><span class="line">   visit[row][col] = 0;</span><br><span class="line"></span><br><span class="line">   return result;</span><br><span class="line">   // &#125;</span><br><span class="line">&#125;</span><br><span class="line">bool exist(vector&lt;vector&lt;char&gt;&gt; a, string s)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   int n = a.size();</span><br><span class="line">   vector&lt;vector&lt;int&gt;&gt; visit(n, vector&lt;int&gt;(n, 0));</span><br><span class="line">   for (int i = 0; i &lt; n; i++)</span><br><span class="line">      for (int j = 0; j &lt; n; j++) // 在我看来，这是为了确定入口的位置</span><br><span class="line">      &#123;</span><br><span class="line">         bool found = check(a, i, j, s, 0, visit);</span><br><span class="line">         if (found)	//必要性，是true了，才要对吧，不然就算了</span><br><span class="line">            return found;</span><br><span class="line">      &#125;</span><br><span class="line">   return false;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   int n;</span><br><span class="line">   cin &gt;&gt; n;</span><br><span class="line">   // cin.ignore();</span><br><span class="line">   string s, t;</span><br><span class="line">   vector&lt;vector&lt;char&gt;&gt; a(n, vector&lt;char&gt;(n));</span><br><span class="line">   // vector&lt;string&gt; a(n);</span><br><span class="line"></span><br><span class="line">   for (int i = 0; i &lt; n; i++)</span><br><span class="line">   &#123;</span><br><span class="line">      cin &gt;&gt; s;</span><br><span class="line">      int j = 0;</span><br><span class="line">      for (int k = 0; k &lt; s.size(); k++)</span><br><span class="line">      &#123;</span><br><span class="line">         if (s[k] != &#x27;,&#x27;)</span><br><span class="line">         &#123;</span><br><span class="line">            a[i][j] = s[k];</span><br><span class="line">            j++;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      //  a.push_back(tt);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   string tt;</span><br><span class="line">   cin &gt;&gt; tt;</span><br><span class="line"></span><br><span class="line">   //  search(a,tt,0,0,0);</span><br><span class="line">   // cout&lt;&lt;a[0][1];</span><br><span class="line">   int flag = 1;</span><br><span class="line"></span><br><span class="line">   // int i = 0, j = 0;</span><br><span class="line">   // bool found = check(a, i, j, tt, 0, visit);//2.只能保证开头0,0是入口的情况</span><br><span class="line"></span><br><span class="line">   vector&lt;vector&lt;int&gt;&gt; visit(n, vector&lt;int&gt;(n, 0));</span><br><span class="line">   bool found = exist(a, tt);</span><br><span class="line">    if(found)</span><br><span class="line">   &#123;</span><br><span class="line">         for (int i = 0; i &lt; path.size(); i++)</span><br><span class="line">   &#123;</span><br><span class="line">      cout &lt;&lt; path[i];</span><br><span class="line">      if (i != path.size() - 1)</span><br><span class="line">         cout &lt;&lt; &quot;,&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   else cout&lt;&lt;&quot;N&quot;;</span><br><span class="line">   cout &lt;&lt; endl</span><br><span class="line">        &lt;&lt; res.size() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>哎，不容易。</p>
<h1 id="68-招聘"><a href="#68-招聘" class="headerlink" title="68.招聘"></a>68.招聘</h1><p><strong>重叠区间问题</strong></p>
<h2 id="题目描述-25"><a href="#题目描述-25" class="headerlink" title="题目描述"></a>题目描述</h2><p>某公司组织一场公开招聘活动，假设由于人数和场地的限制，<br>每人每次面试的时长不等，并已经安排给定，<br>用<code>(S1,E1)</code>、<code>(S2,E2)</code>、<code>(Sj,Ej)</code>…(<code>Si &lt; Ei</code>，均为非负整数)表示每场面试的开始和结束时间。<br>面试采用一对一的方式，即一名面试官同时只能面试一名应试者，<br>一名面试官完成一次面试后可以立即进行下一场面试，且每个面试官的面试人次不超过<code>m</code>。<br>为了支撑招聘活动高效顺利进行，请你计算至少需要多少名面试官。</p>
<h2 id="输入描述-34"><a href="#输入描述-34" class="headerlink" title="输入描述"></a>输入描述</h2><p>输入的第一行为面试官的最多面试人次m，第二行为当天总的面试场次n，<br>接下来的n行为每场面试的起始时间和结束时间，起始时间和结束时间用空格分隔。<br>其中，<code>1 &lt;= n, m &lt;= 500</code></p>
<h2 id="输出描述-34"><a href="#输出描述-34" class="headerlink" title="输出描述"></a>输出描述</h2><p>输出一个整数，表示至少需要的面试官数量。</p>
<h2 id="示例一-20"><a href="#示例一-20" class="headerlink" title="示例一"></a>示例一</h2><h3 id="输入-29"><a href="#输入-29" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">5</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br><span class="line">5 6</span><br></pre></td></tr></table></figure>



<h3 id="输出-28"><a href="#输出-28" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>



<h3 id="说明-5"><a href="#说明-5" class="headerlink" title="说明"></a>说明</h3><p>总共有<code>5</code>场面试<br>且面试时间都不重叠<br>但每个面试官最多只能面试<code>2</code>人次<br>所以需要<code>3</code>名面试官</p>
<h2 id="示例二-3"><a href="#示例二-3" class="headerlink" title="示例二"></a>示例二</h2><h3 id="输入-30"><a href="#输入-30" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br></pre></td></tr></table></figure>



<h3 id="输出-29"><a href="#输出-29" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>



<h3 id="说明-6"><a href="#说明-6" class="headerlink" title="说明"></a>说明</h3><p>总共有<code>3</code>场面时，面试时间都不重叠<br>每个面试官最多能面试<code>3</code>人次<br>所以只需要一名面试官</p>
<h2 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h2><h3 id="输入-31"><a href="#输入-31" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">3</span><br><span class="line">8 35</span><br><span class="line">5 10</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure>



<h3 id="输出-30"><a href="#输出-30" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<h2 id="个人代码-21"><a href="#个人代码-21" class="headerlink" title="个人代码"></a>个人代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct mianshi&#123;</span><br><span class="line">    int l,r;</span><br><span class="line">    bool operator()(mianshi &amp;a,mianshi &amp;b)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        return a.l&lt;b.l||(a.l==b.l&amp;&amp;a.r&lt;b.r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int chongdie(vector&lt;mianshi&gt; a)</span><br><span class="line">&#123;</span><br><span class="line">    int co=0;</span><br><span class="line">    mianshi pre;</span><br><span class="line">    pre.l=a[0].l;</span><br><span class="line">    pre.r=a[0].r;</span><br><span class="line">    for(int i=1;i&lt;a.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pre.r&gt;a[i].l&amp;&amp;pre.l&lt;a[i].r)</span><br><span class="line">           co++;</span><br><span class="line">           //1.一开始少了这一步</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            pre.l=a[i].l;</span><br><span class="line">            pre.r=a[i].r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return co;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int m,n;//一人最多面试m，总共面试n次</span><br><span class="line">    //没有重叠部分,n/m次，除不尽就加1</span><br><span class="line">    //有重叠部分,(n/m)+1</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    vector&lt;mianshi&gt; list;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">      //  a[i].push_back(&#123;a,b&#125;);</span><br><span class="line">        mianshi ms;</span><br><span class="line">        ms.l=a;</span><br><span class="line">        ms.r=b;</span><br><span class="line">        list.push_back(ms);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(list.begin(),list.end(),mianshi());</span><br><span class="line">    cout&lt;&lt;list.size()&lt;&lt;endl;</span><br><span class="line">    int co=chongdie(list);</span><br><span class="line">    cout&lt;&lt;co&lt;&lt;endl;</span><br><span class="line">    for(auto al:list)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;al.l&lt;&lt;&quot;,&quot;&lt;&lt;al.r&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     int num=(n%m==0?n/m:(n/m)+1);</span><br><span class="line">    if(co!=0)</span><br><span class="line">    &#123;</span><br><span class="line">       </span><br><span class="line">        cout&lt;&lt;num+co;</span><br><span class="line">    &#125;</span><br><span class="line">    else cout&lt;&lt;num;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="69-斗地主顺子"><a href="#69-斗地主顺子" class="headerlink" title="69.斗地主顺子"></a>69.斗地主顺子</h1><h2 id="题目描述-26"><a href="#题目描述-26" class="headerlink" title="题目描述"></a>题目描述</h2><p>在斗地主扑克牌游戏中，扑克牌由小到大的顺序为<code>3 4 5 6 7 8 9 10 J Q K A 2</code><br>玩家可以出的扑克牌阵型有，<code>单张</code>，<code>对子</code>，<code>顺子</code>，<code>飞机</code>，<code>炸弹</code>等<br>其中顺子的出牌规则为，由至少5张由小到大连续递增的扑克牌组成<br>且不能包含<code>2</code><br>例如:<code>&#123;3,4,5,6,7&#125;</code>、<code>&#123;3,4,5,6,7,8,9,10,J,Q,K,A&#125;</code>都是有效的顺子<br>而<code>&#123;J,Q,K,A,2&#125;</code>、<code>&#123;2,3,4,5,6&#125;</code>、<code>&#123;3,4,5,6&#125;</code>、<code>&#123;3,4,5,6,8&#125;</code>等都不是顺子<br>给定一个包含<code>13</code>张牌的数组，如果有满足出牌规则的顺子，请输出顺子<br>如果存在多个顺子，请每行输出一个顺子<br>且需要按照顺子的第一张牌的大小(必须从小到大)依次输出<br>如果没有满足出牌规则的顺子，请输出<code>No</code></p>
<h2 id="输入描述-35"><a href="#输入描述-35" class="headerlink" title="输入描述"></a>输入描述</h2><p>13张任意顺序的扑克牌，每张扑克牌数字用空格隔开，<br>每张扑克牌的数字都是合法的<br>并且不包括大小王：<code>2 9 J 2 3 4 K A 7 9 A 5 6</code><br>不需要考虑输入为异常字符的情况</p>
<h2 id="输出描述-35"><a href="#输出描述-35" class="headerlink" title="输出描述"></a>输出描述</h2><p>组成的顺子 每张扑克牌数字用空格隔开<br><code>3 4 5 6 7</code></p>
<h2 id="示例一-21"><a href="#示例一-21" class="headerlink" title="示例一"></a>示例一</h2><h3 id="输入-32"><a href="#输入-32" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 9 J 2 3 4 K A 7 9 A 5 6</span><br></pre></td></tr></table></figure>

<h3 id="输出-31"><a href="#输出-31" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 4 5 6 7</span><br></pre></td></tr></table></figure>

<h2 id="代码（错误）"><a href="#代码（错误）" class="headerlink" title="代码（错误）"></a>代码（错误）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">void zhuanhuan1(vector&lt;string&gt; &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0;i&lt;a.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a[i]==&quot;J&quot;) a[i]=&quot;11&quot;;</span><br><span class="line">        else if(a[i]==&quot;Q&quot;) a[i]=&quot;12&quot;;</span><br><span class="line">        else if(a[i]==&quot;K&quot;) a[i]=&quot;13&quot;;</span><br><span class="line">        else if(a[i]==&quot;A&quot;) a[i]=&quot;14&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void zhuanhuan2(vector&lt;string&gt; &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0;i&lt;a.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a[i]==&quot;11&quot;) a[i]=&quot;J&quot;;</span><br><span class="line">        else if(a[i]==&quot;12&quot;) a[i]=&quot;Q&quot;;</span><br><span class="line">        else if(a[i]==&quot;13&quot;) a[i]=&quot;K&quot;;</span><br><span class="line">        else if(a[i]==&quot;14&quot;) a[i]=&quot;A&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">bool cmp(string &amp;a,string &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    int c1=stoi(a);</span><br><span class="line">    int c2=stoi(b);</span><br><span class="line">    return c1&lt;c2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">vector&lt;string&gt; res;</span><br><span class="line">vector&lt;string&gt; path;</span><br><span class="line">void shunzi(vector&lt;string&gt; a)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int diff=0;</span><br><span class="line">    int i=0,j=1;</span><br><span class="line">    while(i&lt;13)</span><br><span class="line">    &#123;</span><br><span class="line">        //int pre=;</span><br><span class="line">        while(stoi(a[i])==2) i++;</span><br><span class="line">        int pre=stoi(a[i]);</span><br><span class="line">      </span><br><span class="line">        while(stoi(a[j]) == 2) j++;</span><br><span class="line">          int cur = stoi(a[j]);</span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;&quot;now pre= &quot;&lt;&lt;pre&lt;&lt;&quot;noew cur= &quot;&lt;&lt;cur&lt;&lt;endl;</span><br><span class="line">      //  res.push_back(to_string(pre));</span><br><span class="line">        if (cur - pre == diff)</span><br><span class="line">        &#123;</span><br><span class="line">            diff++;</span><br><span class="line">            cout&lt;&lt;&quot;insert &quot;&lt;&lt;cur&lt;&lt;&quot;,diff= &quot;&lt;&lt;diff&lt;&lt;endl;</span><br><span class="line">            res.push_back(to_string(cur));</span><br><span class="line">        &#125;</span><br><span class="line">        else // 3456777789</span><br><span class="line">        &#123;</span><br><span class="line">           // dfindex=j;</span><br><span class="line">           int chongfu=diff-1;</span><br><span class="line">        if(cur-pre!=chongfu)//也不重复(6777789) 而是679</span><br><span class="line">        &#123;</span><br><span class="line">              i=j;</span><br><span class="line">              diff=0;</span><br><span class="line">        &#125; </span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(j==13)//cur遍历完了</span><br><span class="line">          &#123;</span><br><span class="line">            break;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      //  if(j==0&amp;&amp;res.size()&lt;5)//至少够5连</span><br><span class="line">    //    if(res.size()&lt;5)</span><br><span class="line">    //     &#123;</span><br><span class="line">    //         res.clear();</span><br><span class="line">    //     &#125;</span><br><span class="line">    //     else if(res.size()&gt;=5)</span><br><span class="line">    //     &#123;</span><br><span class="line">    //         path=res;</span><br><span class="line">    //         //dfindex=j;</span><br><span class="line">    //         path.push_back(&quot;!&quot;);</span><br><span class="line">    //     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">        //i++;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;string&gt; a13(13); //不用char，有一个10</span><br><span class="line">    for(int i=0;i&lt;13;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a13[i];</span><br><span class="line">    &#125;</span><br><span class="line">    zhuanhuan1(a13);</span><br><span class="line">    sort(a13.begin(),a13.end(),cmp);</span><br><span class="line">    </span><br><span class="line">       for(auto a:a13)</span><br><span class="line">     cout&lt;&lt;a&lt;&lt;&quot; &quot;;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    shunzi(a13);</span><br><span class="line">    for(auto a:res)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;a&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    // zhuanhuan2(a13);</span><br><span class="line">    // for(auto a:a13)</span><br><span class="line">    // cout&lt;&lt;a&lt;&lt;&quot; &quot;;</span><br><span class="line">    //</span><br><span class="line">    //2 2 3 3 4 4 5 5 6 6 7 7 8 连队怎么办</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"> void zhuanhuan1(vector&lt;string&gt; &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0;i&lt;a.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a[i]==&quot;J&quot;) a[i]=&quot;11&quot;;</span><br><span class="line">        else if(a[i]==&quot;Q&quot;) a[i]=&quot;12&quot;;</span><br><span class="line">        else if(a[i]==&quot;K&quot;) a[i]=&quot;13&quot;;</span><br><span class="line">        else if(a[i]==&quot;A&quot;) a[i]=&quot;14&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void zhuanhuan2(vector&lt;string&gt; &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0;i&lt;a.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a[i]==&quot;11&quot;) a[i]=&quot;J&quot;;</span><br><span class="line">        else if(a[i]==&quot;12&quot;) a[i]=&quot;Q&quot;;</span><br><span class="line">        else if(a[i]==&quot;13&quot;) a[i]=&quot;K&quot;;</span><br><span class="line">        else if(a[i]==&quot;14&quot;) a[i]=&quot;A&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">bool cmp(string &amp;a,string &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    int c1=stoi(a);</span><br><span class="line">    int c2=stoi(b);</span><br><span class="line">    return c1&lt;c2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;string&gt; &gt;path;</span><br><span class="line">void shunzi(vector&lt;string&gt; a)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int diff=1,co=1,flag=0;</span><br><span class="line">    int i=0,j=0;</span><br><span class="line">   </span><br><span class="line">    while(i&lt;13)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        flag=0;</span><br><span class="line">        diff=1;</span><br><span class="line">        while(stoi(a[i])==2) i++;</span><br><span class="line">        int fi=stoi(a[i]);</span><br><span class="line"></span><br><span class="line">        res.push_back(a[i]);</span><br><span class="line"></span><br><span class="line">        j=i+1;</span><br><span class="line">        //int pre=;</span><br><span class="line">        while(j&lt;13)</span><br><span class="line">        &#123;</span><br><span class="line">            while(stoi(a[j])==2) j++;</span><br><span class="line">            int cur=stoi(a[j]);</span><br><span class="line">      </span><br><span class="line">            if(cur-fi==diff)</span><br><span class="line">            &#123;</span><br><span class="line">                j++;</span><br><span class="line">                diff++;</span><br><span class="line">                if(diff&gt;=5) flag=1;</span><br><span class="line">                res.push_back(a[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        if(flag==1) path.push_back(res);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>哎，都不对，到时候再是哦</p>
<h2 id="最终代码-2"><a href="#最终代码-2" class="headerlink" title="最终代码"></a>最终代码</h2><p>1.用下标索引比较就好了，0-12分别记录2-A，当然直接从1开始即可</p>
<p>2.for循环作为查找下标，内循环，检查对应下标是否存在值，存在就加入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">void shunzi(vector&lt;string&gt; a)</span><br><span class="line">&#123;</span><br><span class="line">    //a[0]是2，不参与</span><br><span class="line">    for(int i=1;i&lt;a.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int co=0;</span><br><span class="line">        string t=&quot;&quot;;</span><br><span class="line">        while(i&lt;a.size()&amp;&amp;a[i]!=&quot;&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">            t+=a[i]+&quot; &quot;;</span><br><span class="line">            co++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(co&gt;=5)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(t.substr(0,t.size()-1));//去掉末尾空格</span><br><span class="line">        &#125;</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">         if(res.size()==0) cout&lt;&lt;&quot;NO&quot;;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            for(auto list:res)</span><br><span class="line">            cout&lt;&lt;list&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;string&gt; a13(13); //不用char，有一个10</span><br><span class="line">    for(int i=0;i&lt;13;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a13[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   // zhuanhuan1(a13);</span><br><span class="line">   // sort(a13.begin(),a13.end(),cmp);</span><br><span class="line">    </span><br><span class="line">    vector&lt;string&gt; conv(13,&quot;&quot;);//比较下标就好啦</span><br><span class="line">    for(int i=0;i&lt;13;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a13[i]==&quot;J&quot;) conv[9]=&quot;J&quot;;</span><br><span class="line">        else if(a13[i]==&quot;Q&quot;)  conv[10]=&quot;Q&quot;;</span><br><span class="line">        else if(a13[i]==&quot;K&quot;)   conv[11]=&quot;K&quot;;</span><br><span class="line">        else if(a13[i]==&quot;A&quot;)    conv[12]=&quot;A&quot;;</span><br><span class="line">        else </span><br><span class="line">        &#123;</span><br><span class="line">            conv[stoi(a13[i])-2]=a13[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shunzi(conv);</span><br><span class="line"></span><br><span class="line">    // zhuanhuan2(a13);</span><br><span class="line">    // for(auto a:a13)</span><br><span class="line">    // cout&lt;&lt;a&lt;&lt;&quot; &quot;;</span><br><span class="line">    //</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>2 9 J 10 3 4 K A 7 Q A 5 6<br>3 4 5 6 7<br>9 10 J Q K A</p>
</blockquote>
<p>当然，还有一种情况还有&#x2F;&#x2F;2 2 3 3 4 4 5 5 6 6 7 7 8 ，这个不是可以分成两个顺子嘛</p>
<p>看来还是得记录下对应值的次数吧。</p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="n台阶"><a href="#n台阶" class="headerlink" title="n台阶"></a>n台阶</h2><p>一共有n个台阶，一次走1步或3步，有多少种方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int ss(int n)</span><br><span class="line">&#123;</span><br><span class="line">	if(n==1) return 1;</span><br><span class="line">	else if(n==2) return 1;</span><br><span class="line">	else if(n==3) return 2;</span><br><span class="line"></span><br><span class="line">	return ss(n-1)+ss(n-3);</span><br><span class="line">&#125;</span><br><span class="line">void s1(int n)</span><br><span class="line">&#123;</span><br><span class="line">	int step1=1,step2=1,step3=2;</span><br><span class="line">	if(n==1||n==2) cout&lt;&lt;1;</span><br><span class="line">	if(n==3) cout&lt;&lt;2;</span><br><span class="line">	int step4;</span><br><span class="line">	for(int i=4;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		step4=step3+step1;</span><br><span class="line">		step1=step2;</span><br><span class="line">		step2=step3;</span><br><span class="line">		step3=step4;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;step4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><p>顺延思想</p>
<h3 id="题目描述-27"><a href="#题目描述-27" class="headerlink" title="题目描述"></a>题目描述</h3><p>为了充分发挥<code>GPU</code>算力，<br>需要尽可能多的将任务交给<code>GPU</code>执行，<br>现在有一个任务数组，<br>数组元素表示在这<code>1s</code>内新增的任务个数，<br>且每秒都有新增任务，<br>假设<code>GPU</code>最多一次执行<code>n</code>个任务，<br>一次执行耗时<code>1s</code>，<br>在保证<code>GPU</code>不空闲的情况下，最少需要多长时间执行完成。</p>
<h3 id="输入描述-36"><a href="#输入描述-36" class="headerlink" title="输入描述"></a>输入描述</h3><p>第一个参数为<code>GPU</code>最多执行的任务个数，取值范围<code>1 ~ 10000</code><br>第二个参数为任务数组的长度，取值范围<code>1 ~ 10000</code><br>第三个参数为任务数组，数字范围<code>1 ~ 10000</code></p>
<h3 id="输出描述-36"><a href="#输出描述-36" class="headerlink" title="输出描述"></a>输出描述</h3><p>执行完所有任务需要多少秒</p>
<h3 id="示例一-22"><a href="#示例一-22" class="headerlink" title="示例一"></a>示例一</h3><h4 id="输入-33"><a href="#输入-33" class="headerlink" title="输入"></a>输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">5</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure>

<h4 id="输出-32"><a href="#输出-32" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void solution(int n,vector&lt;int&gt; a)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	int time=0,remain=0;</span><br><span class="line">	for(int i=0;i&lt;a.size();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(a[i]+remain&gt;n)//这个是上个任务剩下的任务与当前任务总和</span><br><span class="line">		&#123;</span><br><span class="line">			remain=a[i]+remain-n;//有剩余</span><br><span class="line">			time++;//先执行完n个，即过了1s</span><br><span class="line">		&#125;</span><br><span class="line">		else //总任务数&lt;=n</span><br><span class="line">		&#123;</span><br><span class="line">			time++;</span><br><span class="line">			remain=0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//比如4个任务剩下了1个，与下5个任务一起执行</span><br><span class="line">		//6-3=3;</span><br><span class="line">		time+=remain/n; //处理剩余</span><br><span class="line">		if(remain%n&gt;0) time++;</span><br><span class="line">	cout&lt;&lt;time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最大资金额"><a href="#最大资金额" class="headerlink" title="最大资金额"></a>最大资金额</h2><p>给一堆商品，价格不一，限购n样，有金额m，求最大花费</p>
<p>知识点：全排列组合，其实可以三指针，排序后，一个从最左边开始，一个从最右边和次右边开始</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void quanpai(vector&lt;int&gt; a,int start);</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; combines;</span><br><span class="line">void so(vector&lt;int&gt; s,int num)</span><br><span class="line">&#123;</span><br><span class="line">	sort(s.begin(),s.end());</span><br><span class="line">	if(s.size()&lt;3||s[0]+s[1]+s[2]&gt;num)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;&quot;-1&quot;;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	quanpai(s,0);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">vector&lt;int&gt; cm;</span><br><span class="line"></span><br><span class="line">void quanpai(vector&lt;int&gt; a,int start)</span><br><span class="line">&#123;</span><br><span class="line">	if(cm.size()==3)</span><br><span class="line">	&#123;</span><br><span class="line">		combines.push_back(cm);</span><br><span class="line">		//cm.clear();不用清除</span><br><span class="line">			return;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=start;i&lt;a.size();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cm.push_back(a[i]);</span><br><span class="line">		//cout&lt;&lt;a[i]&lt;&lt;endl;</span><br><span class="line">		quanpai(a,i+1);</span><br><span class="line">		cm.pop_back();//移除最后一个</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="最小步骤"><a href="#最小步骤" class="headerlink" title="最小步骤"></a>最小步骤</h2><h3 id="题目描述-28"><a href="#题目描述-28" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个正整数数组，设为<code>nums</code><br>最大为<code>100</code>个成员<br>求从第一个成员开始正好走到数组最后一个成员所使用的最小步骤数</p>
<p>要求：</p>
<ol>
<li>第一步，必须从第一元素起，且<code>1 &lt;= 第一步步长 &lt; len / 2</code> (len为数组长度)</li>
<li>从第二步开始只能以所在成员的数字走相应的步数，不能多不能少，如果目标不可达返回<code>-1</code>，只输出最小的步骤数量</li>
<li>只能向数组的尾部走不能向回走</li>
</ol>
<h3 id="输入描述-37"><a href="#输入描述-37" class="headerlink" title="输入描述"></a>输入描述</h3><p>一个正整数数组，元素用<code>空格</code>分割<br><code>数组长度 &lt; 100</code></p>
<h3 id="输出描述-37"><a href="#输出描述-37" class="headerlink" title="输出描述"></a>输出描述</h3><p>正整数，最小步数<br>不存在输出<code>-1</code></p>
<h3 id="示例一-23"><a href="#示例一-23" class="headerlink" title="示例一"></a>示例一</h3><h4 id="输入-34"><a href="#输入-34" class="headerlink" title="输入"></a>输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7 5 9 4 2 6 8 3 5 4 3 9</span><br></pre></td></tr></table></figure>

<h4 id="输出-33"><a href="#输出-33" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<h4 id="说明-7"><a href="#说明-7" class="headerlink" title="说明"></a>说明</h4><p>第一个可选步长选择<code>2</code><br>从第一个成员<code>7</code>开始走两步到<code>9</code><br>第二步从<code>9</code>经过<code>9</code>个成员到最后</p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><p>1.第一步只能走1到len&#x2F;2步，从它开始遍历，step默认为1了</p>
<p>2.递归遍历，walk(int curpos,int lastpos)，判断lastpos是否是最后一个索引，是就返回step，如果小于呢，继续递归，从lastpos，走lasepos+a[curpos]步，step++;</p>
<p>3.set记录能够到最后一个索引的所需步骤数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; a;</span><br><span class="line">int step;</span><br><span class="line">int walk(int curpos,int lastpos)</span><br><span class="line">&#123;</span><br><span class="line">	int num=a[curpos];</span><br><span class="line">	if(lastpos==a.size()-1) return step;</span><br><span class="line">	else if(lastpos&lt;a.size()-1)</span><br><span class="line">	&#123;</span><br><span class="line">		step++;</span><br><span class="line">		return walk(lastpos,lastpos+num);//在lastpos走num步</span><br><span class="line">	&#125;</span><br><span class="line">	else return -1;</span><br><span class="line">&#125;</span><br><span class="line">void solu1(vector&lt;int&gt; a)</span><br><span class="line">&#123;</span><br><span class="line">	int n=a.size();</span><br><span class="line">	set&lt;int&gt; set1;</span><br><span class="line">	</span><br><span class="line">	for(int i=1;i&lt;n/2;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		step=1;</span><br><span class="line">		set1.insert(walk(i,i));</span><br><span class="line">	&#125;</span><br><span class="line">	if(set1.size()!=1)//不止一条路径，那就将-1去掉</span><br><span class="line">	&#123;</span><br><span class="line">		auto a=set1.begin();//迭代器访问</span><br><span class="line">		set1.erase(*a);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	for(auto aa:set1)</span><br><span class="line">	cout&lt;&lt;aa&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二叉树层次遍历"><a href="#二叉树层次遍历" class="headerlink" title="二叉树层次遍历"></a>二叉树层次遍历</h1><h2 id="题目描述-29"><a href="#题目描述-29" class="headerlink" title="题目描述"></a>题目描述</h2><p>有一棵二叉树<br>每一个节点用一个大写字母标识<br>最多<code>26</code>个节点<br>现有两组字母<br>分别表示<code>后序遍历</code>（左孩子指向右孩子指向父节点）<br>和<code>中序遍历</code>（左孩子指向父节点指向右孩子）<br>请输出<code>层次遍历</code>的结果</p>
<h2 id="输入描述-38"><a href="#输入描述-38" class="headerlink" title="输入描述"></a>输入描述</h2><p>输入为两个字符串<br>分别为二叉树的后序遍历和中序遍历结果</p>
<h2 id="输出描述-38"><a href="#输出描述-38" class="headerlink" title="输出描述"></a>输出描述</h2><p>输出二叉树的层次遍历结果</p>
<h2 id="示例一-24"><a href="#示例一-24" class="headerlink" title="示例一"></a>示例一</h2><h3 id="输入-35"><a href="#输入-35" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CBEFDA CBAEDF</span><br></pre></td></tr></table></figure>

<h3 id="输出-34"><a href="#输出-34" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ABDCEF</span><br></pre></td></tr></table></figure>

<h2 id="代码-噢，这是前序遍历输出"><a href="#代码-噢，这是前序遍历输出" class="headerlink" title="代码(噢，这是前序遍历输出)"></a>代码(噢，这是前序遍历输出)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;char,int&gt; mp;</span><br><span class="line">void cengxu(string s1,int posts,int poste,string s2,int mids,int mide)</span><br><span class="line">&#123;</span><br><span class="line">   // if(poste==0) return;</span><br><span class="line">   if(posts&gt;poste) return;</span><br><span class="line">    int rootpos=mp[s1[poste]];</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;root: &quot;&lt;&lt;s2[rootpos]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">   // cengxu(s1,0,rootpos-1,s2,0,rootpos-1);</span><br><span class="line">    cengxu(s1,posts,posts+rootpos-mids-1,s2,mids,rootpos-1);</span><br><span class="line">    //cengxu(s1,rootpos,poste-1,s2,rootpos+1,mide);</span><br><span class="line">    cengxu(s1,posts+rootpos-mids,poste-1,s2,rootpos+1,mide);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    cin&gt;&gt;a;</span><br><span class="line">    cin&gt;&gt;b;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    for(int i=0;i&lt;b.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        mp[b[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    cengxu(a,0,a.size()-1,b,0,b.size()-1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h2><p>先用结构体接收根，左，右</p>
<p>再层序输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct Node&#123;</span><br><span class="line">    char data;</span><br><span class="line">    Node* left;</span><br><span class="line">    Node* right;</span><br><span class="line">    Node(char x):data(x),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;char,int&gt; mp;</span><br><span class="line">Node* create(string s1,int posts,int poste,string s2,int mids,int mide)</span><br><span class="line">&#123;</span><br><span class="line">   // if(poste==0) return;</span><br><span class="line">   if(posts&gt;poste||mids&gt;mide) return nullptr;</span><br><span class="line">    char rootdata=s1[poste];</span><br><span class="line">    int rootpos=mp[rootdata];</span><br><span class="line"></span><br><span class="line">  //  cout&lt;&lt;&quot;root: &quot;&lt;&lt;s2[rootpos]&lt;&lt;endl;</span><br><span class="line">    Node* root=new Node(rootdata);</span><br><span class="line"></span><br><span class="line">    root-&gt;left= create(s1,posts,posts+rootpos-mids-1,s2,mids,rootpos-1);</span><br><span class="line"></span><br><span class="line">    root-&gt;right=create(s1,posts+rootpos-mids,poste-1,s2,rootpos+1,mide);</span><br><span class="line">    return root;</span><br><span class="line">&#125; </span><br><span class="line">void cengxu(Node* root)</span><br><span class="line">&#123;</span><br><span class="line">    if(root==nullptr) return;</span><br><span class="line">    </span><br><span class="line">    queue&lt;Node*&gt;q;</span><br><span class="line">    q.push(root);</span><br><span class="line"></span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        Node* cur=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        cout&lt;&lt;cur-&gt;data&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">        if(cur-&gt;left) q.push(cur-&gt;left);</span><br><span class="line">        if(cur-&gt;right) q.push(cur-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    cin&gt;&gt;a;</span><br><span class="line">    cin&gt;&gt;b;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    for(int i=0;i&lt;b.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        mp[b[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* node=create(a,0,a.size()-1,b,0,b.size()-1);</span><br><span class="line">    cengxu(node);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="wp-5"><a href="#wp-5" class="headerlink" title="wp"></a>wp</h2><blockquote>
<p>error: cannot call member function ‘Tree* Tree::create(std::__cxx11::string, std::__cxx11::string)’ without object<br>    Tree* t&#x3D;Tree::create(a,b);</p>
<p>表明您正在尝试调用该类的成员函数而不需要<code>Tree</code>对象创建类的实例。该方法前加个static</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">struct Node&#123;</span><br><span class="line"></span><br><span class="line">    char data;</span><br><span class="line">    Node* left;</span><br><span class="line">    Node* right;</span><br><span class="line">    Node(char x):data(x),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Tree&#123;</span><br><span class="line">//private:</span><br><span class="line">  </span><br><span class="line">public:</span><br><span class="line">    Node* root;</span><br><span class="line">    Tree():root(nullptr)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    static Tree* create(string post,string in)&#123;</span><br><span class="line">        Tree* res=new Tree();</span><br><span class="line">        res-&gt;root=create(post,0,post.size()-1,in,0,in.size()-1);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    static Node* create(string post,int s1,int e1,string in,int s2,int e2)&#123;</span><br><span class="line">        if(s1&gt;e1||s2&gt;e2)</span><br><span class="line">        &#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">       Node* root=new Node(post[e1]);</span><br><span class="line">       for(int i=s2;i&lt;=e2;i++)</span><br><span class="line">       &#123;</span><br><span class="line">        if(post[e1]==in[i])</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;left=create(post,s1,s1+i-s2-1,in,s2,i-1);</span><br><span class="line">            root-&gt;right=create(post,s1+i-s2,e1-1,in,i+1,e2);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">       &#125; </span><br><span class="line">       return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">void cengxu(Node* root)</span><br><span class="line">&#123;</span><br><span class="line">    if(root==nullptr) return;</span><br><span class="line">    queue&lt;Node*&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        Node* node=q.front();</span><br><span class="line">        cout&lt;&lt;node-&gt;data&lt;&lt;endl;</span><br><span class="line">        q.pop();</span><br><span class="line">        if(node-&gt;left!=nullptr) q.push(node-&gt;left);</span><br><span class="line">        if(node-&gt;right!=nullptr) q.push(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    cin&gt;&gt;a;</span><br><span class="line">    cin&gt;&gt;b;</span><br><span class="line"></span><br><span class="line">   Tree* t=Tree::create(a,b);</span><br><span class="line">   cengxu(t-&gt;root);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="代表团坐车"><a href="#代表团坐车" class="headerlink" title="代表团坐车"></a>代表团坐车</h1><p><strong>动态规划</strong></p>
<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><p>现在要举行一场会议，有很多代表团参加。但是他们可能在同一个时间到达，而负责接待它们的接待处只有一辆车，现在为了提高车辆利用率，请帮接待员计算可以坐满车的接待方案，输出方案数量</p>
<p>限制：</p>
<p>1.一个团只能上一辆车，并且代表团数量小于汽车容量</p>
<p>2.需要将车坐满</p>
<h2 id="输入描述-39"><a href="#输入描述-39" class="headerlink" title="输入描述"></a>输入描述</h2><p>第一行 代表团人数，英文逗号分割，代表团数量&lt;30，每个代表团人数&lt;30</p>
<p>第二行 汽车载客量 &lt;100</p>
<h2 id="输出描述-39"><a href="#输出描述-39" class="headerlink" title="输出描述"></a>输出描述</h2><p>坐满汽车的方案数量，无解输出0</p>
<h2 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h2><p>输入 </p>
<p>5,4,2,3,2,4,9</p>
<p>10</p>
<p>输出 4</p>
<p>说明:[2,3,5] [2,4,4] [2,3,5] [2,4,4]</p>
<h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int fangan(vector&lt;int&gt; a,int n)</span><br><span class="line">&#123;</span><br><span class="line">    // if(n==0) ans[0][0]=1;</span><br><span class="line">    // if(n&gt;0) ans[0][n]=0;</span><br><span class="line">    int m=a.size();</span><br><span class="line">    vector&lt;int&gt; dp(n+1,0);//dp[i] 车容量为i时的方案数</span><br><span class="line">    dp[0]=1;</span><br><span class="line">    for (int i = 0; i &lt; m; i++)</span><br><span class="line">    for(int j=n;j&gt;=a[i];j--)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[j]+=dp[j-a[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n];</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    /*</span><br><span class="line">    5,4,2,3,2,4,9</span><br><span class="line">    10</span><br><span class="line">    */</span><br><span class="line">    </span><br><span class="line">    string t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    stringstream ss(t);</span><br><span class="line">    string s;</span><br><span class="line">    vector&lt;int&gt; v;</span><br><span class="line">    while(getline(ss,s,&#x27;,&#x27;))</span><br><span class="line">    &#123;</span><br><span class="line">        v.push_back(stoi(s));</span><br><span class="line">    &#125;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">   // sort(v.begin(),v.end());</span><br><span class="line">    int size=v.size();</span><br><span class="line">    //int ans[size+1][n+1];//在ans[i][j],nums选取前i个元素，和为j的方案数</span><br><span class="line">    </span><br><span class="line">    // for(auto a:v)</span><br><span class="line">    // cout&lt;&lt;a&lt;&lt;&quot; &quot;;</span><br><span class="line">    cout&lt;&lt;fangan(v,n);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="贪心："><a href="#贪心：" class="headerlink" title="贪心："></a>贪心：</h1><h2 id="调整座位"><a href="#调整座位" class="headerlink" title="调整座位"></a>调整座位</h2><p>两人之间至少有一空位，0表示座位空闲，1表示占据，不改变原有座位秩序的情况下，还可以安排坐几人</p>
<p>数组desk.length&lt;&#x3D;2*10⁴</p>
<p>输入：</p>
<p>占座情况</p>
<p>1,0,0,0,1</p>
<p>输出：</p>
<p>根据当前情况，还能坐多少人</p>
<p>1 即desk[2]可以坐一个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for(int i=1;i&lt;a.size();i++)</span><br><span class="line">   &#123;</span><br><span class="line">       if(a[i-1]==0&amp;&amp;a[i]==0&amp;&amp;a[i+1]==0)</span><br><span class="line">       &#123;</span><br><span class="line">           a[i]=1;</span><br><span class="line">           co++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   cout&lt;&lt;co;</span><br></pre></td></tr></table></figure>

<h1 id="动规"><a href="#动规" class="headerlink" title="动规"></a>动规</h1><p>这个按csdn目录来的，它规定了每道题的知识点，比如动态规划，但有的题，我实在看不出动规，没有用动规就表明了其他方法</p>
<h2 id="跳格子"><a href="#跳格子" class="headerlink" title="跳格子"></a>跳格子</h2><p>有n个连续格子，但是首尾相连，组成一个圈，可以从任意格子跳，但：</p>
<p>1.连续的格子不挑</p>
<p>2.不能回头跳</p>
<p>计算最高分</p>
<p>输入 2 3 2</p>
<p>输出 3</p>
<p>输入 1 2 3 1</p>
<p>输出 4  （1+3）</p>
<p>思想：</p>
<p>环状情况，分类讨论</p>
<p>先同时查看两个相邻格子，选较大的那个</p>
<p>第一格子和最后一格子只能选择一个</p>
<p>比较0<del>n-2 和1</del>n-1的最终结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int rob1(vector&lt;int&gt;&amp;nums,int s,int e)</span><br><span class="line">&#123;</span><br><span class="line">    int first=nums[s],second=max(nums[s],nums[s+1]);</span><br><span class="line">    for(int i=s+2;i&lt;=e;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int temp=second;</span><br><span class="line">        second=max(first+nums[i],second);//</span><br><span class="line">        first=temp;</span><br><span class="line">        </span><br><span class="line">        //相当于dp[i]=max(dp[i-1],dp[i-2]+nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return second;</span><br><span class="line">&#125;</span><br><span class="line">    int rob(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int len=nums.size();</span><br><span class="line">        if(len==1) return nums[0];</span><br><span class="line">        else if(len==2) return max(nums[0],nums[1]);</span><br><span class="line"></span><br><span class="line">        return max(rob1(nums,0,len-2),rob1(nums,1,len-1));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int rob1(vector&lt;int&gt; nums,int s,int e)</span><br><span class="line">   &#123;</span><br><span class="line">       int len=nums.size();</span><br><span class="line">         vector&lt;int&gt; dp(len+2);//定义为从第i间房子抢，最多的钱为dp[i]</span><br><span class="line">     //  0~n-1</span><br><span class="line">       dp[len]=0;</span><br><span class="line">       for(int i=e;i&gt;=s;i--)</span><br><span class="line">       &#123;</span><br><span class="line">           dp[i]=max(dp[i+2]+nums[i],dp[i+1]);</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       return dp[s];</span><br><span class="line">   &#125;</span><br><span class="line">   int rob(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">       int len=nums.size();</span><br><span class="line">       if(len==1) return nums[0];</span><br><span class="line">       else if(len==2) return max(nums[0],nums[1]);</span><br><span class="line"></span><br><span class="line">       return max(rob1(nums,0,len-2),rob1(nums,1,len-1));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="雨花石"><a href="#雨花石" class="headerlink" title="雨花石"></a>雨花石</h2><p>n个不同重量的雨花石，两人平分，重量相等</p>
<p>输入 </p>
<p>4  个数n </p>
<p>1 1 2 2  n个不同重量 m[k]&lt;1001</p>
<p>输出</p>
<p>2 从当前雨花石取出的最少数量，or -1</p>
<p>定义dp[i][j]，i个石头里，重量为j时至少取走a[i][j]个</p>
<p>a[0][j]&#x3D;n;(j&#x3D;1~avg)&#x2F;&#x2F;记为取无穷个</p>
<p>如果取的重量为m的石头，比j大，等于没操作，a[i][j]&#x3D;a[i-1][j];</p>
<p>每取走一个重量为m的石头，次数更新为dp[i][j-m]+1</p>
<p>dp[i][j]等于上面两情况取min</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int pingfen(vector&lt;int&gt; nums,int m)</span><br><span class="line">&#123;</span><br><span class="line">    if(m%2!=0) return -1;</span><br><span class="line">    int n=nums.size();</span><br><span class="line">    int avg=m/2;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; dp(n+1,vector&lt;int&gt;(avg+1));//有i个石头，使得总重量为j，至少取a[i][j]次，使得总重量为0</span><br><span class="line">    for(int i=1;i&lt;=avg;i++) //取0个石头，使得重量为i的次数</span><br><span class="line">    &#123;</span><br><span class="line">          dp[0][i]=n;//即无穷次</span><br><span class="line">    &#125;</span><br><span class="line">      for (int i = 1; i &lt;= n; i++) &#123;//取第i块石头</span><br><span class="line">            int num = nums[i - 1];</span><br><span class="line">            for (int j = 1; j &lt;= avg; j++) &#123;//i个石头的重量</span><br><span class="line">                if (j &lt; num) &#123; //当前石头重量大于j，</span><br><span class="line">                    dp[i][j] = dp[i - 1][j];//则无法放入这个石头</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    /*</span><br><span class="line">                    两个选择</span><br><span class="line">                    1.不放入该石头，沿用之前的式子</span><br><span class="line">                    2.放入该石头，那么总重量减少</span><br><span class="line">                    +1，说明使用了该石头，石头个数+1</span><br><span class="line">                    3.要最少的石头个数嘛</span><br><span class="line">                    */</span><br><span class="line">                    dp[i][j] =min(dp[i - 1][j], dp[i - 1][j - num] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(dp[n][avg]==n) return -1;</span><br><span class="line">        else return dp[n][avg];</span><br><span class="line">      </span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">    // string s;</span><br><span class="line">    // cin&gt;&gt;s;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">      vector&lt;int&gt; a(n);</span><br><span class="line">    int m=0;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        m+=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   /*</span><br><span class="line">   1 2 3 1 </span><br><span class="line">   4</span><br><span class="line">   */</span><br><span class="line">   cout&lt;&lt;pingfen(a,m);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="玩牌获取最高分"><a href="#玩牌获取最高分" class="headerlink" title="玩牌获取最高分"></a>玩牌获取最高分</h2><p>1.抽取某张牌后，获得对应分数</p>
<p>2.如果不抽牌，其分数为3轮前的总分数；如果当前是第一轮，第二轮或第三轮，总分数置0</p>
<p>输入描述</p>
<p>第一行为n轮的牌面分数</p>
<p>分数值为整数</p>
<p>输出描述</p>
<p>最终选手<strong>最高</strong>总分数</p>
<blockquote>
<p>输入1 -5 -6 4 3 6 -2</p>
<p>输出11</p>
</blockquote>
<p>1.一旦不抽牌，为<strong>3轮前的总分数</strong>，不满3轮不抽牌，则置0</p>
<p>2.所以即使可能遇到负数也要加和，保持最高分</p>
<p>PS:噢，n轮啊，前3轮已经说明了，1，-5，-6 不用另找变量累积了，误以为当某轮结束后，新的轮数从1开始</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int zongfen(vector&lt;int&gt; s)</span><br><span class="line">&#123;</span><br><span class="line">    int n=s.size();</span><br><span class="line">    vector&lt;int&gt; dp(n+1,0);//i轮时的最高分dp[i]</span><br><span class="line">    dp[1]=max(0,s[0]);</span><br><span class="line">    int count=0,co=0;</span><br><span class="line">    for(int i=2;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        //当前轮选牌后的分数</span><br><span class="line">        count=dp[i-1]+s[i-1];</span><br><span class="line">      //  cout&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">        if(i-1&lt;3)//前3轮  2-1=1是第二轮 3-1=2是第三轮</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=max(count,0);</span><br><span class="line">        &#125;</span><br><span class="line">        else //从第4轮开始</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=max(count,dp[i-3]);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;dp[i-1]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    vector&lt;int&gt; v;</span><br><span class="line">    string s,t;</span><br><span class="line">    //cin&gt;&gt;s; //cin遇到空格也会结束</span><br><span class="line">    getline(cin,s);</span><br><span class="line">    stringstream ss(s);</span><br><span class="line">    while(getline(ss,t,&#x27; &#x27;))</span><br><span class="line">    &#123;</span><br><span class="line">        v.push_back(stoi(t));</span><br><span class="line">    &#125;</span><br><span class="line">   cout&lt;&lt;zongfen(v);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="最小步数"><a href="#最小步数" class="headerlink" title="最小步数"></a>最小步数</h2><p>坐标0点到坐标点n的最小步数，一次沿横坐标只能向左或向右2步或3步</p>
<p>ps:途径坐标点可为负数</p>
<p>输入坐标点n 4</p>
<p>输出		2</p>
<p>即0-&gt;4 先右移两步，再两步</p>
<p>下面这个不对哈，有时候不要考虑那么多，走一步看一步，抓关键点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">dp[0]=0;dp[1]=2;dp[2]=1;dp[3]=1;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">   for(int i=4;i&lt;=end;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       //当i=4,向右两次2步</span><br><span class="line">       if(i%2==0&amp;&amp;i%3!=0)</span><br><span class="line">       &#123;</span><br><span class="line">           cout&lt;&lt;&quot;%2&quot;&lt;&lt;endl;</span><br><span class="line">           dp[i]=dp[i-2]+1;</span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line">       //当i=9，dp[5]+1，即一次三步</span><br><span class="line">       else if(i%2!=0&amp;&amp;i%3==0)</span><br><span class="line">       &#123;</span><br><span class="line">           cout&lt;&lt;&quot;%3&quot;&lt;&lt;endl;</span><br><span class="line">            dp[i]=dp[i-3]+1;</span><br><span class="line">       &#125;</span><br><span class="line">      //当i=6;</span><br><span class="line">       else if(i%2==0&amp;&amp;i%3==0)</span><br><span class="line">       &#123;</span><br><span class="line">           cout&lt;&lt;&quot;%2 and %3&quot;&lt;&lt;endl;</span><br><span class="line">           dp[i]=min(dp[i-2]+1,dp[i-3]+1);</span><br><span class="line">       &#125;</span><br><span class="line">      // 当i=7 是4了，但正确为3</span><br><span class="line">       else if(i%2!=0&amp;&amp;i%3!=0)</span><br><span class="line">       &#123;</span><br><span class="line">           dp[i]=dp[i-2]+dp[i-3];</span><br><span class="line">       &#125;</span><br><span class="line">       cout&lt;&lt;&quot;dp[&quot;&lt;&lt;i&lt;&lt;&quot;] &quot;&lt;&lt;dp[i]&lt;&lt;endl;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>用的3越多，步数就越小</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int bushu(int end)</span><br><span class="line">&#123;</span><br><span class="line">    end=abs(end);</span><br><span class="line">    int dp[end+1];//当前坐标i时，从0到i需要移动的最小步数</span><br><span class="line">    if(end==1) return 2;</span><br><span class="line">    else if(end==2||end==3) return 1;</span><br><span class="line"></span><br><span class="line">    dp[0]=0;dp[1]=2;dp[2]=1;dp[3]=1;</span><br><span class="line"></span><br><span class="line">    //用的3越多，步数越小</span><br><span class="line">    for(int i=4;i&lt;=end;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i]=dp[i-3]+1;</span><br><span class="line">        dp[i]=min(dp[i-2]+1,dp[i]);</span><br><span class="line">        //dp[i]=min()</span><br><span class="line">        cout&lt;&lt;&quot;dp[i]&quot;&lt;&lt;&quot;,&quot;&lt;&lt;i&lt;&lt;&quot;: &quot;&lt;&lt;dp[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[end];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最大可靠性-暴力破解"><a href="#最大可靠性-暴力破解" class="headerlink" title="最大可靠性(暴力破解)"></a>最大可靠性(暴力破解)</h2><p>一个设备N种类型元器件组成(每种类型元器件只要1个，类型编号0~N-1)，每个元器件均有可靠性属性reliability</p>
<p>可靠性越高的器件其价格price越贵</p>
<p>而设备可靠性由组成设备的所有器件中可靠性最低的器件决定</p>
<p>给定预算S，买N种器件(每种类型都要一个)，不超过预算的情况下，给出能够组成的设备最大可靠性</p>
<p>输入:</p>
<p>500 3&#x2F;&#x2F;预算和需要种类数</p>
<p>6 &#x2F;&#x2F;元器件总数</p>
<p>0 80 100</p>
<p>0 90 200</p>
<p>1 50 50</p>
<p>1 70 210</p>
<p>2 50 100</p>
<p>2 60 150</p>
<p>输出</p>
<p>60 &#x2F;&#x2F;符合的最大可靠性  </p>
<p>说明:0的80,1的70,2的60；短板效应，所以是60</p>
<p>暴力枚举，三for()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">struct qijian&#123;</span><br><span class="line">    int id;</span><br><span class="line">    int rely;</span><br><span class="line">    int price;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    int num,n;</span><br><span class="line">    cin&gt;&gt;num&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    int m;</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    vector&lt;qijian&gt; v;</span><br><span class="line">    for(int i=0;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        qijian a;</span><br><span class="line">        cin&gt;&gt;a.id&gt;&gt;a.rely&gt;&gt;a.price;</span><br><span class="line"></span><br><span class="line">        v.push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    int result=0;</span><br><span class="line">    for(int i=0;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j=i+1;j&lt;m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int k=j+1;k&lt;m;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(v[i].price+v[j].price+v[k].price&lt;=num&amp;&amp;(v[i].id!=v[j].id)&amp;&amp;(v[i].id!=v[k].id))</span><br><span class="line">                &#123;</span><br><span class="line">                    int tem=min(v[i].rely,v[j].rely);</span><br><span class="line">                    tem=min(tem,v[k].rely);</span><br><span class="line"></span><br><span class="line">                    result=max(result,tem);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;result;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>500 3<br>6<br>0 80 100<br>0 90 200<br>1 50 50<br>1 70 210<br>2 50 100<br>2 60 150</p>
<p>输出：60</p>
</blockquote>
<h2 id="日志首次上报最多积分-读题是难点，双for"><a href="#日志首次上报最多积分-读题是难点，双for" class="headerlink" title="日志首次上报最多积分(读题是难点，双for)"></a>日志首次上报最多积分(读题是难点，双for)</h2><p>每成功上报一条日志，奖励1分；</p>
<p>每条日志每延迟上报1s，扣1分；</p>
<p>积累日志达到100条，必须立即上报</p>
<p>给出日志序列，根据以上规则，计算首次上报能获得的最多积分数</p>
<p>输入：</p>
<p>按时序产生的日志条数T1,T2…Tn</p>
<p>输出：</p>
<p>首次上报最多能获得的积分数</p>
<blockquote>
<p>input:1 98 1</p>
<p>output:98</p>
</blockquote>
<p>说明：</p>
<blockquote>
<p>input:3 7 40 10 60</p>
<p>output:37</p>
</blockquote>
<p>说明：</p>
<p><strong>它每一次的上报是累积的结果</strong>，首次上报的意思是，随时都可以上报，那些由于延迟而扣的分，是因为它们之前没有在正确的时刻上报过，所以要统计出到当前的日志总条数，再按延迟减</p>
<p>T1上报，当前3条，+3分</p>
<p>T2上报，当前7条，前1s上报3条，共10条，但T1延迟了1s，-3，故10-3&#x3D;7分</p>
<p>T3上报，当前40条，前2s上报10跳，共50条，但是T2延迟了1s，-7，T1延迟了2s，-2*3</p>
<p>故50-1*7-2*3&#x3D;37分</p>
<p>T4上报，当前10条，前3s上报了50条，共60条；但T3延迟1s，-40；T2延迟了2s，-2*7&#x3D;-14；T1延迟了3s，-3*3&#x3D;-9；共60-40-14-9&#x3D;-3分</p>
<p>T5上报，当前60，前4s上报了3+7+40+10&#x3D;60，共120条；</p>
<p>超过100条了，所以按上报100条起，T4延迟了1s，-10；T3延迟了2s，-2*40&#x3D;-80,；T2延迟了3s，-3*7&#x3D;-21；T1延迟了4s，-4*3&#x3D;12</p>
<p>故100-10-80-21-12&#x3D;-23</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int shangbao(vector&lt;int&gt; a)</span><br><span class="line">&#123;</span><br><span class="line">    int n=a.size();</span><br><span class="line">    //int dp[n+1];//上第i时刻上报日志条数，首次上报最多的积分数</span><br><span class="line"></span><br><span class="line">    int res=0;</span><br><span class="line">    //dp[0]=0;</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">       int result=a[i],co=0;//上报总日志数、待扣除的积分</span><br><span class="line">       for(int j=0;j&lt;i;j++)</span><br><span class="line">       &#123;</span><br><span class="line">            result+=a[j];//累加上报值</span><br><span class="line">            co+=(i-j)*a[j];//延迟*对应条数</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       if(result&gt;100) result=100;</span><br><span class="line">       </span><br><span class="line">       result-=co;</span><br><span class="line">       res=max(res,result);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    vector&lt;int&gt; v;</span><br><span class="line">    string s,t;</span><br><span class="line">    getline(cin,s);//以\n结束</span><br><span class="line">    stringstream ss(s);</span><br><span class="line">    while(getline(ss,t,&#x27; &#x27;))</span><br><span class="line">    &#123;</span><br><span class="line">        v.push_back(stoi(t));</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;shangbao(v);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="积木最远距离"><a href="#积木最远距离" class="headerlink" title="积木最远距离"></a>积木最远距离</h2><p>小华和小微一起通过玩积木游戏学习数学。</p>
<p> 他们有很多积木，每个积木块上都有一个数字，积木块上的数字可能相同。 小华随机拿一些积木挨着排成一排，请小微找到这排积木中数字相同且所处位置最远的2块积木块，计算他们的距离， 小微请你帮忙替她解决这个问题。 </p>
<p>输入描述 第一行输入为N，表示小华排成一排的积木上数字</p>
<p>输出描述 相同数字的积木的位置最远距离；</p>
<p>如果所有积木数字都不相同，请返回-1. </p>
<p>备注： 0 &lt;&#x3D; 积木上的数字 &lt;&#x3D; 10^9 1 &lt;&#x3D; 积木长度 &lt;&#x3D; 10^5</p>
<p>示例1 输入输出示例仅供调试，后台判题数据一般不包含示例</p>
<p> 输入 5 </p>
<p>​		1 2 3 1 4 </p>
<p>输出 3 </p>
<p>说明： 共有5个积木，第1个积木和第4个积木数字相同，其距离为3. </p>
<p>示例2 输入输出示例仅供调试，后台判题数据一般不包含示例 </p>
<p>输入 2 	</p>
<p>​		1 2 </p>
<p>输出 -1 </p>
<p>说明 一共有2个积木，没有积木数字相同，返回-1.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int juli(vector&lt;int&gt; a)</span><br><span class="line">&#123;</span><br><span class="line">    int n=a.size();</span><br><span class="line"></span><br><span class="line">    //两块相同数字的最远距离</span><br><span class="line">    int res=-1;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int pre=a[i];</span><br><span class="line">        for(int j=i+1;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(pre==a[j]) res=max(res,j-i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;int&gt; a(n);</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    cin&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;juli(a);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>时间复杂度上的优化，使用unordered_map</p>
<p>映射表中的键值，查找时的时间复杂度O(1)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int juli(vector&lt;int&gt; a)</span><br><span class="line">&#123;</span><br><span class="line">    unordered_map&lt;int,int&gt; mp;//键为数字大小，值为索引</span><br><span class="line">    int res=-1;</span><br><span class="line">    for(int i=0;i&lt;a.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        auto iter=mp.find(a[i]);//哈希表中查找该键</span><br><span class="line">        if(iter==mp.end())//没找到</span><br><span class="line">        &#123;</span><br><span class="line">            mp.insert(make_pair(a[i],i));//存进去</span><br><span class="line">        &#125;</span><br><span class="line">        else//找到了</span><br><span class="line">        &#123;</span><br><span class="line">            if(i-iter-&gt;second&gt;res) //距离是否更大</span><br><span class="line">            res=i-iter-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h1 id="补充知识点"><a href="#补充知识点" class="headerlink" title="补充知识点"></a>补充知识点</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replace(a.begin(),a.end(),&#x27;a&#x27;,&#x27;s&#x27;); //替换指定字符</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Check&#123; </span><br><span class="line">	int x;</span><br><span class="line">	int y;</span><br><span class="line">// 定义 operator== 成员函数</span><br><span class="line">    bool operator==(const Check&amp; other) const &#123;</span><br><span class="line">        return x == other.x &amp;&amp; y == other.y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        bool operator&gt;(const Check&amp; other) const &#123;</span><br><span class="line">        // 比较 x 和 y，根据自定义的逻辑返回结果</span><br><span class="line">        // 例如，这里我们假设只要 x 和 y 的和大于对方的和，就认为当前对象大于对方对象</span><br><span class="line">        return (x + y) &gt; (other.x + other.y);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p>快排</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void quicksort(vector&lt;int&gt;&amp; a,int left,int right)</span><br><span class="line">&#123;</span><br><span class="line">    if(left&gt;=right) return;</span><br><span class="line"></span><br><span class="line">    int first=left;</span><br><span class="line">    int last=right;</span><br><span class="line">    int key=a[first];</span><br><span class="line">    while(first&lt;last)</span><br><span class="line">    &#123;</span><br><span class="line">        while(first&lt;last&amp;&amp;a[last]&gt;key) last--;</span><br><span class="line">        if(first&lt;last) a[first++]=a[last];</span><br><span class="line"></span><br><span class="line">        while(first&lt;last&amp;&amp;a[first]&lt;=key) first++;</span><br><span class="line">        if(first&lt;last) a[last--]=a[first];</span><br><span class="line"></span><br><span class="line">        a[first]=key;</span><br><span class="line">        quicksort(a,left,first-1);</span><br><span class="line">        quicksort(a,first+1,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    vector&lt;int&gt; a=&#123;1,8,9,5,3,2,7&#125;;</span><br><span class="line">    quicksort(a,0,a.size()-1);</span><br><span class="line">    for (auto aa:a)</span><br><span class="line">    cout&lt;&lt;aa&lt;&lt;&quot; &quot;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="两数之和最优解"><a href="#两数之和最优解" class="headerlink" title="两数之和最优解"></a>两数之和最优解</h3><p>给数组nums，有目标target，找到和为target的两个整数的下标</p>
<p>利用unorder</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">map&lt;int,int&gt; numtoindex;</span><br><span class="line">vector&lt;int&gt; ss(vector&lt;int&gt; a,int t)</span><br><span class="line">&#123;</span><br><span class="line">   for(int i=0;i&lt;a.size();i++)</span><br><span class="line">   &#123;</span><br><span class="line">        int num=t-a[i];</span><br><span class="line">        if(numtoindex.find(num)!=numtoindex.end())</span><br><span class="line">        &#123;</span><br><span class="line">            return &#123;numtoindex[num],i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        numtoindex[a[i]]=i;</span><br><span class="line">   &#125;</span><br><span class="line">   return &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    vector&lt;int&gt; a=&#123;1,8,9,5,3,2,7&#125;;</span><br><span class="line">    int t=7;</span><br><span class="line">    vector&lt;int&gt; res=ss(a,t);</span><br><span class="line">    if(res.size()!=0) cout&lt;&lt;res[0]&lt;&lt;&quot;,&quot;&lt;&lt;res[1];</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>3,5</p>
</blockquote>
<h1 id="20230802"><a href="#20230802" class="headerlink" title="20230802"></a>20230802</h1><h3 id="第一题-100"><a href="#第一题-100" class="headerlink" title="第一题 100%"></a>第一题 100%</h3><p>就是找宝藏，有n个箱子，删除k个i编号的箱子，使得剩下的箱子个数小于等于原个数的一半</p>
<p> 1 1 1 1 3 3 3 6 6 8  10个箱子，1号箱子4个，3号3个，6号2个，8号1个</p>
<p>我用的map，统计i号箱子，及其个数</p>
<p>按个数从大到小排</p>
<p>初始化result&#x3D;n</p>
<p>遍历mp:map</p>
<p>num&#x3D;num-mp.second</p>
<p>co++&#x2F;&#x2F;统计箱子个数</p>
<p>如果满足 num&lt;&#x3D;n&#x2F;2 break;</p>
<h3 id="第二题-40"><a href="#第二题-40" class="headerlink" title="第二题 40%"></a>第二题 40%</h3><p>哎，这个题，待检测目录的大小统计</p>
<p>给目录行数n，待检测目录ID</p>
<p>n行目录，格式为 目录ID(1~200)，目录大小 (子目录)</p>
<p>如</p>
<blockquote>
<p>3 2</p>
<p>3 20 ()</p>
<p>2 15 (1)</p>
<p>1 20 (3)</p>
<p>输出</p>
<p>55</p>
</blockquote>
<p>这个倒是小问题</p>
<p>主要是</p>
<blockquote>
<p>4 2</p>
<p>3 20 ()</p>
<p>2 15 (1,4)</p>
<p>1 20 (3)</p>
<p>4 15 ()</p>
<p>输出</p>
<p>15+20+20+15&#x3D;70</p>
</blockquote>
<p>有逗号了</p>
<p>记不清了</p>
<p>当时想的是递归，但是存储的时候就有问题，我塔喵用vector&lt;string&gt; s，没错，就是把前面的值当做下标i，比如，s[1]&#x3D;”20 (3)”，塔喵的</p>
<p>做第三题的时候才想到struct，应该用struct的</p>
<p>int id</p>
<p>int size</p>
<p>vector&lt;int&gt; next;</p>
<p>这样存储看着也好点吧</p>
<h4 id="完善代码"><a href="#完善代码" class="headerlink" title="完善代码"></a>完善代码</h4><p>思想</p>
<blockquote>
<p>1.struct起存储作用</p>
<p>2.map建立映射关系，目录与大小的映射mp1；父目录与子目录的映射mp2</p>
<p>3.递归遍历子目录、子目录的子目录、子目录的子目录的子目录。。。</p>
<p>4.相加的话，直接加mp1[id]就可以了</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct mulu&#123;</span><br><span class="line">    int id;</span><br><span class="line">    int size;</span><br><span class="line">    vector&lt;int&gt; nextid;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map&lt;int,int &gt;mp1;//来个映射，目录与大小映射</span><br><span class="line">map&lt;int,vector&lt;int&gt; &gt;mp2;//目录与子目录映射</span><br><span class="line">void yingshe(vector&lt;mulu&gt; a)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    //目录与大小</span><br><span class="line">    for(auto tem:a)</span><br><span class="line">    &#123;</span><br><span class="line">        mp1[tem.id]=tem.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //目录与子目录</span><br><span class="line">      for(auto tem:a)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=0;i&lt;tem.nextid.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            mp2[tem.id].push_back(tem.nextid[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int jisuan(map&lt;int,int&gt; mp1,map&lt;int,vector&lt;int&gt; &gt;mp2,int n)</span><br><span class="line">&#123;</span><br><span class="line">    int result=0;</span><br><span class="line">    for(auto dir:mp2)//目录与子目录</span><br><span class="line">    &#123;   </span><br><span class="line">        if(dir.first==n)//先将父目录的大小加上来</span><br><span class="line">        &#123;</span><br><span class="line">            result+=mp1[n];</span><br><span class="line">        for(auto dir1:dir.second)//遍历它的子目录</span><br><span class="line">        &#123;</span><br><span class="line">            //n=dir1;</span><br><span class="line">            //result+=jisuan(mp1,mp2,n);//这样不对，应该是要把参数改为&amp;n，所以用下面的吧</span><br><span class="line">            result+=jisuan(mp1,mp2,dir1);//递归子目录的子目录</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    /*</span><br><span class="line">    3 2</span><br><span class="line"></span><br><span class="line">3 20 ()</span><br><span class="line"></span><br><span class="line">2 15 (1)</span><br><span class="line"></span><br><span class="line">1 20 (3)</span><br><span class="line">    */</span><br><span class="line">   int m,n;</span><br><span class="line">   cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    vector&lt;mulu&gt; dir;</span><br><span class="line">   for(int i=0;i&lt;m;i++)</span><br><span class="line">   &#123;</span><br><span class="line">        string t;</span><br><span class="line">        mulu a;</span><br><span class="line">        cin&gt;&gt;a.id&gt;&gt;a.size;</span><br><span class="line">        cin&gt;&gt;t;</span><br><span class="line">        t=t.substr(1,t.size()-2);</span><br><span class="line">        cout&lt;&lt;&quot;now the t is&quot;&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">        if(t.size()==0) a.nextid.push_back(0);//没有值</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if(!count(t.begin(),t.end(),&#x27;,&#x27;))//只有一个值</span><br><span class="line">                a.nextid.push_back(stoi(t));</span><br><span class="line">            else   //有多个子目录</span><br><span class="line">            &#123;</span><br><span class="line">                stringstream ss(t);</span><br><span class="line">                string s;</span><br><span class="line">                while(getline(ss,s,&#x27;,&#x27;))</span><br><span class="line">                 a.nextid.push_back(stoi(s));</span><br><span class="line">            &#125;</span><br><span class="line">            // string shuzi=&quot;&quot;;</span><br><span class="line">            // for(int k=0;k&lt;t.size();k++)</span><br><span class="line">            // &#123;</span><br><span class="line">            //     if(isdigit(t[k]))</span><br><span class="line">            //     shuzi+=t[k];</span><br><span class="line">            //     else if(k==t.size()-1)//末尾</span><br><span class="line">            //     &#123;</span><br><span class="line">            //         a.nextid.push_back(stoi(shuzi));</span><br><span class="line">            //     &#125;</span><br><span class="line">            //     else if(t[k]==&#x27;,&#x27;)</span><br><span class="line">            //     &#123;</span><br><span class="line">            //         cout&lt;&lt;shuzi&lt;&lt;endl;</span><br><span class="line">            //         a.nextid.push_back(stoi(shuzi));</span><br><span class="line">            //         shuzi=&quot;&quot;;</span><br><span class="line">            //     &#125;</span><br><span class="line"></span><br><span class="line">            // &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dir.push_back(a);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    yingshe(dir);</span><br><span class="line"></span><br><span class="line">//    for(auto tem:dir)</span><br><span class="line">//    &#123;</span><br><span class="line">//     cout&lt;&lt;tem.id&lt;&lt;&quot;,&quot;&lt;&lt;tem.size&lt;&lt;&quot;,&quot;;</span><br><span class="line">//     for(auto tem1:tem.nextid)</span><br><span class="line">//     &#123;</span><br><span class="line">//         cout&lt;&lt;tem1&lt;&lt;&quot;,&quot;;</span><br><span class="line">//     &#125;</span><br><span class="line">//     cout&lt;&lt;endl;</span><br><span class="line">//    &#125;</span><br><span class="line">cout&lt;&lt;jisuan(mp1,mp2,n);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第三题-60"><a href="#第三题-60" class="headerlink" title="第三题 60%"></a>第三题 60%</h3><p>这个题，哎，一开始没看懂题，花了不少时间，虽然最后可能看懂了，但没时间了</p>
<p>它是这样的，分销公司自己的钱+下级公司上交的钱（开始这里就没注意），如果满100，上交给它的上级公司15，不够100就算了</p>
<p>比如 199	还是15</p>
<p>​		200	就是30</p>
<p>注意的是，最终的钱上交给唯一一个公司，称为boss。</p>
<p>且输入不会有回路</p>
<p>输入格式</p>
<p>第一行 行数n</p>
<p>第二行起的n行，格式为分销公司Id 上级公司id 钱</p>
<p>如</p>
<blockquote>
<p>5</p>
<p>1 0 100</p>
<p>2 0 199</p>
<p>3 0 200</p>
<p>4 0 200</p>
<p>5 0 200</p>
<p>输出boss 15+15+30+30+30</p>
</blockquote>
<p>这题我觉得有两个关键点</p>
<p>1是找boss</p>
<p>2是子公司上交的钱</p>
<p>先找出boss</p>
<p>比如</p>
<blockquote>
<p>5</p>
<p>1 4 200</p>
<p>2 4 200</p>
<p>3 4 200</p>
<p>4 0 200</p>
<p>5 0 200</p>
</blockquote>
<p>我的中间阶段的想法是：</p>
<p>上面这三个我用了struct boss啊，int no, int boss, int money</p>
<p>先用vector&lt;boss&gt; a接收了值</p>
<p>先找boss:</p>
<p>这里又引入一个map&lt;int,vector&lt;int&gt; &gt;mp 存储映射关系 键为可能的boss,值为其子公司</p>
<p>上面的例子存储结果为:</p>
<p>0 4,5</p>
<p>4 1,2,3</p>
<p>我到了中期阶段才想到，如果是真正的boss，它是不会出现在值里的</p>
<p>那我引入了一个vector&lt;int&gt; head，存储键，内容为(0,4)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> t:mp)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​	head.<span class="built_in">push_back</span>(t.first);</span><br><span class="line"></span><br><span class="line">​	<span class="keyword">for</span>(<span class="keyword">auto</span> tem:mp)</span><br><span class="line"></span><br><span class="line">&#123;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tem.second.<span class="built_in">size</span>();i++)</span><br><span class="line"></span><br><span class="line">​	<span class="keyword">if</span>(head.<span class="built_in">back</span>()==tem.second[i]) head.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>这里的head[0]应该就是boss了</p>
<p>然后关于计算我也有个map&lt;int,int&gt; mp2</p>
<p>这里就是遍历vector&lt;boss&gt; s，键为tem.boss，值为上交的钱((money&#x2F;100)*15);</p>
<p>mp2的结果就是</p>
<blockquote>
<p>0 30+30&#x3D;60</p>
<p>4 90</p>
</blockquote>
<p><strong>噢~，问题就出现在这里</strong></p>
<p>当时我的中期乃至后期思想是这样的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">	for(auto tem:mp2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	if(tem.first==head[0])</span><br><span class="line">		result+=tem.second;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		result+=(tem.second/100)*15;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样得到了 0 60</p>
<p><strong>但是正确的逻辑应该是下面的</strong></p>
<p>4 90</p>
<p>而4 0 200</p>
<p>所以mp2的内容应该是</p>
<blockquote>
<p>0 30</p>
<p>4 90</p>
</blockquote>
<p>那么其实最终有</p>
<blockquote>
<p>4 290</p>
</blockquote>
<p>0收到的钱应该是30+(290&#x2F;100)*15&#x3D;60</p>
<p>。。。</p>
<p>怪不得，有多少用例答案是这样凑巧对的。</p>
<p>这样说的话，感觉可以套用第二题啊</p>
<p>等等</p>
<blockquote>
<p>0 4,5</p>
<p>4 1,2,3</p>
</blockquote>
<p>让我们这样分析一下，0公司收获了200+4公司的钱，而4公司收获了600，本身有200，则4公司有</p>
<p>所以0公司收获800&#x2F;100，嘶不对</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">struct gongsi&#123;</span><br><span class="line"></span><br><span class="line">    int id;</span><br><span class="line">    int shangji;</span><br><span class="line">    int money;</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;int,int&gt; mp1;</span><br><span class="line">map&lt;int,vector&lt;int&gt; &gt;mp2;</span><br><span class="line">void yingshe(vector&lt;gongsi&gt; gs)</span><br><span class="line">&#123;</span><br><span class="line">    //公司与钱</span><br><span class="line">    for(auto tem:gs)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;tem.id&lt;&lt;endl;</span><br><span class="line">        mp1[tem.id]=tem.money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //公司与子公司</span><br><span class="line">    for(auto tem:gs)</span><br><span class="line">    &#123;</span><br><span class="line">        mp2[tem.shangji].push_back(tem.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;int&gt; head;//boss作为键，不会出现在值里</span><br><span class="line">void zhaoboss(map&lt;int,vector&lt;int&gt; &gt;mp2)</span><br><span class="line">&#123;</span><br><span class="line">    //题目限定 boss就一个</span><br><span class="line">    for(auto tem:mp2)</span><br><span class="line">    &#123;</span><br><span class="line">        head.push_back(tem.first);</span><br><span class="line"></span><br><span class="line">        for(auto tem1:mp2)</span><br><span class="line">        &#123;</span><br><span class="line">            if(count(tem1.second.begin(),tem1.second.end(),head.back()))</span><br><span class="line">            head.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//难点在于从最子公司上交，是boss的直属子公司的话，那还要先等其子公司上交完了再说</span><br><span class="line">/*</span><br><span class="line">公司与子公司</span><br><span class="line">0 1</span><br><span class="line">1 2,3,4</span><br><span class="line">这种处理方法就是，将2,3,4上交给1的钱加起来</span><br><span class="line">再与1本身的钱相加做处理，再交给0，最终才是0所得</span><br><span class="line"></span><br><span class="line">所以是1的钱先暂时不交给0，等其子公司忙完再说</span><br><span class="line"></span><br><span class="line">那如果是</span><br><span class="line">0 1</span><br><span class="line">1 2,3,4</span><br><span class="line">4 5</span><br><span class="line"></span><br><span class="line">先等5交给4</span><br><span class="line">再等4本身的钱+5上交的钱 给1</span><br><span class="line">1本身的钱+2,3,4上交的钱，处理后，给0</span><br><span class="line"></span><br><span class="line">怎么搞</span><br><span class="line">关键是上级公司很多，下级公司也很多</span><br><span class="line">每个公司交钱，将自己的+下级公司上交的钱上交</span><br><span class="line">每个上级公司上交给自己的上级前，需要等待下级公司的上交</span><br><span class="line">作为上级公司，怎么知道自己下级公司交完了呢？</span><br><span class="line">1 2 3 4</span><br><span class="line">4 5</span><br><span class="line">*/</span><br><span class="line">map&lt;int,int&gt; mp3;</span><br><span class="line">int jisuan(map&lt;int,int&gt; mp1,map&lt;int,vector&lt;int&gt; &gt;mp2,int boss)</span><br><span class="line">&#123;</span><br><span class="line">    for(auto tem:mp2)//子公司对接名单咯</span><br><span class="line">    &#123;</span><br><span class="line">        //直系公司先不处理，就是直接上交给boss的</span><br><span class="line">        if(tem.first!=boss)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;gongsi&gt; gs;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        gongsi a;</span><br><span class="line">        cin&gt;&gt;a.id&gt;&gt;a.shangji&gt;&gt;a.money;</span><br><span class="line">        gs.push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    // for(auto a:gs)</span><br><span class="line">    // &#123;</span><br><span class="line">    //     cout&lt;&lt;a.id&lt;&lt;a.shangji&lt;&lt;a.money&lt;&lt;endl;</span><br><span class="line">    // &#125;</span><br><span class="line"></span><br><span class="line">    yingshe(gs);</span><br><span class="line"></span><br><span class="line">    // for(auto a:mp1)</span><br><span class="line">    // cout&lt;&lt;a.first&lt;&lt;&quot;,&quot;&lt;&lt;a.second&lt;&lt;endl;</span><br><span class="line">    // for(auto a:mp2)</span><br><span class="line">    // &#123;</span><br><span class="line">    //     cout&lt;&lt;a.first&lt;&lt;&quot; &quot;;</span><br><span class="line">    //   for(auto aa:a.second)</span><br><span class="line">    //   &#123;</span><br><span class="line">    //     cout&lt;&lt;aa&lt;&lt;&quot;,&quot;;</span><br><span class="line">    //   &#125;</span><br><span class="line">    //   cout&lt;&lt;endl;</span><br><span class="line">    // &#125;</span><br><span class="line">    zhaoboss(mp2);</span><br><span class="line">    int boss=head[0];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="完善代码-1"><a href="#完善代码-1" class="headerlink" title="完善代码"></a>完善代码</h4><p>几天时间后，</p>
<p>思路：</p>
<blockquote>
<p>1.两个映射，map&lt;int,vector&lt;int&gt; &gt; mp1 记录公司与子公司</p>
<p>​	map&lt;int,int&gt; 记录公司与自己的钱，注意的是boss需要额外添加</p>
<p>2.找boss，没什么好说的，遍历mp1，如果键出现在了值里，它就不是boss</p>
<p>3.jisuan(mp1,mp2,id)，这个计算逻辑：</p>
<p> 如果有个底层公司直接归属于上级，直接上交</p>
<p>如果子公司还有子公司，那就遍历，直到子公司是底层为止</p>
<p>比如映射关系如下</p>
<p>0 4,5</p>
<p>4 1,2,3</p>
<p>先找到boss，从boss的子公司开始遍历，是4</p>
<p>那么，开始递归，4的子公司，1有没有子公司呢（mp1的键上有它没有）</p>
<p>没有，则直接交15%给4，修改mp2对应的值，同时将交钱的公司，金钱归0</p>
<p>2,3依次类推</p>
<p>5也可以上交，mp2[5]&#x3D;0;</p>
<p>最后mp2的情况就是</p>
<p>0 30</p>
<p>4 290</p>
<p>遍历mp2，如果是boss，直接加，如果不是boss，交15%</p>
</blockquote>
<p>哎，总结：</p>
<p>对于一个公司来说，其有一个底层公司，那就直接上交15%，但如果其子公司还有子公司，先不接收上交，</p>
<p>最后遍历的时候统一计算</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">struct gongsi&#123;</span><br><span class="line"></span><br><span class="line">    int id;</span><br><span class="line">    int shangji;</span><br><span class="line">    int money;</span><br><span class="line"> //   vector&lt;int&gt; xiaji;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;int&gt; head;</span><br><span class="line">map&lt;int,vector&lt;int&gt; &gt; mp1;//公司与子公司映射</span><br><span class="line">//void zhaoboss(map&lt;int,vector&lt;gongsi&gt; &gt; companies)//单纯把键存起来，即可能的boss</span><br><span class="line">map&lt;int,int&gt; mp2;//公司id与money映射</span><br><span class="line"></span><br><span class="line">void zhaoboss(map&lt;int,vector&lt;int&gt; &gt; mp1)</span><br><span class="line">&#123;</span><br><span class="line">    for(auto tem:mp1)//如果键出现在值里，不是boss</span><br><span class="line">    &#123;</span><br><span class="line">        head.push_back(tem.first);</span><br><span class="line">        for(auto zigs:tem.second)</span><br><span class="line">        &#123;</span><br><span class="line">            if(head.back()==zigs) head.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void jisuan1(map&lt;int,vector&lt;int&gt; &gt;mp1,map&lt;int,int&gt;&amp; mp2,int id)</span><br><span class="line">&#123;</span><br><span class="line">    if(mp1.count(id))</span><br><span class="line">    &#123;</span><br><span class="line">        for(auto zigs:mp1[id])</span><br><span class="line">        &#123;</span><br><span class="line">            jisuan1(mp1,mp2,zigs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        for(auto tem:mp1)</span><br><span class="line">        &#123;</span><br><span class="line">            if(count(tem.second.begin(),tem.second.end(),id))//底层公司</span><br><span class="line">            &#123;</span><br><span class="line">                  cout&lt;&lt;&quot;Change!&quot;&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;&quot;当前&quot;&lt;&lt;id&lt;&lt;&quot;是底层公司&quot;&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;&quot;上级是&quot;&lt;&lt;tem.first&lt;&lt;&quot;,&quot;&lt;&lt;mp2[tem.first]&lt;&lt;&quot;,&quot;&lt;&lt;mp2[id]&lt;&lt;endl;</span><br><span class="line">                mp2[tem.first]+=mp2[id]/100*15;</span><br><span class="line">                mp2[id]=0;</span><br><span class="line">                cout&lt;&lt;&quot;上交之后&quot;&lt;&lt;mp2[tem.first]&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">   // vector&lt;gongsi&gt; gs(n);</span><br><span class="line">  //  map&lt;int,vector&lt;gongsi&gt; &gt; company;//上级与下级映射</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        gongsi a;</span><br><span class="line">        cin&gt;&gt;a.id&gt;&gt;a.shangji&gt;&gt;a.money;</span><br><span class="line">        mp1[a.shangji].push_back(a.id);</span><br><span class="line">        mp2[a.id]=a.money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    zhaoboss(mp1);</span><br><span class="line">      //boss是没有值的</span><br><span class="line">   // cout&lt;&lt;head[0]&lt;&lt;endl;</span><br><span class="line">   mp2[head[0]]=0;</span><br><span class="line">//    for(auto a:mp1)</span><br><span class="line">//    &#123;</span><br><span class="line">//     cout&lt;&lt;a.first&lt;&lt;&quot; &quot;;</span><br><span class="line">//     for(auto a1:a.second)</span><br><span class="line">//     &#123;</span><br><span class="line">//         cout&lt;&lt;a1&lt;&lt;&quot;,&quot;;</span><br><span class="line">//     &#125;</span><br><span class="line">//     cout&lt;&lt;endl;</span><br><span class="line">//    &#125;</span><br><span class="line">   for(auto a:mp2)</span><br><span class="line">    cout&lt;&lt;a.first&lt;&lt;&quot;,&quot;&lt;&lt;a.second&lt;&lt;endl;</span><br><span class="line">    jisuan1(mp1,mp2,head[0]);</span><br><span class="line">    // for(auto a:company)</span><br><span class="line">    // &#123;</span><br><span class="line">    //     cout&lt;&lt;a.first&lt;&lt;&quot; &quot;;</span><br><span class="line">    //     for(auto a1:a.second)</span><br><span class="line">    //         cout&lt;&lt;a1.id&lt;&lt;&quot;(&quot;&lt;&lt;a1.money&lt;&lt;&quot;),&quot;;</span><br><span class="line"></span><br><span class="line">    //     cout&lt;&lt;endl;</span><br><span class="line">    // &#125;</span><br><span class="line">    for(auto a:mp2)</span><br><span class="line">    cout&lt;&lt;a.first&lt;&lt;&quot;,&quot;&lt;&lt;a.second&lt;&lt;endl;</span><br><span class="line">   //cout&lt;&lt;head[0]&lt;&lt;&quot;,&quot;&lt;&lt;jisuan(company,head[0]);</span><br><span class="line">    </span><br><span class="line">    int result=0;</span><br><span class="line">    for(auto a:mp2)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a.first==head[0])</span><br><span class="line">        result+=a.second;</span><br><span class="line">        else result+=(a.second/100)*15;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    cout&lt;&lt;head[0]&lt;&lt;&quot;,&quot;&lt;&lt;result&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个例子</p>
<blockquote>
<p>5<br>1 0 200<br>2 1 200<br>3 1 200<br>4 1 200<br>5 4 200</p>
<p>0,0<br>1,200<br>2,200<br>3,200<br>4,200<br>5,200</p>
<p>（我打印一下公司的映射关系）</p>
<p>0 1</p>
<p>1 2,3,4</p>
<p>4 5</p>
<p>(从boss开始，0)</p>
<p>Change!<br>当前2是底层公司<br>上级是1,200,200<br>上交之后230<br>Change!<br>当前3是底层公司<br>上级是1,230,200<br>上交之后260<br>Change!<br>当前5是底层公司<br>上级是4,200,200<br>上交之后230<br>0,0<br>1,260<br>2,0<br>3,0<br>4,230<br>5,0</p>
<p>最终输出：0,60</p>
</blockquote>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2023/07/02/%E5%8A%9B%E6%89%A3/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/" rel="tag">c++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8A%9B%E6%89%A3/" rel="tag">力扣</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2023/07/03/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            内网穿透
          
        </div>
      </a>
    
    
      <a href="/2023/07/02/%E6%98%A5%E7%A7%8B/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">chunqiu</div>
      </a>
    
  </nav>

  
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2023
        <i class="ri-heart-fill heart_icon"></i> 是羽泪云诶
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/favicon.ico" alt="小张之栈"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>