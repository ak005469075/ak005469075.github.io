<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>C++知识点 |  小张之栈</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-C"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  C++知识点
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/08/03/C/" class="article-date">
  <time datetime="2023-08-02T16:21:20.000Z" itemprop="datePublished">2023-08-03</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/C-%E7%9F%A5%E8%AF%86%E7%82%B9/">C++知识点</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">11.1k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">43 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="基础知识点"><a href="#基础知识点" class="headerlink" title="基础知识点"></a>基础知识点</h1><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230804173925602.png" alt="指针与变量"></p>
<p>无论是int *p，还是void *p，不会对存储的值有影响</p>
<p>但是嘞，如果要存储整形数字的话，是需要声明类型的，比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void *p=&amp;a;</span><br><span class="line">*p=8; //这就会报错</span><br><span class="line"></span><br><span class="line">所以是</span><br><span class="line">int *p=&amp;a;</span><br><span class="line">*p=8;</span><br></pre></td></tr></table></figure>

<p>这就是指针的工作原理</p>
<p>看下，下面这个，分配内存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;string.h&gt;</span><br><span class="line">...</span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	char *buffer=new char[8];</span><br><span class="line">	memset(buffer,1,8);</span><br><span class="line">	</span><br><span class="line">	//delete[] buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230804180029168.png" alt="分配8个字节内存"></p>
<p>开辟了8个字节，存储了一个指向该数据开头的指针</p>
<p>双指针嘞，那值就变成地址了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char *buffer=new char[8];</span><br><span class="line">	memset(buffer,1,8);</span><br><span class="line"></span><br><span class="line">	char** ptr=&amp;buffer;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230804181127018.png" alt="双指针"></p>
<p>在十六进制表示中<code>0x1c7080</code>，<strong>左</strong>侧是<strong>最高</strong>有效字节（MSB），<strong>右</strong>侧是<strong>最低</strong>有效字节（LSB）。</p>
<p>大端：高地址存低字节，(人类的顺序)</p>
<p>小端：低地址存低字节 </p>
<p>堆中的变量(程序员自己new或malloc的)：分配的内存一般是按照地址递增的顺序存储的。堆往高地址生长，先声明的变量位于低地址</p>
<p>栈中的变量：栈往低地址生长，先声明的变量位于高地址</p>
<h1 id="1-虚函数"><a href="#1-虚函数" class="headerlink" title="1.虚函数"></a>1.虚函数</h1><p><code>virtual 类型 成员函数名 (参数表);</code></p>
<p>虚函数必须存在于类的继承环境中才有意义</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>不同<strong>对象</strong>调用相同的<strong>函数</strong>，但呈现多样的<strong>结果</strong></p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="编译时多态"><a href="#编译时多态" class="headerlink" title="编译时多态"></a>编译时多态</h4><p>编译过程中静态确定同名操作与具体对象绑定的关系（函数重载、运算符重载、模板）</p>
<p>优点：程序运行时函数调用速度快、效率高</p>
<p>缺点：编程不灵活</p>
<h4 id="运行时多态"><a href="#运行时多态" class="headerlink" title="运行时多态"></a>运行时多态</h4><p>动态确定同名操作与具体对象绑定的关系（继承和虚函数）</p>
<p>优点：编程更加灵活、系统易于扩展</p>
<p>缺点：调用速度比静态绑定的函数慢</p>
<p><strong>条件：</strong></p>
<p><code>1.有虚函数；</code></p>
<p><code>			2.符合赋值兼容规则；</code></p>
<p><code>3.由指针或引用去调用虚函数</code></p>
<h5 id="如果不用虚函数"><a href="#如果不用虚函数" class="headerlink" title="如果不用虚函数"></a>如果不用虚函数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class test1&#123;</span><br><span class="line">protected:</span><br><span class="line">    int b;</span><br><span class="line">public:</span><br><span class="line">    test1(int v):b(v) &#123;&#125;</span><br><span class="line">  //  virtual void eat()=0;</span><br><span class="line">    void eat()&#123;</span><br><span class="line">        cout&lt;&lt;&quot;test1&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class him:public test1&#123;</span><br><span class="line">public:</span><br><span class="line">    him():test1(0)&#123;&#125;</span><br><span class="line">    // virtual void eat() override&#123;</span><br><span class="line">    //     cout&lt;&lt;&quot;him,&quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    // &#125;</span><br><span class="line">    void eat() &#123;</span><br><span class="line">        cout&lt;&lt;&quot;him,&quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class you:public test1&#123;</span><br><span class="line">private:</span><br><span class="line">    int c;</span><br><span class="line">public:</span><br><span class="line">    you():test1(1),c(2)&#123;&#125;</span><br><span class="line">    // virtual void eat() override&#123;</span><br><span class="line">    //     cout&lt;&lt;&quot;you,&quot;&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">    // &#125;</span><br><span class="line">    void eat() &#123;</span><br><span class="line">        cout&lt;&lt;&quot;you,&quot;&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    you* pyou=new you();</span><br><span class="line">    him* phim=new him();</span><br><span class="line"></span><br><span class="line">	//基类的指针指向派生类的对象</span><br><span class="line">    test1* eater1=(test1*)pyou;</span><br><span class="line">    test1* eater2=(test1*)phim;</span><br><span class="line"></span><br><span class="line">    eater2-&gt;eat();</span><br><span class="line">    eater1-&gt;eat();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>test1<br>test1</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">class test1&#123;</span><br><span class="line">protected:</span><br><span class="line">    int b;</span><br><span class="line">public:</span><br><span class="line">    test1(int v):b(v) &#123;&#125;</span><br><span class="line">    virtual void eat()=0;</span><br><span class="line">&#125;;</span><br><span class="line">class him:public test1&#123;</span><br><span class="line">public:</span><br><span class="line">    him():test1(0)&#123;&#125;</span><br><span class="line">    virtual void eat() override&#123;</span><br><span class="line">        cout&lt;&lt;&quot;him,&quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class you:public test1&#123;</span><br><span class="line">private:</span><br><span class="line">    int c;</span><br><span class="line">public:</span><br><span class="line">    you():test1(1),c(2)&#123;&#125;</span><br><span class="line">    virtual void eat() override&#123;</span><br><span class="line">        cout&lt;&lt;&quot;you,&quot;&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    you* pyou=new you();</span><br><span class="line">    him* phim=new him();</span><br><span class="line">	</span><br><span class="line">	//基类的指针指向派生类的对象</span><br><span class="line">    test1* eater1=(test1*)pyou;</span><br><span class="line">    test1* eater2=(test1*)phim;</span><br><span class="line">	</span><br><span class="line">	//相同结果</span><br><span class="line">	 // you pyou;</span><br><span class="line">    // him phim;</span><br><span class="line"></span><br><span class="line">    // test1* eater1= &amp;pyou;</span><br><span class="line">    // test1* eater2= &amp;phim;</span><br><span class="line">	</span><br><span class="line">    eater2-&gt;eat();// 调用 him 类的 eat() 函数</span><br><span class="line">    eater1-&gt;eat();//// 调用 you 类的 eat() 函数</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>him,0<br>you,2</p>
</blockquote>
<p><code>有了虚函数</code>，<strong>指定哪个对象，就调用哪个函数的方法</strong></p>
<p>类-&gt;内存对象-&gt;虚函数表</p>
<p>PS:那个override可写可不写，c++11提出的，为了增加可读性</p>
<p>​	<strong>基类函数写了virtual，派生类就不需要写了，重写一遍函数就行了</strong></p>
<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>指在delete对象指针的时候，调用的函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Base *bp;</span><br><span class="line"></span><br><span class="line">bp=new derived();//Base的派生</span><br><span class="line"></span><br><span class="line">delete bp;</span><br></pre></td></tr></table></figure>

<p>如果基类没有加virtual，delete时只返回基类的析构</p>
<p>如果基类加了virtual，派生的析构可不加，delete时返回基类+派生的析构</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>而且基类一般不需要实现virtual 函数，它只为派生提供一个接口，只用提供函数名，而不实现函数体，即为<strong>纯虚函数</strong> ：<code>virtual void eat()=0;</code>(声明语句，而不能被调用)</p>
<p>有<strong>纯虚函数</strong>的类叫做<strong>抽象类</strong>，不能实例化一个抽象类的对象，所以会报错，因为没有具体的功能实现</p>
<p>如果其派生类也不实现同名函数的话（比如，直接不写eat()函数）也会报错的。</p>
<p><strong>纯虚函数</strong>的优点就是可以防止派生类忘记实现虚函数</p>
<h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>虚函数的使用：</p>
<p>第一步，基类，声明某个基类函数为virtual</p>
<p>第二步。派生类，定义在基类的virtual函数</p>
<p>第三步，声明基类指针，指向派生类，调用virtual函数</p>
<p> 虚函数（Virtual Function）是通过一张虚函数表（Virtual Table） 来实现的。简称为 V-Table 。在这个表中，主是要一个类的虚 函数的地址表，这张表解决了继承、覆盖的问题，保证其容 真实反应实际的函数。</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>在面向对象程序设计中，创建一个只包含未实现方法然后交由子类去实际实现功能的类是非常普遍的,这通常被称为<strong>接口</strong>。<strong>接口就是一个只包含未实现的方法并作为一个模板的类</strong>。并且由于此<strong>接口类</strong>实际上不包含方法实现，所以我们<strong>无法实例化</strong>这个类。</p>
<p>比如来个打印类名的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class printable&#123;//接口，就纯模板</span><br><span class="line">public:</span><br><span class="line">    virtual string printclass()=0;</span><br><span class="line">&#125;;</span><br><span class="line">//基类</span><br><span class="line">class entity:public printable&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual string getname()&#123;return &quot;entity&quot;;&#125;</span><br><span class="line">     string printclass()  &#123;return &quot;entity&quot;;&#125;//实现接口的纯需函数</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">//派生类</span><br><span class="line">class player:public entity&#123;//继承entity，entity已有接口</span><br><span class="line">private:</span><br><span class="line">    string pname;</span><br><span class="line">public:</span><br><span class="line">    player(const string&amp; name):pname(name)&#123;&#125;</span><br><span class="line">     string getname()  &#123;return pname;&#125;</span><br><span class="line">     string printclass()  &#123;return &quot;player&quot;;&#125;//实现接口的纯虚函数</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void print(printable *obj)&#123;//为了输出返回值为string类型的函数，它接收printable对象，不关心什么类</span><br><span class="line">    cout&lt;&lt;obj-&gt;printclass()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    entity* e=new entity();</span><br><span class="line">   // player* p=new player(&quot;132&quot;);</span><br><span class="line">   entity*p =new player(&quot;132&quot;);</span><br><span class="line">    print(e);</span><br><span class="line">    print(p);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>entity<br>player</p>
</blockquote>
<p>PS:如果player不继承entity</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class player : public Otherclass,printable&#123;</span><br><span class="line">	...</span><br><span class="line">	string pintclass() &#123;return &quot;player&quot;;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个就体现了下接口。</p>
<p>当然啊，如果还是看虚函数的话</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//基类</span><br><span class="line">class entity:public printable&#123;</span><br><span class="line">public:</span><br><span class="line">     //virtual string getname()&#123;return &quot;entity&quot;;&#125;</span><br><span class="line">     string getname()&#123;return &quot;entity&quot;;&#125;</span><br><span class="line">     string printclass()  &#123;return &quot;entity&quot;;&#125;//实现接口的纯需函数</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">   entity* e=new entity();</span><br><span class="line">   // player* p=new player(&quot;132&quot;);</span><br><span class="line">    entity*p =new player(&quot;132&quot;);</span><br><span class="line">    // print(e);</span><br><span class="line">    // print(p);</span><br><span class="line">    cout&lt;&lt;e-&gt;getname();</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;p-&gt;getname();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>entity<br>entity</p>
</blockquote>
<p>但是：基类函数加了virtual后嘞</p>
<blockquote>
<p>entity<br>132</p>
</blockquote>
<h1 id="2-C-中-const、define、static-的区别？"><a href="#2-C-中-const、define、static-的区别？" class="headerlink" title="2.C++中 const、define、static 的区别？"></a>2.C++中 const、define、static 的区别？</h1><p><strong>const</strong> 是单词 constant 的简写，字面意思是<strong>常数</strong>、常量。 用于变量修饰，表明这个变量<strong>不能被修改</strong>；用于指针修饰， 表明指针的指向物<strong>不能被修改</strong>；用于方法修饰，表明这个方法<strong>不会</strong>对对象造成改变。 </p>
<p><strong>#define</strong> 和另外两个不一样，它属于<strong>宏</strong>，是预处理器的一部分。 预处理是在编译之前的一道，简单地进行字符串替换，它不按照语言的语法，而是直管自己的语法。</p>
<p> <strong>static</strong> 的定义相对较复杂，用在<strong>全局变量</strong>表明这个变量在每个编译单元有独自的实例；用在函数里的<strong>局部变量</strong>，表明它的生存周期其实是全局变量，但仅在函数内可见；用在<strong>类成员</strong>，表明成员或者方法是类的，而不是对象实例的。</p>
<h1 id="3-对于epoll底层结构和原理有什么了解？"><a href="#3-对于epoll底层结构和原理有什么了解？" class="headerlink" title="*3. 对于epoll底层结构和原理有什么了解？"></a>*3. 对于epoll底层结构和原理有什么了解？</h1><p>这啥啊Σ(⊙▽⊙”a</p>
<p>eventpoll的使用中，经常需要对文件描述符集合进行添加、删除等操作，同时对触发的事件类型进行处理，回调IO事件中的工作函数。</p>
<p>epoll,<strong>I&#x2F;O多路复用技术</strong>，最大特点是<strong>支持高并发</strong>，从linux内核2.6引入的</p>
<p>头文件<code>#include &lt;sys/epoll.h&gt;</code></p>
<p>三个关键函数</p>
<blockquote>
<p>创建 eventpoll 对象</p>
<p>int epoll_create(int size); </p>
<p>操作 eventpoll 对象</p>
<p>int epoll_ctl(int epfd, int op, int fd, struct epoll_events* event);</p>
<p>从 eventpoll 对象中返回活跃的事件。</p>
<p>int epoll_wait(int epfd, struct epoll_event* events, int maxevents, int timeout);</p>
</blockquote>
<h3 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create;"></a>epoll_create;</h3><blockquote>
<ul>
<li>功能：创建一个epoll对象，返回该对象的描述符【文件描述符】，这个描述符就代表这个epoll对象，后续会用到。</li>
<li>这个epoll对象最终要用close()，因为文件描述符&#x2F;句柄 总是关闭的。</li>
<li>size &gt; 0;。</li>
</ul>
</blockquote>
<h3 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h3><blockquote>
<ul>
<li>功能：把一个socket以及这个socket相关的事件添加到这个epoll对象描述符中去，目的就是通过这个epoll对象来监视这个socket【客户端的TCP连接】上数据的来往情况；当有数据来往时，系统会通知我们。</li>
<li>我们把感兴趣的事件通过 epoll_ctl()  添加到系统，当这些事件来的时候，系统会通知我们。</li>
<li>efpd：epoll_create()返回的epoll对象描述符</li>
<li>op：动作，添加&#x2F;删除&#x2F;修改 ，对应数字是1,2,3， EPOLL_CTL_ADD, EPOLL_CTL_DEL ,EPOLL_CTL_MOD</li>
<li>EPOLL_CTL_ADD添加事件：等于你往红黑树上添加一个节点，每个客户端连入服务器后，服务器都会产生一个对应的socket，每个连接这个socket值都不重复，所以，这个socket就是红黑树中的key，把这个节点添加到红黑树上去</li>
<li>EPOLL_CTL_MOD：修改事件，用了EPOLL_CTL_ADD把节点添加到红黑树上之后，才存在修改</li>
<li>EPOLL_CTL_DEL：是从红黑树上把这个节点干掉这会导致这个socket【这个tcp链接】上无法收到任何系统通知事件</li>
<li>sockid：表示客户端连接，就是你从accept()这个是红黑树里边的key;</li>
<li>event：事件信息，这里包括的是 一些事件信息EPOLL_CTL_ADD和EPOLL_CTL_MOD都要用到这个event参数里边的事件信息</li>
</ul>
</blockquote>
<h3 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h3><blockquote>
<ul>
<li>功能：阻塞一小段时间并等待事件发生，返回事件集合，也就是获取内核的事件通知</li>
</ul>
</blockquote>
<h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p>CSDN<a target="_blank" rel="noopener" href="https://me.csdn.net/baidu_41388533">NGC_2070</a></p>
<h1 id="4-epoll-的-ET-模式和-LT-模式哪个更高效？"><a href="#4-epoll-的-ET-模式和-LT-模式哪个更高效？" class="headerlink" title="4. epoll 的 ET 模式和 LT 模式哪个更高效？"></a>4. epoll 的 ET 模式和 LT 模式哪个更高效？</h1><p>LT(level triggered) 默认&#x2F;缺省的工作方式，同时支持 block和no_block socket。这种工作方式下，内核会通知你一个fd是否就绪，然后才可以对这个就绪的fd进行I&#x2F;O操作。就算你没有任何操作，系统还是会继续提示fd已经就绪，不过这种工作方式出错会比较小，传统的select&#x2F;poll就是这种工作方式的代表。</p>
<p>ET(edge-triggered) 是高速工作方式，仅支持no_block socket，这种工作方式下，当fd从未就绪变为就绪时，内核会通知fd已经就绪，并且内核认为你知道该fd已经就绪，不会再次通知了，除非因为某些操作导致fd就绪状态发生变化。如果一直不对这个fd进行I&#x2F;O操作，导致fd变为未就绪时，内核同样不会发送更多的通知，因为only once。所以这种方式下，出错率比较高，需要增加一些检测程序。</p>
<p>PS:fd(文件描述符)</p>
<p><strong>LT可以理解为水平触发，只要有数据可以读，不管怎样都会通知。而ET为边缘触发，只有状态发生变化时才会通知，可以理解为电平变化</strong>。</p>
<p>来源<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37003559">编程哲学家</a></p>
<p>所以嘞：</p>
<p> ET 模式更加高效。<br>与 poll 的事件宏相比， epoll 新增了一个事件宏 EPOLLET ， 这就是所谓的边缘触发模式（<br>Edge Trigger ， ET ），而默认的模式称为水平触发模式（Level Trigger， LT ）。 对于水平触发模式，一个事件只要有，<strong>就会一直触发</strong>； 对于边缘触发模式，只有一个事件从无到有才会触发。</p>
<p>CSDN博主<a target="_blank" rel="noopener" href="https://blog.csdn.net/Lushengshi/article/details/127580635">「丘比特惩罚陆」</a></p>
<h1 id="5-什么情况下C-STL迭代器会失效？"><a href="#5-什么情况下C-STL迭代器会失效？" class="headerlink" title="5.什么情况下C++STL迭代器会失效？"></a>5.什么情况下C++STL迭代器会失效？</h1><p>当容器调用 erase() 方法后，当前位置到容器末尾元素的所有迭代器全部失效。 当容器调用 insert() 方法后，当前位置到容器末尾元素的所有迭代器全部失效。 如果容器扩容，在其他地方重新又开辟了一块内存。原来容器底层的内存上所保存的迭代器全都失效了。</p>
<h1 id="6-什么是右值引用？和移动语义、完美转发有什么联系？"><a href="#6-什么是右值引用？和移动语义、完美转发有什么联系？" class="headerlink" title="6.什么是右值引用？和移动语义、完美转发有什么联系？"></a>6.什么是右值引用？和移动语义、完美转发有什么联系？</h1><p>它是移动语义和完美转发的基石，定义右值引用需要使用&amp;&amp;、右值引用一定不能被左值所初始 化，只能用右值初始化。</p>
<h2 id="左值"><a href="#左值" class="headerlink" title="左值"></a>左值</h2><p>有地址、数值、有存储空间的值，长期存在</p>
<p>左值<strong>是由某种存储支持的变量，左值有地址和值</strong>，可以出现在赋值运算符左边或右边</p>
<h2 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h2><p>左值引用仅仅接收左值，除非用了const兼容（非const的左值引用只接受左值），所以c++常用<strong>常量</strong>引用。</p>
<p><strong>它们兼容临时的右值和实际存在的左值变量</strong></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    int x=8;</span><br><span class="line">    int&amp; refx=x;</span><br><span class="line">    cout&lt;&lt;&quot;x: &quot;&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;refx: &quot;&lt;&lt;refx&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    refx=28;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;x: &quot;&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;refx: &quot;&lt;&lt;refx&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>x: 8<br>refx: 8<br>x: 28<br>refx: 28</p>
</blockquote>
<p>有一个值为10的int变量，声明一个左值引用并使用初始化它。现在，指的是与相同的内存位置。<code>x``refX``x``refX``x</code></p>
<p>对 所做的任何更改<code>refX</code>也会影响 的值，<code>x</code>因为它们引用相同的内存位置。在示例中，当我们修改<code>refX</code>，它也会修改的值<code>x</code>。</p>
<p>左值引用在 C++ 中用于多种目的，例如通过函数引用传递变量、运算符重载以及为现有变量创建别名。</p>
<h2 id="右值"><a href="#右值" class="headerlink" title="右值"></a>右值</h2><p>就是临时量，无地址（或者有地址，但访问不到，只是一个临时量），没有存储空间而短暂存在的值</p>
<h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p>c++11出现的</p>
<p>右值引用不能绑定到左值，可以通过常引用或右值引用延长右值的生命周期。</p>
<p>“有名字的右值引用”是左值</p>
<p>定义需要使用&amp;&amp;</p>
<h2 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h2><p>c++11后出现的</p>
<h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><p>有时候我们需要单纯创建一些右值，赋给某个对象用作构造函数。</p>
<p>这个时候需要：</p>
<p>在main函数里创建这个右值对象，然后复制给这个对象相应的成员变量。</p>
<p>这里有一个额外行为，是<strong>复制</strong>。</p>
<p>如果我们可以直接把这个<strong>右值变量移动给成员变量</strong>，程序性能就会提高</p>
<p><strong>所以我们要移动对象，而不是复制它，这就有了语义的出现。</strong></p>
<p>看一下复制的情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string.h&gt;//strlen的头文件</span><br><span class="line">using namespace std;</span><br><span class="line">class String&#123;</span><br><span class="line">private:</span><br><span class="line">    char * m_data;</span><br><span class="line">    uint32_t m_size;</span><br><span class="line">public:</span><br><span class="line">    String()=default;</span><br><span class="line">    String(const char* str)//构造函数</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Created!\n&quot;);</span><br><span class="line">        m_size=strlen(str);</span><br><span class="line">        m_data=new char[m_size];</span><br><span class="line">        memcpy(m_data,str,m_size);</span><br><span class="line">    &#125;</span><br><span class="line">    String(const String&amp; other)//拷贝构造函数</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Copyed!\n&quot;);</span><br><span class="line">        m_size=other.m_size;</span><br><span class="line">        m_data=new char[m_size];</span><br><span class="line">        memcpy(m_data,other.m_data,m_size);</span><br><span class="line">    &#125;</span><br><span class="line">    ~String()</span><br><span class="line">    &#123;</span><br><span class="line">        delete m_data;</span><br><span class="line">    &#125;</span><br><span class="line">    void print()</span><br><span class="line">    &#123;</span><br><span class="line">        for (uint32_t i = 0; i &lt; m_size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">           printf(&quot;%c&quot;,m_data[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printf(&quot;\n&quot;);       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class entity&#123;</span><br><span class="line">private:</span><br><span class="line">    String m_name;</span><br><span class="line">public:</span><br><span class="line">    entity(const String&amp; name):m_name(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    void printname()</span><br><span class="line">    &#123;</span><br><span class="line">        m_name.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    entity e(String(&quot;yuleiyun&quot;));</span><br><span class="line">    e.printname();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Created!<br>Copyed!<br>yuleiyun</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String(const String&amp; other)//拷贝构造函数</span><br><span class="line">  &#123;</span><br><span class="line">      printf(&quot;Copyed!\n&quot;);</span><br><span class="line">      m_size=other.m_size;</span><br><span class="line">      m_data=new char[m_size];</span><br><span class="line">      memcpy(m_data,other.m_data,m_size);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>复制字符串，意味着我们需要在堆上分配内存，调用新字符</p>
<p>我们的主函数中写入了参数，然后调用的是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">entity(const String&amp; name):m_name(name)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>为什么不能直接写进</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private:</span><br><span class="line">    String m_name;</span><br></pre></td></tr></table></figure>



<p>这就引入了移动语义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">class String&#123;</span><br><span class="line">private:</span><br><span class="line">    char * m_data;</span><br><span class="line">    uint32_t m_size;</span><br><span class="line">public:</span><br><span class="line">    String()=default;</span><br><span class="line">    String(const char* str)//构造函数</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Created!\n&quot;);</span><br><span class="line">        m_size=strlen(str);</span><br><span class="line">        m_data=new char[m_size];</span><br><span class="line">        memcpy(m_data,str,m_size);</span><br><span class="line">    &#125;</span><br><span class="line">    String(const String&amp; other)//拷贝构造函数</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Copyed!\n&quot;);</span><br><span class="line">        m_size=other.m_size;</span><br><span class="line">        m_data=new char[m_size];</span><br><span class="line">        memcpy(m_data,other.m_data,m_size);</span><br><span class="line">    &#125;</span><br><span class="line">    String(String&amp;&amp; other) noexcept//右值引用拷贝，相当于移动（复制一次指针，原来的指针给nullptr）</span><br><span class="line">    &#123;</span><br><span class="line">     </span><br><span class="line">        printf(&quot;Moved!\n&quot;);</span><br><span class="line">           //新对象的指针指向指定内存，将旧对象的指针移开</span><br><span class="line">           //这里是接管了原来的旧内存</span><br><span class="line">        m_size=other.m_size;</span><br><span class="line">        m_data=other.m_data;</span><br><span class="line">        </span><br><span class="line">        //数据的转移，将other的数据偷走</span><br><span class="line">        other.m_size=0;</span><br><span class="line">        other.m_data=nullptr;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ~String()</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Desdroyed\n&quot;);</span><br><span class="line">        delete m_data;</span><br><span class="line">    &#125;</span><br><span class="line">    void print()</span><br><span class="line">    &#123;</span><br><span class="line">        for (uint32_t i = 0; i &lt; m_size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">           printf(&quot;%c&quot;,m_data[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printf(&quot;\n&quot;);       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class entity&#123;</span><br><span class="line">private:</span><br><span class="line">    String m_name;</span><br><span class="line">public:</span><br><span class="line">    entity(const String&amp; name):m_name(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    entity(String&amp;&amp; name):m_name(move(name))//或者(String&amp;&amp;)name</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    void printname()</span><br><span class="line">    &#123;</span><br><span class="line">        m_name.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    entity e(String(&quot;yuleiyun&quot;));</span><br><span class="line">    e.printname();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Created!<br>Moved!<br>Desdroyed<br>yuleiyun<br>Desdroyed</p>
</blockquote>
<p><code>String(String&amp;&amp; other) noexcept</code></p>
<blockquote>
<p>该<code>&amp;&amp;</code>语法用于定义移动构造函数，它是一种特殊类型的构造函数，允许将资源（如动态分配的内存）从一个对象有效传输到另一个对象。</p>
<p>在 C++ 中，移动构造函数是使用右值引用作为参数来定义的。<code>&amp;&amp;</code>表示这是一个右值引用参数，并且它允许在从右值（临时）对象构造对象或显式转换为右值引用时调用移动<code>other</code>构造函数。</p>
</blockquote>
<p>当一个表达式出现的形式表示它是一个右值，就是告诉编译器，我以后不会再用到这个资源，放心大胆的转移销毁，这就可以做优化，比如节省拷贝之类的。 move的作用是无条件的把表达式转成右值</p>
<p>来源 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/553405837">知乎</a></p>
<h1 id="7-智能指针定义、类别和应用场景"><a href="#7-智能指针定义、类别和应用场景" class="headerlink" title="7.智能指针定义、类别和应用场景"></a>7.智能指针定义、类别和应用场景</h1><p>作用是管理一个指针。</p>
<p>存在以下这种情况：</p>
<p>申请的空间在函数结束时忘记释放，造成内存泄漏。通过智能指针避免该问题。</p>
<p>智能指针是一个类，当超出了类的实例对象的作用域时，会自动调用对象的析构函数，析构函数会自动释放资源。</p>
<p>其作用原理就是：<strong>在函数结束时自动释放内存空间，不需要手动释放内存空间。</strong></p>
<p>unique_ptr独占式，同一时间只允许一个智能指针指向该对象</p>
<p>shared_ptr共享式，多个智能指针指向同一个对象，当最后一个引用被销毁时，就会释放对象和其相关资源</p>
<p>weak_ptr 是一种不控制对象生命周期的智能指针 , 它指向 一个 shared_ptr 管理的对象 . 进行该对象的内存管理的是那个强引用的 shared_ptr ， weak_ptr 只是提供了对管理对象的一个访问手段。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>本质上是原始指针的包装。当你创建一个智能指针，它会调用new并为你分配内存，然后基于你使用的智能指针，这些内存会在某一时刻自动释放。</p>
<p>优先使用unique_ptr，其次考虑shared_ptr</p>
<blockquote>
<p>尽量使用unique_ptr因为它有一个较低的开销，但如果你需要在对象之间共享，不能使用unique_ptr的时候，就使用shared_ptr</p>
</blockquote>
<p><strong>访问所有智能指针，先要有头文件&lt;memory&gt;</strong></p>
<h2 id="作用域指针unique-ptr的使用"><a href="#作用域指针unique-ptr的使用" class="headerlink" title="作用域指针unique_ptr的使用"></a>作用域指针unique_ptr的使用</h2><ul>
<li><p>作用域指针意味着，超出作用域，就会被销毁，调用delete</p>
</li>
<li><p>唯一、不可复制、不可共享</p>
</li>
</ul>
<blockquote>
<p>如果复制一个unique_ptr，会有两个指针，两个unique_ptr指向同一个内存块，如果其中一个死了，它会释放那段内存，也就是说，指向同一块内存的第二个unique_ptr指向了已经被释放的内存。</p>
</blockquote>
<ul>
<li>unique_ptr 需要显示调用构造函数</li>
<li>最好使用 unique_ptr&lt;Entity&gt; entity&#x3D;make_unique&lt;Entity&gt;();以防构造函数抛出异常，得到一个没有引用的空指针而造成内存泄露，稍安全点</li>
<li>make_unique&lt;&gt;() c++14引入</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Entity&#123;</span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    Entity()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Create!&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Entity()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Destroy!&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">       void Print()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">        //unique_ptr&lt;Entity&gt; entity = new Entity(); //错误，unique_ptr不能隐式转换</span><br><span class="line">        //unique_ptr&lt;Entity&gt; entity(new Entity()); //可以，但不建议说是</span><br><span class="line">        unique_ptr&lt;Entity&gt; entity=make_unique&lt;Entity&gt;();</span><br><span class="line">        entity-&gt;Print();//像一般原始指针的使用方式</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Create!<br>Destroy!</p>
</blockquote>
<h2 id="共享指针shared-ptr"><a href="#共享指针shared-ptr" class="headerlink" title="共享指针shared_ptr"></a>共享指针shared_ptr</h2><ul>
<li>其工作方式 <strong>通过引用计数</strong></li>
</ul>
<blockquote>
<p>引用计数基本上是一种方法，可以跟踪你的指针有多少个引用，一旦引用计数达到零，他就被删除了。<br>例如：我创建了一个共享指针shared_ptr，我又创建了另一个shared_ptr来复制它，我的引用计数是2，第一个和第二个，共2个。当第一个死的时候，我的引用计数器现在减少1，然后当最后一个shared_ptr死了，我的引用计数回到零，内存就被释放。</p>
</blockquote>
<ul>
<li>该指针需要分配另一块内存，叫控制块，存储引用计数</li>
</ul>
<blockquote>
<p>首先创建一个new Entity，然后传递给shared_ptr构造函数，它必须分配两次；</p>
<p>用make_shared组合起来更有效率、</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;Entity&gt; sharedEntity = sharedEntity(new Entity());//不推荐！</span><br><span class="line">std::shared_ptr&lt;Entity&gt; sharedEntity = std::make_shared&lt;Entity&gt;();//ok</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">        &#123;</span><br><span class="line">        std::shared_ptr&lt;Entity&gt; e;</span><br><span class="line">        &#123;</span><br><span class="line">        //  std::shared_ptr&lt;Entity&gt; sharedEntity = sharedEntity(new Entity());//不推荐！</span><br><span class="line">            std::shared_ptr&lt;Entity&gt; sharedEntity = std::make_shared&lt;Entity&gt;();//ok</span><br><span class="line">            e = sharedEntity; //可以复制</span><br><span class="line">        &#125; //此时sharedEntity已经“死了”,但没有调用析构，因为e仍然是活的，并且持有对该Entity的引用，此时计数由2-》1</span><br><span class="line">    &#125; //析构被调用，因为所有的引用都消失了，计数由2-&gt;0，内存被释放</span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    std::cin.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Create!<br>Destroy!</p>
</blockquote>
<h2 id="弱指针weak-ptr"><a href="#弱指针weak-ptr" class="headerlink" title="弱指针weak_ptr"></a>弱指针weak_ptr</h2><ul>
<li>可以和shared_ptr一起使用</li>
<li>该指针可以被复制，但 <strong>不会增加额外的控制块来计数</strong>，仅仅声明该指针活着</li>
</ul>
<blockquote>
<p>当你将一个shared_ptr赋值给另外一个shared_ptr，引用计数++，而若是<strong>把一个shared_ptr赋值给一个weak_ptr时，它不会增加引用计数</strong>。这很好，如果你不想要Entity的所有权，就像你可能在排序一个Entity列表，你不关心它们是否有效，你只需要存储它们的一个引用就可以了。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">    std::weak_ptr&lt;Entity&gt; e0;</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;Entity&gt; sharedEntity = std::make_shared&lt;Entity&gt;();</span><br><span class="line">        e0 = sharedEntity;</span><br><span class="line">    &#125; //此时，此析构被调用，内存被释放</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它指向一个 shared_ptr 管理的对象 . 进行该对象的内存管理的是那个强引用的 shared_ptr ， weak_ptr 只是提供了对管理对象的一个访问手段。</p>
<h1 id="8-vector-和-list-有什么区别？"><a href="#8-vector-和-list-有什么区别？" class="headerlink" title="8.vector 和 list 有什么区别？"></a>8.vector 和 list 有什么区别？</h1><p> vector 和 built-in 数组类似，它拥有一段<strong>连续的内存空间</strong>，并且起始地址不变，因此它能非常好的支持<strong>随即存取</strong>，即[] 操作符，但由于它的内存空间是连续的，所以在中间进行插入和删除会造成内存块的拷贝，另外，当该数组后的内存空间不够时，需要重新申请一块足够大的内存并进行内存的拷贝。</p>
<p> list 就是数据结构中的双向链表，它的内存空间<strong>可以是不连续的</strong>，通过<strong>指针来进行数据的访问</strong>， 这个特点使得它的随即存取变的非常没有效率，因此它没有提供[]操作符的重载。<strong>支持任意地方的删除和插入</strong></p>
<p>vector 适用：对象数量变化少，简单对象，随机访问元素频繁；</p>
<p>list 适用：对象数量变化大，对象复杂，插入和删除频繁</p>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p><strong>C++ STL</strong>中提供的一种<strong>容器</strong>，是<strong>线性的双向链表</strong>的数据结构。拥有<strong>链式结构的特征</strong>：<strong>支持元素的快速插入和删除，但是元素随机访问较慢（相较于vector容器），不提供[]运算符的重载</strong>。C++中使用list容器需要包含<strong>头文件<list><strong>，把list当做</strong>双向链表</strong>来看</p>
<p>基本操作</p>
<blockquote>
<p>push_back()</p>
<p>push_front();</p>
<p>pop_</p>
<p>merge()&#x2F;&#x2F;两个list表必须事先有序</p>
<p>sort()</p>
</blockquote>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p>向量</p>
<p>与数组相比其优点在于它能够根据需要随时自动调整自身的大小以便容下所要放入的元素。</p>
<blockquote>
<p>插入 - insert</p>
<p>​    ①、a.insert(a.begin(), 1000);<em>&#x2F;&#x2F;将1000插入到向量a的起始位置前</em></p>
<p>​    ②、a.insert(a.begin(), 3, 1000);<em>&#x2F;&#x2F;将1000分别插入到向量元素位置的0-2处(共3个元素)</em></p>
<p>​    ③、 vector&lt;int&gt; a(5, 1) ;</p>
<p>​        vector&lt;int&gt; b(10) ;</p>
<p>​        b.insert(b.begin(), a.begin(), a.end()) ; <em>&#x2F;&#x2F;将a.begin(), a.end()之间的全部元素插入到b.begin()前</em></p>
<p>删除 - erase</p>
<p>​    ①、b.erase(b.begin());<em>&#x2F;&#x2F;将起始位置的元素删除</em></p>
<p>​    ②、b.erase(b.begin(), b.begin()+3);<em>&#x2F;&#x2F;将(b.begin(), b.begin()+3)之间的元素删除</em></p>
<p>交换 - swap</p>
<p>​        b.swap(a) ;            <em>&#x2F;&#x2F;a向量与b向量进行交换</em></p>
</blockquote>
<h1 id="9-C-内存-New-与-malloc-区别是什么？"><a href="#9-C-内存-New-与-malloc-区别是什么？" class="headerlink" title="9. C++内存 New 与 malloc 区别是什么？"></a>9. C++内存 New 与 malloc 区别是什么？</h1><ol>
<li><p>申请的内存所在位置；</p>
<blockquote>
<p>new：此操作符分配的内存空间是在自由存储区；</p>
<p>malloc：申请的内存是在堆空间。</p>
<p>堆 </p>
<p>​	是C语言和操作系统的术语，堆是操作系统所维护的一块特殊内存，它提供了动态分配的功能，当运行程序调用malloc()时就会从中分配，调用free()归还内存。</p>
<p>自由存储区 </p>
<p>​	是C++中动态分配和释放对象的一个概念，通过new分配的内存区域可以称为自由存储区，通过delete释放归还内存。自由存储区可以是堆、全局&#x2F;静态存储区等，具体是在哪个区，主要还是要看new的实现以及C++编译器默认new申请的内存是在哪里。但是基本上，很多C++编译器默认使用堆来实现自由存储，运算符new和delete内部默认是使用malloc和free的方式来被实现，说它在堆上也对，说它在自由存储区上也正确。因为在C++中new和delete符号是可以重载的，我们可以重新实现new的实现代码，可以让其分配的内存位置在静态存储区等。而malloc和free是C里的库函数，无法对其进行重载。</p>
<p>CSDN博主<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46094676/article/details/129677525">「呆萌理科生」</a></p>
</blockquote>
</li>
<li><p>返回类型安全性；</p>
<blockquote>
<p>new分配内存成功，则返回对象指针，使用new是类型安全的；而malloc分配成功会返回void*类型指针</p>
</blockquote>
</li>
<li><p>内存分配失败时的返回值；</p>
<blockquote>
<p>C++标准中new如果分配内存失败要求抛出bad_alloc异常，需要自己捕捉，但是有些编译器对C++标准的适配没那么好，也会返回null指针，这是保留了C的处理。</p>
<p>而malloc分配失败则会返回null指针。</p>
</blockquote>
</li>
<li><p>是否需要指定的内存大小；</p>
<blockquote>
<p>使用malloc为对象指针分配内存，要明确指定分配内存的大小，而new不需要</p>
<p>malloc返回的指针还需要进行强制类型转换才赋值给A<em>的指针对象，而使用new则不需要，直接返回的是A</em>的指针。</p>
</blockquote>
</li>
<li><p>是否调用构造函数&#x2F;析构函数；</p>
<blockquote>
<p>new调用时先为对象分配内存，再调用对象的构造函数，delete会调用析构函数</p>
<p>而malloc不会</p>
<p>A* a&#x3D;new A();</p>
<p>A* aa&#x3D;(A*)malloc (sizeof(A));</p>
</blockquote>
</li>
<li><p>对数组的处理；</p>
<blockquote>
<p>new的话，有new []，delete []</p>
<p>A * ptr &#x3D; new A[10];&#x2F;&#x2F;分配10个A对象</p>
<p>delete [] ptr;</p>
<p>——————————</p>
<p>int * ptr &#x3D; (int *) malloc( sizeof(int) );&#x2F;&#x2F;分配一个10个int元素的数组</p>
</blockquote>
</li>
<li><p>是否可以被重载；</p>
<blockquote>
<p>new 是操作符，可以被重载，malloc&#x2F;free是库函数，不能被重载</p>
</blockquote>
</li>
<li><p>能够直观的重新分配内存；</p>
<blockquote>
<p>malloc内存不够，可以用realloc扩张内存大小</p>
<p>new没有</p>
</blockquote>
</li>
<li><p>客户处理内存分配不足；</p>
</li>
</ol>
<p>总结：</p>
<p>malloc给你的就好像一块原始的土地，你要种什么需要自己在土地上来播种</p>
<p>而new帮你划好了田地的分块（数组），帮你播了种（构造函数），还提供其他的设施给你使用:</p>
<p><strong>来源：CSDN</strong> <a target="_blank" rel="noopener" href="http://t.csdn.cn/nQer6">AI浩</a></p>
<h1 id="10-常量指针和指针常量有什么区别？"><a href="#10-常量指针和指针常量有什么区别？" class="headerlink" title="10.常量指针和指针常量有什么区别？"></a>10.常量指针和指针常量有什么区别？</h1><p>常量指针又叫常指针，可以理解为常量的指针，指向的是一个常量，这个常量是指针的值(地址)，const在前</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int x = 10; </span><br><span class="line">int y = 20;</span><br><span class="line">const int* ptr = &amp;x;</span><br><span class="line">ptr = &amp;y;</span><br><span class="line">//*x=30 //Error</span><br><span class="line">它可以指向不同的常量，但数据不能改</span><br></pre></td></tr></table></figure>

<p>指针常量本质是一个常量，而用指针修饰它。指针常量的值是指针，这个值因为是常量，所以不能被赋值。const在后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int x = 10;</span><br><span class="line">int y = 20;</span><br><span class="line"></span><br><span class="line">int* const ptr = &amp;x; // ptr is a pointer constant to an integer, pointing to x</span><br><span class="line">//ptr = &amp;y; // Error</span><br><span class="line">*x = 30; // Valid</span><br><span class="line">它可以修改数据，但不能修改指向</span><br></pre></td></tr></table></figure>

<h1 id="11-map-和-unordered-map-的区别以及适用场景？"><a href="#11-map-和-unordered-map-的区别以及适用场景？" class="headerlink" title="11. map 和 unordered_map 的区别以及适用场景？"></a>11. map 和 unordered_map 的区别以及适用场景？</h1><p>map会自动按键的字典序排序</p>
<p>unordered_map随机排序，用于查找</p>
<h1 id="12-静态链接库和动态链接库各自的优缺点分别是什么？"><a href="#12-静态链接库和动态链接库各自的优缺点分别是什么？" class="headerlink" title="12. 静态链接库和动态链接库各自的优缺点分别是什么？"></a>12. 静态链接库和动态链接库各自的优缺点分别是什么？</h1><p>静态链接库的优点：</p>
<blockquote>
<p>代码装载速度快，执行速度略比动态链接库快； </p>
<p>只需保证在开发者的计算机中有正确的.LIB 文件，在以二进制形式发布程序时不需考虑在用户的计算机<br>上 .LIB 文件是否存在及版本问题，可避免 DLL 地狱等问题。</p>
</blockquote>
<p>​		缺点：</p>
<blockquote>
<p>使用静链接生成的可执行文件体积较大，包含相同的公共代码，造成浪费</p>
<p>全量更新</p>
</blockquote>
<p>动态链接库优点：</p>
<blockquote>
<p>更加节省内存并减少页面交换；</p>
<p>DLL 文件与 EXE 文件独立，只要输出接口不变（即名称、参数、返回值类型和调用约定不变），更换 DLL 文件不会对 EXE 文件造成任何影响，因而极大地提高了可维护性和可扩展性；</p>
<p>不同编程语言编写的程序只要按照函数调用约定就可以调用同一个 DLL 函数；</p>
</blockquote>
<p>缺点：</p>
<blockquote>
<p>使用动态链接库的应用程序不是自完备的，它依赖的 DLL 模块也要存在，如果使用载入时动态链接， 程序启动时发现 DLL 不存在，系统将终止程序并给出错误信息。</p>
<p>而使用运行时动态链接，系统不会终止，但由于 DLL 中的导出函数不可用，程序会加载失败；</p>
<p>速度比静态链接慢</p>
<p>当某个模块更新后，如果新模块与旧的模块不兼容，那么那些需要该模块才能运行的软件，统统撕掉。</p>
</blockquote>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>库是写好的现有的，成熟的，可以复用的代码。</p>
<p>静态和动态指<strong>链接</strong></p>
<p>将一个程序编译成可执行程序的步骤：将源文件(.h,.cpp)预编译-&gt;编译-&gt;汇编-&gt;<strong>链接</strong></p>
<p><code>静态库是.lib</code></p>
<p>其特点：</p>
<blockquote>
<ol>
<li>静态库对函数库的链接是放在编译时期完成的</li>
<li>程序在运行时与函数库再无瓜葛，移植方便</li>
<li>浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件</li>
</ol>
</blockquote>
<p><code>动态库是.dll</code></p>
<p>由于静态库的空间浪费和全量更新(如果静态库liba.lib更新了，所以使用它的应用程序都需要重新编译、发布给用户)</p>
<p>其特点：</p>
<blockquote>
<ol>
<li>动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。</li>
<li><strong>不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例</strong>，规避了空间浪费问题</li>
<li>解决了静态库对程序的更新、部署和发布页会带来麻烦</li>
</ol>
</blockquote>
<p>来源CSDN <a target="_blank" rel="noopener" href="http://t.csdn.cn/99Ige">hllyzms</a></p>
<h1 id="13-C-虚函数、纯虚函数的区别和适用场景？"><a href="#13-C-虚函数、纯虚函数的区别和适用场景？" class="headerlink" title="13. C++虚函数、纯虚函数的区别和适用场景？"></a>13. C++虚函数、纯虚函数的区别和适用场景？</h1><p>虚函数:</p>
<p>在类成员方法的声明语句前加 “virtual”, 如 virtual void func() ；</p>
<p>对于虚函数,子类可以(也可以不)重新定义基类的虚函数，该行为称之为复写 Override 。 </p>
<p>纯虚函数:</p>
<p>在虚函数后加“&#x3D;0” ,如 virtual void func()&#x3D;0 ;</p>
<p>对于纯虚函数，<strong>子类必须</strong>提供纯函数的个性化实现</p>
<p>使用场景：当子类<strong>必须</strong>要实现个性化的时候，用纯虚函数</p>
<h1 id="14-是否遇到过-C-变量冲突的情况？如何解决？"><a href="#14-是否遇到过-C-变量冲突的情况？如何解决？" class="headerlink" title="14. 是否遇到过 C++变量冲突的情况？如何解决？"></a>14. 是否遇到过 C++变量冲突的情况？如何解决？</h1><p>换变量名；</p>
<p>应用命名空间；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//来自chatgpt</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">// First namespace named &#x27;A&#x27;</span><br><span class="line">namespace A &#123;</span><br><span class="line">    int num = 5; // Variable &#x27;num&#x27; in namespace &#x27;A&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Second namespace named &#x27;B&#x27;</span><br><span class="line">namespace B &#123;</span><br><span class="line">    int num = 10; // Variable &#x27;num&#x27; in namespace &#x27;B&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // Accessing variables from namespaces</span><br><span class="line">    std::cout &lt;&lt; &quot;Value from namespace A: &quot; &lt;&lt; A::num &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;Value from namespace B: &quot; &lt;&lt; B::num &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>命名空间嵌套；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">namespace Outer &#123;</span><br><span class="line">    int num = 5; // Variable &#x27;num&#x27; in outer namespace &#x27;Outer&#x27;</span><br><span class="line"></span><br><span class="line">    // Inner namespace named &#x27;Inner&#x27; within &#x27;Outer&#x27;</span><br><span class="line">    namespace Inner &#123;</span><br><span class="line">        int num = 10; // Variable &#x27;num&#x27; in inner namespace &#x27;Inner&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">std::cout &lt;&lt; &quot;Value from outer namespace: &quot; &lt;&lt; Outer::num &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; &quot;Value from inner namespace: &quot; &lt;&lt; Outer::Inner::num &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>加入类前缀 作为成员变量</p>
<h2 id="15-聊聊-C-的内存碎片？"><a href="#15-聊聊-C-的内存碎片？" class="headerlink" title="15 .聊聊 C++的内存碎片？"></a>15 .聊聊 C++的内存碎片？</h2><p>即碎片的内存，分为外碎片和内碎片</p>
<p>内存碎片指的是系统中不可用的空闲内存</p>
<p>由于空闲内存小，且以不连续方式出现在不同位置。</p>
<p>该问题解决取决于内存管理算法</p>
<h1 id="16-C-中-lambda-表达式的捕捉变量的方式有哪几种？"><a href="#16-C-中-lambda-表达式的捕捉变量的方式有哪几种？" class="headerlink" title="16. C++中 lambda 表达式的捕捉变量的方式有哪几种？"></a>16. C++中 lambda 表达式的捕捉变量的方式有哪几种？</h1><h2 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h2><p>lambda本质上是一个<strong>匿名函数</strong>。 用这种方式创建函数不需要实际创建一个函数 ，它就像一个<strong>快速的一次性函数</strong> 。 lambda更像是一种变量，在实际编译的代码中作为一个符号存在，而不是像正式的函数那样。</p>
<p>使用格式：<code>[]( &#123;参数表&#125; )&#123; 函数体 &#125;</code></p>
<blockquote>
<p>中括号<strong>表示的是</strong>捕获，作用是<strong>如何传递变量</strong> lambda使用<strong>外部（相对）</strong>的变量时，就要<strong>使用捕获</strong>。</p>
</blockquote>
<p>如果使用捕获,则：</p>
<ul>
<li>添加头文件： <code>#include &lt;functional&gt;</code></li>
<li>修改相应的函数签名 <code>std::function &lt;void(int)&gt; func</code>替代 <code>void(*func)(int)</code></li>
<li>捕获[]使用方式：</li>
</ul>
<blockquote>
<p><code>[=]</code>，则是将所有变量<strong>值传递</strong>到lambda中<br><code>[&amp;]</code>，则是将所有变量<strong>引用传递</strong>到lambda中<br><code>[a]</code>是将变量a通过值传递，如果是<code>[&amp;a]</code>就是将变量a引用传递<br>它可以有0个或者多个捕获</p>
</blockquote>
<p>基础使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line"></span><br><span class="line">void foreach(const std::vector&lt;int&gt; &amp;values,void(*func)(int))</span><br><span class="line">&#123;</span><br><span class="line">    for(int value:values)</span><br><span class="line">        func(value);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    std::vector&lt;int&gt; values=&#123;6,1,7,0,9&#125;;</span><br><span class="line">    foreach(values,[](int value)&#123;std::cout&lt;&lt;&quot;Value: &quot;&lt;&lt;value&lt;&lt;std::endl;&#125;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Value: 6<br>Value: 1<br>Value: 7<br>Value: 0<br>Value: 9</p>
</blockquote>
<p>这里对捕获解释一下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;int&gt; values=&#123;6,1,7,0,9&#125;;</span><br><span class="line"> int a=5;</span><br><span class="line"> auto lambda=[](int value)&#123;std::cout&lt;&lt;&quot;Value: &quot;&lt;&lt;a&lt;&lt;std::endl;&#125;;</span><br><span class="line"> foreach(values,lambda);</span><br></pre></td></tr></table></figure>

<p>看，我们尝试让lambda函数输出a</p>
<blockquote>
<p> error: ‘a’ is not captured<br>     auto lambda&#x3D;[](int value){std::cout&lt;&lt;”Value: “&lt;&lt;a&lt;&lt;std::endl;};<br>                                                     ^<br>lambda.cpp:13:18: note: the lambda has no capture-default<br>     auto lambda&#x3D;[](int value){std::cout&lt;&lt;”Value: “&lt;&lt;a&lt;&lt;std::endl;};<br>                  ^<br>lambda.cpp:12:9: note: ‘int a’ declared here<br>     int a&#x3D;5;</p>
</blockquote>
<p>报错说，a没有<code>捕获</code></p>
<p>在中括号补充一个<code>=</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto lambda=[=](int value)&#123;std::cout&lt;&lt;&quot;Value: &quot;&lt;&lt;a&lt;&lt;std::endl;&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>error: cannot convert ‘main()::&lt;lambda(int)&gt;’ to ‘void (<em>)(int)’ for argument ‘2’ to ‘void foreach(const std::vector&lt;int&gt;&amp;, void (</em>)(int))’<br>     foreach(values,lambda);</p>
</blockquote>
<p>因为使用了<code>捕获</code></p>
<p>所以要添加头文件，然后更改下新的函数指针的签名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">..</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">void foreach(const std::vector&lt;int&gt; &amp;values,const std::function&lt;void(int)&gt;&amp; func)</span><br><span class="line">&#123;</span><br><span class="line">    for(int value:values)</span><br><span class="line">        func(value);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">auto lambda=[=](int value)&#123;std::cout&lt;&lt;&quot;Value: &quot;&lt;&lt;a&lt;&lt;std::endl;&#125;;</span><br><span class="line">//这里[&amp;] [a] [&amp;a]都可</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Value: 5…</p>
</blockquote>
<p>万一我们想对捕获的变量修改值怎么办呢？</p>
<p>需要用到mutable</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">auto lambda=[=](int value) mutable &#123;a=6,std::cout&lt;&lt;&quot;Value: &quot;&lt;&lt;a&lt;&lt;std::endl;&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Value: 6…</p>
</blockquote>
<p>还可以写一个lambda去接受vector元素，遍历该vector找到大于6的数，并返回它的迭代器</p>
<p>find_if是搜索类函数，<code>需要头文件algorithm</code></p>
<p>它与find不同，find_if是<strong>可以接受一个函数指针来定义搜索的规则，返回满足这个规则的第一个元素的迭代器</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    std::vector&lt;int&gt; values=&#123;6,1,7,0,9&#125;;</span><br><span class="line">    auto it=find_if(values.begin(),values.end(),[](int value)&#123;return value&gt;6;&#125;);</span><br><span class="line">   std::cout&lt;&lt;*it;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>7</p>
</blockquote>
<h1 id="17-C-中-final-关键字是做什么的？能否想到更多作用？"><a href="#17-C-中-final-关键字是做什么的？能否想到更多作用？" class="headerlink" title="17.C++中 final 关键字是做什么的？能否想到更多作用？"></a>17.C++中 final 关键字是做什么的？能否想到更多作用？</h1><p>C++11 引入了关键字 final ，按官方的标准是该关键字是 用来标识虚函数不能在子类中被覆盖(override) ，或一个类不能被继承。</p>
<h1 id="18-对-RPC-框架有什么了解？原理？"><a href="#18-对-RPC-框架有什么了解？原理？" class="headerlink" title="18.对 RPC 框架有什么了解？原理？"></a>18.对 RPC 框架有什么了解？原理？</h1><p>使得远端的一个进程可以调用远端另一个进程所提供的方法</p>
<p>RPC用户调用接口 + 具体网络协议。 前者为开发者需要关心的，后者由框架来实现。</p>
<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>如果有一个数独求解服务器，包含了登陆服务模块、计算求解模块、后台管理模块，开始时服务器可以部署在单机，但是如果用户增多、请求计算量增多，那么就需要<strong>集群</strong>和<strong>分布式</strong>部署架构达到高并发要求</p>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>将服务器部署到了多台机器上，每一台机器上都是独立的服务器。</p>
<p>再通过负载均衡服务器进行管理，供用户使用，由此大大增加了服务器的并发负载量。</p>
<p>这种部署方式比较简单，并且切实的提高了服务器的并发量。</p>
<p>缺点：</p>
<p>1.服务器的一个模块修改，所有服务器都要重新编译、部署，所以是<strong>维护麻烦</strong></p>
<p>2.服务器有些模块是CPU密集型，需要CPU性能强的机器，有些I&#x2F;O密集型，需要内存更大点的机器，所以<strong>是各模块对硬件资源要求不同</strong></p>
<p>因此，引入分布式架构</p>
<h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><p><strong>支持分模块部署服务器</strong>，例如将数独服务器的计算模块部署到一个CPU强的机器上（不一定是一个，可以单独对模块进行集群部署），将登录模块部署到内存大的机器上。</p>
<p>如此分模块运行在<strong>不同</strong>机器的docker<strong>虚拟化环境</strong>中，属于<strong>不同的进程</strong>，分布在不同机器的各个模块共同构成了高性能的服务器。由此，<code>集群的两个问题都可以得到解决</code>。</p>
<p><strong>但是</strong>嘞，有这样一种情况：有些模块的某段代码，其他模块也需要调用，这样的话，模块间是有<strong>大量重复代码</strong>的</p>
<p>为了让机器1上的模块调用机器2上模块的方法，必要要有一个通信协议，即<code>RPC通信框架</code></p>
<h3 id="RPC框架原理"><a href="#RPC框架原理" class="headerlink" title="RPC框架原理"></a>RPC框架原理</h3><p>分布式计算的 CS 模式，总是由 Client 向 Server 发出一个执行若干过程请求，Server 接受请求，使用者客户端提供的参数，计算完成之后将结果返回给客户端。</p>
<p><strong>由于提供端与客户端分属于不同的进程乃至不同的机器，那么必定是需要通过网络进行通信，并且需要是可靠的网络。</strong></p>
<p>通信框架一般是这样：</p>
<p>user-&gt;序列化-&gt;通信-&gt;反序列化-&gt;server</p>
<p>其实现需解决三个部分：</p>
<p>1.<code>调用映射</code></p>
<blockquote>
<p>比如调用者要调用RPC的login方法，怎么保证它不会调用到register方法呢？</p>
<p>这就需要RPC框架建立一个映射表，</p>
<p>比如{server_name,severinfo}，serverinfo包含server对象</p>
<p>以及{method_name,methoddescriptor}</p>
<p>先解析server_name,得到要连接的server的ip和端口，再通过method_name找到要调用的函数</p>
</blockquote>
<p>2.<code>序列化与反序列化</code></p>
<blockquote>
<p>一般的参数调用，系统会将参数放进内存中，但是远程调用又是另一台机器，不能通过内存传递函数，需要RPC客户将参数序列化为字节流，传给RPC提供方，它进行反序列化，得到参数。</p>
<p>这个序列化反序列化方法之一是Protobuf，它的字节流是用二进制存储的</p>
<p>并且Protobuf提供了很完备的RPC服务接口，很方便通过.proto文件生成服务器与客户端需要的RPCService类与Stub类。</p>
</blockquote>
<p>3.<code>网络传输</code></p>
<blockquote>
<p>RPC既然是远程调用，离不开网络传输，可以使用muduo库</p>
<p>是一个linux多线程网络库，使用的是reactors in threads - one loop per thread模式，支持多线程，高并发。</p>
</blockquote>
<p>来源: CSDN <a target="_blank" rel="noopener" href="http://t.csdn.cn/LCDLF">Jacky__Ren</a></p>
<p>使用最广泛的 Spring Cloud，基于 Spring Boot 特性整合了开源行业中优秀的组件，整体对外提供了一套在微服务架构中服务治理的解决方案。</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230806221812465.png"></p>
<p>1.服务集成RPC后，Provider启动后会通过Register模块，把服务的唯一ID和IP地址，端口信息等注册到RPC框架注册中心</p>
<p>2.调用者(Consumer)想要调用服务的时候，通过Provider注册时的服务唯一ID去注册中心查找在线可供调用的服务，返回一个IP列表（notify部分）</p>
<p>3.Consumer根据一定策略，比如随机或轮询从Register返回的可用IP列表真正调用服务(invoke)</p>
<p>4.最后是统计功能，RPC框架提供监控功能，监控服务监控状态，控制服务线上扩展和上下线</p>
<h2 id="主流RPC"><a href="#主流RPC" class="headerlink" title="主流RPC"></a>主流RPC</h2><p>RMI(java自带的远程方法调用工具)</p>
<p>Hessian（基于HTTP的远程方法调用）</p>
<p>Dubbo（淘宝开源的基于TCP的RPC框架）</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>Provider：服务提供方，CS 模型中的 Server。<br>Consumer： 调用远程服务服务消费方，CS 模型中的 Client。<br>Registry：服务注册与发现的服务管理中心。<br>Monitor：统计服务的调用次数和调用时间的监控中心。<br>Container：服务运行容器，如 jetty。</p>
<h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>服务容器负责启动，加载，运行服务提供者。<br>服务提供者在启动时，向注册中心注册自己提供的服务，暴露自己的 IP 和端口信息。<br>服务消费者在启动时，向注册中心订阅自己所需的服务。<br>注册中心返回服务提供者列表给消费者，如果有变更，注册中心将基于长连接推送给数据消费者。<br>服务消费者，从提供这地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另外一台服务调用。<br>服务消费者和提供者，在内存中累计调用次数和调用时间，定时发送一次统计数据到监控中心。</p>
<p>来源：CSDN <a target="_blank" rel="noopener" href="http://t.csdn.cn/72BLc">Q.E.D.</a></p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>很多时候不会使用using namespace std;（会不容易分辨各类函数来源）</p>
<p>以vector为例，自己的库定义了一个vector，标准库又有一个，这时候引用using namespace std;</p>
<p>会出现分歧</p>
<p>大型程序往往会使用多个独立开发的库，这些库会定义大量的全局名字，如类、函数和模板等，不可避免会出现某些名字相互冲突的情况。命名空间<code>namespace</code>分割了全局命名空间，其中每个命名空间是一个作用域。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">namespace foo &#123;</span><br><span class="line">    class Bar &#123; /*...*/ &#125;;</span><br><span class="line">&#125;  // 命名空间结束后无需分号</span><br></pre></td></tr></table></figure>



<h1 id="来源-1"><a href="#来源-1" class="headerlink" title="来源"></a>来源</h1><p>CSDN博主<a target="_blank" rel="noopener" href="https://blog.csdn.net/Lushengshi/article/details/127580635">「丘比特惩罚陆」</a></p>
<p>知识补充来源：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/553387258">知乎笔记</a></p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2023/08/03/C/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-%E7%9F%A5%E8%AF%86%E7%82%B9/" rel="tag">C++知识点</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2023/08/03/git/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            git bash
          
        </div>
      </a>
    
    
      <a href="/2023/07/04/%E5%9B%9E%E5%BD%92%E8%AF%BE%E6%9C%AC/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">回归课本</div>
      </a>
    
  </nav>

  
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2023
        <i class="ri-heart-fill heart_icon"></i> 是羽泪云诶
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/favicon.ico" alt="小张之栈"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>