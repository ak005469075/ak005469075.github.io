<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>C++知识点 |  小张之栈</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-C"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  C++知识点
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/08/03/C/" class="article-date">
  <time datetime="2023-08-02T16:21:20.000Z" itemprop="datePublished">2023-08-03</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/C-%E7%9F%A5%E8%AF%86%E7%82%B9/">C++知识点</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">27.8k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">109 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="基础知识点"><a href="#基础知识点" class="headerlink" title="基础知识点"></a>基础知识点</h1><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230804173925602.png" alt="指针与变量"></p>
<p>无论是int *p，还是void *p，不会对存储的值有影响</p>
<p>但是嘞，如果要存储整形数字的话，是需要声明类型的，比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void *p=&amp;a;</span><br><span class="line">*p=8; //这就会报错</span><br><span class="line"></span><br><span class="line">所以是</span><br><span class="line">int *p=&amp;a;</span><br><span class="line">*p=8;</span><br></pre></td></tr></table></figure>

<p>这就是指针的工作原理</p>
<p>看下，下面这个，分配内存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;string.h&gt;</span><br><span class="line">...</span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	char *buffer=new char[8];</span><br><span class="line">	memset(buffer,1,8);//将内存的内容设置为指定值</span><br><span class="line">	</span><br><span class="line">	//delete[] buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230804180029168.png" alt="分配8个字节内存"></p>
<p>开辟了8个字节，存储了一个指向该数据开头的指针</p>
<p>双指针嘞，那值就变成地址了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char *buffer=new char[8];</span><br><span class="line">	memset(buffer,1,8);</span><br><span class="line"></span><br><span class="line">	char** ptr=&amp;buffer;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230804181127018.png" alt="双指针"></p>
<p>在十六进制表示中<code>0x1c7080</code>，<strong>左</strong>侧是<strong>最高</strong>有效字节（MSB），<strong>右</strong>侧是<strong>最低</strong>有效字节（LSB）。</p>
<p>大端：高地址存低字节，(人类的顺序)</p>
<p>小端：低地址存低字节 </p>
<p>堆中的变量(程序员自己new或malloc的)：分配的内存一般是按照地址递增的顺序存储的。堆往高地址生长，先声明的变量位于低地址</p>
<p>栈中的变量：栈往低地址生长，先声明的变量位于高地址</p>
<h1 id="1-虚函数"><a href="#1-虚函数" class="headerlink" title="1.虚函数"></a>1.虚函数</h1><p><code>virtual 类型 成员函数名 (参数表);</code></p>
<p>虚函数必须存在于类的继承环境中才有意义</p>
<p>存在虚函数的类都有一个一维的虚函数表叫虚表，类的对象有一个指向虚表开始的虚指针，占4&#x2F;8字节；</p>
<p>虚表与类对应；虚表指针和对象对应</p>
<p>定义一个函数为虚函数，是为了允许基类指针调用子类的这个函数</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>不同<strong>对象</strong>调用相同的<strong>函数</strong>，但呈现多样的<strong>结果</strong></p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="编译时多态"><a href="#编译时多态" class="headerlink" title="编译时多态"></a>编译时多态</h4><p>编译过程中静态确定同名操作与具体对象绑定的关系（函数重载、运算符重载、模板）</p>
<p>优点：程序运行时函数调用速度快、效率高</p>
<p>缺点：编程不灵活</p>
<h4 id="运行时多态"><a href="#运行时多态" class="headerlink" title="运行时多态"></a>运行时多态</h4><p>动态确定同名操作与具体对象绑定的关系（继承和虚函数）</p>
<p>优点：编程更加灵活、系统易于扩展</p>
<p>缺点：调用速度比静态绑定的函数慢</p>
<p><strong>条件：</strong></p>
<p><code>1.有虚函数；</code></p>
<p><code>			2.符合赋值兼容规则；</code></p>
<p><code>3.由指针或引用去调用虚函数</code></p>
<h5 id="如果不用虚函数"><a href="#如果不用虚函数" class="headerlink" title="如果不用虚函数"></a>如果不用虚函数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class test1&#123;</span><br><span class="line">protected:</span><br><span class="line">    int b;</span><br><span class="line">public:</span><br><span class="line">    test1(int v):b(v) &#123;&#125;</span><br><span class="line">  //  virtual void eat()=0;</span><br><span class="line">    void eat()&#123;</span><br><span class="line">        cout&lt;&lt;&quot;test1&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class him:public test1&#123;</span><br><span class="line">public:</span><br><span class="line">    him():test1(0)&#123;&#125;</span><br><span class="line">    // virtual void eat() override&#123;</span><br><span class="line">    //     cout&lt;&lt;&quot;him,&quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    // &#125;</span><br><span class="line">    void eat() &#123;</span><br><span class="line">        cout&lt;&lt;&quot;him,&quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class you:public test1&#123;</span><br><span class="line">private:</span><br><span class="line">    int c;</span><br><span class="line">public:</span><br><span class="line">    you():test1(1),c(2)&#123;&#125;</span><br><span class="line">    // virtual void eat() override&#123;</span><br><span class="line">    //     cout&lt;&lt;&quot;you,&quot;&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">    // &#125;</span><br><span class="line">    void eat() &#123;</span><br><span class="line">        cout&lt;&lt;&quot;you,&quot;&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    you* pyou=new you();</span><br><span class="line">    him* phim=new him();</span><br><span class="line"></span><br><span class="line">	//基类的指针指向派生类的对象</span><br><span class="line">    test1* eater1=(test1*)pyou;</span><br><span class="line">    test1* eater2=(test1*)phim;</span><br><span class="line"></span><br><span class="line">    eater2-&gt;eat();</span><br><span class="line">    eater1-&gt;eat();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>test1<br>test1</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">class test1&#123;</span><br><span class="line">protected:</span><br><span class="line">    int b;</span><br><span class="line">public:</span><br><span class="line">    test1(int v):b(v) &#123;&#125;</span><br><span class="line">    virtual void eat()=0;</span><br><span class="line">&#125;;</span><br><span class="line">class him:public test1&#123;</span><br><span class="line">public:</span><br><span class="line">    him():test1(0)&#123;&#125;</span><br><span class="line">    virtual void eat() override&#123;</span><br><span class="line">        cout&lt;&lt;&quot;him,&quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class you:public test1&#123;</span><br><span class="line">private:</span><br><span class="line">    int c;</span><br><span class="line">public:</span><br><span class="line">    you():test1(1),c(2)&#123;&#125;</span><br><span class="line">    virtual void eat() override&#123;</span><br><span class="line">        cout&lt;&lt;&quot;you,&quot;&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    you* pyou=new you();</span><br><span class="line">    him* phim=new him();</span><br><span class="line">	</span><br><span class="line">	//基类的指针指向派生类的对象</span><br><span class="line">    test1* eater1=(test1*)pyou;</span><br><span class="line">    test1* eater2=(test1*)phim;</span><br><span class="line">	</span><br><span class="line">	//相同结果</span><br><span class="line">	 // you pyou;</span><br><span class="line">    // him phim;</span><br><span class="line"></span><br><span class="line">    // test1* eater1= &amp;pyou;</span><br><span class="line">    // test1* eater2= &amp;phim;</span><br><span class="line">	</span><br><span class="line">    eater2-&gt;eat();// 调用 him 类的 eat() 函数</span><br><span class="line">    eater1-&gt;eat();//// 调用 you 类的 eat() 函数</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>him,0<br>you,2</p>
</blockquote>
<p><code>有了虚函数</code>，<strong>指定哪个对象，就调用哪个函数的方法</strong></p>
<p>类-&gt;内存对象-&gt;虚函数表</p>
<p>PS:那个override可写可不写，c++11提出的，为了增加可读性</p>
<p>​	<strong>基类函数写了virtual，派生类就不需要写了，重写一遍函数就行了</strong></p>
<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>指在delete对象指针的时候，调用的函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Base *bp;</span><br><span class="line"></span><br><span class="line">bp=new derived();//Base的派生</span><br><span class="line"></span><br><span class="line">delete bp;</span><br></pre></td></tr></table></figure>

<p>如果基类没有加virtual，delete时只返回基类的析构</p>
<p>如果基类加了virtual，派生的析构可不加，delete时返回基类+派生的析构</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>而且基类一般不需要实现virtual 函数，它只为派生提供一个接口，只用提供函数名，而不实现函数体，即为<strong>纯虚函数</strong> ：<code>virtual void eat()=0;</code>(声明语句，而不能被调用)</p>
<p>有<strong>纯虚函数</strong>的类叫做<strong>抽象类</strong>，不能实例化一个抽象类的对象，所以会报错，因为没有具体的功能实现</p>
<p>如果其派生类也不实现同名函数的话（比如，直接不写eat()函数）也会报错的。</p>
<p><strong>纯虚函数</strong>的优点就是可以防止派生类忘记实现虚函数</p>
<h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>虚函数的使用：</p>
<p>第一步，基类，声明某个基类函数为virtual</p>
<p>第二步。派生类，定义在基类的virtual函数</p>
<p>第三步，声明基类指针，指向派生类，调用virtual函数</p>
<p> 虚函数（Virtual Function）是通过一张虚函数表（Virtual Table） 来实现的。简称为 V-Table 。在这个表中，主是要一个类的虚 函数的地址表，这张表解决了继承、覆盖的问题，保证其容 真实反应实际的函数。</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>在面向对象程序设计中，创建一个只包含未实现方法然后交由子类去实际实现功能的类是非常普遍的,这通常被称为<strong>接口</strong>。<strong>接口就是一个只包含未实现的方法并作为一个模板的类</strong>。并且由于此<strong>接口类</strong>实际上不包含方法实现，所以我们<strong>无法实例化</strong>这个类。</p>
<p>比如来个打印类名的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class printable&#123;//接口，就纯模板</span><br><span class="line">public:</span><br><span class="line">    virtual string printclass()=0;</span><br><span class="line">&#125;;</span><br><span class="line">//基类</span><br><span class="line">class entity:public printable&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual string getname()&#123;return &quot;entity&quot;;&#125;</span><br><span class="line">     string printclass()  &#123;return &quot;entity&quot;;&#125;//实现接口的纯需函数</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">//派生类</span><br><span class="line">class player:public entity&#123;//继承entity，entity已有接口</span><br><span class="line">private:</span><br><span class="line">    string pname;</span><br><span class="line">public:</span><br><span class="line">    player(const string&amp; name):pname(name)&#123;&#125;</span><br><span class="line">     string getname()  &#123;return pname;&#125;</span><br><span class="line">     string printclass()  &#123;return &quot;player&quot;;&#125;//实现接口的纯虚函数</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void print(printable *obj)&#123;//为了输出返回值为string类型的函数，它接收printable对象，不关心什么类</span><br><span class="line">    cout&lt;&lt;obj-&gt;printclass()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    entity* e=new entity();</span><br><span class="line">   // player* p=new player(&quot;132&quot;);</span><br><span class="line">   entity*p =new player(&quot;132&quot;);</span><br><span class="line">    print(e);</span><br><span class="line">    print(p);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>entity<br>player</p>
</blockquote>
<p>PS:如果player不继承entity</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class player : public Otherclass,printable&#123;</span><br><span class="line">	...</span><br><span class="line">	string pintclass() &#123;return &quot;player&quot;;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个就体现了下接口。</p>
<p>当然啊，如果还是看虚函数的话</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//基类</span><br><span class="line">class entity:public printable&#123;</span><br><span class="line">public:</span><br><span class="line">     //virtual string getname()&#123;return &quot;entity&quot;;&#125;</span><br><span class="line">     string getname()&#123;return &quot;entity&quot;;&#125;</span><br><span class="line">     string printclass()  &#123;return &quot;entity&quot;;&#125;//实现接口的纯需函数</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">   entity* e=new entity();</span><br><span class="line">   // player* p=new player(&quot;132&quot;);</span><br><span class="line">    entity*p =new player(&quot;132&quot;);</span><br><span class="line">    // print(e);</span><br><span class="line">    // print(p);</span><br><span class="line">    cout&lt;&lt;e-&gt;getname();</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;p-&gt;getname();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>entity<br>entity</p>
</blockquote>
<p>但是：基类函数加了virtual后嘞</p>
<blockquote>
<p>entity<br>132</p>
</blockquote>
<h1 id="2-C-中-const、define、static-的区别？"><a href="#2-C-中-const、define、static-的区别？" class="headerlink" title="2.C++中 const、define、static 的区别？"></a>2.C++中 const、define、static 的区别？</h1><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p><strong>const</strong> 是单词 constant 的简写，字面意思是<strong>常数</strong>、常量。 用于变量修饰，表明这个变量<strong>不能被修改</strong>；(mutable就是可改)</p>
<p>用于指针修饰， 表明指针的指向物<strong>不能被修改</strong>；</p>
<p>用于方法修饰，表明这个方法<strong>不会</strong>对对象造成改变。 </p>
<p>const修饰指针时，cosnt位置不同，那么修饰对象不同</p>
<p>int *const p2中 const修饰的是p2的值，即该指针p2的指向不可变，但*p2可读取该指向的变量值</p>
<p>int const *p1与const int *p1中，const修饰*p1，即*p1的值不可改变，但可以更改p1的指向</p>
<p>底层指针：指示<strong>指针所指向的变量</strong>是一个<strong>常量</strong></p>
<h3 id="define"><a href="#define" class="headerlink" title="define"></a>define</h3><p><strong>#define</strong> 和另外两个不一样，它属于<strong>宏</strong>，是预处理器的一部分。</p>
<p> 预处理是在编译之前的一道，简单地进行字符串替换，它不按照语言的语法，而是直管自己的语法。</p>
<p>定义的常量没有类型；而const定义的常量有类型名字，且放在静态区域</p>
<p>#define定义的常量不可以用指针指向；const可以</p>
<p>#define可以定义简单的函数，const不可以定义函数	</p>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p> <strong>static</strong> 的定义相对较复杂，用在<strong>全局变量</strong>表明这个变量在每个编译单元有独自的实例；</p>
<p>用在函数里的<strong>局部变量</strong>，表明它的生存周期其实是全局变量，但仅在函数内可见；(可用来统计函数调用次数)</p>
<p>用在<strong>类成员</strong>，表明成员或者方法是类的，而不是对象实例的。</p>
<p>静态成员不占用类的大小，普通函数也不占用</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul>
<li>隐藏：当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性</li>
<li>保持变量内容的持久：存储在静态数据 区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。</li>
<li>默认初始化为0（static变量）；全局变量也具备这一属性，因为全局变量也存储在静态数据区。</li>
<li>c++类成员声明：<ul>
<li>函数体内static变量的作用范围为该函数体</li>
<li>模块内的static<strong>全局变量</strong>可以被<strong>模块内所用函数</strong>访问，但不能被模块外其它函数访问</li>
<li>在模块内的static<strong>函数</strong>只可被这一<strong>模块内的其它函数调用</strong>，这个函数的使用范围被限制在声明它的模块内；</li>
<li>static成员函数不能被virtual修饰，static成员不属于任何对象或实例，所以加上virtual没有任何实际意义；</li>
</ul>
</li>
</ul>
<h1 id="3-对于epoll底层结构和原理有什么了解？"><a href="#3-对于epoll底层结构和原理有什么了解？" class="headerlink" title="*3. 对于epoll底层结构和原理有什么了解？"></a>*3. 对于epoll底层结构和原理有什么了解？</h1><p>这啥啊Σ(⊙▽⊙”a</p>
<p>eventpoll的使用中，经常需要对文件描述符集合进行添加、删除等操作，同时对触发的事件类型进行处理，回调IO事件中的工作函数。</p>
<p>epoll,<strong>I&#x2F;O多路复用技术</strong>，最大特点是<strong>支持高并发</strong>，从linux内核2.6引入的</p>
<p>头文件<code>#include &lt;sys/epoll.h&gt;</code></p>
<p>三个关键函数</p>
<blockquote>
<p>创建 eventpoll 对象</p>
<p>int epoll_create(int size); </p>
<p>操作 eventpoll 对象</p>
<p>int epoll_ctl(int epfd, int op, int fd, struct epoll_events* event);</p>
<p>从 eventpoll 对象中返回活跃的事件。</p>
<p>int epoll_wait(int epfd, struct epoll_event* events, int maxevents, int timeout);</p>
</blockquote>
<h3 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create;"></a>epoll_create;</h3><blockquote>
<ul>
<li>功能：创建一个epoll对象，返回该对象的描述符【文件描述符】，这个描述符就代表这个epoll对象，后续会用到。</li>
<li>这个epoll对象最终要用close()，因为文件描述符&#x2F;句柄 总是关闭的。</li>
<li>size &gt; 0;。</li>
</ul>
</blockquote>
<h3 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h3><blockquote>
<ul>
<li>功能：把一个socket以及这个socket相关的事件添加到这个epoll对象描述符中去，目的就是通过这个epoll对象来监视这个socket【客户端的TCP连接】上数据的来往情况；当有数据来往时，系统会通知我们。</li>
<li>我们把感兴趣的事件通过 epoll_ctl()  添加到系统，当这些事件来的时候，系统会通知我们。</li>
<li>efpd：epoll_create()返回的epoll对象描述符</li>
<li>op：动作，添加&#x2F;删除&#x2F;修改 ，对应数字是1,2,3， EPOLL_CTL_ADD, EPOLL_CTL_DEL ,EPOLL_CTL_MOD</li>
<li>EPOLL_CTL_ADD添加事件：等于你往红黑树上添加一个节点，每个客户端连入服务器后，服务器都会产生一个对应的socket，每个连接这个socket值都不重复，所以，这个socket就是红黑树中的key，把这个节点添加到红黑树上去</li>
<li>EPOLL_CTL_MOD：修改事件，用了EPOLL_CTL_ADD把节点添加到红黑树上之后，才存在修改</li>
<li>EPOLL_CTL_DEL：是从红黑树上把这个节点干掉这会导致这个socket【这个tcp链接】上无法收到任何系统通知事件</li>
<li>sockid：表示客户端连接，就是你从accept()这个是红黑树里边的key;</li>
<li>event：事件信息，这里包括的是 一些事件信息EPOLL_CTL_ADD和EPOLL_CTL_MOD都要用到这个event参数里边的事件信息</li>
</ul>
</blockquote>
<h3 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h3><blockquote>
<ul>
<li>功能：阻塞一小段时间并等待事件发生，返回事件集合，也就是获取内核的事件通知</li>
</ul>
</blockquote>
<h3 id="与select相比"><a href="#与select相比" class="headerlink" title="与select相比"></a>与select相比</h3><p>网络编程中，当每个线程都要阻塞在 recv 等待对方的请求，如果访问的人多了，线程开的就多了，大量线程都在阻塞，系统运转速度也随之下降。这个时候，你需要多路复用技术。</p>
<p>select不能应付海量的网站访问，所以需要epoll</p>
<ul>
<li><p>select底层采用数组来管理套接字描述符，管理的数量有上限，不超过几千个；</p>
<p>而epoll使用树和链表来管理，同时管理数量可以更大</p>
</li>
<li><p>select不会告诉你到底哪个套接字来了消息，需要轮询；</p>
<p>epoll直接告诉谁来了消息</p>
</li>
<li><p>select进行系统调用，需要把套接字列表在用户空间和内核空间来回拷贝；</p>
<p>epoll统一在内核管理套接字描述符，无需来回拷贝</p>
</li>
</ul>
<h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p>CSDN<a target="_blank" rel="noopener" href="https://me.csdn.net/baidu_41388533">NGC_2070</a></p>
<h1 id="4-epoll-的-ET-模式和-LT-模式哪个更高效？"><a href="#4-epoll-的-ET-模式和-LT-模式哪个更高效？" class="headerlink" title="4. epoll 的 ET 模式和 LT 模式哪个更高效？"></a>4. epoll 的 ET 模式和 LT 模式哪个更高效？</h1><p>LT(level triggered) 默认&#x2F;缺省的工作方式，同时支持 block和no_block socket。这种工作方式下，内核会通知你一个fd是否就绪，然后才可以对这个就绪的fd进行I&#x2F;O操作。就算你没有任何操作，系统还是会继续提示fd已经就绪，不过这种工作方式出错会比较小，传统的select&#x2F;poll就是这种工作方式的代表。</p>
<p>ET(edge-triggered) 是高速工作方式，仅支持no_block socket，这种工作方式下，当fd从未就绪变为就绪时，内核会通知fd已经就绪，并且内核认为你知道该fd已经就绪，不会再次通知了，除非因为某些操作导致fd就绪状态发生变化。如果一直不对这个fd进行I&#x2F;O操作，导致fd变为未就绪时，内核同样不会发送更多的通知，因为only once。所以这种方式下，出错率比较高，需要增加一些检测程序。</p>
<p>PS:fd(文件描述符)</p>
<p><strong>LT可以理解为水平触发，只要有数据可以读，不管怎样都会通知。而ET为边缘触发，只有状态发生变化时才会通知，可以理解为电平变化</strong>。</p>
<p>来源<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37003559">编程哲学家</a></p>
<p>所以嘞：</p>
<p> ET 模式更加高效。<br>与 poll 的事件宏相比， epoll 新增了一个事件宏 EPOLLET ， 这就是所谓的边缘触发模式（<br>Edge Trigger ， ET ），而默认的模式称为水平触发模式（Level Trigger， LT ）。 对于水平触发模式，一个事件只要有，<strong>就会一直触发</strong>； 对于边缘触发模式，只有一个事件从无到有才会触发。</p>
<p>CSDN博主<a target="_blank" rel="noopener" href="https://blog.csdn.net/Lushengshi/article/details/127580635">「丘比特惩罚陆」</a></p>
<h1 id="5-什么情况下C-STL迭代器会失效？"><a href="#5-什么情况下C-STL迭代器会失效？" class="headerlink" title="5.什么情况下C++STL迭代器会失效？"></a>5.什么情况下C++STL迭代器会失效？</h1><p>当容器调用 erase() 方法后，当前位置到容器末尾元素的所有迭代器全部失效。 当容器调用 insert() 方法后，当前位置到容器末尾元素的所有迭代器全部失效。 如果容器扩容，在其他地方重新又开辟了一块内存。原来容器底层的内存上所保存的迭代器全都失效了。</p>
<h1 id="6-什么是右值引用？和移动语义、完美转发有什么联系？"><a href="#6-什么是右值引用？和移动语义、完美转发有什么联系？" class="headerlink" title="6.什么是右值引用？和移动语义、完美转发有什么联系？"></a>6.什么是右值引用？和移动语义、完美转发有什么联系？</h1><p>它是移动语义和完美转发的基石，定义右值引用需要使用&amp;&amp;、右值引用一定不能被左值所初始 化，只能用右值初始化。</p>
<h2 id="左值"><a href="#左值" class="headerlink" title="左值"></a>左值</h2><p>有地址、数值、有存储空间的值，长期存在</p>
<p>左值<strong>是由某种存储支持的变量，左值有地址和值</strong>，可以出现在赋值运算符左边或右边</p>
<h2 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h2><p>左值引用仅仅接收左值，除非用了const兼容（非const的左值引用只接受左值），所以c++常用<strong>常量</strong>引用。</p>
<p><strong>它们兼容临时的右值和实际存在的左值变量</strong></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    int x=8;</span><br><span class="line">    int&amp; refx=x;</span><br><span class="line">    cout&lt;&lt;&quot;x: &quot;&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;refx: &quot;&lt;&lt;refx&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    refx=28;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;x: &quot;&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;refx: &quot;&lt;&lt;refx&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>x: 8<br>refx: 8<br>x: 28<br>refx: 28</p>
</blockquote>
<p>在这个示例中，<code>refx</code> 是一个引用，它引用了变量 <code>x</code>。左值引用允许你通过 <code>refx</code> 修改 <code>x</code> 的值，因为引用绑定后，对引用的修改实际上是对被引用变量的修改。</p>
<p>需要注意的是，一旦引用绑定到某个变量，它会一直引用该变量，不能重新绑定到其他变量。因此，左值引用一般在绑定后不会再改变其引用对象。</p>
<p>左值引用在 C++ 中用于多种目的，例如通过函数引用传递变量、运算符重载以及为现有变量创建别名。</p>
<h2 id="右值"><a href="#右值" class="headerlink" title="右值"></a>右值</h2><p>就是临时量，无地址（或者有地址，但访问不到，只是一个临时量），没有存储空间而短暂存在的值</p>
<h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p>c++11出现的</p>
<p>右值引用不能绑定到左值，可以通过常引用或右值引用延长右值的生命周期。</p>
<p>“有名字的右值引用”是左值</p>
<p>定义需要使用&amp;&amp;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int&amp;&amp; rref = 42; // rref 是一个右值引用，绑定到临时右值 42</span><br></pre></td></tr></table></figure>

<p><code>rref</code> 是一个右值引用，它可以绑定到一个临时右值，如字面值或表达式计算的结果。右值引用通常用于实现移动语义和完美转发（perfect forwarding），允许有效地管理资源并将参数传递到其他函数，同时避免不必要的数据复制。</p>
<p>需要注意的是，与左值引用不同，右值引用可以绑定到临时对象，但不能绑定到具有名称的左值。右值引用通常在函数参数中使用，例如在移动构造函数和移动赋值运算符中。</p>
<h3 id="1-string-foo-2-void-bar-string-amp-s-为什么下面的操作非法1-bar-foo-2-bar-“hello-world”"><a href="#1-string-foo-2-void-bar-string-amp-s-为什么下面的操作非法1-bar-foo-2-bar-“hello-world”" class="headerlink" title="1 string foo( ); 2 void bar(string &amp; s); 为什么下面的操作非法1 bar(foo( )); 2 bar(“hello world”);"></a>1 string foo( ); 2 void bar(string &amp; s); 为什么下面的操作非法1 bar(foo( )); 2 bar(“hello world”);</h3><ol>
<li><p><strong>Rvalue vs. Lvalue:</strong> 在 C++ 中，表达式可以被分为右值（Rvalue）和左值（Lvalue）。右值是临时的、不可修改的值，左值是可寻址的、可修改的值。函数返回的临时对象通常是右值，而具有名称的变量是左值。在 <code>bar(foo());</code> 中，<code>foo()</code> 返回一个临时的 <code>string</code> 对象，因此它是一个右值。</p>
</li>
<li><p><strong>Const Reference and Non-Const Reference:</strong> 函数参数可以是 const 引用（const reference）或非 const 引用。<code>string&amp; s</code> 表示非 const 引用，而 <code>const string&amp; s</code> 表示 const 引用。</p>
</li>
<li><p><code>bar(foo());</code>: 在这个操作中，<code>foo()</code> 返回的是右值，但 <code>bar</code> 函数的参数要求是非 const 引用，而右值不能直接绑定到非 const 引用，因此这个操作是非法的。</p>
</li>
<li><p><code>bar(&quot;hello world&quot;);</code>: <code>&quot;hello world&quot;</code> 是一个字符串字面量，它是右值，而 <code>bar</code> 函数的参数要求是非 const 引用，同样不能直接绑定到非 const 引用，因此这个操作也是非法的。</p>
</li>
</ol>
<p>解决：</p>
<ol>
<li>修改 <code>bar</code> 函数参数为 <code>const string&amp; s</code>，以允许将右值（临时对象）绑定到 const 引用参数。</li>
<li>在 <code>foo</code> 调用后创建一个命名的 <code>string</code> 变量，然后将这个变量传递给 <code>bar</code> 函数，因为左值可以绑定到非 const 引用参数。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void bar(const string&amp; s);</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string fooResult = foo();</span><br><span class="line">    bar(fooResult); // 合法，将左值传递给非 const 引用参数</span><br><span class="line"></span><br><span class="line">    bar(&quot;hello world&quot;); // 合法，将右值传递给 const 引用参数</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>可以取地址的，有名字的就是<strong>左值</strong></p>
<p>不能取地址的，没名字的就是<strong>右值</strong></p>
<p>int a&#x3D;b+c;&#x2F;&#x2F;a左值，变量名为a，&amp;a为其地址；b+c表达式、函数int func()返回值是右值</p>
<h2 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h2><p>c++11后出现的</p>
<h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><p>有时候我们需要单纯创建一些右值，赋给某个对象用作构造函数。</p>
<p>这个时候需要：</p>
<p>在main函数里创建这个右值对象，然后复制给这个对象相应的成员变量。</p>
<p>这里有一个额外行为，是<strong>复制</strong>。</p>
<p>如果我们可以直接把这个<strong>右值变量移动给成员变量</strong>，程序性能就会提高</p>
<p><strong>所以我们要移动对象，而不是复制它，这就有了语义的出现。</strong></p>
<p>看一下复制的情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string.h&gt;//strlen的头文件</span><br><span class="line">using namespace std;</span><br><span class="line">class String&#123;</span><br><span class="line">private:</span><br><span class="line">    char * m_data;</span><br><span class="line">    uint32_t m_size;</span><br><span class="line">public:</span><br><span class="line">    String()=default;</span><br><span class="line">    String(const char* str)//构造函数</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Created!\n&quot;);</span><br><span class="line">        m_size=strlen(str);</span><br><span class="line">        m_data=new char[m_size];</span><br><span class="line">        memcpy(m_data,str,m_size);</span><br><span class="line">    &#125;</span><br><span class="line">    String(const String&amp; other)//拷贝构造函数</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Copyed!\n&quot;);</span><br><span class="line">        m_size=other.m_size;</span><br><span class="line">        m_data=new char[m_size];</span><br><span class="line">        memcpy(m_data,other.m_data,m_size);</span><br><span class="line">    &#125;</span><br><span class="line">    ~String()</span><br><span class="line">    &#123;</span><br><span class="line">        delete m_data;</span><br><span class="line">    &#125;</span><br><span class="line">    void print()</span><br><span class="line">    &#123;</span><br><span class="line">        for (uint32_t i = 0; i &lt; m_size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">           printf(&quot;%c&quot;,m_data[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printf(&quot;\n&quot;);       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class entity&#123;</span><br><span class="line">private:</span><br><span class="line">    String m_name;</span><br><span class="line">public:</span><br><span class="line">    entity(const String&amp; name):m_name(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    void printname()</span><br><span class="line">    &#123;</span><br><span class="line">        m_name.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    entity e(String(&quot;yuleiyun&quot;));</span><br><span class="line">    e.printname();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Created!<br>Copyed!<br>yuleiyun</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String(const String&amp; other)//拷贝构造函数</span><br><span class="line">  &#123;</span><br><span class="line">      printf(&quot;Copyed!\n&quot;);</span><br><span class="line">      m_size=other.m_size;</span><br><span class="line">      m_data=new char[m_size];</span><br><span class="line">      memcpy(m_data,other.m_data,m_size);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>复制字符串，意味着我们需要在堆上分配内存，调用新字符</p>
<p>我们的主函数中写入了参数，然后调用的是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">entity(const String&amp; name):m_name(name)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>为什么不能直接写进</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private:</span><br><span class="line">    String m_name;</span><br></pre></td></tr></table></figure>



<p>这就引入了移动语义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">class String&#123;</span><br><span class="line">private:</span><br><span class="line">    char * m_data;</span><br><span class="line">    uint32_t m_size;</span><br><span class="line">public:</span><br><span class="line">    String()=default;</span><br><span class="line">    String(const char* str)//构造函数</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Created!\n&quot;);</span><br><span class="line">        m_size=strlen(str);</span><br><span class="line">        m_data=new char[m_size];</span><br><span class="line">        memcpy(m_data,str,m_size);</span><br><span class="line">    &#125;</span><br><span class="line">    String(const String&amp; other)//拷贝构造函数</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Copyed!\n&quot;);</span><br><span class="line">        m_size=other.m_size;</span><br><span class="line">        m_data=new char[m_size];</span><br><span class="line">        memcpy(m_data,other.m_data,m_size);</span><br><span class="line">    &#125;</span><br><span class="line">    String(String&amp;&amp; other) noexcept//右值引用拷贝，相当于移动（复制一次指针，原来的指针给nullptr）</span><br><span class="line">    &#123;</span><br><span class="line">     </span><br><span class="line">        printf(&quot;Moved!\n&quot;);</span><br><span class="line">           //新对象的指针指向指定内存，将旧对象的指针移开</span><br><span class="line">           //这里是接管了原来的旧内存</span><br><span class="line">        m_size=other.m_size;</span><br><span class="line">        m_data=other.m_data;</span><br><span class="line">        </span><br><span class="line">        //数据的转移，将other的数据偷走</span><br><span class="line">        other.m_size=0;</span><br><span class="line">        other.m_data=nullptr;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ~String()</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Desdroyed\n&quot;);</span><br><span class="line">        delete m_data;</span><br><span class="line">    &#125;</span><br><span class="line">    void print()</span><br><span class="line">    &#123;</span><br><span class="line">        for (uint32_t i = 0; i &lt; m_size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">           printf(&quot;%c&quot;,m_data[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printf(&quot;\n&quot;);       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class entity&#123;</span><br><span class="line">private:</span><br><span class="line">    String m_name;</span><br><span class="line">public:</span><br><span class="line">    entity(const String&amp; name):m_name(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    entity(String&amp;&amp; name):m_name(move(name))//或者(String&amp;&amp;)name</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    void printname()</span><br><span class="line">    &#123;</span><br><span class="line">        m_name.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    entity e(String(&quot;yuleiyun&quot;));</span><br><span class="line">    e.printname();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Created!<br>Moved!<br>Desdroyed<br>yuleiyun<br>Desdroyed</p>
</blockquote>
<p><code>String(String&amp;&amp; other) noexcept</code></p>
<blockquote>
<p>该<code>&amp;&amp;</code>语法用于定义移动构造函数，它是一种特殊类型的构造函数，允许将资源（如动态分配的内存）从一个对象有效传输到另一个对象。</p>
<p>在 C++ 中，移动构造函数是使用右值引用作为参数来定义的。<code>&amp;&amp;</code>表示这是一个右值引用参数，并且它允许在从右值（临时）对象构造对象或显式转换为右值引用时调用移动<code>other</code>构造函数。</p>
</blockquote>
<p>当一个表达式出现的形式表示它是一个右值，就是告诉编译器，我以后不会再用到这个资源，放心大胆的转移销毁，这就可以做优化，比如节省拷贝之类的。 move的作用是无条件的把表达式转成右值</p>
<p>来源 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/553405837">知乎</a></p>
<h1 id="7-智能指针定义、类别和应用场景"><a href="#7-智能指针定义、类别和应用场景" class="headerlink" title="7.智能指针定义、类别和应用场景"></a>7.智能指针定义、类别和应用场景</h1><p>作用是管理一个指针。</p>
<p>存在以下这种情况：</p>
<p>申请的空间在函数结束时忘记释放，造成内存泄漏。通过智能指针避免该问题。</p>
<p>智能指针是一个类，当超出了类的实例对象的作用域时，会自动调用对象的析构函数，析构函数会自动释放资源。</p>
<p>其作用原理就是：<strong>在函数结束时自动释放内存空间，不需要手动释放内存空间。</strong></p>
<p>unique_ptr独占式，同一时间只允许一个智能指针指向该对象</p>
<p>shared_ptr共享式，多个智能指针指向同一个对象，当最后一个引用被销毁时，就会释放对象和其相关资源</p>
<p>weak_ptr 是一种不控制对象生命周期的智能指针 , 它指向 一个 shared_ptr 管理的对象 . 进行该对象的内存管理的是那个强引用的 shared_ptr ， weak_ptr 只是提供了对管理对象的一个访问手段。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>本质上是原始指针的包装。当你创建一个智能指针，它会调用new并为你分配内存，然后基于你使用的智能指针，这些内存会在某一时刻自动释放。</p>
<p>优先使用unique_ptr，其次考虑shared_ptr</p>
<blockquote>
<p>尽量使用unique_ptr因为它有一个较低的开销，但如果你需要在对象之间共享，不能使用unique_ptr的时候，就使用shared_ptr</p>
</blockquote>
<p><strong>访问所有智能指针，先要有头文件&lt;memory&gt;</strong></p>
<h2 id="作用域指针unique-ptr的使用"><a href="#作用域指针unique-ptr的使用" class="headerlink" title="作用域指针unique_ptr的使用"></a>作用域指针unique_ptr的使用</h2><ul>
<li><p>作用域指针意味着，超出作用域，就会被销毁，调用delete</p>
</li>
<li><p>唯一、不可复制、不可共享</p>
</li>
</ul>
<blockquote>
<p>如果复制一个unique_ptr，会有两个指针，两个unique_ptr指向同一个内存块，如果其中一个死了，它会释放那段内存，也就是说，指向同一块内存的第二个unique_ptr指向了已经被释放的内存。</p>
</blockquote>
<ul>
<li>unique_ptr 需要显示调用构造函数</li>
<li>最好使用 unique_ptr&lt;Entity&gt; entity&#x3D;make_unique&lt;Entity&gt;();以防构造函数抛出异常，得到一个没有引用的空指针而造成内存泄露，稍安全点</li>
<li>make_unique&lt;&gt;() c++14引入</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Entity&#123;</span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    Entity()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Create!&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Entity()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Destroy!&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">       void Print()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">        //unique_ptr&lt;Entity&gt; entity = new Entity(); //错误，unique_ptr不能隐式转换</span><br><span class="line">        //unique_ptr&lt;Entity&gt; entity(new Entity()); //可以，但不建议说是</span><br><span class="line">        unique_ptr&lt;Entity&gt; entity=make_unique&lt;Entity&gt;();</span><br><span class="line">        entity-&gt;Print();//像一般原始指针的使用方式</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Create!<br>Destroy!</p>
</blockquote>
<h2 id="共享指针shared-ptr"><a href="#共享指针shared-ptr" class="headerlink" title="共享指针shared_ptr"></a>共享指针shared_ptr</h2><ul>
<li>其工作方式 <strong>通过引用计数</strong></li>
</ul>
<blockquote>
<p>引用计数基本上是一种方法，可以跟踪你的指针有多少个引用，一旦引用计数达到零，他就被删除了。<br>例如：我创建了一个共享指针shared_ptr，我又创建了另一个shared_ptr来复制它，我的引用计数是2，第一个和第二个，共2个。当第一个死的时候，我的引用计数器现在减少1，然后当最后一个shared_ptr死了，我的引用计数回到零，内存就被释放。</p>
</blockquote>
<ul>
<li>该指针需要分配另一块内存，叫控制块，存储引用计数</li>
</ul>
<blockquote>
<p>首先创建一个new Entity，然后传递给shared_ptr构造函数，它必须分配两次；</p>
<p>用make_shared组合起来更有效率、</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;Entity&gt; sharedEntity = sharedEntity(new Entity());//不推荐！</span><br><span class="line">std::shared_ptr&lt;Entity&gt; sharedEntity = std::make_shared&lt;Entity&gt;();//ok</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">        &#123;</span><br><span class="line">        std::shared_ptr&lt;Entity&gt; e;</span><br><span class="line">        &#123;</span><br><span class="line">        //  std::shared_ptr&lt;Entity&gt; sharedEntity = sharedEntity(new Entity());//不推荐！</span><br><span class="line">            std::shared_ptr&lt;Entity&gt; sharedEntity = std::make_shared&lt;Entity&gt;();//ok</span><br><span class="line">            e = sharedEntity; //可以复制</span><br><span class="line">        &#125; //此时sharedEntity已经“死了”,但没有调用析构，因为e仍然是活的，并且持有对该Entity的引用，此时计数由2-》1</span><br><span class="line">    &#125; //析构被调用，因为所有的引用都消失了，计数由2-&gt;0，内存被释放</span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    std::cin.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Create!<br>Destroy!</p>
</blockquote>
<p>注：main函数的花括号是为了让括号内的内容为局部对象，方便测试</p>
<h2 id="弱指针weak-ptr"><a href="#弱指针weak-ptr" class="headerlink" title="弱指针weak_ptr"></a>弱指针weak_ptr</h2><ul>
<li>可以和shared_ptr一起使用</li>
<li>该指针可以被复制，但 <strong>不会增加额外的控制块来计数</strong>，仅仅声明该指针活着</li>
</ul>
<blockquote>
<p>当你将一个shared_ptr赋值给另外一个shared_ptr，引用计数++，而若是<strong>把一个shared_ptr赋值给一个weak_ptr时，它不会增加引用计数</strong>。这很好，如果你不想要Entity的所有权，就像你可能在排序一个Entity列表，你不关心它们是否有效，你只需要存储它们的一个引用就可以了。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">    std::weak_ptr&lt;Entity&gt; e0;</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;Entity&gt; sharedEntity = std::make_shared&lt;Entity&gt;();</span><br><span class="line">        e0 = sharedEntity;</span><br><span class="line">    &#125; //此时，此析构被调用，内存被释放</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它指向一个 shared_ptr 管理的对象 . 进行该对象的内存管理的是那个强引用的 shared_ptr ， weak_ptr 只是提供了对管理对象的一个访问手段。</p>
<h1 id="8-vector-和-list-有什么区别？"><a href="#8-vector-和-list-有什么区别？" class="headerlink" title="8.vector 和 list 有什么区别？"></a>8.vector 和 list 有什么区别？</h1><p> vector 和 built-in 数组类似，它拥有一段<strong>连续的内存空间</strong>，并且起始地址不变，因此它能非常好的支持<strong>随即存取</strong>，即[] 操作符，但由于它的内存空间是连续的，所以在中间进行插入和删除会造成内存块的拷贝，另外，当该数组后的内存空间不够时，需要重新申请一块足够大的内存并进行内存的拷贝。</p>
<p>它的emplace_back()体现了零拷贝技术，虽然后push_back()作用一样，但不需要调用拷贝构造函数和转移构造函数，而是原地构造该元素</p>
<p> list 就是数据结构中的双向链表，它的内存空间<strong>可以是不连续的</strong>，通过<strong>指针来进行数据的访问</strong>， 这个特点使得它的随即存取变的非常没有效率，因此它没有提供[]操作符的重载。<strong>支持任意地方的删除和插入</strong></p>
<p>vector 适用：对象数量变化少，简单对象，随机访问元素频繁；</p>
<p>list 适用：对象数量变化大，对象复杂，插入和删除频繁</p>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p><strong>C++ STL</strong>中提供的一种<strong>容器</strong>，是<strong>线性的双向链表</strong>的数据结构。拥有<strong>链式结构的特征</strong>：<strong>支持元素的快速插入和删除，但是元素随机访问较慢（相较于vector容器），不提供[]运算符的重载</strong>。C++中使用list容器需要包含<strong>头文件<list><strong>，把list当做</strong>双向链表</strong>来看</p>
<p>基本操作</p>
<blockquote>
<p>push_back()</p>
<p>push_front();</p>
<p>pop_</p>
<p>merge()&#x2F;&#x2F;两个list表必须事先有序</p>
<p>sort()</p>
</blockquote>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p>向量</p>
<p>与数组相比其优点在于它能够根据需要随时自动调整自身的大小以便容下所要放入的元素。</p>
<blockquote>
<p>插入 - insert</p>
<p>​    ①、a.insert(a.begin(), 1000);<em>&#x2F;&#x2F;将1000插入到向量a的起始位置前</em></p>
<p>​    ②、a.insert(a.begin(), 3, 1000);<em>&#x2F;&#x2F;将1000分别插入到向量元素位置的0-2处(共3个元素)</em></p>
<p>​    ③、 vector&lt;int&gt; a(5, 1) ;</p>
<p>​        vector&lt;int&gt; b(10) ;</p>
<p>​        b.insert(b.begin(), a.begin(), a.end()) ; <em>&#x2F;&#x2F;将a.begin(), a.end()之间的全部元素插入到b.begin()前</em></p>
<p>删除 - erase</p>
<p>​    ①、b.erase(b.begin());<em>&#x2F;&#x2F;将起始位置的元素删除</em></p>
<p>​    ②、b.erase(b.begin(), b.begin()+3);<em>&#x2F;&#x2F;将(b.begin(), b.begin()+3)之间的元素删除</em></p>
<p>交换 - swap</p>
<p>​        b.swap(a) ;            <em>&#x2F;&#x2F;a向量与b向量进行交换</em></p>
</blockquote>
<h1 id="9-C-内存-new-与-malloc-区别是什么？"><a href="#9-C-内存-new-与-malloc-区别是什么？" class="headerlink" title="9. C++内存 new 与 malloc 区别是什么？"></a>9. C++内存 new 与 malloc 区别是什么？</h1><ol>
<li><p>申请的内存所在位置；</p>
<blockquote>
<p>new：此操作符分配的内存空间是在自由存储区；</p>
<p>malloc：申请的内存是在堆空间。</p>
<p>堆 </p>
<p>​	是C语言和操作系统的术语，堆是操作系统所维护的一块特殊内存，它提供了动态分配的功能，当运行程序调用malloc()时就会从中分配，调用free()归还内存。</p>
<p>自由存储区 </p>
<p>​	是C++中动态分配和释放对象的一个概念，通过new分配的内存区域可以称为自由存储区，通过delete释放归还内存。自由存储区可以是堆、全局&#x2F;静态存储区等，具体是在哪个区，主要还是要看new的实现以及C++编译器默认new申请的内存是在哪里。但是基本上，很多C++编译器默认使用堆来实现自由存储，运算符new和delete内部默认是使用malloc和free的方式来被实现，说它在堆上也对，说它在自由存储区上也正确。因为在C++中new和delete符号是可以重载的，我们可以重新实现new的实现代码，可以让其分配的内存位置在静态存储区等。而malloc和free是C里的库函数，无法对其进行重载。</p>
<p>CSDN博主<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46094676/article/details/129677525">「呆萌理科生」</a></p>
</blockquote>
</li>
<li><p>返回类型安全性；</p>
<blockquote>
<p>new分配内存成功，则返回<strong>对象类型的指针</strong>，使用new是类型安全的；而malloc分配成功会返回void*类型指针，需要通过强制类型转换</p>
</blockquote>
</li>
<li><p>内存分配失败时的返回值；</p>
<blockquote>
<p>C++标准中new如果分配内存失败要求抛出bad_alloc异常，需要自己捕捉，但是有些编译器对C++标准的适配没那么好，也会返回null指针，这是保留了C的处理。</p>
<p>而malloc分配失败则会返回null指针。</p>
</blockquote>
</li>
<li><p>是否需要指定的内存大小；</p>
<blockquote>
<p>使用malloc为对象指针分配内存，要<strong>明确</strong>指定分配内存的大小，而new不需要</p>
<p>malloc返回的指针还需要进行强制类型转换才赋值给A<em>的指针对象，而使用new则不需要，直接返回的是A</em>的指针。</p>
</blockquote>
</li>
<li><p>是否调用构造函数&#x2F;析构函数；</p>
<blockquote>
<p>new调用时先为对象分配内存，再调用对象的构造函数，delete会调用析构函数</p>
<p>而malloc不会</p>
<p>A* a&#x3D;new A();</p>
<p>A* aa&#x3D;(A*)malloc (sizeof(A));</p>
</blockquote>
</li>
<li><p>对数组的处理；</p>
<blockquote>
<p>new的话，有new []，delete []</p>
<p>A * ptr &#x3D; new A[10];&#x2F;&#x2F;分配10个A对象</p>
<p>delete [] ptr;</p>
<p>——————————</p>
<p>int * ptr &#x3D; (int *) malloc( sizeof(int) );&#x2F;&#x2F;分配一个10个int元素的数组</p>
</blockquote>
</li>
<li><p>是否可以被重载；</p>
<blockquote>
<p>new 是操作符(需要编译器支持)，可以被重载，malloc&#x2F;free是库函数（头文件支持），不能被重载</p>
</blockquote>
</li>
<li><p>能够直观的重新分配内存；</p>
<blockquote>
<p>malloc内存不够，可以用realloc扩张内存大小</p>
<p>new没有</p>
</blockquote>
</li>
<li><p>客户处理内存分配不足；</p>
</li>
</ol>
<p>总结：</p>
<p>malloc给你的就好像一块原始的土地，你要种什么需要自己在土地上来播种</p>
<p>而new帮你划好了田地的分块（数组），帮你播了种（构造函数），还提供其他的设施给你使用</p>
<p><strong>来源：CSDN</strong> <a target="_blank" rel="noopener" href="http://t.csdn.cn/nQer6">AI浩</a></p>
<h2 id="有了malloc-x2F-free-为什么还要有new-x2F-delete"><a href="#有了malloc-x2F-free-为什么还要有new-x2F-delete" class="headerlink" title="有了malloc&#x2F;free 为什么还要有new&#x2F;delete"></a>有了malloc&#x2F;free 为什么还要有new&#x2F;delete</h2><p>new 在对象创建的时候执行构造函数&#x2F; delete 销毁的时候执行析构函数</p>
<h3 id="new的工作原理："><a href="#new的工作原理：" class="headerlink" title="new的工作原理："></a>new的工作原理：</h3><p>先调用operator new函数，申请足够内存(底层用malloc)</p>
<p>调用类型的构造函数，初始化成员变量</p>
<p>返回自定义类型指针</p>
<p>new[] 返回的是元素类型的指针</p>
<p>new的机制是将内存分配和对象构造组合一起</p>
<h3 id="delete工作原理"><a href="#delete工作原理" class="headerlink" title="delete工作原理"></a>delete工作原理</h3><p>调用operator delete释放内存(底层用free)</p>
<p>delete[] 将元素逆序销毁</p>
<p>delete也是将对象析构和内存释放组合一起</p>
<p>而allocator将这两部分分开，申请一部分内存，不初始化对象，只有当需要的时候才初始化操作</p>
<h2 id="被free回收的内存是立即返回操作系统吗"><a href="#被free回收的内存是立即返回操作系统吗" class="headerlink" title="被free回收的内存是立即返回操作系统吗"></a>被free回收的内存是立即返回操作系统吗</h2><p>否，会首先被ptmalloc使用双链表保存起来，并尝试对小块内存合并，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回，就避免了频繁的系统调用，占用过多的系统资源。</p>
<h1 id="10-常量指针和指针常量有什么区别？"><a href="#10-常量指针和指针常量有什么区别？" class="headerlink" title="10.常量指针和指针常量有什么区别？"></a>10.常量指针和指针常量有什么区别？</h1><p>指向const的指针，指向一个常量项目。<strong>指针指向的数据不能改变，但指针本身可以改变</strong></p>
<p>对于const指针，指针本身就是常量。<strong>一旦指针使用了某个地址进行初始化，那么它就不能指向除此地址之外的任何其他东西</strong></p>
<p>来自 精通c++(第9版)</p>
<h2 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h2><p><code>指针常量</code>是一个指针，（即指向常量的指针）指向一个只读常量，这个值因为是常量，所以不能被修改，const在*之前</p>
<p><code>const int* p //const int是p指向的内容,*表示p是一个指针</code></p>
<p>注意的是：const适用于p指向的东西；而不是p本身</p>
<p>虽然常量的地址只能传递给指向const的指针，但是，指向const的指针是可以接收非常量的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void display(const int *nums,int size)</span><br><span class="line">&#123;</span><br><span class="line">	for(int i=0;i&lt;sizel;i++)</span><br><span class="line">	cout&lt;&lt;*(nums+i)&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">int size=6;</span><br><span class="line">const int arr1[size]=&#123;1,2,3,4,5,6&#125;;</span><br><span class="line">display(arr1,size);// 1 2 3 4 5 6</span><br><span class="line"></span><br><span class="line">int arr2[size]=&#123;2,4,6,8,10,12&#125;;</span><br><span class="line">display(arr2,size);//2 4 6 8 10 12</span><br></pre></td></tr></table></figure>

<p>应用场景：当编写一个使用指针形参的函数，并且该函数不打算改变形参指向的数据时，将形参设置为一个指向const的指针。</p>
<p>补充：</p>
<p>数组名称是指针常量(Pointer Conster)，不能让它们指向除了它们所代表的数组之外的任何东西</p>
<blockquote>
<p>int a[20],b[20];</p>
<p>int *p;</p>
<p>p&#x3D;a;&#x2F;&#x2F;正确</p>
<p>a&#x3D;b;&#x2F;&#x2F;错误</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int x = 10; </span><br><span class="line">int y = 20;</span><br><span class="line">const int* ptr = &amp;x;</span><br><span class="line">ptr = &amp;y;</span><br><span class="line">//*x=30 //Error</span><br><span class="line">它可以指向不同的常量，但数据不能改</span><br></pre></td></tr></table></figure>

<h2 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针"></a>常量指针</h2><p><code>常量指针</code>是一个不能给改变指向的指针。指针是一个常量必须初始化，一旦初始化完成，它的值，即这个地址就不能改变，<strong>不能中途改变指向</strong> ，const在*之后，如</p>
<p><code>int *const p; //*const 表示p是一个常量指针，int是p指向的内容</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int x = 10;</span><br><span class="line">int y = 20;</span><br><span class="line"></span><br><span class="line">int* const ptr = &amp;x; // ptr is a pointer constant to an integer, pointing to x</span><br><span class="line">//ptr = &amp;y; // Error</span><br><span class="line">*x = 30; // Valid</span><br><span class="line">它可以修改数据，但不能修改指向</span><br></pre></td></tr></table></figure>

<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>还有一个指向常量的常量指针，<code>const int *const ptr;//const int是ptr指向的内容，*const表示ptr是一个常量指针</code> <strong>既不可以改变指针指向的内容,也不能再去修改指针指向的地址</strong></p>
<h1 id="11-map-和-unordered-map-的区别以及适用场景？"><a href="#11-map-和-unordered-map-的区别以及适用场景？" class="headerlink" title="11. map 和 unordered_map 的区别以及适用场景？"></a>11. map 和 unordered_map 的区别以及适用场景？</h1><p>map会自动按键的字典序排序</p>
<p>unordered_map随机排序，用于查找</p>
<h1 id="12-静态链接库和动态链接库各自的优缺点分别是什么？"><a href="#12-静态链接库和动态链接库各自的优缺点分别是什么？" class="headerlink" title="12. 静态链接库和动态链接库各自的优缺点分别是什么？"></a>12. 静态链接库和动态链接库各自的优缺点分别是什么？</h1><p>静态链接库的优点：</p>
<blockquote>
<p>代码装载速度快，执行速度略比动态链接库快； </p>
<p>只需保证在开发者的计算机中有正确的.LIB 文件，在以二进制形式发布程序时不需考虑在用户的计算机<br>上 .LIB 文件是否存在及版本问题，可避免 DLL 地狱等问题。</p>
</blockquote>
<p>​		缺点：</p>
<blockquote>
<p>使用静链接生成的可执行文件体积较大，包含相同的公共代码，造成浪费</p>
<p>全量更新</p>
</blockquote>
<p>动态链接库优点：</p>
<blockquote>
<p>更加节省内存并减少页面交换；</p>
<p>DLL 文件与 EXE 文件独立，只要输出接口不变（即名称、参数、返回值类型和调用约定不变），更换 DLL 文件不会对 EXE 文件造成任何影响，因而极大地提高了可维护性和可扩展性；</p>
<p>不同编程语言编写的程序只要按照函数调用约定就可以调用同一个 DLL 函数；</p>
</blockquote>
<p>缺点：</p>
<blockquote>
<p>使用动态链接库的应用程序不是自完备的，它依赖的 DLL 模块也要存在，如果使用载入时动态链接， 程序启动时发现 DLL 不存在，系统将终止程序并给出错误信息。</p>
<p>而使用运行时动态链接，系统不会终止，但由于 DLL 中的导出函数不可用，程序会加载失败；</p>
<p>速度比静态链接慢</p>
<p>当某个模块更新后，如果新模块与旧的模块不兼容，那么那些需要该模块才能运行的软件，统统撕掉。</p>
</blockquote>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>库是写好的现有的，成熟的，可以复用的代码。</p>
<p>静态和动态指<strong>链接</strong></p>
<p>将一个程序编译成可执行程序的步骤：将源文件(.h,.cpp)预编译-&gt;编译-&gt;汇编-&gt;<strong>链接</strong></p>
<p><code>静态库是.lib</code></p>
<p>其特点：</p>
<blockquote>
<ol>
<li>静态库对函数库的链接是放在编译时期完成的</li>
<li>程序在运行时与函数库再无瓜葛，移植方便</li>
<li>浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件</li>
</ol>
</blockquote>
<p><code>动态库是.dll</code></p>
<p>由于静态库的空间浪费和全量更新(如果静态库liba.lib更新了，所以使用它的应用程序都需要重新编译、发布给用户)</p>
<p>其特点：</p>
<blockquote>
<ol>
<li>动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。</li>
<li><strong>不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例</strong>，规避了空间浪费问题</li>
<li>解决了静态库对程序的更新、部署和发布页会带来麻烦</li>
</ol>
</blockquote>
<p>来源CSDN <a target="_blank" rel="noopener" href="http://t.csdn.cn/99Ige">hllyzms</a></p>
<h1 id="13-C-虚函数、纯虚函数的区别和适用场景？"><a href="#13-C-虚函数、纯虚函数的区别和适用场景？" class="headerlink" title="13. C++虚函数、纯虚函数的区别和适用场景？"></a>13. C++虚函数、纯虚函数的区别和适用场景？</h1><p>虚函数:</p>
<p>在类成员方法的声明语句前加 “virtual”, 如 virtual void func() ；</p>
<p>对于虚函数,子类可以(也可以不)重新定义基类的虚函数，该行为称之为复写 Override 。 </p>
<p>纯虚函数:</p>
<p>在虚函数后加“&#x3D;0” ,如 virtual void func()&#x3D;0 ;</p>
<p>对于纯虚函数，<strong>子类必须</strong>提供纯函数的个性化实现</p>
<p>使用场景：当子类<strong>必须</strong>要实现个性化的时候，用纯虚函数</p>
<h1 id="14-是否遇到过-C-变量冲突的情况？如何解决？"><a href="#14-是否遇到过-C-变量冲突的情况？如何解决？" class="headerlink" title="14. 是否遇到过 C++变量冲突的情况？如何解决？"></a>14. 是否遇到过 C++变量冲突的情况？如何解决？</h1><p>换变量名；</p>
<p>应用命名空间；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//来自chatgpt</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">// First namespace named &#x27;A&#x27;</span><br><span class="line">namespace A &#123;</span><br><span class="line">    int num = 5; // Variable &#x27;num&#x27; in namespace &#x27;A&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Second namespace named &#x27;B&#x27;</span><br><span class="line">namespace B &#123;</span><br><span class="line">    int num = 10; // Variable &#x27;num&#x27; in namespace &#x27;B&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // Accessing variables from namespaces</span><br><span class="line">    std::cout &lt;&lt; &quot;Value from namespace A: &quot; &lt;&lt; A::num &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;Value from namespace B: &quot; &lt;&lt; B::num &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>命名空间嵌套；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">namespace Outer &#123;</span><br><span class="line">    int num = 5; // Variable &#x27;num&#x27; in outer namespace &#x27;Outer&#x27;</span><br><span class="line"></span><br><span class="line">    // Inner namespace named &#x27;Inner&#x27; within &#x27;Outer&#x27;</span><br><span class="line">    namespace Inner &#123;</span><br><span class="line">        int num = 10; // Variable &#x27;num&#x27; in inner namespace &#x27;Inner&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">std::cout &lt;&lt; &quot;Value from outer namespace: &quot; &lt;&lt; Outer::num &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; &quot;Value from inner namespace: &quot; &lt;&lt; Outer::Inner::num &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>加入类前缀 作为成员变量</p>
<h2 id="15-聊聊-C-的内存碎片？"><a href="#15-聊聊-C-的内存碎片？" class="headerlink" title="15 .聊聊 C++的内存碎片？"></a>15 .聊聊 C++的内存碎片？</h2><p>即碎片的内存，分为外碎片和内碎片</p>
<p>内存碎片指的是系统中不可用的空闲内存</p>
<p>由于空闲内存小，且以不连续方式出现在不同位置。</p>
<p>该问题解决取决于内存管理算法</p>
<h1 id="16-C-中-lambda-表达式的捕捉变量的方式有哪几种？"><a href="#16-C-中-lambda-表达式的捕捉变量的方式有哪几种？" class="headerlink" title="16. C++中 lambda 表达式的捕捉变量的方式有哪几种？"></a>16. C++中 lambda 表达式的捕捉变量的方式有哪几种？</h1><h2 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h2><p>lambda本质上是一个<strong>匿名函数</strong>。 用这种方式创建函数不需要实际创建一个函数 ，它就像一个<strong>快速的一次性函数</strong> 。 lambda更像是一种变量，在实际编译的代码中作为一个符号存在，而不是像正式的函数那样。</p>
<p>使用格式：<code>[]( &#123;参数表&#125; )&#123; 函数体 &#125;</code></p>
<blockquote>
<p>中括号<strong>表示的是</strong>捕获，作用是<strong>如何传递变量</strong> lambda使用<strong>外部（相对）</strong>的变量时，就要<strong>使用捕获</strong>。</p>
</blockquote>
<p>如果使用捕获,则：</p>
<ul>
<li>添加头文件： <code>#include &lt;functional&gt;</code></li>
<li>修改相应的函数签名 <code>std::function &lt;void(int)&gt; func</code>替代 <code>void(*func)(int)</code></li>
<li>捕获[]使用方式：</li>
</ul>
<blockquote>
<p><code>[=]</code>，则是将所有变量<strong>值传递</strong>到lambda中<br><code>[&amp;]</code>，则是将所有变量<strong>引用传递</strong>到lambda中<br><code>[a]</code>是将变量a通过值传递，如果是<code>[&amp;a]</code>就是将变量a引用传递<br>它可以有0个或者多个捕获</p>
</blockquote>
<p>基础使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line"></span><br><span class="line">void foreach(const std::vector&lt;int&gt; &amp;values,void(*func)(int))</span><br><span class="line">&#123;</span><br><span class="line">    for(int value:values)</span><br><span class="line">        func(value);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    std::vector&lt;int&gt; values=&#123;6,1,7,0,9&#125;;</span><br><span class="line">    foreach(values,[](int value)&#123;std::cout&lt;&lt;&quot;Value: &quot;&lt;&lt;value&lt;&lt;std::endl;&#125;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Value: 6<br>Value: 1<br>Value: 7<br>Value: 0<br>Value: 9</p>
</blockquote>
<p>这里对捕获解释一下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;int&gt; values=&#123;6,1,7,0,9&#125;;</span><br><span class="line"> int a=5;</span><br><span class="line"> auto lambda=[](int value)&#123;std::cout&lt;&lt;&quot;Value: &quot;&lt;&lt;a&lt;&lt;std::endl;&#125;;</span><br><span class="line"> foreach(values,lambda);</span><br></pre></td></tr></table></figure>

<p>看，我们尝试让lambda函数输出a</p>
<blockquote>
<p> error: ‘a’ is not captured<br>     auto lambda&#x3D;[](int value){std::cout&lt;&lt;”Value: “&lt;&lt;a&lt;&lt;std::endl;};<br>                                                     ^<br>lambda.cpp:13:18: note: the lambda has no capture-default<br>     auto lambda&#x3D;[](int value){std::cout&lt;&lt;”Value: “&lt;&lt;a&lt;&lt;std::endl;};<br>                  ^<br>lambda.cpp:12:9: note: ‘int a’ declared here<br>     int a&#x3D;5;</p>
</blockquote>
<p>报错说，a没有<code>捕获</code></p>
<p>在中括号补充一个<code>=</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto lambda=[=](int value)&#123;std::cout&lt;&lt;&quot;Value: &quot;&lt;&lt;a&lt;&lt;std::endl;&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>error: cannot convert ‘main()::&lt;lambda(int)&gt;’ to ‘void (<em>)(int)’ for argument ‘2’ to ‘void foreach(const std::vector&lt;int&gt;&amp;, void (</em>)(int))’<br>     foreach(values,lambda);</p>
</blockquote>
<p>因为使用了<code>捕获</code></p>
<p>所以要添加头文件，然后更改下新的函数指针的签名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">..</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">void foreach(const std::vector&lt;int&gt; &amp;values,const std::function&lt;void(int)&gt;&amp; func)</span><br><span class="line">&#123;</span><br><span class="line">    for(int value:values)</span><br><span class="line">        func(value);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">auto lambda=[=](int value)&#123;std::cout&lt;&lt;&quot;Value: &quot;&lt;&lt;a&lt;&lt;std::endl;&#125;;</span><br><span class="line">//这里[&amp;] [a] [&amp;a]都可</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Value: 5…</p>
</blockquote>
<p>万一我们想对捕获的变量修改值怎么办呢？</p>
<p>需要用到mutable</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">auto lambda=[=](int value) mutable &#123;a=6,std::cout&lt;&lt;&quot;Value: &quot;&lt;&lt;a&lt;&lt;std::endl;&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Value: 6…</p>
</blockquote>
<p>还可以写一个lambda去接受vector元素，遍历该vector找到大于6的数，并返回它的迭代器</p>
<p>find_if是搜索类函数，<code>需要头文件algorithm</code></p>
<p>它与find不同，find_if是<strong>可以接受一个函数指针来定义搜索的规则，返回满足这个规则的第一个元素的迭代器</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    std::vector&lt;int&gt; values=&#123;6,1,7,0,9&#125;;</span><br><span class="line">    auto it=find_if(values.begin(),values.end(),[](int value)&#123;return value&gt;6;&#125;);</span><br><span class="line">   std::cout&lt;&lt;*it;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>7</p>
</blockquote>
<h1 id="17-C-中-final-关键字是做什么的？能否想到更多作用？"><a href="#17-C-中-final-关键字是做什么的？能否想到更多作用？" class="headerlink" title="17.C++中 final 关键字是做什么的？能否想到更多作用？"></a>17.C++中 final 关键字是做什么的？能否想到更多作用？</h1><p>C++11 引入了关键字 final ，按官方的标准是该关键字是用来标识虚函数不能在子类中被覆盖(override) ，或一个类不能被继承。</p>
<h1 id="18-对-RPC-框架有什么了解？原理？"><a href="#18-对-RPC-框架有什么了解？原理？" class="headerlink" title="18.对 RPC 框架有什么了解？原理？"></a>18.对 RPC 框架有什么了解？原理？</h1><p>远程过程调用（Remote Procedure Call ，缩写为RPC）是一个计算机通讯协议</p>
<p>允许运行于一台计算机的程序调用另一台计算机的子程序，就像调用本地程序一样，无需额外的为这个交互作用编程（无需关注细节）</p>
<p>RPC用户调用接口 + 具体网络协议。 前者为开发者需要关心的，后者由框架来实现。</p>
<p>RPC是一种服务器-客户端模式，经典实现是一个通过 发送请求-接收响应 进行信息交互的系统</p>
<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>如果有一个数独求解服务器，包含了登陆服务模块、计算求解模块、后台管理模块，开始时服务器可以部署在单机，但是如果用户增多、请求计算量增多，那么就需要<strong>集群</strong>和<strong>分布式</strong>部署架构达到高并发要求</p>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>将服务器部署到了多台机器上，每一台机器上都是独立的服务器。</p>
<p>再通过负载均衡服务器进行管理，供用户使用，由此大大增加了服务器的并发负载量。</p>
<p>这种部署方式比较简单，并且切实的提高了服务器的并发量。</p>
<p>缺点：</p>
<p>1.服务器的一个模块修改，所有服务器都要重新编译、部署，所以是<strong>维护麻烦</strong></p>
<p>2.服务器有些模块是CPU密集型，需要CPU性能强的机器，有些I&#x2F;O密集型，需要内存更大点的机器，所以<strong>是各模块对硬件资源要求不同</strong></p>
<p>因此，引入分布式架构</p>
<h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><p><strong>支持分模块部署服务器</strong>，例如将数独服务器的计算模块部署到一个CPU强的机器上（不一定是一个，可以单独对模块进行集群部署），将登录模块部署到内存大的机器上。</p>
<p>如此分模块运行在<strong>不同</strong>机器的docker<strong>虚拟化环境</strong>中，属于<strong>不同的进程</strong>，分布在不同机器的各个模块共同构成了高性能的服务器。由此，<code>集群的两个问题都可以得到解决</code>。</p>
<p><strong>但是</strong>嘞，有这样一种情况：有些模块的某段代码，其他模块也需要调用，这样的话，模块间是有<strong>大量重复代码</strong>的</p>
<p>为了让机器1上的模块调用机器2上模块的方法，必要要有一个通信协议，即<code>RPC通信框架</code></p>
<h3 id="RPC框架原理"><a href="#RPC框架原理" class="headerlink" title="RPC框架原理"></a>RPC框架原理</h3><p>分布式计算的 CS 模式，总是由 Client 向 Server 发出一个执行若干过程请求，Server 接受请求，使用客户端提供的参数，计算完成之后将结果返回给客户端。</p>
<p><strong>由于提供端与客户端分属于不同的进程乃至不同的机器，那么必定是需要通过网络进行通信，并且需要是可靠的网络。</strong></p>
<p>通信框架一般是这样：</p>
<p>user-&gt;序列化-&gt;通信-&gt;反序列化-&gt;server</p>
<p>其实现需解决三个部分：</p>
<p>1.<code>调用映射</code></p>
<blockquote>
<p>比如调用者要调用RPC的login方法，怎么保证它不会调用到register方法呢？</p>
<p>这就需要RPC框架建立一个映射表，</p>
<p>比如{server_name,severinfo}，serverinfo包含server对象</p>
<p>以及{method_name,methoddescriptor}</p>
<p>先解析server_name,得到要连接的server的ip和端口，再通过method_name找到要调用的函数</p>
</blockquote>
<p>2.<code>序列化与反序列化</code></p>
<blockquote>
<p>一般的参数调用，系统会将参数放进内存中，但是远程调用又是另一台机器，不能通过内存传递函数，需要RPC客户将参数序列化为字节流，传给RPC提供方，它进行反序列化，得到参数。</p>
<p>这个序列化反序列化方法之一是Protobuf，它的字节流是用二进制存储的</p>
<p>并且Protobuf提供了很完备的RPC服务接口，很方便通过.proto文件生成服务器与客户端需要的RPCService类与Stub类。</p>
</blockquote>
<p>3.<code>网络传输</code></p>
<blockquote>
<p>RPC既然是远程调用，离不开网络传输，可以使用muduo库</p>
<p>是一个linux多线程网络库，使用的是reactors in threads - one loop per thread模式，支持多线程，高并发。</p>
</blockquote>
<p>来源: CSDN <a target="_blank" rel="noopener" href="http://t.csdn.cn/LCDLF">Jacky__Ren</a></p>
<p>使用最广泛的 Spring Cloud，基于 Spring Boot 特性整合了开源行业中优秀的组件，整体对外提供了一套在微服务架构中服务治理的解决方案。</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230806221812465.png"></p>
<p>1.服务集成RPC后，Provider启动后会通过Register模块，把服务的唯一ID和IP地址，端口信息等注册到RPC框架注册中心</p>
<p>2.调用者(Consumer)想要调用服务的时候，通过Provider注册时的服务唯一ID去注册中心查找在线可供调用的服务，返回一个IP列表（notify部分）</p>
<p>3.Consumer根据一定策略，比如随机或轮询从Register返回的可用IP列表真正调用服务(invoke)</p>
<p>4.最后是统计功能，RPC框架提供监控功能，监控服务监控状态，控制服务线上扩展和上下线</p>
<h2 id="主流RPC"><a href="#主流RPC" class="headerlink" title="主流RPC"></a>主流RPC</h2><p>RMI(java自带的远程方法调用工具)</p>
<p>Hessian（基于HTTP的远程方法调用）</p>
<p>Dubbo（淘宝开源的基于TCP的RPC框架）</p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>Provider：服务提供方，CS 模型中的 Server。<br>Consumer： 调用远程服务服务消费方，CS 模型中的 Client。<br>Registry：服务注册与发现的服务管理中心。<br>Monitor：统计服务的调用次数和调用时间的监控中心。<br>Container：服务运行容器，如 jetty。</p>
<h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>服务容器负责启动，加载，运行服务提供者。<br>服务提供者在启动时，向注册中心注册自己提供的服务，暴露自己的 IP 和端口信息。<br>服务消费者在启动时，向注册中心订阅自己所需的服务。<br>注册中心返回服务提供者列表给消费者，如果有变更，注册中心将基于长连接推送给数据消费者。<br>服务消费者，从提供这地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另外一台服务调用。<br>服务消费者和提供者，在内存中累计调用次数和调用时间，定时发送一次统计数据到监控中心。</p>
<p>来源：CSDN <a target="_blank" rel="noopener" href="http://t.csdn.cn/72BLc">Q.E.D.</a></p>
<h1 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h1><p>很多时候不会使用using namespace std;（会不容易分辨各类函数来源）</p>
<p>以vector为例，自己的库定义了一个vector，标准库又有一个，这时候引用using namespace std;</p>
<p>会出现分歧</p>
<p>大型程序往往会使用多个独立开发的库，这些库会定义大量的全局名字，如类、函数和模板等，不可避免会出现某些名字相互冲突的情况。命名空间<code>namespace</code>分割了全局命名空间，其中每个命名空间是一个作用域。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">namespace foo &#123;</span><br><span class="line">    class Bar &#123; /*...*/ &#125;;</span><br><span class="line">&#125;  // 命名空间结束后无需分号</span><br></pre></td></tr></table></figure>

<h2 id="c-三大特性"><a href="#c-三大特性" class="headerlink" title="c++三大特性"></a>c++三大特性</h2><p>多态:主要指泛型编程运行时多态；在基类的函数加上virtual关键字，派生类重写该函数，运行时会根据对象的实际类型调用相应的函数。</p>
<p>多态性，允许将子类类型的指针复制给父类类型的指针</p>
<p><strong>重载实现编译时多态，虚函数实现运行时多态</strong></p>
<p>封装：封装隐藏了实现细节，使得代码模块化</p>
<p>继承:子类继承父类的数据和方法</p>
<p><strong>泛型编程:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">T max1(T a, T b)</span><br><span class="line">&#123;</span><br><span class="line">    return a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line">//#endif</span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;max1(2,3)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;max1(3.1f,2.6f)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;max1(&#x27;a&#x27;,&#x27;b&#x27;)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;max1(&quot;abc&quot;,&quot;abb&quot;)&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>3<br>3.1<br>b<br>abc</p>
</blockquote>
<h2 id="重载与重写的区别"><a href="#重载与重写的区别" class="headerlink" title="重载与重写的区别"></a>重载与重写的区别</h2><p>重载：</p>
<p>是一个类中多态性的体现， 同一个类中<strong>不同函数</strong>使用相同<strong>函数名</strong>，但<strong>函数的参数个数</strong>和<strong>类型不同</strong>，有<strong>不同的返回类型</strong></p>
<p>重写：</p>
<p><strong>子类对父类函数的重新实现</strong>，<strong>函数名和参数与父类一样</strong>，子类与父类<strong>函数体内容不一样</strong>，子类返回类型必须与父类保持一致。</p>
<h2 id="指针和引用区别"><a href="#指针和引用区别" class="headerlink" title="指针和引用区别"></a>指针和引用区别</h2><p>&amp;叫做地址运算符，*是间接运算符</p>
<p>int* ptr;&#x2F;&#x2F;这样的书写方式说明ptr数据类型不是int，而是int指针</p>
<p>cout&lt;&lt;*ptr，这将解引用指针，实际上使用指针指向的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a=10;</span><br><span class="line">cout&lt;&lt;a&lt;&lt;&quot;,&quot;&lt;&lt;&amp;a&lt;&lt;&quot;,&quot;&lt;&lt;*&amp;a;// 10,0x72fe0c,10</span><br></pre></td></tr></table></figure>



<ul>
<li><p>指针是一个新的<code>变量</code>，存储的是地址，可通过访问这个地址来修改另一个变量；</p>
<p>引用属于<code>原变量的别名</code>，对引用的任何操作就是对变量本身操作</p>
</li>
<li><p>指针可以有多级，引用就一级</p>
</li>
<li><p>指针可以为空，引用定义时必须初始化</p>
</li>
<li><p>指针初始化后可以改变指向，但引用不可以</p>
</li>
<li><p>sizeof指针得到的是该指针的大小，sizeof引用是引用所指向变量的大小</p>
</li>
<li><p>指针作为参数传递时(将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量)，在函数中改变这个变量的指向不影响实参，引用却可以</p>
<p>(即，指针传参还是值传递，指针本身的值不可改，除非解引用对指向的对象进行操作；</p>
<p>引用传参，传进来的就是变量本身，因此变量可以修改</p>
<p>)</p>
</li>
<li><p>引用本身不是一种数据类型，不占用存储单元；指针是具体的变量，占用存储空间</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void testPTR(int *p)</span><br><span class="line">&#123;</span><br><span class="line">	int a=12;</span><br><span class="line">	p=&amp;a;</span><br><span class="line">&#125;</span><br><span class="line">void testREFF(int &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">	int a=12;</span><br><span class="line">	p=a;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int a=10;</span><br><span class="line">	int* b=&amp;a;</span><br><span class="line">	testPTR(b);</span><br><span class="line">	cout&lt;&lt;a; //10</span><br><span class="line">	cout&lt;&lt;*b;//10</span><br><span class="line">	——————————————</span><br><span class="line">	a=10;</span><br><span class="line">	testREFF(a);</span><br><span class="line">	cout&lt;&lt;a;//12</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引用变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void ss(int &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">  a=7;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"> 	int b=5;</span><br><span class="line">    std::cout&lt;&lt;&amp;b&lt;&lt;&quot;,&quot;&lt;&lt;b&lt;&lt;std::endl;</span><br><span class="line">    ss(b);</span><br><span class="line">    std::cout&lt;&lt;&amp;b&lt;&lt;&quot;,&quot;&lt;&lt;b;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>0x72fdec,5<br>0x72fdec,7</p>
</blockquote>
<h3 id="引用作为函数返回类型"><a href="#引用作为函数返回类型" class="headerlink" title="引用作为函数返回类型"></a>引用作为函数返回类型</h3><p><code>int&amp; jisuan(int x)&#123;&#125;</code></p>
<blockquote>
<ol>
<li><strong>避免复制：</strong> 使用引用作为返回类型可以避免在函数调用时进行数据的复制操作。当返回引用时，实际上是将调用方的变量和函数内部的对象绑定在一起，而不是创建一个新的副本。这可以提高程序的性能，尤其是当返回的对象很大时。</li>
<li><strong>允许修改：</strong> 返回引用使调用方能够修改原始对象。这在需要从函数内部修改调用方的变量时非常有用，特别是在函数内部修改一个对象而不需要使用指针的情况下。</li>
<li><strong>链式调用：</strong> 使用引用作为返回类型，可以实现链式调用。这在某些情况下可以使代码更加清晰和简洁。例如，很多标准库的操作就采用了链式调用的方式。</li>
<li><strong>传递信息：</strong> 引用作为返回类型可以传递更多的信息，如返回一个布尔值来指示函数执行的成功与否。这种情况下，函数可以直接修改调用方提供的变量来传递额外的信息。</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">int</span>  a=<span class="number">4</span>;</span><br><span class="line"> <span class="number">2</span> <span class="function"><span class="type">int</span>  &amp;<span class="title">f</span><span class="params">(<span class="type">int</span>  x)</span></span></span><br><span class="line"><span class="function"> 3 </span>&#123;</span><br><span class="line"> <span class="number">4</span>     a = a + x;</span><br><span class="line"> <span class="number">5</span>     <span class="keyword">return</span>  a;</span><br><span class="line"> <span class="number">6</span> &#125;</span><br><span class="line"> <span class="number">7</span> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> 8 </span>&#123;</span><br><span class="line"> <span class="number">9</span>     <span class="type">int</span> t = <span class="number">5</span>;</span><br><span class="line"><span class="number">10</span>     cout&lt;&lt;<span class="built_in">f</span>(t)&lt;&lt;endl;  <span class="comment">//a = 9</span></span><br><span class="line"><span class="number">11</span>     <span class="built_in">f</span>(t) = <span class="number">20</span>;           <span class="comment">//a = 20</span></span><br><span class="line"><span class="number">12</span>     cout&lt;&lt;<span class="built_in">f</span>(t)&lt;&lt;endl;  <span class="comment">//t = 5,a = 25</span></span><br><span class="line"><span class="number">13</span>     t = <span class="built_in">f</span>(t);            <span class="comment">//a = 30 t = 30</span></span><br><span class="line"><span class="number">14</span>     cout&lt;&lt;<span class="built_in">f</span>(t)&lt;&lt;endl;  <span class="comment">//t = 60</span></span><br><span class="line"><span class="number">15</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">16</span> &#125;</span><br></pre></td></tr></table></figure>



<h2 id="结构体为什么要内存对齐"><a href="#结构体为什么要内存对齐" class="headerlink" title="结构体为什么要内存对齐"></a>结构体为什么要内存对齐</h2><p>平台原因，有的平台只能在某些地址处取特定类型的数据，否则抛出硬件异常</p>
<p>硬件原因，内存对齐之后，cpu内存访问速度大大提升</p>
<p>1、 分配内存的顺序是按照声明的顺序。</p>
<p>2、 每个变量<strong>相对于起始位置的偏移量</strong>必须是<strong>该变量类型大小的整数倍</strong>，不是整数倍，则空出内存，直到偏移量是整数倍为止</p>
<p> 3、 最后整个结构体的大小必须是里面变量类型最大值的整数倍</p>
<p>添加了#pragma pack(n)后规则就变成了下面这样： </p>
<p>1、 偏移量要是n和当前变量大小中较小值的整数倍</p>
<p> 2、 整体大小要是n和最大变量大小中较小值的整数倍</p>
<p> 3、 n值必须为1,2,4,8…，为其他值时就按照默认的分配规则</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct Test&#123;</span><br><span class="line">	int a;//4</span><br><span class="line">	char b;//1</span><br><span class="line">	int c;//4    总共会是9字节吗</span><br><span class="line">&#125;test;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	test.a=1;</span><br><span class="line">	test.b=2;</span><br><span class="line">	test.c=3;</span><br><span class="line">	cout&lt;&lt;sizeof(test)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实是12字节</p>
<p>以0x0000为起始地址，32位操作系统讨论</p>
<table>
<thead>
<tr>
<th>0x01</th>
<th>0x00</th>
<th>0x00</th>
<th>0x00</th>
</tr>
</thead>
<tbody><tr>
<td>变量a</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>还空了三字节</p>
<table>
<thead>
<tr>
<th>0x02</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>变量b</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>0x03</th>
<th>0x00</th>
<th>0x00</th>
<th>0x00</th>
</tr>
</thead>
<tbody><tr>
<td>变量c</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>对于变量b，c，如果无内存对齐情况，这是5字节</p>
<p>前4字节</p>
<table>
<thead>
<tr>
<th>0x02</th>
<th>0x03</th>
<th>0x00</th>
<th>0x00</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>后1字节</p>
<table>
<thead>
<tr>
<th>0x00</th>
</tr>
</thead>
</table>
<p>这样的话，要读取两次，再拼接；而内存对齐，一次读取即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">double a;//4</span><br><span class="line">char b;//1</span><br><span class="line">   double d;//8   总共的sizeof是24(8+8+8)</span><br><span class="line">   </span><br><span class="line">   int a;//4</span><br><span class="line">char b;//1</span><br><span class="line">int c;//4   </span><br><span class="line">   double d;//8 //总共是24 (4+4+4+8)=20</span><br><span class="line">   </span><br><span class="line"> </span><br><span class="line">  cout&lt;&lt;offsetof(Test,a)&lt;&lt;endl;//0</span><br><span class="line">   cout&lt;&lt;offsetof(Test,b)&lt;&lt;endl;//4</span><br><span class="line">   cout&lt;&lt;offsetof(Test,c)&lt;&lt;endl;//8</span><br><span class="line">   cout&lt;&lt;offsetof(Test,d)&lt;&lt;endl;//16</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   int a;//4</span><br><span class="line">char b;//1  </span><br><span class="line">   double d;//8  //总共是16 (4+4+8)</span><br><span class="line">   </span><br><span class="line">   综上，所以类型大小小的那个，本身所占的空间取决于其上一个类型</span><br><span class="line">   </span><br><span class="line">   int a;//4</span><br><span class="line">   double d;//8</span><br><span class="line">char b;//1   //总共是24   那就是说本来是4+8+8为20，因为要满足最大类型的整数倍，那就24咯？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> cout&lt;&lt;offsetof(Test,a)&lt;&lt;endl;//0</span><br><span class="line">   cout&lt;&lt;offsetof(Test,d)&lt;&lt;endl;//8</span><br><span class="line">   cout&lt;&lt;offsetof(Test,b)&lt;&lt;endl;//16</span><br></pre></td></tr></table></figure>



<h2 id="传递函数参数，什么时候用指针、引用"><a href="#传递函数参数，什么时候用指针、引用" class="headerlink" title="传递函数参数，什么时候用指针、引用"></a>传递函数参数，什么时候用指针、引用</h2><p>指针：</p>
<blockquote>
<ul>
<li>返回函数内局部变量的内存时。使用指针传参需要开辟内存，用完释放，否则引起内存泄露。而返回局部变量的引用无意义</li>
</ul>
</blockquote>
<p>引用</p>
<blockquote>
<ul>
<li>对栈空间大小比较敏感(比如递归)时用引用，引用传递不需要创建临时变量，开销更小</li>
<li>类对象作为参数传递要用引用</li>
</ul>
</blockquote>
<h2 id="堆和栈区别"><a href="#堆和栈区别" class="headerlink" title="堆和栈区别"></a>堆和栈区别</h2><p>申请方式</p>
<blockquote>
<ul>
<li>栈由系统自动分配</li>
<li>堆是自己申请、释放</li>
</ul>
</blockquote>
<p>申请大小限制</p>
<blockquote>
<p>栈顶和栈底是之前预设好的，栈是向栈底扩展，大小固定</p>
<p>堆向高地址扩展，是不连续的内存区域，大小灵活调整(这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，链表的遍历方向是由低地址向高地址)</p>
</blockquote>
<p>申请效率</p>
<blockquote>
<p>栈由系统分配，速度快，无碎片 (先进后出，进出一一对应)</p>
<p>堆有程序员分配，速度慢，有碎片</p>
</blockquote>
<p>分配方式和空间大小</p>
<blockquote>
<p>堆，动态分配，不连续</p>
<p>栈，动态、静态都有，连续内存区域</p>
</blockquote>
<p>栈空间默认4M，堆区一般1G-4G</p>
<p>栈就像点菜，申请、使用，快捷，但自由度小</p>
<p>堆，自己做菜，麻烦，自由度大</p>
<h2 id="宏定义和函数区别"><a href="#宏定义和函数区别" class="headerlink" title="宏定义和函数区别"></a>宏定义和函数区别</h2><p>1.执行速度</p>
<blockquote>
<p>宏在编译时完成替换，被替换的文本参与编译，相当于直接插入了代码；运行时不存在函数调用，执行更快；</p>
<p>而调用函数，需要跳转到具体调用函数</p>
</blockquote>
<p>2.返回值</p>
<blockquote>
<p>宏定义相当于在结构中插入代码，无返回值；</p>
<p>函数调用是有的</p>
</blockquote>
<p>3.类型检查</p>
<blockquote>
<p>宏定义无类型，不进行类型检查</p>
<p>函数要</p>
</blockquote>
<p>4.宏定义，不是语句，最后不加分号</p>
<h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><p>1.预处理阶段：当编译c++代码时，预处理器过一遍c++所以#开头的语句，预编译器将这些代码评估完后给到编译器进行实际的编译</p>
<p>2.用宏的目的：将代码中的文本替换为其它东西</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT std::cin.get()</span></span><br><span class="line"><span class="comment">//可以不放分号，否则会加入宏了</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	WAIT;</span><br><span class="line">	<span class="comment">//等价于std::cin.get()</span></span><br><span class="line">	<span class="comment">//当然，这种操作很蠢，只能让自己读懂代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.用法1：<code>发送参数</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">#define log(x) std::cout&lt;&lt;x&lt;&lt;std::endl</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    log(&quot;hello&quot;);//输出hello</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>用法2：<code>辅助调试</code></p>
<p>debug模式下会有很多日志的输出，Release模式下就不需要日志的输出了，正常的方法会删除	很多输出日志的语句或函数。 <strong>宏可以直接取消掉这样的语句</strong></p>
<p>利用<code>#if,#else,endif</code>实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">#define PR_DEBUG 1 </span><br><span class="line">#if PR_DEBUG==1</span><br><span class="line">#define log(x) std::cout&lt;&lt;x&lt;&lt;std::endl </span><br><span class="line">#else</span><br><span class="line">#define log(x) //什么也不定义 无意义</span><br><span class="line">#endif</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">   </span><br><span class="line">    log(&quot;hello&quot;);//当PR_DEBUG 为 1，输出，为0，无输出</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用<code>#if 0</code>和<code>#endif</code>删除一段宏</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">#if 0</span><br><span class="line"></span><br><span class="line">#define PR_DEBUG 1 </span><br><span class="line">#if PR_DEBUG==1</span><br><span class="line">#define log(x) std::cout&lt;&lt;x&lt;&lt;std::endl </span><br><span class="line">#else</span><br><span class="line">#define log(x) //什么也不定义 无意义</span><br><span class="line">#endif</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line">int main()&#123;</span><br><span class="line">   </span><br><span class="line">    log(&quot;hello&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//输出 error: &#x27;log&#x27; was not declared in this scope</span><br></pre></td></tr></table></figure>



<h2 id="宏和模板的区别"><a href="#宏和模板的区别" class="headerlink" title="宏和模板的区别"></a>宏和模板的区别</h2><p>发生时间不同，宏在预处理阶段就被评估了</p>
<h2 id="宏和typedef区别"><a href="#宏和typedef区别" class="headerlink" title="宏和typedef区别"></a>宏和typedef区别</h2><p>1.用途</p>
<blockquote>
<p>宏主要用于定义常量和书写复杂的内容</p>
<p>typede定义类型f<strong>别名</strong></p>
</blockquote>
<p>2.时间</p>
<blockquote>
<p>宏替换发生在编译阶段之前，文本插入替换</p>
<p>typedef是编译的一部分</p>
</blockquote>
<p>3.宏不检查类型，typedef检查数据类型</p>
<p>4.宏不是语句，末尾不加分号；typedef要</p>
<p>5.指针的操作不同 ，typedef char * p_char和#define p_char char *区别巨大。</p>
<h2 id="变量声明和定义区别？"><a href="#变量声明和定义区别？" class="headerlink" title="变量声明和定义区别？"></a>变量声明和定义区别？</h2><ul>
<li>声明仅仅把变量的声明的<strong>位置及类型</strong>提供给编译器，不分配内存空间</li>
</ul>
<p>定义，要在定义的地方为其分配存储空间</p>
<ul>
<li>相同变量多处声明（外部变量<strong>extern</strong>） ，但只能在一处定义</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//变量声明</span><br><span class="line">extern int x;</span><br><span class="line">//变量定义</span><br><span class="line">int x;</span><br><span class="line">int y=10;</span><br></pre></td></tr></table></figure>

<p>总之，变量声明通知编译器变量的存在和类型，而变量定义创建变量，为其分配内存，</p>
<p>总结：</p>
<p>声明就是告知一下，你知道有这么个变量或者函数，这个变量的具体值，还有这个函数的函数体，不用知道；就告诉<strong>基本信息</strong>，<strong>需要extern关键字</strong></p>
<p>定义就是，变量的初始化啊，函数体的<strong>具体实现</strong>啊</p>
<p>如果是在类中的话</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">    Person(); // 成员函数的声明</span><br><span class="line">    void SetName(const std::string&amp; name); // 成员函数的声明</span><br><span class="line">    void SetAge(int age); // 成员函数的声明</span><br><span class="line">    void PrintInfo() const; // 成员函数的声明</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    std::string name_; // 成员变量的声明</span><br><span class="line">    int age_; // 成员变量的声明</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person::Person() : age_(0) &#123;</span><br><span class="line">    // 构造函数的定义</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Person::SetName(const std::string&amp; name) &#123;</span><br><span class="line">    name_ = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Person::SetAge(int age) &#123;</span><br><span class="line">    age_ = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Person::PrintInfo() const &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Name: &quot; &lt;&lt; name_ &lt;&lt; &quot;, Age: &quot; &lt;&lt; age_ &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="strlen和sizeof区别"><a href="#strlen和sizeof区别" class="headerlink" title="strlen和sizeof区别"></a>strlen和sizeof区别</h2><p>sizeof运算符，结果在编译时得到，所以不能得到运行时分配的存储空间大小；strlen是库函数</p>
<p>sizeof参数可以是任何数据的类型或数据；strlen的参数只能是字符指针且结尾是’\0’的字符串</p>
<h2 id="a与-amp-a的区别"><a href="#a与-amp-a的区别" class="headerlink" title="a与&amp;a的区别"></a>a与&amp;a的区别</h2><p>假设数组int a[10] 与int(*p)[10]&#x3D;&amp;a</p>
<p>a是数组名，是数组首元素地址，*(a+1)&#x3D;a[1]，a相当于&amp;a[0]</p>
<p>&amp;a是数组的指针，其类型为int(*p)[10]，值就是地址了，如果+1，其实是整个数组的偏移，地址为尾元素的后一个元素地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">   </span><br><span class="line">    int a[4]=&#123;1,2,3,4&#125;;</span><br><span class="line">    int (*p)[4]=&amp;a;</span><br><span class="line">   </span><br><span class="line">    std::cout&lt;&lt;a&lt;&lt;&quot;,&quot;&lt;&lt;&amp;a&lt;&lt;std::endl;//0x72fdf0,0x72fdf0</span><br><span class="line">   </span><br><span class="line">    std::cout&lt;&lt;*a&lt;&lt;&quot;,&quot;&lt;&lt;*&amp;a[0]&lt;&lt;std::endl;//1,1</span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt;*(a+1)&lt;&lt;&quot;,&quot;&lt;&lt;*(&amp;a[1])&lt;&lt;std::endl;//2,2</span><br><span class="line">	//也就是说(&amp;a+1)，其实是整个数组的偏移，地址为尾元素的后一个元素地址</span><br><span class="line">    std::cout&lt;&lt;(a+4)&lt;&lt;&quot;,&quot;&lt;&lt;(&amp;a+1)&lt;&lt;std::endl;//0x72fe00,0x72fe00</span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt;*(a+1)&lt;&lt;&quot;,&quot;&lt;&lt;*(*p+1)&lt;&lt;std::endl;//2,2</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="c-与python"><a href="#c-与python" class="headerlink" title="c++与python"></a>c++与python</h2><p>python是解释执行的脚本语言；c++是在特定平台运行的编译语言</p>
<p>python缩进区分代码块；c++花括号</p>
<p>python库多，调用方便，不需要事先定义变量类型，基本数据类型为数字、布尔值、字符串、列表、元组等等</p>
<h2 id="c-与c"><a href="#c-与c" class="headerlink" title="c++与c"></a>c++与c</h2><p>c没有字符串类型</p>
<p>c++的new取代了c中的malloc</p>
<p>c++的控制态输入输出iostream类替代c的stdio函数</p>
<p>c++允许重载，c不允许</p>
<p>c++允许重复定义变量，变量定义语句在使用它之前都可以；但c不能重复定义，且必须在函数开头部分</p>
<p>c++多了关键字 bool、using、namespace等等</p>
<h3 id="c的特点"><a href="#c的特点" class="headerlink" title="c的特点"></a>c的特点</h3><p>面向过程的结构化语言，易于调试和维护</p>
<p>表现能力和处理能力极强，可以直接访问内存的物理地址</p>
<p>c实现了对硬件的编程操作，也适合应用软件的开发</p>
<h3 id="c-特点"><a href="#c-特点" class="headerlink" title="c++特点"></a>c++特点</h3><p>在c的基础上扩充和完善，使c++兼容了c语言的面向过程特点，又成为了一种面向对象的程序设计语言</p>
<p>可以使用抽象数据类型进行基于对象的编程</p>
<p>可以使用多继承、多态进行面向对象的编程</p>
<p>担负起以模板为特征的泛型化编程</p>
<h2 id="c-与java"><a href="#c-与java" class="headerlink" title="c++与java"></a>c++与java</h2><h3 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h3><p>java完全面向对象，jvm(java虚拟机)安装到任何操作系统上，可移植性强</p>
<p>java没有指针的概念</p>
<p>java用接口取代了c++中的抽象类，省却了在实现和维护上的复杂性</p>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>c++析构函数回收</p>
<p>java是内存的分配和回收都是自动的</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>java在web应用上相比具有优势	，有丰富的框架</p>
<p>底层程序的编程以及控制方面的编程，c++灵活，有句柄的存在</p>
<p>java在桌面程序的实用性不如c++;c++可直接编译成exe文件，指针是c++的优势，可以直接对内存操作，但有危险性</p>
<h2 id="c-的class和struct"><a href="#c-的class和struct" class="headerlink" title="c++的class和struct"></a>c++的class和struct</h2><p>相同</p>
<blockquote>
<p>都有成员函数、公有、私有部分</p>
<p>任何可以用class完成的工作，可以用struct完成</p>
</blockquote>
<p>不同点</p>
<blockquote>
<p>如果不对成员不指定公私有，struct默认公有。class默认私有</p>
<p>class默认private继承，struct默认public继承</p>
</blockquote>
<h2 id="define与const"><a href="#define与const" class="headerlink" title="define与const"></a>define与const</h2><p>编译阶段</p>
<blockquote>
<p>define编译的预处理阶段起作用</p>
<p>const在编译、运行时起作用</p>
</blockquote>
<p>安全性</p>
<blockquote>
<p>define只做替换，不做类型检查和计算，不求解</p>
<p>const常量有数据类型，编译器对其进行类型安全检查</p>
</blockquote>
<p>内存占用</p>
<blockquote>
<p>define只是将宏名称进行替换，内存中有多个相同的备份；const就一份</p>
<p>宏定义的数据没有分配内存空间，const定义的变量只是值不能改变，但要分配内存空间</p>
</blockquote>
<h2 id="const和static的作用"><a href="#const和static的作用" class="headerlink" title="const和static的作用"></a>const和static的作用</h2><h3 id="static-1"><a href="#static-1" class="headerlink" title="static"></a>static</h3><h4 id="不考虑类的情况"><a href="#不考虑类的情况" class="headerlink" title="不考虑类的情况"></a>不考虑类的情况</h4><p>1.隐藏</p>
<blockquote>
<p>不加static的全局变量和函数具有全局可见性，可在其他文件中使用，加了只能在该文件所在的编译模块中使用</p>
</blockquote>
<p>2.默认初始化为0</p>
<blockquote>
<p>包括未初始化的全局静态变量与局部静态变量</p>
</blockquote>
<p>3.静态变量在函数内定义，始终存在，且只进行一次初始化，具有记忆性</p>
<blockquote>
<p>作用范围与局部变量相同，函数退出后仍然存在，但不能使用</p>
</blockquote>
<p>应用场景：两个全局变量的名字不能一样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//在a.cpp中</span><br><span class="line">//int s_var=5;//冲突了</span><br><span class="line">static int s_var=5;</span><br><span class="line">//main.cpp中</span><br><span class="line">int s_var=10;</span><br><span class="line">//或者extern int s_var;</span><br><span class="line">...</span><br><span class="line">cout&lt;&lt;s_var;// 10</span><br></pre></td></tr></table></figure>



<h4 id="考虑类"><a href="#考虑类" class="headerlink" title="考虑类"></a>考虑类</h4><p>static成员变量:</p>
<blockquote>
<p>只与类关联，不与类的对象关联，定义时要分配空间，不能在类声明中初始化</p>
<p>必须在类定义体<strong>外部</strong>初始化(为了分配内存)，初始化时不需要标识为static，可以被非static成员函数任意访问</p>
</blockquote>
<p>static成员函数:</p>
<blockquote>
<p>不具有this指针(本质上，写的所有非static方法都会获得当前类实例作为参数)</p>
<p>没有类实例</p>
<p>无法访问类对象的非static成员变量和非static成员函数；</p>
<p>不能被声明为const、虚函数和volatile；可以被非static成员函数任意访问</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct Entity</span><br><span class="line">&#123;</span><br><span class="line">    static int x;</span><br><span class="line"></span><br><span class="line">    void print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int Entity::x;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Entity e1;</span><br><span class="line">    e1.x = 1;</span><br><span class="line"></span><br><span class="line">    Entity e2;</span><br><span class="line">    e2.x = 2;</span><br><span class="line"></span><br><span class="line">    e1.print();//2</span><br><span class="line">    e2.print();//2</span><br><span class="line"></span><br><span class="line">    cin.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个实例化对象共享的是同一个变量，正因如此，<strong>通过类实例来引用静态变量是没有意义的</strong></p>
<p>所以可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Entity e1;</span><br><span class="line">   Entity::x = 1;</span><br><span class="line"></span><br><span class="line">   Entity e2;</span><br><span class="line">    Entity::x = 2;</span><br><span class="line"></span><br><span class="line">   e1.print();//2</span><br><span class="line">   e2.print();//2</span><br></pre></td></tr></table></figure>

<p>如果连print()也是静态的话，由于静态函数无实例，可以这样写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct Entity</span><br><span class="line">&#123;</span><br><span class="line">    static int x;</span><br><span class="line"></span><br><span class="line">    static void print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int Entity::x;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Entity::x = 1;</span><br><span class="line">    Entity::x= 2;</span><br><span class="line">    Entity::print();//2</span><br><span class="line">    Entity::print();//2</span><br><span class="line"></span><br><span class="line">    cin.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然了，此时将x改为非static，会报错，因为static函数无法访问非静态变量(静态方法无实例)</p>
<p>所以，静态方法和在类外部编写的方法一样</p>
<p>如果在类外面写一个print()，访问不到x</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">struct Entity</span><br><span class="line">&#123;</span><br><span class="line">    int x;</span><br><span class="line"></span><br><span class="line">    static void print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; endl;  // 报错，不能访问到非静态变量x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//在类外面写一个print()函数</span><br><span class="line">static void print()</span><br><span class="line">&#123;</span><br><span class="line"> cout &lt;&lt; x &lt;&lt; endl;  // 报错，x是什么？没被定义。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Entity e1;</span><br><span class="line">    e1.x = 1;</span><br><span class="line"></span><br><span class="line">    Entity e2;</span><br><span class="line">    e2.x = 2;</span><br><span class="line"></span><br><span class="line">    e1.print();</span><br><span class="line">    e2.print();</span><br><span class="line"></span><br><span class="line">    cin.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这种就可以</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//在类外面写一个print()函数</span><br><span class="line">static void print(Entity e)</span><br><span class="line">&#123;</span><br><span class="line"> cout &lt;&lt; e.x &lt;&lt; endl;  // 成功运行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="const-1"><a href="#const-1" class="headerlink" title="const"></a>const</h3><ul>
<li><strong>const首先作用于左边的东西；如果左边没东西，就做用于右边的东西</strong></li>
<li>const被cherno称为伪关键字，因为它在改变生成代码方面做不了什么。</li>
<li>const是一个承诺，承诺一些东西是不变的，你是否遵守诺言取决于你自己。我们要保持const是因为这个承诺实际上可以简化很多代码。</li>
</ul>
<h4 id="不考虑类"><a href="#不考虑类" class="headerlink" title="不考虑类"></a>不考虑类</h4><p>const常量在定义时 必须初始化，之后无法更改</p>
<p>const形参可以接收const和非const类型的实参</p>
<h4 id="考虑类-1"><a href="#考虑类-1" class="headerlink" title="考虑类"></a>考虑类</h4><p>const成员变量:</p>
<blockquote>
<p>不能在类定义外部初始化，只能通过构造函数初始化列表进行初始化，并且必须有构造函数；</p>
<p>不同类对其const数据成员的值可以不同，所以不能在类中初始化</p>
</blockquote>
<p>const成员函数：</p>
<blockquote>
<p>const对象不可以调用非const成员函数;</p>
<p>非const对象都可以调用</p>
<p>不可以改变非mutable数据的值</p>
</blockquote>
<p><strong>mutable:该关键字声明的变量可以在const成员函数中被修改</strong></p>
<h2 id="顶层const和底层const"><a href="#顶层const和底层const" class="headerlink" title="顶层const和底层const"></a>顶层const和底层const</h2><p>顶层const：指的是const修饰的变量本身是一个常量，无法修改，指的是指针，就是*号的右边</p>
<p>底层const：指的是const修饰的变量所指向的对象是一个常量，指的是所指变量，就是*号的左边</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a=10;int* const b1=&amp;a;//顶层const，b1本身是个常量</span><br><span class="line">const int* b2=&amp;a;//底层const，b2本身可变，所指对象是常量</span><br><span class="line">const int b3=20;//顶层const，b3常量不可变</span><br><span class="line">const int* const b4=&amp;a;//前一个const为底层;后一个为顶层,b4不可变</span><br><span class="line">const int&amp; b5=a;//用于声明引用变量，底层const</span><br></pre></td></tr></table></figure>

<p>区分作用：</p>
<blockquote>
<p>执行对象拷贝时有限制，常量的底层const不能赋值给非常量的底层const</p>
<p>使用命令强制类型转换函数const_cast时，只能改变运算对象的底层const</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const int a;int const a;//定义常量类型a</span><br><span class="line">const int* a;//a为指向int型变量的指针，const在*左侧，表示a指向不可变常量</span><br><span class="line">int *const a;//a指向int型变量，const在*右侧，表示常指针，即该指针初始化后，不可更改指向</span><br></pre></td></tr></table></figure>

<h2 id="数组名与指针的区别"><a href="#数组名与指针的区别" class="headerlink" title="数组名与指针的区别"></a>数组名与指针的区别</h2><blockquote>
<p>都可以通过增减偏移量来访问数组中的元素</p>
<p>数组名理解为常指针，所以数组名没有自增自减操作</p>
<p>数组名做形参传递给调用函数后，失去原有特性，退化为一般指针，可以自增、自减，但sizeof运算符不能得到原数组大小</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1 char a[] = &quot;hello world&quot;;</span><br><span class="line"> 2 char *p = a;</span><br><span class="line"> 3 </span><br><span class="line"> 4 //计算数组和指针的内存容量</span><br><span class="line"> 5 cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 12 字节</span><br><span class="line"> 6 cout&lt;&lt; sizeof(p) &lt;&lt; endl; // 4 字节</span><br><span class="line"> 7 </span><br><span class="line"> 8 //数组作为函数参数传递</span><br><span class="line"> 9 void Func(char a[100])//数组退化成指针</span><br><span class="line">10 &#123;</span><br><span class="line">11     cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 4 字节而不是100 字节</span><br><span class="line">12 &#125;</span><br></pre></td></tr></table></figure>



<h2 id="final和override关键字"><a href="#final和override关键字" class="headerlink" title="final和override关键字"></a>final和override关键字</h2><h3 id="override"><a href="#override" class="headerlink" title="override"></a>override</h3><p>父类中用了虚函数，子类对父类的虚函数进行重写</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line">	<span class="comment">//void foo()&#123;&#125;也是可以的</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;&#125;;<span class="comment">//加了override，如果函数名写错了，编译不通过</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>不希望某个类被继承 or 不希望某个虚函数被重写；可以添加该关键字，一旦添加该关键字的类被继承，或方法被重写，编译报错</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">final</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">final</span>:A&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fool</span><span class="params">()</span></span>; <span class="comment">//error，A里已经final了</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:<span class="keyword">public</span> B&#123;<span class="comment">//error，B类final</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="拷贝初始化与直接初始化"><a href="#拷贝初始化与直接初始化" class="headerlink" title="拷贝初始化与直接初始化"></a>拷贝初始化与直接初始化</h2><p>用于类类型对象时：</p>
<blockquote>
<p>直接初始化：</p>
<p>直接调用与实参匹配的构造函数</p>
<p>拷贝初始化：</p>
<p>先使用指定构造函数创建一个临时对象，调用拷贝构造函数将临时对象拷贝到正在创建的对象</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//直接初始化</span><br><span class="line">  string str1(&quot;i am a string&quot;);</span><br><span class="line">  string str2(str1);</span><br><span class="line"></span><br><span class="line">  //拷贝初始化</span><br><span class="line">  string str3=&quot;I am a string&quot;;</span><br><span class="line">  string str4=str3;//相当于隐身调用拷贝构造函数，而不是复制运算符函数</span><br></pre></td></tr></table></figure>

<p>当然了，拷贝构造函数为private时，语句3,4编译时会报错</p>
<p>explict修饰构造函数时：如果构造函数存在隐式转化，也报错</p>
<h3 id="什么时候调用拷贝构造函数"><a href="#什么时候调用拷贝构造函数" class="headerlink" title="什么时候调用拷贝构造函数"></a>什么时候调用拷贝构造函数</h3><p>用类的一个实例化对象去初始化另一个对象的时候 </p>
<p>函数的参数是类的对象时（非引用传递） </p>
<p>函数的返回值是函数体内局部对象的类的对象时 ,此时虽然发生（Named return Value优化）NRV优化，但是由于返回方式是值传递，所以会在返回值的地方调用拷贝构造函数</p>
<h2 id="编译型与解释型语言区别"><a href="#编译型与解释型语言区别" class="headerlink" title="编译型与解释型语言区别"></a>编译型与解释型语言区别</h2><p>执行方面</p>
<blockquote>
<p>编译型语言，先用编译器将代码编译成可执行文件如.exe才能执行</p>
<p>即源程序-&gt;机器指令-&gt;机器运行</p>
<p>解释型，解释(翻译)一条执行一条</p>
</blockquote>
<p>跨平台性</p>
<blockquote>
<p>编译型依赖特定平台，不同操作系统下使用不同编译工具进行编译，编译出来的机器代码不同</p>
<p>解释型移植性好（jvm(java虚拟机)、python虚拟机的强大）</p>
</blockquote>
<p>性能</p>
<blockquote>
<p>编译型要好一点</p>
<p>解释型语言中间隔了个虚拟机的存在，运行速度慢了，要求的内存也比较高</p>
</blockquote>
<p>总之，编译型，运行快，所需内存小，但跨平台性差</p>
<p>​			解释型，跨平台性好，但运行慢，内存大</p>
<h2 id="初始化和赋值的区别"><a href="#初始化和赋值的区别" class="headerlink" title="初始化和赋值的区别"></a>初始化和赋值的区别</h2><p>初始化：创建对象时赋予一个初值，分为直接初始化、拷贝初始化</p>
<p>赋值：将对象的当前值擦掉，用新值代替</p>
<p>简单类型来说没区别</p>
<p>对于类和复杂类型的话</p>
<p>怎么区分嘞：对象创建的时候就是初始化，未创建对象而对象的值改变就是赋值</p>
<h2 id="extern-“C”的用法"><a href="#extern-“C”的用法" class="headerlink" title="extern “C”的用法"></a>extern “C”的用法</h2><p>为了在c++代码中正确调用c语言代码，在程序中加上 extern “C”，相当于按照C语言进行编译了</p>
<p>使用场景：你比如多人协同开发，有人c++，有人c</p>
<p>使用例子：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_58367586/article/details/123015442">https://blog.csdn.net/m0_58367586/article/details/123015442</a></p>
<h2 id="野指针与悬空指针"><a href="#野指针与悬空指针" class="headerlink" title="野指针与悬空指针"></a>野指针与悬空指针</h2><p>都是指向无效内存区域的</p>
<p>野指针：</p>
<p>野指针，指的是没有被初始化过的指针</p>
<p><code>比如int *p;</code>为了防止出错，可这样 <code>int* p=nullptr;</code></p>
<p>解决：要么初始化、要么置空</p>
<p>悬空指针：</p>
<p>最初指向的内存已经被释放了的指针，如下p和p2都是悬空指针</p>
<p>解决：释放操作后，及时置空</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">int* p=nullptr;</span><br><span class="line">int* p2=new int;</span><br><span class="line"></span><br><span class="line">p=p2;</span><br><span class="line"></span><br><span class="line">delete p2;</span><br></pre></td></tr></table></figure>

<p>所以，c++引入了智能指针，避免悬空指针的产生</p>
<h2 id="C-类型安全"><a href="#C-类型安全" class="headerlink" title="C++类型安全"></a>C++类型安全</h2><h3 id="什么是类型安全？"><a href="#什么是类型安全？" class="headerlink" title="什么是类型安全？"></a>什么是类型安全？</h3><p>类型安全很大程度上等价于内存安全，类型安全的代码不会试图访问自己没被授权的区域。</p>
<h3 id="c-的类型安全"><a href="#c-的类型安全" class="headerlink" title="c++的类型安全"></a>c++的类型安全</h3><p>操作符new返回的指针类型严格与对象匹配，而不是void*</p>
<p>dynamic_cast比static_cast有更多具体的类型检查</p>
<p>const关键字(有类型、作用域)代替#define constants(简单的文本替换)</p>
<h2 id="c-的构造函数"><a href="#c-的构造函数" class="headerlink" title="c++的构造函数"></a>c++的构造函数</h2><p>默认构造函数（无参）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Student</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">	student()&#123;</span><br><span class="line">	this-&gt;id=1;</span><br><span class="line">	this-&gt;name=&quot;yuleiyun&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>初始化构造函数(有参数)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">student(int a, string str):id(a), name(str)&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>拷贝构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">student(const student&amp; s)&#123;</span><br><span class="line"> this-&gt;id = s.id;</span><br><span class="line"> this-&gt;name = s.name;</span><br><span class="line"> &#125;; </span><br></pre></td></tr></table></figure>

<p>移动构造函数(move和右值引用)</p>
<p>委托构造函数</p>
<p>转换构造函数(形参只有一个，是其他类型变量)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">student(int id)&#123; //将其它类型变量，隐式转换为本类对象</span><br><span class="line"> this-&gt;id = id;</span><br><span class="line"> this-&gt;name = &quot;yuleiyun&quot;;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="浅拷贝与深拷贝-暂略"><a href="#浅拷贝与深拷贝-暂略" class="headerlink" title="浅拷贝与深拷贝(暂略)"></a>浅拷贝与深拷贝(暂略)</h2><p>当进行变量被赋值给另一变量的时候，这是在进行<strong>复制</strong></p>
<p>浅拷贝只是拷贝基本数据类型(非指针变量)，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址</p>
<p>如果对象中变量带有指针或引用，再释放浅拷贝的指针资源会出错</p>
<p>深拷贝不仅拷贝指针，还开辟出一块新的空间用来存放新的值。不会出现浅拷贝出错的情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">class Person&#123;</span><br><span class="line">private:</span><br><span class="line">    int num; </span><br><span class="line">    char* name;</span><br><span class="line">public:</span><br><span class="line">    Person()&#123;</span><br><span class="line">        name=new char(20);</span><br><span class="line">        cout&lt;&lt;&quot;Person&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~Person()&#123;</span><br><span class="line">        cout&lt;&lt;&quot;~Person &quot;&lt;&lt;&amp;name&lt;&lt;endl;</span><br><span class="line">        delete name;</span><br><span class="line">        name=NULL;</span><br><span class="line">    &#125;;</span><br><span class="line">    Person(const Person &amp;p)&#123;</span><br><span class="line">        //浅拷贝</span><br><span class="line">        name=p.name;</span><br><span class="line"></span><br><span class="line">        //深拷贝</span><br><span class="line">        // name=new char(20);</span><br><span class="line">        // memcpy(name,p.name,strlen(p.name));</span><br><span class="line">        cout&lt;&lt;&quot;Copy Person&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    void getname()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;name&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        Person p1;</span><br><span class="line">     Person p2(p1);//复制</span><br><span class="line">    // p2.getname();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是我的浅拷贝没报错</p>
<h2 id="内联函数与宏定义"><a href="#内联函数与宏定义" class="headerlink" title="内联函数与宏定义"></a>内联函数与宏定义</h2><p>在使用时，宏只做简单字符串替换（编译前）；</p>
<p>而内联函数可以进行参数类型检查（编译时），且具有返回值</p>
<p>内联函数在编译时直接将函数代码嵌入到目标代码中，省去函数调用的开销来提高执行效率，并且进行参数类型检查，具有返回值，可以实现重载</p>
<p>宏定义时要注意书写（参数要括起来）否则容易出现歧义；</p>
<p>内联函数不会产生歧义，内联函数有类型检测、语法判断等功能，而宏没有</p>
<h3 id="内联函数使用场景"><a href="#内联函数使用场景" class="headerlink" title="内联函数使用场景"></a>内联函数使用场景</h3><p>使用宏定义的地方都可以inline函数</p>
<p>作为类成员接口函数来读写类的私有成员或保护成员，提高效率</p>
<h2 id="大小端存储"><a href="#大小端存储" class="headerlink" title="大小端存储"></a>大小端存储</h2><p>大端：字数据的高字节存储在低地址</p>
<p>小端：字数据的低字节存储在低地址</p>
<p>在socket编程中，往往将操作系统使用的小端存储的IP地址转化为大端存储，从而进行网络传输</p>
<p>例如32字节的0x12345678（高字节-&gt;低字节）</p>
<p>小端存储方式：</p>
<table>
<thead>
<tr>
<th>内存地址</th>
<th>0x2000</th>
<th>0x2001</th>
<th>0x2002</th>
<th>0x2003</th>
</tr>
</thead>
<tbody><tr>
<td>内存内容</td>
<td>0x78</td>
<td>0x56</td>
<td>0x34</td>
<td>0x12</td>
</tr>
</tbody></table>
<p>大端存储方式：</p>
<table>
<thead>
<tr>
<th>内存地址</th>
<th>0x2000</th>
<th>0x2001</th>
<th>0x2002</th>
<th>0x2003</th>
</tr>
</thead>
<tbody><tr>
<td>内存内容</td>
<td>0x12</td>
<td>0x34</td>
<td>0x56</td>
<td>0x78</td>
</tr>
</tbody></table>
<h3 id="代码判断"><a href="#代码判断" class="headerlink" title="代码判断"></a>代码判断</h3><h4 id="1-强制类型转换"><a href="#1-强制类型转换" class="headerlink" title="1.强制类型转换"></a>1.强制类型转换</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a=0x1234;//int 与 char的长度不同，int转换成char，只会留下低字节部分</span><br><span class="line">char c=(char)(a);</span><br><span class="line">if(c==0x12)</span><br><span class="line">cout&lt;&lt;&quot;大端&quot;&lt;&lt;endl;</span><br><span class="line">else if(c==0x34)</span><br><span class="line">cout&lt;&lt;&quot;小端&quot;&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<h4 id="2-巧用union联合体"><a href="#2-巧用union联合体" class="headerlink" title="2.巧用union联合体"></a>2.巧用union联合体</h4><h2 id="volatile、mutable和explicit关键字的用法"><a href="#volatile、mutable和explicit关键字的用法" class="headerlink" title="volatile、mutable和explicit关键字的用法"></a>volatile、mutable和explicit关键字的用法</h2><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。多线程中被几个任务共享的变量需要定义为volatile类型。</p>
<p>多线程下：有些变量是用volatile关键字声明的。当两个线程都要用到某一个变量且该变量的值会被改变时，应该用 volatile声明，该关键字的作用是防止优化编译器把变量从内存装入CPU寄存器中。</p>
<h3 id="mutable"><a href="#mutable" class="headerlink" title="mutable"></a>mutable</h3><p>mutable:可变的、易变的，在C++中，mutable 也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const 函数中。我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成const的。 但是，有些时候，我们需要在const函数里面修改一些跟类状态无关的数据成员，那么这个函数就应该被 mutable来修饰，并且放在函数后后面关键字位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">int m_A;</span><br><span class="line">mutable int m_B;//特殊变量 在常函数里值也可以被修改</span><br><span class="line">public:</span><br><span class="line"> void add() const//在函数里不可修改this指针指向的值 常量指针</span><br><span class="line"> &#123;</span><br><span class="line"> m_A=10;//错误 不可修改值，this已经被修饰为常量指针</span><br><span class="line"> m_B=20;//正确</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">int m_A;</span><br><span class="line">mutable int m_B;//特殊变量 在常函数里值也可以被修改</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">const person p;//修饰常对象 不可修改类成员的值</span><br><span class="line">p.m_A=10;//错误，被修饰了指针常量</span><br><span class="line">p.m_B=200;//正确，特殊变量，修饰了mutable</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h3><p>explicit关键字用来修饰类的<strong>构造函数</strong>，被修饰的构造函数的类，不能发生相应的隐式类型转换，<strong>只能以显示的方式进行类型转换</strong>，注意以下几点： </p>
<p>explicit 关键字只能用于类内部的构造函数声明上 </p>
<p>explicit 关键字作用于单个参数的构造函数 </p>
<p>被explicit修饰的构造函数的类，不能发生相应的隐式类型转换</p>
<h2 id="c-的异常处理方法"><a href="#c-的异常处理方法" class="headerlink" title="c++的异常处理方法"></a>c++的异常处理方法</h2><p>常见异常：</p>
<blockquote>
<p>数组下标越界</p>
<p>除数为0</p>
<p>动态分配空间不足</p>
<p>…</p>
</blockquote>
<h3 id="1-try、throw、catch关键字"><a href="#1-try、throw、catch关键字" class="headerlink" title="1.try、throw、catch关键字"></a>1.try、throw、catch关键字</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    double m,n;</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    try&#123;</span><br><span class="line">        cout&lt;&lt;&quot;before dividing: &quot;&lt;&lt;endl;</span><br><span class="line">        if(n==0) throw -1;//抛出int型异常</span><br><span class="line">        else if(m==0) throw -1.0;//抛出double型异常</span><br><span class="line">        else cout&lt;&lt;m/n&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;&quot;after dividing. &quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    catch(double d)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;catch (double) &quot;&lt;&lt;d&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    catch(int c)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;catch (int) &quot;&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;&quot;finished. &quot;&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输入m&#x3D;1，n&#x3D;0</p>
<blockquote>
<p>before dividing:<br>catch (int) -1<br>finished.</p>
</blockquote>
<p>输入m&#x3D;0,n&#x3D;1</p>
<blockquote>
<p>before dividing:<br>catch (double) -1<br>finished.</p>
</blockquote>
<p>输入 m&#x3D;4,n&#x3D;2;</p>
<blockquote>
<p>before dividing:<br>2<br>after dividing.<br>finished.</p>
</blockquote>
<p>程序的执行流程是：</p>
<p>先执行try包裹的语句块：</p>
<p>​		如果执行过程中没有异常发生，则不会进入任何catch包裹的语句块</p>
<p>如果发生异常， 则使用throw进行异常抛出，再由catch进行捕获，throw可以抛出各种数据类型的信息</p>
<p>代码中使用的是数字，也可以自定义异常class</p>
<p>catch根据throw抛出的数据类型进行精确捕获（不会出现类型转换）， 如果匹配不到就直接报错，可以使用catch(…)的方式捕获任何异常（不推荐）</p>
<p>当然，如果catch了异常，当前函数如果不进行处理，或者已经处理了想通知上一层的调用者，可以在catch里面再throw异常。</p>
<h3 id="2-函数的异常声明列表"><a href="#2-函数的异常声明列表" class="headerlink" title="2.函数的异常声明列表"></a>2.函数的异常声明列表</h3><p><code>int fun() throw(int,double,A,B,C)&#123;...&#125;;</code></p>
<h3 id="3-c-标准异常类exception"><a href="#3-c-标准异常类exception" class="headerlink" title="3.c++标准异常类exception"></a>3.c++标准异常类exception</h3><p>bad_typeid：使用typeid运算符，如果其操作数是一个多态类的指针，而该指针的值为 NULL，则会拋 出此异常</p>
<p>bad_cast：在用 dynamic_cast 进行从多态基类对象（或引用）到派生类的引用的强制类型转换时，如 果转换是不安全的，则会拋出此异常 </p>
<p>bad_alloc：在用 new 运算符进行动态内存分配时，如果没有足够的内存，则会引发此异常</p>
<p> out_of_range:用 vector 或 string的at 成员函数根据下标访问元素时，如果下标越界，则会拋出此异常</p>
<h2 id="形参、实参区别"><a href="#形参、实参区别" class="headerlink" title="形参、实参区别"></a>形参、实参区别</h2><ul>
<li>形参变量只有在被调用时才分配内存单元，在调用结束时， 即刻释放所分配的内存单元</li>
<li>实参是一个确定的值(常量、函数、变量、表达式)，获取输入也好、预先赋值也好使实参获得确认值，产生临时变量</li>
<li>它们在个数、类型上、顺序上严格匹配，否则调用函数出错</li>
<li>函数调用中数据单向传递，实参-&gt;形参；所以形参的值变化，不影响实参</li>
<li>当形参、实参不是指针类型：<ul>
<li>在该函数运行时，形参和实参是不同的变量，他们在内存中位于不同的位置</li>
<li>形参将实参的内容复制一份，在该函数运行结束的时候形参被释放，而实参内容不会改变</li>
</ul>
</li>
</ul>
<h2 id="值传递、指针传递、引用传递的区别和效率"><a href="#值传递、指针传递、引用传递的区别和效率" class="headerlink" title="值传递、指针传递、引用传递的区别和效率"></a>值传递、指针传递、引用传递的区别和效率</h2><h3 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h3><p>形参向函数所属的栈拷贝数据的过程，如果值传递的对象是类对象，耗费一定的时间和空间</p>
<h3 id="指针传递"><a href="#指针传递" class="headerlink" title="指针传递"></a>指针传递</h3><p>传地址值，同样有一个形参向函数所属栈拷贝数据的过程，但拷贝数据固定为4字节的地址</p>
<h3 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h3><p>同样有上述拷贝过程，但是针对地址的，为该数据所在地址起了一个别名</p>
<h2 id="静态变量什么时候初始化"><a href="#静态变量什么时候初始化" class="headerlink" title="静态变量什么时候初始化"></a>静态变量什么时候初始化</h2><h2 id="const关键字作用"><a href="#const关键字作用" class="headerlink" title="const关键字作用"></a>const关键字作用</h2><ul>
<li>防止变量改变，防止指针更改指向</li>
<li>修饰形参，在函数内部不能修改</li>
<li>对于类的成员函数，const修饰表示常函数，不能修改类的成员变量；类的常对象只能访问类的常成员函数</li>
<li>对于类的成员函数，必须指定其返回值为const类型，使得其返回值不为左值</li>
<li>const成员函数可以访问 非const对象的非const或const数据成员、const对象内的所有数据成员</li>
<li>非const成员函数不能访问const对象的任意数据成员</li>
<li>引用或指针传递函数调用时，因为函数内部可以改变引用或指针所指向的变量，用const修饰形参才是实在地保护了实参所指向变量</li>
</ul>
<h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p>子类或派生类</p>
<p>特点为：</p>
<p>子类拥有父类所有属性和方法</p>
<p>子类可以拥有父类没有的属性和方法</p>
<p>子类对象可以当做父类对象使用</p>
<h2 id="c-编译过程"><a href="#c-编译过程" class="headerlink" title="c++编译过程"></a>c++编译过程</h2><p>预处理-&gt;编译-&gt;汇编-&gt;链接</p>
<h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>预处理，对伪指令(以#开头的指令，如：宏定义、条件编译(#if #endif)、头文件)和特殊符号（注释、三元符）处理</p>
<p>预处理指令包括(#include、#define、#pragma)</p>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>编译器，对上步的文件词法分析、语法分析、语义分析，生成汇编代码文件</p>
<h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p>汇编器，将汇编代码转化为机器可执行的二进制代码(机器码)，并生成目标文件</p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>链接器，解决多个文件之间符号引用问题；</p>
<p>因为编译时，编译器只对单个文件进行处理，如果该文件需要引用到其他文件中的符号的话，比如全局变量或调用某个库函数中的函数，需要由链接器把所有的目标文件链接到一起才能确定最终地址，生成最终可执行文件</p>
<p><img src="/../../../Typora/img111/image-20230810125208966.png"></p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h2 id="c-内存的5个区"><a href="#c-内存的5个区" class="headerlink" title="c++内存的5个区"></a>c++内存的5个区</h2><p>1、栈：内存由编译器在<strong>需要时自动分配和释放</strong>。通常用来存储局部变量和函数参数。（为运行函数而分配的局部变量、函数参数、返回地址等存放在栈区）。</p>
<p>栈运算分配内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</p>
<p>2、堆：内存使用<strong>new进行分配，使用delete或delete[]释放</strong>。如果未能对内存进行正确的释放，会造成内存泄漏。但在程序结束时，会由操作系统自动回收。</p>
<p>3、 代码区：存放程序的二进制代码</p>
<p>4、全局&#x2F;静态存储区：全局变量和静态变量被分配到同一块内存中，C语言中区分初始化和未初始化的，C++中不再区分了。（全局变量、静态数据、常量存放在全局数据区），使用静态关键字static声明，在静态存储区申请一个静态变量</p>
<p>5、 常量存储区：存储常量，不允许被修改。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int* p=new int[5];</span><br></pre></td></tr></table></figure>

<p>看到new，说明分配了一块堆内存；而指针p嘞，分配的是一块栈内存；</p>
<p>该语句是：在栈内存中存放了一个指向一块堆内存的指针p，调用operator new 分配内存，然后返回这块内存的首地址，放入栈中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int a = 0; //全局初始化区</span><br><span class="line">char *p1; //全局未初始化区</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int b; //栈</span><br><span class="line">    char s[] = &quot;abc&quot;; //栈</span><br><span class="line">    char *p2; //栈</span><br><span class="line">    char *p3 = &quot;123456&quot;; //123456\0在常量区，p3在栈上。</span><br><span class="line">    static int c = 0; //全局（静态）初始化区</span><br><span class="line">    p1 = (char *)malloc(10);</span><br><span class="line">    p2 = (char *)malloc(20);</span><br><span class="line">    //分配得来得10和20字节的区域就在堆区。</span><br><span class="line">    strcpy(p1, &quot;123456&quot;); //123456\0放在常量区，编译器可能会将它与p3所指向的&quot;123456&quot;优化成一个地方。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="c-没有垃圾回收机制"><a href="#c-没有垃圾回收机制" class="headerlink" title="c++没有垃圾回收机制"></a>c++没有垃圾回收机制</h2><p>首先，实现一个垃圾回收器会带来额外的空间和时间开销。你需要开辟一定的空间保存指针的引用计 数和对他们进行标记mark。然后需要单独开辟一个线程在空闲的时候进行free操作。 垃圾回收会使得C++不适合进行很多底层的操作。</p>
<h2 id="malloc、realloc、calloc"><a href="#malloc、realloc、calloc" class="headerlink" title="malloc、realloc、calloc"></a>malloc、realloc、calloc</h2><ol>
<li><p>malloc函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void* malloc(unsigned int num_size);</span><br><span class="line">int *p = malloc(20*sizeof(int));申请20个int类型的空间；</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>calloc函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void* calloc(size_t n,size_t size);</span><br><span class="line">int *p = calloc(20, sizeof(int));</span><br></pre></td></tr></table></figure>

<p>省去了人为空间计算；malloc申请的空间的值是随机初始化的，calloc申请的空间的值是初始化为0的；</p>
</li>
<li><p>realloc函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void realloc(void *p, size_t new_size)</span><br></pre></td></tr></table></figure>

<p>给动态分配的空间分配额外的空间，用于扩充容量。</p>
</li>
</ol>
<h2 id="类成员初始化方式？构造函数的执行顺序-？为什么用成员初始化列表-会快一些？"><a href="#类成员初始化方式？构造函数的执行顺序-？为什么用成员初始化列表-会快一些？" class="headerlink" title="类成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表 会快一些？"></a>类成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表 会快一些？</h2><ol>
<li><p>赋值初始化，通过在函数体内进行赋值初始化；</p>
</li>
<li><p>列表初始化，在冒号后使用初始化列表进行初始化。 </p>
<p>这两种方式的主要区别在于：</p>
<p> 对于在<strong>函数体中初始化</strong>，是在所有的<strong>数据成员被分配内存空间后</strong>才进行的；</p>
<p><code>相当于一次默认构造+一次赋值</code></p>
<p> <strong>列表初始化是</strong>给数据成员<strong>分配内存空间时</strong>就进行初始化，就是说分配一个数据成员只要冒号后有此数据成员的赋值表达式(此表达式必须是括号赋值表达式),那么分配了内存空间后在进入函数体之前给数据成员赋值，就是说初始化这个数据成员此时函数体还未执行。</p>
<p><code>相当于一次赋值操作</code></p>
<p><code>其相比赋值初始化而言，少了调用构造函数的过程</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class test&#123;</span><br><span class="line">private:</span><br><span class="line">	string val;</span><br><span class="line">	test* tep;</span><br><span class="line">	</span><br><span class="line">public:</span><br><span class="line">	test()//赋值初始化</span><br><span class="line">	&#123;</span><br><span class="line">	this.val=&quot;yuleiyun&quot;;</span><br><span class="line">	this-&gt;tep=nullptr;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	test(string s):val(s),tep(nullptr)&#123;&#125;//列表初始化</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>一个派生类构造函数的执行顺序如下：</p>
<p> ① 虚拟基类的构造函数（多个虚拟基类则按照继承的顺序执行构造函数）</p>
<p> ② 基类的构造函数（多个普通基类也按照继承的顺序执行构造函数）</p>
<p> ③ 类类型的成员对象的构造函数（按照初始化顺序）</p>
<p> ④ 派生类自己的构造函数。</p>
</li>
</ol>
<p>方法一是在构造函数当中做赋值的操作，</p>
<p>而方法二是做纯粹的初始化操作</p>
<p>我们都知道，C++的赋值操作是会产生临时对象的。临时对象的出现会降低程序的效率。</p>
<h2 id="string与c的char"><a href="#string与c的char" class="headerlink" title="string与c的char*"></a>string与c的char*</h2><p>string是对char*的封装，string包含了char*数组的属性</p>
<p>string可以进行动态扩展</p>
<h2 id="内存泄露"><a href="#内存泄露" class="headerlink" title="*内存泄露"></a>*内存泄露</h2><p>一般指堆的内存泄露，使用malloc、new分配完内存，使用完后，程序必须调用相应的free或delete释放该内存块，否则，这块内存就不能被访问，从而造成系统内存资源的浪费</p>
<h3 id="避免内存泄露："><a href="#避免内存泄露：" class="headerlink" title="避免内存泄露："></a>避免内存泄露：</h3><p>1.计数法:使用new或malloc时，该计数++，delete或free时，该计数–，程序执行完打印这个计数，不为0则存在内存泄露</p>
<p>2.将基类的析构函数声明为虚函数</p>
<p>3.保证new&#x2F;delete、malloc&#x2F;free的成对出现</p>
<p>4.智能指针自动化地管理动态分配的内存资源</p>
<h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><h3 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h3><p>reinterpret_cast (expression):type-id 必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以用于类型之间进行强制转 换。</p>
<h3 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h3><p>const_cast (expression) 该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。 一般修改底指针</p>
<h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h3><p>static_cast &lt; type-id &gt; (expression) 该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性。</p>
<p>用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。</p>
<h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h3><p>有类型检查，基类向派生类转换比较安全，但是派生类向基类转换则不太安全</p>
<p>dynamic_cast (expression) 该运算符把expression转换成type-id类型的对象。type-id 必须是类的指针、类的引用或者void*</p>
<h2 id="c-函数调用的压栈过程"><a href="#c-函数调用的压栈过程" class="headerlink" title="c++函数调用的压栈过程"></a>c++函数调用的压栈过程</h2><p>函数的调用过程：</p>
<p> 1）从栈空间分配存储空间 </p>
<p>2）从实参的存储空间复制值到形参栈空间 </p>
<p>3）进行运算</p>
<p>形参在函数未调用之前都是没有分配存储空间的，在函数调用结束之后，形参弹出栈空间，清除形参空间</p>
<p>数组作为参数的函数调用方式是地址传递，形参和实参都指向相同的内存空间，调用完成后，形参指针被销毁，但是所指向的内存空间依然存在，不能也不会被销毁</p>
<p>当函数有多个返回值的时候，不能用普通的 return 的方式实现，需要通过传回地址的形式进行，即地址&#x2F; 指针传递。</p>
<h2 id="浮点数比较"><a href="#浮点数比较" class="headerlink" title="浮点数比较"></a>浮点数比较</h2><p>浮点数的精度是有限，通过相减取绝对值，并与预设的精度比较</p>
<h2 id="类的对象建立"><a href="#类的对象建立" class="headerlink" title="类的对象建立"></a>类的对象建立</h2><p>main函数中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Test a;//静态建立，那就是存在栈上，销毁什么的自动</span><br><span class="line">Test *b=new Test();//因为new，那就是在堆上，new Test()返回是Test对象的指针，销毁需要手动delete</span><br></pre></td></tr></table></figure>

<h2 id="组合与继承"><a href="#组合与继承" class="headerlink" title="组合与继承"></a>组合与继承</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>优点：子类重写父类方法实现扩展</p>
<p>缺点：</p>
<p>父类的内部细节对子类来说可见</p>
<p>是高耦合关系，如果父类的方法有修改，比如参数个数，子类必须做出相应调整</p>
<h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>将A类的对象作为B类的成员变量</p>
<p>优点：</p>
<p>所包含的对象的内部细节不可见</p>
<p>低耦合，修改了包含对象的代码，不需要修改当前对象类的代码</p>
<p>缺点：</p>
<p>容易产生过多的对象</p>
<p>必须对接口仔细定义</p>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>意义：希望在同一个函数中通过<strong>使用相同的形参</strong>在<strong>不同的时间</strong>使用产生<strong>不同的效果</strong></p>
<p>函数指针指向的是特殊的数据类型，函数的类型是由其返回的数据类型和其参数列表共同决定的，而函数的名称则不是其类型的一部分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int (*pf)(const int&amp;, const int&amp;); </span><br></pre></td></tr></table></figure>

<p> 上面的pf就是一个函数指针，指向所有<strong>返回类型为int</strong>，并带有两个const int&amp;参数的函数。注意*pf两边的括号是必须的</p>
<p>否则就是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int *pf(const int&amp;, const int&amp;);</span><br></pre></td></tr></table></figure>

<p>而这声明了一个函数pf，其**返回类型为int ***， 带有两个const int&amp;参数。</p>
<h2 id="结构体变量比较相等"><a href="#结构体变量比较相等" class="headerlink" title="结构体变量比较相等"></a>结构体变量比较相等</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct foo &#123;</span><br><span class="line"> int a;</span><br><span class="line"> int b;</span><br><span class="line"> bool operator==(const foo&amp; rhs) *//* *操作运算符重载*</span><br><span class="line"> &#123;</span><br><span class="line"> return( a == rhs.a) &amp;&amp; (b == rhs.b);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="c-访问权限和继承权限"><a href="#c-访问权限和继承权限" class="headerlink" title="c++访问权限和继承权限"></a>c++访问权限和继承权限</h2><p>① public:用该关键字修饰的成员表示公有成员，该成员不仅可以在类内可以被访问，在类外也是可以被访问的，是类对外提供的可访问接口； </p>
<p>② private:用该关键字修饰的成员表示私有成员，该成员仅在类内可以被访问，在类体外是隐藏状态；</p>
<p> ③ protected:用该关键字修饰的成员表示保护成员，保护成员在类体外同样是隐藏状态，但是对于该类的派生类来说，相当于公有成员，在派生类中可以被访问。</p>
<p>三种继承方式 </p>
<p>① 若继承方式是public，基类成员在派生类中的访问权限保持不变，也就是说，基类中的成员访问权 限，在派生类中仍然保持原来的访问权限； </p>
<p>② 若继承方式是private，基类所有成员在派生类中的访问权限都会变为私有(private)权限；</p>
<p> ③ 若继承方式是protected，基类的共有成员和保护成员在派生类中的访问权限都会变为保护(protected) 权限，私有成员在派生类中的访问权限仍然是私有(private)权限。</p>
<h2 id="strcpy和memcpy的区别是什么"><a href="#strcpy和memcpy的区别是什么" class="headerlink" title="strcpy和memcpy的区别是什么"></a>strcpy和memcpy的区别是什么</h2><p>1、复制的内容不同。</p>
<p>strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。 </p>
<p>2、复制的方法不同。</p>
<p><strong>strcpy</strong>不需要指定长度，它遇到被复制字符的串结束符”\0”才结束，所以<strong>容易溢出</strong>。memcpy则是根据其第3个参数决定复制的长度。 </p>
<p>3、用途不同。</p>
<p>通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy</p>
<h2 id="空类，默认添加哪些函数"><a href="#空类，默认添加哪些函数" class="headerlink" title="*空类，默认添加哪些函数"></a>*空类，默认添加哪些函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1) Empty(); // 缺省构造函数//</span><br><span class="line">2) Empty( const Empty&amp; ); // 拷贝构造函数//</span><br><span class="line">3) ~Empty(); // 析构函数//</span><br><span class="line">4) Empty&amp; operator=( const Empty&amp; ); // 赋值运算符//</span><br></pre></td></tr></table></figure>

<h2 id="静态绑定与动态绑定"><a href="#静态绑定与动态绑定" class="headerlink" title="静态绑定与动态绑定"></a>静态绑定与动态绑定</h2><p>对象的静态类型：对象在声明时采用的类型，编译期确定</p>
<p>对象的动态类型：目前所指对象的类型。运行期觉得，对象的动态类型可以更改，静态类型无法更改</p>
<p>静态绑定：绑定对象静态类型</p>
<p>动态绑定：</p>
<h2 id="C-中哪些运算符不能重载？"><a href="#C-中哪些运算符不能重载？" class="headerlink" title="C++中哪些运算符不能重载？"></a><strong>C++中哪些运算符不能重载？</strong></h2><p>1 .（成员访问运算符）<br>2 .*（成员指针访问运算符）<br>3 ::（域运算符）<br>4 sizeof关键字<br>5 ?:（条件运算符）</p>
<h2 id="c-编译模块是什么"><a href="#c-编译模块是什么" class="headerlink" title="c++编译模块是什么"></a>c++编译模块是什么</h2><h2 id="什么是全局静态变量和局部静态变量"><a href="#什么是全局静态变量和局部静态变量" class="headerlink" title="什么是全局静态变量和局部静态变量"></a>什么是全局静态变量和局部静态变量</h2><h2 id="c-线程池"><a href="#c-线程池" class="headerlink" title="c++线程池"></a>c++线程池</h2><h2 id="技术面（gg）"><a href="#技术面（gg）" class="headerlink" title="技术面（gg）"></a>技术面（gg）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">char a[] = &quot;hello world&quot;;</span><br><span class="line">   char *p = a;</span><br><span class="line">   cout &lt;&lt; sizeof(a) &lt;&lt; endl; </span><br><span class="line">   cout &lt;&lt; sizeof(p) &lt;&lt; endl;</span><br><span class="line">   return 0;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>char a[]相当于string，所以，字符串长度+”\0”的长度为11+1&#x3D;12</p>
<p>第二个sizeof是指针的大小，一般为8字节</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">执行以下语句会有什么结果</span><br><span class="line">char a[] = “hello”;</span><br><span class="line">a[0] = ‘X’;</span><br><span class="line"></span><br><span class="line">char *p = “world”;</span><br><span class="line">p[0] = ‘X’; </span><br></pre></td></tr></table></figure>

<blockquote>
<p>前两行没问题</p>
<p>后两行，字符串常量通常被存储在只读的内存区域，不能修改</p>
<p>后两行运行时，会给出警告，但p[1]，p[0]是可以访问的</p>
</blockquote>
<blockquote>
<p>1,4,7,11,15<br>2,5,8,12,19<br>3,6,9,16,22<br>10,13,14,17,24<br>18,21,23,26,30</p>
</blockquote>
<p>有个MN矩阵，每一行每一列升序，用最优解找数字</p>
<p>思想：要么左下角，要么右上角开始找</p>
<p>下面代码以右上角开始：</p>
<p>如果a[row][col]&gt;t呢，说明在左边col–</p>
<p>否则呢，说明在下边row++</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">bool jisuan(vector&lt;vector&lt;int&gt; &gt; a, int t)</span><br><span class="line">&#123;</span><br><span class="line">    // for (auto we : a)</span><br><span class="line">    //     for (auto we1 : we)</span><br><span class="line">    //     &#123;</span><br><span class="line">    //         if (we1 == t)</span><br><span class="line">    //             return true;</span><br><span class="line">    //     &#125;</span><br><span class="line">    // return false;</span><br><span class="line">       int row=a.size(),col=a[0].size();</span><br><span class="line">       int minv=min(row,col);</span><br><span class="line"></span><br><span class="line">       row=0;col=col-1;</span><br><span class="line">       while (row &lt;a.size() &amp;&amp; col &gt;= 0)</span><br><span class="line">       &#123;</span><br><span class="line">            if(a[row][col]==t) return true;</span><br><span class="line">            else if(a[row][col]&gt;t) col--;</span><br><span class="line">            else row++;</span><br><span class="line">       &#125;</span><br><span class="line">       return false;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; a;</span><br><span class="line"></span><br><span class="line">    string s;</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        getline(cin, s);</span><br><span class="line">        if(s.empty()) break;</span><br><span class="line">        stringstream ss(s);</span><br><span class="line">        string t;</span><br><span class="line">        vector&lt;int&gt; b;</span><br><span class="line">        while (getline(ss, t, &#x27;,&#x27;))</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            b.push_back(stoi(t));</span><br><span class="line">        &#125;</span><br><span class="line">        a.push_back(b);</span><br><span class="line">       // if (s.size() == 0)</span><br><span class="line">    //    if(s.empty()) //如果判断空行放在这里，到时候输入的t是不存在的值时，不会输出false;</span><br><span class="line">    //         break;</span><br><span class="line">    &#125;</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    bool flag=jisuan(a, t);</span><br><span class="line">    if (flag)</span><br><span class="line">    &#123;</span><br><span class="line">          cout &lt;&lt; &quot;true&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;false&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1,4,7,11,15<br>2,5,8,12,19<br>3,6,9,16,22<br>10,13,14,17,24<br>18,21,23,26,30</p>
<p>28</p>
<p>输出false</p>
</blockquote>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>任何东西都不是速成的，知识需要时间去检验，空有理论，没有实际应用，白搭</p>
<h2 id="技术二面-gg"><a href="#技术二面-gg" class="headerlink" title="技术二面(gg)"></a>技术二面(gg)</h2><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>关键字friend</p>
<p><a target="_blank" rel="noopener" href="http://t.csdn.cn/Oa7kU">CSDN</a></p>
<h3 id="一个空类会自动初始化多少函数"><a href="#一个空类会自动初始化多少函数" class="headerlink" title="一个空类会自动初始化多少函数"></a>一个空类会自动初始化多少函数</h3><p>除了构造和析构</p>
<p>还有拷贝构造函数</p>
<p>复制运算符</p>
<h3 id="赋值初始化和拷贝初始化-记不清了"><a href="#赋值初始化和拷贝初始化-记不清了" class="headerlink" title="赋值初始化和拷贝初始化(记不清了)"></a>赋值初始化和拷贝初始化(记不清了)</h3><h3 id="基类的析构函数设置为虚函数有什么用"><a href="#基类的析构函数设置为虚函数有什么用" class="headerlink" title="基类的析构函数设置为虚函数有什么用"></a>基类的析构函数设置为虚函数有什么用</h3><p>释放基类的析构函数同时，释放派生类的析构函数</p>
<h3 id="栈和队列区别"><a href="#栈和队列区别" class="headerlink" title="栈和队列区别"></a>栈和队列区别</h3><p>栈先进后出；队列先进先出</p>
<p>栈表的一端插入和删除；队列一端进一端出</p>
<p>栈只能取顶部元素，遍历数据的同时要为数据开辟临时空间；队列无需开辟空间，遍历速度稍快</p>
<h3 id="能重载吗"><a href="#能重载吗" class="headerlink" title="*能重载吗"></a>*能重载吗</h3><p>不可以</p>
<h3 id="操作符重载用过吗"><a href="#操作符重载用过吗" class="headerlink" title="操作符重载用过吗"></a>操作符重载用过吗</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool operator()(pair&lt;int,int&gt; &amp;a, pair&lt;int,int&gt;&amp;b)&#123;</span><br><span class="line">      return a.second &lt; b.second;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h3 id="static在类里，在类外，有什么区别"><a href="#static在类里，在类外，有什么区别" class="headerlink" title="static在类里，在类外，有什么区别"></a>static在类里，在类外，有什么区别</h3><p>类里的static存在哪里，存在<strong>数据段</strong>。</p>
<h3 id="析构函数如果，会发生什么-记不清了"><a href="#析构函数如果，会发生什么-记不清了" class="headerlink" title="析构函数如果，会发生什么(记不清了)"></a>析构函数如果，会发生什么(记不清了)</h3><p>崩溃</p>
<h3 id="C-为什么面向对象-具体说明一下"><a href="#C-为什么面向对象-具体说明一下" class="headerlink" title="C++为什么面向对象(具体说明一下)"></a>C++为什么面向对象(具体说明一下)</h3><p>我答的是多态、封装和继承</p>
<h3 id="继承是什么关系"><a href="#继承是什么关系" class="headerlink" title="继承是什么关系"></a>继承是什么关系</h3><p>子类与父类之间的关系是“是一个”（is-a）关系，即子类是父类的一种特殊类型</p>
<h3 id="嵌套和继承的区别"><a href="#嵌套和继承的区别" class="headerlink" title="嵌套和继承的区别"></a>嵌套和继承的区别</h3><p>嵌套类是一个在另一个类的内部定义的类。它在外部类中具有作用域限制，可以访问外部类的私有成员。嵌套类通常用于实现某个类的内部辅助功能或数据结构。这可以帮助保持代码的整洁性，因为嵌套类的实现细节不会暴露给外部世界。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Outer &#123;</span><br><span class="line">public:</span><br><span class="line">    class Nested &#123;</span><br><span class="line">    public:</span><br><span class="line">        void nestedMethod() &#123;</span><br><span class="line">            // 可以访问外部类的成员</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int privateMember;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Outer::Nested nestedObj;</span><br><span class="line">    nestedObj.nestedMethod();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="写个双向链表的插入实现-gg"><a href="#写个双向链表的插入实现-gg" class="headerlink" title="写个双向链表的插入实现(gg)"></a>写个双向链表的插入实现(gg)</h3><p>哇，基础不牢，地动山摇</p>
<p>双向链表的实现，惭愧，这个基础没记住</p>
<p>当时写的这玩意儿</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">List* insert(List* head,int p,int q)</span><br><span class="line">   &#123;</span><br><span class="line">       List* p1=head;</span><br><span class="line">       while(p1)</span><br><span class="line">       &#123;</span><br><span class="line">           if(p1&gt;val==p)</span><br><span class="line">           &#123;</span><br><span class="line">           /*h-&gt;p&lt;-q----&gt;h</span><br><span class="line">              &lt;- -&gt;</span><br><span class="line">               */</span><br><span class="line">               List* p2=new List(q);</span><br><span class="line">               /* p-&gt;end</span><br><span class="line">                   </span><br><span class="line">                    */</span><br><span class="line">               </span><br><span class="line">               p1-&gt;end=p2;</span><br><span class="line">               p2-&gt;pre=p1;</span><br><span class="line">               p2-&gt;end=head;</span><br><span class="line">               p2=nullptr;</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">           p1=p1-&gt;end;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230812222457210.png" alt="image-20230812222457210"></p>
<p>以插入角度来讲，p后面加入q，我们考虑一下，在p与p-&gt;next结点中间插入q，需要满足什么</p>
<blockquote>
<p>q结点与p-&gt;next结点先完成互指：</p>
<p>p-&gt;next-&gt;pre&#x3D;q;</p>
<p>q-&gt;next&#x3D;p-&gt;next;</p>
<p>p结点再与q结点完成互指：</p>
<p>p-&gt;next&#x3D;q;</p>
<p>q-&gt;pre&#x3D;p;</p>
</blockquote>
<p>如果p是第一个节点怎么办捏</p>
<blockquote>
<p>q-&gt;next&#x3D;nullptr;</p>
<p>p-&gt;next&#x3D;q;</p>
<p>q-&gt;pre&#x3D;p;</p>
</blockquote>
<p>如果p是尾结点</p>
<blockquote>
<p>List* tem&#x3D;p-&gt;pre;</p>
<p>p-&gt;pre&#x3D;q;</p>
<p>p-&gt;next&#x3D;nullptr;</p>
<p>tem-&gt;next&#x3D;q;</p>
<p>q-&gt;pre&#x3D;tem;</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">List* insert(List* &amp;head,int p,int q)</span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line">        List* p1=head;</span><br><span class="line">        while(p1-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            if(p1-&gt;val==p)</span><br><span class="line">            &#123;</span><br><span class="line">                List* qq=new List(q);</span><br><span class="line">                p1-&gt;next-&gt;pre=qq;</span><br><span class="line">                qq-&gt;next=p1-&gt;next;</span><br><span class="line"></span><br><span class="line">                qq-&gt;pre=p1;</span><br><span class="line">                p1-&gt;next=qq;</span><br><span class="line"></span><br><span class="line">                return head;</span><br><span class="line">            &#125;</span><br><span class="line">            p1=p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>完善判空，还有尾结点情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">if (!head) &#123;</span><br><span class="line">       head = new List(0);</span><br><span class="line">       head-&gt;next = head;</span><br><span class="line">       head-&gt;pre = head;</span><br><span class="line">       return head;</span><br><span class="line">   &#125;</span><br><span class="line">    List* p1=head;</span><br><span class="line">       while(p1-&gt;next)</span><br><span class="line">       &#123;</span><br><span class="line">           if(p1-&gt;val==p)</span><br><span class="line">           &#123;</span><br><span class="line">               List* qq=new List(q);</span><br><span class="line">               qq-&gt;next=p1-&gt;next;</span><br><span class="line">               qq-&gt;pre=p1;</span><br><span class="line">			</span><br><span class="line">			if(p1-&gt;next)&#123;</span><br><span class="line">			p1-&gt;next-&gt;pre=qq;</span><br><span class="line">			&#125;</span><br><span class="line">               p1-&gt;next=qq;</span><br><span class="line"></span><br><span class="line">               return head;</span><br><span class="line">           &#125;</span><br><span class="line">           p1=p1-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">       return head;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>



<h3 id="来个判断字符串包含-gg"><a href="#来个判断字符串包含-gg" class="headerlink" title="来个判断字符串包含(gg)"></a>来个判断字符串包含(gg)</h3><p>哇，基础不牢，地动山摇</p>
<p>当时脑抽写了这个，啧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0;i&lt;s1.size();i++)</span><br><span class="line">   &#123;</span><br><span class="line">       st.insert(s1[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   for(int i=0;i&lt;s2.size();i++)</span><br><span class="line">   &#123;</span><br><span class="line">       if(st.count(s2[i])) tem+=st-&gt;first;</span><br><span class="line">   &#125;</span><br><span class="line">   if(tem==s2) return true;</span><br><span class="line">   return false;</span><br></pre></td></tr></table></figure>

<p>之后口头的时候提到了substr函数的实现方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0;i&lt;s1.size();i++)</span><br><span class="line"> &#123;</span><br><span class="line">      if(s1.substr(i,s2.size())==s2) return true;</span><br><span class="line"> &#125;</span><br><span class="line"> return false;</span><br></pre></td></tr></table></figure>



<h2 id="c-标准库函数有了解吗"><a href="#c-标准库函数有了解吗" class="headerlink" title="c++标准库函数有了解吗"></a>c++标准库函数有了解吗</h2><p>stl嘛，容器那些，面试官只是回了：行</p>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>空中楼阁；基础不牢，地动山摇</p>
<p>c++的应用，面试官说是很多，鸿蒙开发就是c；至于桌面应用是应用层的关系</p>
<p>面试官说，设计模式的重要性；基础掌握；思想逻辑；算法一定要知道基础；系统设计框架：生产者和消费者</p>
<h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h1 id="来源-1"><a href="#来源-1" class="headerlink" title="来源"></a>来源</h1><p>CSDN博主<a target="_blank" rel="noopener" href="https://blog.csdn.net/Lushengshi/article/details/127580635">「丘比特惩罚陆」</a></p>
<p>知识补充来源：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/553387258">知乎笔记</a></p>
<p>为什么c++很少用于后端开发：</p>
<p>与java和python相比，c++缺乏像Spring和Django这种web框架，也没有一个像 J2EE 或 Servlet API 这样的标准。</p>
<p>c++适用于高性能和实时系统，如游戏开发、图形处理和科学计算等领域</p>
<p>而Web后端开发的重点是数据处理和业务逻辑</p>
<p>此外，web开发的工作是处理字符串，比如url，http头啊，输出的html、js啊，确实其它的语言，java、c#或者是python，处理字符串很容易，都有自带的库，随便调用一下，比如split这种方法。c++明显在这方面弱</p>
<p>说是没有自动垃圾回收器，即GC</p>
<p>然后嘞，web开发的都是解释性语言，c#,java等，解释性语言移植性要高些，c++这种编译性依赖特定平台</p>
<p>对计算量大又想高效的前后端应用，C++可能会合适。且Web Assembly已经全面落户最新的Chrome、Firefox、Edge、Safari等主流浏览器。可以将C++源码编译成wasm二进制文件直接在浏览器里高速运行（使用Emscripten编译更加便捷）。对很多前端应用来说，使用C++加速可能并没有必要。但是如果想要在前端产品中加入机器视觉，自然语言处理，机器学习等模块，WebAssembly将成为一个极好的选择。</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/26782196/answer/2946648596?utm_id=0">知乎</a></p>
<p><a target="_blank" rel="noopener" href="https://six.club/article/2775">sixclub</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2023/08/03/C/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-%E7%9F%A5%E8%AF%86%E7%82%B9/" rel="tag">C++知识点</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E7%BB%8F/" rel="tag">面经</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2023/08/03/git/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            git bash
          
        </div>
      </a>
    
    
      <a href="/2023/07/04/%E5%9B%9E%E5%BD%92%E8%AF%BE%E6%9C%AC/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">回归课本</div>
      </a>
    
  </nav>

  
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2023
        <i class="ri-heart-fill heart_icon"></i> 是羽泪云诶
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/favicon.ico" alt="小张之栈"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>